关于析构函数和垃圾回收机制
在C#中，当一个对象成为垃圾后仍然会占用内存空间，时间一长，就会导致内存空间的不足
为了清除这些无用的垃圾对象，释放一定的内存空间，C#中引入了垃圾回收机制，在这中机制下，程序员不需要过多关心垃圾对象回收的问题
.Net 运行环境会在合适的时机启动垃圾回收器将这些垃圾对象从内存中释放，从而使程序获得更多可用的内存空间
除了等待运行环境进行自动垃圾回收，还可以通过调用GC.Collect()方法来通知运行环境立即进行垃圾回收
堆中没有被引用或null的对象才会被回收，GC只会回收堆中引用类型的活动内存数据（且必须是托管资源），值类型在栈中使用完就释放并不需要GC进行处理
静态数据在程序结束前不会被回收但能重复利用（它们是静态内存区逻辑允许读写的1份数据副本，不是逻辑只读的初始模板数据），而其他不使用但占位的活动内存数据要回收以重复访问这些内存地址
因调用外部dll、ShellAPI等手段，通过系统创建非托管对象、数据流、一些数据库的连接，或特定操作系统，这些情况GC无法找到对象，需特定手段手动清理
如：Stream、StreamReader、StreamWrite、HttpWebResponse、网络端口或复杂数据对话框等，这些对象一般需要调用专门的Close()或Dispose()方法进行手动回收
析构函数就是提供设计手动回收机制，写法与构造方法类似，只不过需要在函数名前加上~号，析构函数会在对象销毁时，被垃圾回收器调用
析构函数：1.一个类只能有一个析构函数;2.无法继承或重载析构函数;3.无法调用析构函数，而是在对象被销毁时被自动调用的;4.析构函数即没有修饰符也没有参数
正常情况下不建议手动使用GC，会让程序短暂暂停等待回收（如GC.Collect(1)执行百次约耗时1毫秒），频繁使用会影响执行效率，除非马上需要进行非常消耗内存的操作
Unity的GC在.net基础上又封装了一些算法去不定时去调.net的GC

关于栈和堆
每个线程都有独立的栈空间，栈空间用于保存调用函数的数据，如果说某一个数据，只在某个函数中使用，那么可以把数据定义为这个函数的一个本地变量，这样它就会随着函数一起分配并且随着函数的返回一起释放
但不是所有数据都可跟随函数去返回释放的，总会有一部分数据需要在函数返回后继续使用还有一部分数据需在多个线程中同时使用，那这些数据都是不能从栈空间去分配的，这些数据被分配到堆空间
堆空间是程序中一块独立空间，从堆空间分配的数据可被程序中所有函数和线程访问，并且不会随着函数返回、线程结束而释放，只能通过垃圾回收机制释放

关于值类型和引用类型
值类型的对象本身存储的就是值（存放在栈）
引用类型的对象本身存储的是内存地址（存放在栈），它的值存储在内存地址指向的堆中
值类型的对象会根据定义的位置隐式分配与释放
引用类型的对象需要通过new关键字显式分配，new动作会从堆中申请一块空间用于保存值，然后返回空间的开始地址

关于内存泄漏和内存溢出
内存溢出：程序在运行的过程中，堆内存的需求超过了计算机分配给程序的内存，从而造成”Out of Memory”之类的错误（动态分配的活动内存问题）
如何解决内存溢出：
计算机本身的内存小，通过追加物理内存条或虚拟内存来解决
程序在运行时没能及时释放不用的内存，造成内存越来越大从而溢出，一般是非托管资源没有手动释放或程序优化问题
内存泄露：应用程序分配某段内存后，由于设计错误失去了对该段内存的控制，造成了内存不能回收和不能及时回收，当程序不能释放的内存越来越多就会造成程序性能下降或出现内存溢出错误，一般也跟非托管资源有关

标记并清除
标记并清除的方式会选择一部分引用类型的对象作为根对象，然后去递归标记对象以及对象的引用类 型成员，最后所有已标记的引用类型对象会存活下来，而未被标记的引用类型对象会被回收
选择根对象的方式必须保证从根对象开始可以遍历所有程序中能够访问的对象
.NET中的根对象，包括各个线程栈空间上的变量，全局变量，GC句柄和析构队列中的对象

分代
.NET中将引用类型的对象分为三类，分别是第0代，第1代与第2代
新分配的对象如果说不超过一定的大小，它会作为小对象被归属为第0代
如果超过一定的大小，就会作为大对象归属为第二代
执行垃圾回收以后存活的第0代对象通常会成为第1代
再有一轮GC执行完成，那么第1代存活的对象会成为第2代
存活的第2代对象会继续留在第2代
这样的处理可以让.NET中的对象按存活的时间分成了三个不同的群组
第0代中的对象存活时间通常最短，第1代中的对象存活时间比较长，第2代中的对象存活时间最长
.NET垃圾回收机制中第0代和第1代的处理频率比较高，第2代比较低
分代依据的目的是尽量增加每次执行垃圾回收处理时可回收的对象数量，并减少处理所需的时间
GC.Collect(1)是清理第一代，GC.Collect()是清理所有代

压缩（对活动内存堆空间进行碎片整理，缓减内存占用）
反复执行分配与回收的操作，可能导致堆上产生很多空余的空间，这些空余的空间又被称为碎片空间
压缩机制可以通过移动已分配的空间把碎片空间合并到一起，使得堆可以分配更大的对象
.NET运行时提供的GC是支持压缩机制的

大小对象
.NET根据引用类型对象的值占用的空间大小来区分是小对象还是大对象
大于或等于85000字节的对象就会成为大对象
大对象和小对象会在不同的堆区域中分配
分配大对象的区域称为大对象堆，分配小对象的区域称为小对象堆
区分大小对象的原因是因为处理大对象需要更长的时间和更多的资源，并且大对象存活时间通常都会更长一些
所以新分配的小对象都是归属第0代的，新分配的大对象都是归属第2代的，移动大对象需要的成本很高
压缩机制默认只在小对象堆启用，大对象堆是不会执行压缩的

固定对象
.NET支持托管代码调用非托管代码，如果把一个引用类型的对象传递给非托管代码，那么它的内存地址就会被复制到非托管代码管理的区域中，而.NET运行时无法得知非托管代码把对象的内存地址保存到了哪里
这个时候就会导致两个问题：
无法确定这个非托管代码是否仍然使用这个对象
执行压缩操作已分配空间的地址会改变，改变以后非托管代码中保存的内存地址不能够同步更新
为了解决这两个问题，.NET要求托管代码传递引用类型对象给非托管代码时必须创建固定类型的GC句柄，并在托管代码中保持这个句柄存活到非托管代码的调用结束
创建了固定类型GC句柄的对象就称为固定对象
.NET运行时执行垃圾回收时候会扫描GC句柄并标记所有固定对象存活与否
并且在执行压缩操作的时候，还会避开这些固定对象，让它们的位置保持不变
固定对象带来的碎片空间是无法合并的，并且固定对象在垃圾回收后可能会发生降代

析构队列
.NET支持在回收对象时去调用析构函数，还可以在析构函数中去使用托管代码去编写一些自定义的逻辑
具体析构过程中会执行什么代码逻辑会执行多长时间，对于.NET运行时来说都是不确定的
如果在垃圾回收的过程中执行析构函数，垃圾回收需要的时间是不可预料的，因为这个逻辑是开发人员自己写的，谁也不知道你在析构函数里写了什么，所以垃圾回收在执行这些析构函数的时候会有问 题。
.NET里面定义了一个析构队列以及一个对应的析构线程，在执行垃圾回收的时候，如对象不再存活但定义了析构函数，那么对象会添加到析构队列,并标记存活与否
等GC结束以后，这个时候就会启动一个析构线程，这个析构线程就是专门用来从这个析构队列取对象，然后来执行它们的析构函数
析构函数执行完毕的对象，可以在下一轮GC中被回收，所以有析构函数的对象，通常需要至少两轮才能把它给回收掉
析构函数通常都是在使用非托管资源的类型中定义，如fileStream类里面有非托管资源文件句柄，它的析构函数会调用Dispose函数去关闭打开的文件
尽管非托管资源可通过析构函数自动释放，但GC发生时期与析构函数调用时期不明确不可控，托管代码在不用托管资源后往往主动调用Dispose函数去释放不用等析构函数
并且Dispose函数在释放完资源以后，应该还要抑制析构函数的运行

STW
标记并清除是用GC，它要确定哪些对象正在被程序使用，那么这就要扫描对象之间的引用关系，也就是说要遍历对象包含的引用类型成员，因为成员值会随着程序运行不断修改
对象之间的引用关系会随着程序运行不断改变，让执行GC的线程与执行其它处理的线程同时运行会带来一些问题
所以需要让执行GC处理以外的线程全都暂停运行（GC运行时程序会短暂停止），像这样的停止操作称为STW(Stop The World)

工作站模式/服务器模式
工作站模式适用于内存占用量小的程序和桌面程序，可以提供更短的响应时间。GC运行频繁，且使用分配对象的线程，数量为单线程。
服务器模式适用于内存占用量大的程序与服务程序，可以提供更高的吞吐量。GC运行不频繁，且使用独立线程，数量为多线程。

普通GC/后台GC
普通GC会导致更长的单次STW停顿时间，但消耗的资源比较小，并且支持压缩处理。目标全代，执行时间短，STW停顿发生在整个执行过程，支持压缩处理。
后台GC每次STW停顿时间会更短，但停顿次数与消耗的资源会更多，并且不支持压缩处理。目标2代，执行时间长，STW停顿发生在部分执行过程，不支持压缩处理。

对象头
对象头包含了标志与同步块索引等数据
在32位平台上对象头是4个字节，在64位平台上对象头是8个字节
在32位里面，高6位用于保存一些重要的标志，低26位保存的内容是根据标记来定的
高1位用于.NET运行中内部检查托管堆状态时，标记对象是否已检查
高2位用于标记是否抑制运行对象的析构函数
高3位用于标记对象是否为固定对象
高4~6位用于标记低26位保存了什么内容，其中就包括了获取锁，释放锁和对象Hash值的信息

类型信息
每个引用类型的对象值都保存了一个类型信息
类型信息实际上是一个内存地址，是一个指向的.NET运行时内部保存的类型数据(MethodTable)的内存地址
类型数据包含了类型的所属模块名称，字段列表，属性列表，方法列表，以及各个方法入口点的地址等信息
.NET中的反射机制、接口、虚方法都需要依赖这些类型数据，反射会把类型数据中的内容包装成托管对象供托管代码访问
接口与虚方法需要访问这个类型数据中的方法表，在执行时需要定位实际调用的方法地址

内存结构
GC在执行时会记录哪些对象存活，记录使用每个对象关联的存活标记初始是0，当扫描时对象为1， 最后清除标记为0的对象
存活标记保存在一个全局的位数组中，GC执行的时候还会根据固定类型的GC句柄来标记对象是否固定，固定对象是不可以被移动的
.NET程序内存结构包含以下
1、非托管部分（非托管代码/非托管静态变量/...）；
2、AppDoman：
1）高频堆（常用数据类型/托管静态变量）；
2）低频堆（不常用数据类型/函数元数据）；
3）字符串池（编译时已知字符串对象的索引）；
4）函数入口代码堆（函数入口点代码）；
5）托管函数代码堆（托管函数代码）；
3、托管堆：
1）小对象堆段；
2）短暂堆段（最新小对象堆段）；
3）大对象堆段（>85000字节）；
4）可重用堆段；

托管堆/堆段
托管堆用于保存引用类型对象的值
托管堆→区域(通过gc_heap实例管理)→
{
    1-1、小对象堆段(通过heap_segment实例管理)，只保存第2代对象
    ↓
    1-2、小对象雉段，只保存第2代对象
    ↓
    1-3、短暂堆段(小对象堆段)，保存全代
}
{
    2-1、大对象堆段(通过heap_segment实例管理)，只保存第2代对象
    ↓
    2-2、大对象雉段，只保存第2代对象
    ↓
    2-3、大对象雉段，只保存第2代对象
}
每个堆段默认的大小同样根据GC模式与运行环境的CPU逻辑核心数量来决定
GC模式      CPU逻辑核心数  32位   64位
工作站模式        -        16MB   256MB
                 <4        64MB   4GB
服务器模式   >= 4 && < 8   32MB   2GB
                >= 8       16MB   1GB

分配上下文
堆段分配对象值，最简单的方式就是在管理堆段的实例中保存3个实例地址，一般预留小对象分配上下文
堆段↓
    |...|最后一个对象值|        ...       |
    |    已分配空间    |    已分配空间    |
开始地址      分配下一个对象值的地址   结束地址

    |...|对象值|对象值|    ...   |对象值|    ...   |    ...   |
    |已分配空间|线程0的分配上下文|线程1的分配上下文|未分配空间|
开始地址                                      已使用地址   结束地址

分代的实例
在.NET中，托管堆每个区域的小对象堆有三个代，大对象堆有一个代(第2代)，这些代会通过generation类型的实例进行管理
每个区域都有4个generation类型的实例，每个generation类型包含的数据可以根据可变性分为静态数据和动态数据
静态数据是实例创建后不会改变的数据，它包含触发GC所需的分配量阈值上限和下限
动态数据会根据运行状况不断改变，包含已分配的大小和回收次数等等
代的开始地址决定了哪些对象在哪些代
区域(通过gc_heap实例管理)→
{
    1-1、小对象堆段(通过heap_segment实例管理)，只保存第2代对象→①|小对象|小对象|...|
    ↓
    1-2、小对象雉段，只保存第2代对象→|小对象|...|
    ↓
    1-3、短暂堆段(小对象堆段)，保存全代→|小对象|②|小对象|小对象|③|小对象|...|
}
注：①第2代的开始地址，②第1代的开地址，③第0代的开地址

自由对象列表
GC执行的时候，需要清除没有标记存活的对象，标记为存活的就不清除
这些对象占用的空间需要还给操作系统，或者说再下一次分配对象的时候使用
.NET堆段上的对象是连续的，被清除的对象就会变成一个特殊的数组对象，这个数组的元素大小为1，长度可以自由控制
这个对象的总长度会等于被清除对象的长度用于标记这一处空间没有被使用，像这样的对象被称为自由对象
GC标记对象是否存活↓
    |    ...   |小对象|小对象|小对象|小对象|小对象|    ...   |
    |                 已分配空间                  |未分配空间|
                  ↓                  ↓
未存活的对象变为自由对象，相邻的自由对象会合并，同时存活标记被清除↓
    |    ...   |小对象|自由对象|小对象|自由对象|    ...   |
    |                 已分配空间               |未分配空间|
如果自由空间出现在已分配空间的尾部，那么它会释放给操作系统，并且所占空间会归为未分配空间
    |    ...   |小对象|自由对象|小对象|             ...   |
    |                 已分配空间      |         未分配空间|
堆段上自由对象所占的空间可以称为碎片空间
如果说碎片空间太多，GC就会选择压缩来减少它们，压缩会把各个对象的值往前移动，这样就会让分配空间总体减少
如果说整个堆段都没有存活的空间，那么会从堆段的链表中删掉，并且占用的空间会重新还给操作系统
而管理被释放堆段实例的本身，可能会作为可重用堆段记录下来，以供下次新建对象使用
托管堆的每个区域有4个自由对象列表，它们分别记录第0、1代的自由对象、第2代小对象堆段的自由对象、第2代大对象堆段的自由对象
GC会先从第0代的自由对象列表获取自由对象，然后把自由对象占用的空间变为分配上下文的空间
分配大对象的时候，先从第2代大对象堆段的自由对象列表里面去获取自由对象，然后把大对象的值放在这个自由对象占用的空间中
如果说自由对象还有剩余部分，那么会在这个部分创建一个新的自由对象，并且再把它记录到这个自由对象列表中
为了提升这种重用自由对象的效率，第2代的自由对象列表，还会根据自由对象的大小进行分组
重用自由对象的时候会根据需要的大小，尽量从更小的分组中去找到自由对象并重用

跨代引用记录
.NET实现分代的主要原因是为了支持垃圾回收时只处理一部分对象
目前.NET中的GC支持指定目标代
支持指定目标代是可以减少扫描的对象数量
第1代对象的引用类型成员指向了第0代对象称为跨代引用，这就有可能出现漏标记存活的问题
为了解决跨代引用的问题，.NET中有一个数组专门记录跨代引用，这个数组又称为卡片表，卡片表会标记所有发生跨代引用的位置
当GC扫描的时候除了扫描目标代，还会扫描卡片表中标记的位置，以防止发生漏标记存活，因为卡片表实际上是一个数组，扫描卡片表中标记的位置是一个线性时间
如果说这个程序内存占用越大，那么扫描卡片表需要的时间就越长
.NET会根据程序的内存占用量来决定是否使用卡片束，卡片束记录卡片表中哪些位置有标记，先扫描卡片束再扫描卡片表就可以减少处理时间

GC的触发条件
第1个条件是分配对象时找不到可用空间
第2个条件是分配量超过阈值
第3个条件是托管代码主动调用GC.Collect函数
第4个条件是收到物理内存不足的通知

分配对象时找不到可用空间
分配上下文的时候或者分配大对象的时候，先尝试从自由对象列表查找可用的自由对象，再尝试从短暂堆段或者最新的大对象堆段末尾去分配，如果这些分配都失败了，就会触发GC
第1种是针对第1代的GC，这一种GC会尝试回收短暂堆段上的对象，使得短暂堆段有更多的空间
第2种是针对第2代的GC，也就是完整的GC，这种GC会在物理内存不足或执行第1种GC以后仍然 无法分配时触发
分配小对象时找不到空间，通常是因为新分配对象越来越多导致的，如果GC可以从短暂堆段中回收足 够多的对象，那么短暂堆段会继续使用，否则GC新建一个短暂堆段，而原有的短暂堆段可以变成小对 象堆，
其中所有的对象都会变成2代
分配大对象时找不到可用空间，除了由于新分配的对象越来越多导致以外，还有可能是大对象的碎片 空间率比较高导致的，如果说原因是因为碎片太多，.NET默认是不会执行大对象的压缩处理的
在开发过程种，应当尽可能的减少大对象的分配，可以在程序中建立对象池，重用对象，享元模式
如果说程序明确会创建大对象，那么就可以强制开启大对象的压缩

分配量超过阈值
.NET中托管堆根据工作模式以及CPU的逻辑核心数量，可以分为多个区域，每个区域都有所谓的四个实例，每一个实例包含静态数据和动态数据
静态数据包含了分配量阈值的上限和下限
动态数据包含了分配量的阈值
如果在某个代分配的对象值大小合计超过分配量阈值，就会触发针对这个代的GC
分配量的阈值会在每次结束后重新计算
这个东西它没有一个绝对的值，是由GC自己计算的，而且这个值还是动态的
新分配的阈值它会由GC结束后，这个代存活数量的多少以及存活率决定的
存活下来的对象越多，新分配量的阈值就越高

GC.Collect
托管代码中调用GC.Collect函数可以主动触发GC。

物理内存不足
物理内存接近用尽时，操作系统会把物理内存中的部分内容移动到分页文件
.NET为了避免因使用分页文件带来的性能低下，会自动检测物理内存是否接近不足，然后触发GC
目前这个机制只支持windows系统

GC的总流程
触发GC→停止其它线程（切换其它线程到抢占模式）→重新决定目标代与判断是否执行后台GC
→后台GC→①标记阶段/②后台标记阶段，恢复其它线程(合作模式)
          ↓                                             ↓
          ↓                                             ↓
       计划阶段                                          ↓
          ↓                                             ↓
          ↓                                        后台清扫阶段
         压缩→是→④重定位阶段                          ↓
          ↓             ↓                              ↓
          否             ↓                              ↓
          ↓          压缩阶段                           ↓
      ③清扫阶段         ↓                              ↓
          ↓             ↓                              ↓
          ↓←←←←←←←                               ↓
          ↓                                             ↓
     恢复其它线程，切换其它线程到合作模式(合作模式)←←←← 
          ↓
         结束

GC代码设置
<Project Sdk="Microsoft.NET.sdk">
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>netcoreapp3.1</TargetFramewark>
    <!-- true 服务图模式 false 工作站模式 -->
    <ServerGarbageCollection>true</ServerGarbageCollection>
    <!-- true 启动后台GC false 禁用后台GC -->
    <ConcurrentGarbageCollection>true</ConcurrentGarbageCollection>
  </PropertyGroup>
</Project>

Close和Dispose
调用完Close方法后，可以通过Open重新打开一个数据库连接，当彻底不用这个对象了就可以调用Dispose方法来标记此对象无用，等待GC回收