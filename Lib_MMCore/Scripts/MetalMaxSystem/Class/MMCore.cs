using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading;
using System.Runtime.InteropServices;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Net;
using Mathf = System.MathF;
using Vector2F = System.Numerics.Vector2;
using Vector3F = System.Numerics.Vector3;
using Vector2D = System.Windows.Vector;
//Vector3D见自定义结构体
using Point2D = System.Windows.Point;
//Point3D见自定义结构体

//其他引用
using System.Management;
using Microsoft.Win32;
using System.Diagnostics;
using System.Windows;

namespace MetalMaxSystem
{
    /// <summary>
    /// 【MM_函数库】核心类
    /// </summary>
    public static class MMCore
    {
        #region 常量

        //键盘按键映射

        public const int c_keyNone = -1;
        public const int c_keyShift = 0;
        public const int c_keyControl = 1;
        public const int c_keyAlt = 2;
        public const int c_key0 = 3;
        public const int c_key1 = 4;
        public const int c_key2 = 5;
        public const int c_key3 = 6;
        public const int c_key4 = 7;
        public const int c_key5 = 8;
        public const int c_key6 = 9;
        public const int c_key7 = 10;
        public const int c_key8 = 11;
        public const int c_key9 = 12;
        public const int c_keyA = 13;
        public const int c_keyB = 14;
        public const int c_keyC = 15;
        public const int c_keyD = 16;
        public const int c_keyE = 17;
        public const int c_keyF = 18;
        public const int c_keyG = 19;
        public const int c_keyH = 20;
        public const int c_keyI = 21;
        public const int c_keyJ = 22;
        public const int c_keyK = 23;
        public const int c_keyL = 24;
        public const int c_keyM = 25;
        public const int c_keyN = 26;
        public const int c_keyO = 27;
        public const int c_keyP = 28;
        public const int c_keyQ = 29;
        public const int c_keyR = 30;
        public const int c_keyS = 31;
        public const int c_keyT = 32;
        public const int c_keyU = 33;
        public const int c_keyV = 34;
        public const int c_keyW = 35;
        public const int c_keyX = 36;
        public const int c_keyY = 37;
        public const int c_keyZ = 38;
        public const int c_keySpace = 39;
        public const int c_keyGrave = 40;
        public const int c_keyNumPad0 = 41;
        public const int c_keyNumPad1 = 42;
        public const int c_keyNumPad2 = 43;
        public const int c_keyNumPad3 = 44;
        public const int c_keyNumPad4 = 45;
        public const int c_keyNumPad5 = 46;
        public const int c_keyNumPad6 = 47;
        public const int c_keyNumPad7 = 48;
        public const int c_keyNumPad8 = 49;
        public const int c_keyNumPad9 = 50;
        public const int c_keyNumPadPlus = 51;
        public const int c_keyNumPadMinus = 52;
        public const int c_keyNumPadMultiply = 53;
        public const int c_keyNumPadDivide = 54;
        public const int c_keyNumPadDecimal = 55;
        public const int c_keyEquals = 56;
        public const int c_keyMinus = 57;
        public const int c_keyBracketOpen = 58;
        public const int c_keyBracketClose = 59;
        public const int c_keyBackSlash = 60;
        public const int c_keySemiColon = 61;
        public const int c_keyApostrophe = 62;
        public const int c_keyComma = 63;
        public const int c_keyPeriod = 64;
        public const int c_keySlash = 65;
        public const int c_keyEscape = 66;
        public const int c_keyEnter = 67;
        public const int c_keyBackSpace = 68;
        public const int c_keyTab = 69;
        public const int c_keyLeft = 70;
        public const int c_keyUp = 71;
        public const int c_keyRight = 72;
        public const int c_keyDown = 73;
        public const int c_keyInsert = 74;
        public const int c_keyDelete = 75;
        public const int c_keyHome = 76;
        public const int c_keyEnd = 77;
        public const int c_keyPageUp = 78;
        public const int c_keyPageDown = 79;
        public const int c_keyCapsLock = 80;
        public const int c_keyNumLock = 81;
        public const int c_keyScrollLock = 82;
        public const int c_keyPause = 83;
        public const int c_keyPrintScreen = 84;
        public const int c_keyNextTrack = 85;
        public const int c_keyPrevTrack = 86;
        public const int c_keyF1 = 87;
        public const int c_keyF2 = 88;
        public const int c_keyF3 = 89;
        public const int c_keyF4 = 90;
        public const int c_keyF5 = 91;
        public const int c_keyF6 = 92;
        public const int c_keyF7 = 93;
        public const int c_keyF8 = 94;
        public const int c_keyF9 = 95;
        public const int c_keyF10 = 96;
        public const int c_keyF11 = 97;
        public const int c_keyF12 = 98;

        //鼠标按键映射

        public const int c_mouseButtonNone = 0;
        public const int c_mouseButtonLeft = 1;
        public const int c_mouseButtonMiddle = 2;
        public const int c_mouseButtonRight = 3;
        public const int c_mouseButtonXButton1 = 4;
        public const int c_mouseButtonXButton2 = 5;

        //其他常量

        //暂无

        //键鼠函数引用上限及单键注册上限

        /// <summary>
        /// 【MM_函数库】键盘按键句柄上限（句柄范围0~98，无按键-1）
        /// </summary>
        public const int c_keyMax = 98;
        /// <summary>
        /// 【MM_函数库】每个键盘按键可注册函数上限
        /// </summary>
        public const int c_regKeyMax = 8;
        /// <summary>
        /// 【MM_函数库】鼠标按键句柄上限（句柄范围1~5，无按键0）
        /// </summary>
        public const int c_mouseMax = 5;
        /// <summary>
        /// 【MM_函数库】每个鼠标按键可注册函数上限
        /// </summary>
        public const int c_regMouseMax = 24;

        //主副循环入口函数引用上限及单入口注册上限

        /// <summary>
        /// 【MM_函数库】主副循环入口句柄上限（句柄范围0~9）
        /// </summary>
        private const int c_entryMax = 9;//内部使用，无需给用户使用
        /// <summary>
        /// 【MM_函数库】每个主副循环入口可注册函数上限
        /// </summary>
        private const int c_regEntryMax = 1;//内部使用，无需给用户使用

        #endregion

        #region "全局和局部变量"（不同作用域下的无属性字段）

        //类只有字段没变量说法，但理论上公有静态字段是该程序在内存中唯一的全局变量，无论类实例化多次或多线程从模板调用，它只生成一次副本直到程序结束才清理
        //而非静态（实例）类每次实例化都复制一份模板去形成多个副本，私有实例字段相当于类的局部变量
        //不标Static则类及其成员在结束时垃圾回收，标Static则副本唯一且程序结束才从内存消失
        //静态局部变量在函数结束时不参与垃圾回收，以便相同函数重复访问
        //静态数据是从模板形成的内存中唯一的可修改副本（不同类同名也不一样，要考虑命名空间和类名路径，无需担心重复）
        //数组元素数量上限均+1是习惯问题，防止某些循环以数组判断时最后退出还+1导致超限

        /// <summary>
        /// 【MM_函数库】键盘按键已注册数量（每个数组元素算1个，即使它们+=多个委托函数）
        /// </summary>
        private static int[] keyEventFuncrefGroupNum = new int[c_keyMax + 1];//内部使用

        /// <summary>
        /// 【MM_函数库】鼠标按键的已注册数量（每个数组元素算1个，即使它们+=多个委托函数）
        /// </summary>
        private static int[] mouseEventFuncrefGroupNum = new int[c_mouseMax + 1];//内部使用

        private static bool[] _stopKeyMouseEvent = new bool[Game.c_maxPlayers + 1];
        /// <summary>
        /// 【MM_函数库】用户按键事件禁用状态（用于过场、剧情对话、特殊技能如禁锢时强制停用用户的按键事件）
        /// </summary>
        public static bool[] StopKeyMouseEvent
        {
            get
            {
                return _stopKeyMouseEvent;
            }

            set
            {
                _stopKeyMouseEvent = value;
            }
        }

        /// <summary>
        /// 【MM_函数库】主副循环每个入口的已注册数量（每个数组元素算1个，即使它们+=多个委托函数）
        /// </summary>
        private static int[] entryEventFuncrefGroupNum = new int[c_entryMax + 1];//内部使用

        private static bool[] _stopEntryEvent = new bool[Game.c_maxPlayers + 1];
        /// <summary>
        /// 【MM_函数库】主副循环事件禁用状态（用于特殊情况如个人处理队列过多、玩家间未同步时间过长情况下停用用户主副循环事件）
        /// </summary>
        public static bool[] StopEntryEvent
        {
            get
            {
                return _stopEntryEvent;
            }

            set
            {
                _stopEntryEvent = value;
            }
        }

        #region 字典

        #region 值类型

        /// <summary>
        /// 【MM_函数库】全局字典<string,int> （不排泄，直到程序结束）
        /// </summary>
        private static Dictionary<string, int> systemDictionaryInt = new Dictionary<string, int>();//内部使用
        /// <summary>
        /// 【MM_函数库】临时字典<string,int> （函数或动作集结束时应手动排泄）
        /// </summary>
        private static Dictionary<string, int> tempDictionaryInt = new Dictionary<string, int>();//内部使用

        /// <summary>
        /// 【MM_函数库】全局字典<string,long> （不排泄，直到程序结束）
        /// </summary>
        private static Dictionary<string, long> systemDictionaryLong = new Dictionary<string, long>();//内部使用
        /// <summary>
        /// 【MM_函数库】临时字典<string,long> （函数或动作集结束时应手动排泄）
        /// </summary>
        private static Dictionary<string, long> tempDictionaryLong = new Dictionary<string, long>();//内部使用

        /// <summary>
        /// 【MM_函数库】全局字典<string,char> （不排泄，直到程序结束）
        /// </summary>
        private static Dictionary<string, char> systemDictionaryChar = new Dictionary<string, char>();//内部使用
        /// <summary>
        /// 【MM_函数库】临时字典<string,char> （函数或动作集结束时应手动排泄）
        /// </summary>
        private static Dictionary<string, char> tempDictionaryChar = new Dictionary<string, char>();//内部使用

        /// <summary>
        /// 【MM_函数库】全局字典<string,float> （不排泄，直到程序结束）
        /// </summary>
        private static Dictionary<string, float> systemDictionaryFloat = new Dictionary<string, float>();//内部使用
        /// <summary>
        /// 【MM_函数库】临时字典<string,float> （函数或动作集结束时应手动排泄）
        /// </summary>
        private static Dictionary<string, float> tempDictionaryFloat = new Dictionary<string, float>();//内部使用

        /// <summary>
        /// 【MM_函数库】全局字典<string,double> （不排泄，直到程序结束）
        /// </summary>
        private static Dictionary<string, double> systemDictionaryDouble = new Dictionary<string, double>();//内部使用
        /// <summary>
        /// 【MM_函数库】临时字典<string,double> （函数或动作集结束时应手动排泄）
        /// </summary>
        private static Dictionary<string, double> tempDictionaryDouble = new Dictionary<string, double>();//内部使用

        /// <summary>
        /// 【MM_函数库】全局字典<string,bool> （不排泄，直到程序结束）
        /// </summary>
        private static Dictionary<string, bool> systemDictionaryBool = new Dictionary<string, bool>();//内部使用
        /// <summary>
        /// 【MM_函数库】临时字典<string,bool> （函数或动作集结束时应手动排泄）
        /// </summary>
        private static Dictionary<string, bool> tempDictionaryBool = new Dictionary<string, bool>();//内部使用

        /// <summary>
        /// 【MM_函数库】全局字典<string,byte> （不排泄，直到程序结束）
        /// </summary>
        private static Dictionary<string, byte> systemDictionaryByte = new Dictionary<string, byte>();//内部使用
        /// <summary>
        /// 【MM_函数库】临时字典<string,byte> （函数或动作集结束时应手动排泄）
        /// </summary>
        private static Dictionary<string, byte> tempDictionaryByte = new Dictionary<string, byte>();//内部使用

        #endregion

        #region 引用类型

        /// <summary>
        /// 【MM_函数库】全局字典<string,Object> （不排泄，直到程序结束）
        /// </summary>
        private static Dictionary<string, object> systemDictionaryObject = new Dictionary<string, object>();//内部使用
        /// <summary>
        /// 【MM_函数库】临时字典<string,Object> （函数或动作集结束时应手动排泄）
        /// </summary>
        private static Dictionary<string, object> tempDictionaryObject = new Dictionary<string, object>();//内部使用

        /// <summary>
        /// 【MM_函数库】全局字典<string,Vector> （不排泄，直到程序结束）
        /// </summary>
        private static Dictionary<string, Vector2F> systemDictionaryVector = new Dictionary<string, Vector2F>();//内部使用
        /// <summary>
        /// 【MM_函数库】临时字典<string,Vector> （函数或动作集结束时应手动排泄）
        /// </summary>
        private static Dictionary<string, Vector2F> tempDictionaryVector = new Dictionary<string, Vector2F>();//内部使用

        /// <summary>
        /// 【MM_函数库】全局字典<string,Timer> （不排泄，直到程序结束）
        /// </summary>
        private static Dictionary<string, Timer> systemDictionaryTimer = new Dictionary<string, Timer>();//内部使用
        /// <summary>
        /// 【MM_函数库】临时字典<string,Timer> （函数或动作集结束时应手动排泄）
        /// </summary>
        private static Dictionary<string, Timer> tempDictionaryTimer = new Dictionary<string, Timer>();//内部使用

        /// <summary>
        /// 【MM_函数库】全局字典<string,string> （不排泄，直到程序结束）
        /// </summary>
        private static Dictionary<string, string> systemDictionaryString = new Dictionary<string, string>();//内部使用
        /// <summary>
        /// 【MM_函数库】临时字典<string,string> （函数或动作集结束时应手动排泄）
        /// </summary>
        private static Dictionary<string, string> tempDictionaryString = new Dictionary<string, string>();//内部使用

        #endregion

        #endregion

        /// <summary>
        /// 【MM_函数库】全局哈希表（不排泄，直到程序结束）
        /// </summary>
        private static Hashtable systemHashTable = new Hashtable();//内部使用
        /// <summary>
        /// 【MM_函数库】临时哈希表（函数或动作集结束时应手动排泄）
        /// </summary>
        private static Hashtable tempHashTable = new Hashtable();//内部使用

        //声明用于存放键盘、鼠标"按键事件引用类型"委托变量的二维数组集合（单元素也是集合能+=多个委托函数），C#自带委托列表类型能继续存储这些委托类型变量

        /// <summary>
        /// 【MM_函数库】键盘按键事件引用委托类型变量数组[c_keyMax + 1, c_regKeyMax + 1]，用于自定义委托函数注册
        /// </summary>
        private static KeyMouseEventFuncref[,] keyEventFuncrefGroup = new KeyMouseEventFuncref[c_keyMax + 1, c_regKeyMax + 1];//内部使用
        /// <summary>
        /// 【MM_函数库】鼠标按键事件引用委托类型变量数组[c_mouseMax + 1, c_regMouseMax + 1]，用于自定义委托函数注册
        /// </summary>
        private static KeyMouseEventFuncref[,] mouseEventFuncrefGroup = new KeyMouseEventFuncref[c_mouseMax + 1, c_regMouseMax + 1];//内部使用

        //声明用于存放"主副循环入口事件引用类型"委托变量二维数组集合

        /// <summary>
        /// 【MM_函数库】主副循环入口事件引用委托类型变量数组[c_entryMax + 1, c_regEntryMax + 1]，用于自定义委托函数注册
        /// </summary>
        private static EntryEventFuncref[,] entryEventFuncrefGroup = new EntryEventFuncref[c_entryMax + 1, c_regEntryMax + 1];//内部使用

        #endregion

        #region 构造函数

        /// <summary>
        /// 【MM_函数库】核心类
        /// </summary>
        static MMCore()
        {
            //这里可给字段进行第二次赋值或安排其他动作（字段的首次赋值是在声明时，同一次初始化执行顺序受动作所在上下文影响）
        }

        #endregion

        #region 字段及其属性方法

        //字段及其属性方法（避免不安全读写，private保护和隐藏字段，设计成只允许通过public修饰的属性方法间接去安全读写）

        public static string _dataTableType;
        /// <summary>
        /// 【MM_函数库】数据表类型，填入"HashTable"时切换为哈希表，其他情况默认采用字典
        /// </summary>
        public static string DataTableType
        {
            get
            {
                return _dataTableType;
            }

            set
            {
                switch (value)
                {
                    case "HashTable":
                        _dataTableType = value;
                        break;
                    default:
                        _dataTableType = "Dictionary";
                        break;
                }
            }
        }

        /// <summary>
        /// 【MM_函数库】本地主机编号
        /// </summary>
        public static int LocalID { get; set; }

        private static int _directoryEmptyUserDefIndex = 0;
        /// <summary>
        /// 【MM_函数库】用户定义的空文件夹形式，以供内部判断：0是子文件（夹）数量为0，1是文件夹大小为0，2是前两者必须都符合，如果用户输入错误，本属性方法将纠正为默认值0
        /// </summary>
        public static int DirectoryEmptyUserDefIndex
        {
            get
            {
                return _directoryEmptyUserDefIndex;
            }
            //如果用户输入错误，纠正为默认值0
            set
            {
                if (value >= 0 && value <= 2)
                {
                    _directoryEmptyUserDefIndex = value;
                }
                else
                {
                    _directoryEmptyUserDefIndex = 0;
                }
            }
        }

        #endregion

        #region Functions 数学公式

        /// <summary>
        /// 【MM_函数库】随机角度
        /// </summary>
        /// <param name="min"></param>
        /// <param name="max"></param>
        /// <returns>返回[0,360)之间的随机角度</returns>
        public static double RandomAngle()
        {
            System.Random r = new System.Random(Guid.NewGuid().GetHashCode());
            return 360 * r.NextDouble();
        }

        /// <summary>
        /// 【MM_函数库】随机实数（不含最大值）
        /// </summary>
        /// <param name="min"></param>
        /// <param name="max"></param>
        /// <returns>返回[min,max)之间的随机实数</returns>
        public static double RandomDouble(double min, double max)
        {
            System.Random r = new System.Random(Guid.NewGuid().GetHashCode());
            if (min <= max)
            {
                return min + (max - min) * r.NextDouble();
            }
            else
            {
                return max + (min - max) * r.NextDouble();
            }
        }

        /// <summary>
        /// 【MM_函数库】随机整数（不含最大值）
        /// </summary>
        /// <param name="min"></param>
        /// <param name="max"></param>
        /// <returns>返回[min,max)之间的随机整数</returns>
        public static int RandomInt(int min, int max)
        {
            System.Random r = new System.Random(Guid.NewGuid().GetHashCode());
            if (min <= max)
            {
                return r.Next(min, max);
            }
            else
            {
                return r.Next(max, min);
            }
        }

        /// <summary>
        /// 【MM_函数库】将Vector3转Vector2（去掉Z轴）
        /// </summary>
        /// <param name="vector"></param>
        /// <returns></returns>
        public static Vector2F ToVector2F(Vector3F vector)
        {
            return new Vector2F(vector.X, vector.Y);
        }

        /// <summary>
        /// 【MM_函数库】将Vector3转Vector2（去掉Z轴）
        /// </summary>
        /// <param name="vector"></param>
        /// <returns></returns>
        public static Vector2D ToVector2D(Vector3D vector)
        {
            return new Vector2D(vector.x, vector.y);
        }

        /// <summary>
        ///  【MM_函数库】以实数返回二维坐标（x,y）与（a,b）形成的角度（单位：度）
        /// </summary>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static float AngleBetween(float x, float y, float a, float b)
        {
            Vector2F vector1 = new Vector2F(x, y);
            Vector2F vector2 = new Vector2F(a, b);

            float dotProduct = Vector2F.Dot(vector1, vector2);
            float magnitude1 = Mathf.Sqrt(vector1.X * vector1.X + vector1.Y * vector1.Y);
            float magnitude2 = Mathf.Sqrt(vector2.X * vector2.X + vector2.Y * vector2.Y);
            //Rad2Deg等于57.29578，它是180除以π（圆周率）的结果
            float angle = Mathf.Acos(dotProduct / (magnitude1 * magnitude2)) * 180 / Mathf.PI;

            return angle;

            //return Vector2D.Angle(new Vector2D(x, y), new Vector2D(a, b)); //Unity引擎函数
        }

        /// <summary>
        /// 【MM_函数库】以实数返回三维坐标（x,y,z）与（a,b,c）形成的角度（单位：度）
        /// </summary>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <param name="z"></param>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <param name="c"></param>
        /// <returns></returns>
        public static float AngleBetween(float x, float y, float z, float a, float b, float c)
        {
            Vector3F vector1 = new Vector3F(x, y, z);
            Vector3F vector2 = new Vector3F(a, b, c);
            float dotProduct = Vector3F.Dot(vector1, vector2);
            float magnitude1 = Mathf.Sqrt(vector1.X * vector1.X + vector1.Y * vector1.Y + vector1.Z * vector1.Z);
            float magnitude2 = Mathf.Sqrt(vector2.X * vector2.X + vector2.Y * vector2.Y + vector2.Z * vector2.Z);
            float angle = Mathf.Acos(dotProduct / (magnitude1 * magnitude2)) * 180 / Mathf.PI;
            return angle;

            //return Vector3F.Angle(new Vector3F(x, y, z), new Vector3F(a, b, z)); //Unity引擎函数
        }

        /// <summary>
        /// 【MM_函数库】以实数返回二维点1点2形成的角度（单位：度）
        /// Returns the angle from point 1 to point 2 as a real value, in degrees
        /// </summary>
        /// <param name="point1">二维点</param>
        /// <param name="point2">二维点</param>
        /// <returns></returns>
        public static float AngleBetween(Point2F point1, Point2F point2)
        {
            float X1 = point1.x, Y1 = point1.y, X2 = point2.y, Y2 = point2.y;
            float angleOfLine = Mathf.Atan2((Y2 - Y1), (X2 - X2)) * 180 / Mathf.PI;
            return angleOfLine;

            //return Vector2F.Angle(new Vector2F(point1.x, point1.y), new Vector2F(point2.x, point2.y)); //Unity引擎函数
        }

        /// <summary>
        /// 【MM_函数库】以实数返回三维点1点2形成的角度（单位：度）
        /// </summary>
        /// <param name="point1">三维点</param>
        /// <param name="point2">三维点</param>
        /// <returns></returns>
        public static float AngleBetween(Point3F point1, Point3F point2)
        {
            float X1 = point1.x, Y1 = point1.y, Z1 = point1.z;
            float X2 = point2.x, Y2 = point2.y, Z2 = point2.z;
            float dotProduct = X1 * X2 + Y1 * Y2 + Z1 * Z2;
            float magnitude1 = Mathf.Sqrt(X1 * X1 + Y1 * Y1 + Z1 * Z1);
            float magnitude2 = Mathf.Sqrt(X2 * X2 + Y2 * Y2 + Z2 * Z2);
            float cosineOfAngle = dotProduct / (magnitude1 * magnitude2);
            float angle = Mathf.Acos(cosineOfAngle) * 180 / Mathf.PI;
            return angle;

            //return Vector3F.Angle(new Vector3F(point1.x, point1.y, point1.z), new Vector3F(point2.x, point2.y, point2.z)); //Unity引擎函数
        }

        /// <summary>
        /// 【MM_函数库】以实数返回二维向量之间形成的角度（单位：度）
        /// </summary>
        /// <param name="vector1"></param>
        /// <param name="vector2"></param>
        /// <returns></returns>
        public static float AngleBetween(Vector2F vector1, Vector2F vector2)
        {
            float dotProduct = Vector2F.Dot(vector1, vector2);
            float magnitude1 = Mathf.Sqrt(vector1.X * vector1.X + vector1.Y * vector1.Y);
            float magnitude2 = Mathf.Sqrt(vector2.X * vector2.X + vector2.Y * vector2.Y);
            //Rad2Deg等于57.29578，它是180除以π（圆周率）的结果
            float angle = Mathf.Acos(dotProduct / (magnitude1 * magnitude2)) * 180 / Mathf.PI;

            return angle;

            //return Vector2F.Angle(vector1, vector2); //Unity引擎函数
        }

        /// <summary>
        /// 【MM_函数库】以实数返回三维向量之间形成的角度（单位：度）
        /// </summary>
        /// <param name="vector1"></param>
        /// <param name="vector2"></param>
        /// <returns></returns>
        public static float AngleBetween(Vector3F vector1, Vector3F vector2)
        {
            float dotProduct = Vector3F.Dot(vector1, vector2);
            float magnitude1 = Mathf.Sqrt(vector1.X * vector1.X + vector1.Y * vector1.Y + vector1.Z * vector1.Z);
            float magnitude2 = Mathf.Sqrt(vector2.X * vector2.X + vector2.Y * vector2.Y + vector2.Z * vector2.Z);
            float angle = Mathf.Acos(dotProduct / (magnitude1 * magnitude2)) * 180 / Mathf.PI;
            return angle;

            //return Vector3F.Angle(vector1, vector2); //Unity引擎函数
        }

        /// <summary>
        /// 【MM_函数库】以实数返回二维坐标（x,y）与（a,b）形成的距离（单位：m）
        /// </summary>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static float Distance(float x, float y, float a, float b)
        {
            float x1 = x;
            float y1 = y;

            float x2 = a;
            float y2 = b;

            float result = Mathf.Sqrt(Mathf.Pow((x1 - x2), 2) + Mathf.Pow((y1 - y2), 2));
            return result;
        }

        /// <summary>
        /// 【MM_函数库】以实数返回二维点之间形成的距离（单位：m）
        /// </summary>
        /// <param name="point1"></param>
        /// <param name="point2"></param>
        /// <returns></returns>
        public static float Distance(Point2F point1, Point2F point2)
        {
            float x1 = point1.x;
            float y1 = point1.y;

            float x2 = point2.x;
            float y2 = point2.y;

            float result = Mathf.Sqrt(Mathf.Pow((x1 - x2), 2) + Mathf.Pow((y1 - y2), 2));
            return result;
        }

        /// <summary>
        /// 【MM_函数库】以实数返回二维向量之间形成的距离（单位：m）
        /// </summary>
        /// <param name="vector1"></param>
        /// <param name="vector2"></param>
        /// <returns></returns>
        public static float Distance(Vector2F vector1, Vector2F vector2)
        {
            float x1 = vector1.X;
            float y1 = vector1.Y;

            float x2 = vector2.X;
            float y2 = vector2.Y;

            float result = Mathf.Sqrt(Mathf.Pow((x1 - x2), 2) + Mathf.Pow((y1 - y2), 2));
            return result;
        }

        /// <summary>
        /// 【MM_函数库】以实数返回三维坐标（x,y,z）与（a,b,c）形成的距离（单位：度）
        /// </summary>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <param name="z"></param>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <param name="c"></param>
        /// <returns></returns>
        public static float Distance(float x, float y, float z, float a, float b, float c)
        {
            float x1 = x;
            float y1 = y;
            float z1 = z;

            float x2 = a;
            float y2 = b;
            float z2 = c;

            float result = Mathf.Sqrt(Mathf.Pow((x1 - x2), 2) + Mathf.Pow((y1 - y2), 2) + Mathf.Pow((z1 - z2), 2));
            return result;
        }

        /// <summary>
        /// 【MM_函数库】以实数返回三维点之间形成的距离（单位：m）
        /// </summary>
        /// <param name="point1"></param>
        /// <param name="point2"></param>
        /// <returns></returns>
        public static float Distance(Point3F point1, Point3F point2)
        {
            float x1 = point1.x;
            float y1 = point1.y;
            float z1 = point1.z;

            float x2 = point2.x;
            float y2 = point2.y;
            float z2 = point2.z;

            float result = Mathf.Sqrt(Mathf.Pow((x1 - x2), 2) + Mathf.Pow((y1 - y2), 2) + Mathf.Pow((z1 - z2), 2));
            return result;
        }

        /// <summary>
        /// 【MM_函数库】以实数返回三维向量之间形成的距离（单位：m）
        /// </summary>
        /// <param name="vector1"></param>
        /// <param name="vector2"></param>
        /// <returns></returns>
        public static float Distance(Vector3F vector1, Vector3F vector2)
        {
            float x1 = vector1.X;
            float y1 = vector1.Y;
            float z1 = vector1.Z;

            float x2 = vector2.X;
            float y2 = vector2.Y;
            float z2 = vector2.Z;

            float result = Mathf.Sqrt(Mathf.Pow((x1 - x2), 2) + Mathf.Pow((y1 - y2), 2) + Mathf.Pow((z1 - z2), 2));
            return result;
        }

        #endregion

        #region Functions 通用功能

        /// <summary>
        /// 将字符串转换为字节数组，再转成2位16进制字符串格式或转成10进制数字再转为3位8进制字符串格式，以供在Galaxy代码中混肴使用
        /// Galaxy代码会自动转转义8和16位格式字符串（\0及\x）为ASCII值（数字）,再转为控制字符使用
        /// </summary>
        /// <param name="input"></param>
        /// <param name="r">向16进制转换的概率，否则向8进制转换</param>
        /// <returns></returns>
        public static string ConvertStringToHOMixed(string input, double r)
        {
            string result = "";
            // 创建一个System.Random对象
            System.Random random = new System.Random(Guid.NewGuid().GetHashCode());
            foreach (byte b in Encoding.UTF8.GetBytes(input))
            {
                // 根据随机数和触发概率决定是否执行动作
                if (random.NextDouble() < r)
                {
                    //result += $"\\x{b:X2}";
                    result += string.Format("\\x{0:X2}", b);
                }
                else
                {
                    //result += $"\\0{Convert.ToString(b, 8)}";
                    result += string.Format("\\0{Convert.ToString(b, 8)}", b);
                }
            }
            return result;
        }

        /// <summary>
        /// 将字符串转换为字节数组，再转成10进制数字，再转为3位8进制字符串格式，以供在Galaxy代码中混肴使用
        /// Galaxy代码会自动转转义8和16位格式字符串（\0及\x）为ASCII值（数字）,再转为控制字符使用
        /// 如八进制"\0124"、"\0114"表示十进制的84和76，Galaxy脚本中识别为"T"和"L"
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        public static string ConvertStringToOctal(string input)
        {
            string result = "";
            foreach (byte b in Encoding.UTF8.GetBytes(input))
            {
                //result += $"\\0{Convert.ToString(b, 8)}";
                result += string.Format("\\0{Convert.ToString(b, 8)}", b);
            }
            return result;
        }

        /// <summary>
        /// 将字符串转换为字节数组，再转成2位16进制字符串格式，以供在Galaxy代码中混肴使用
        /// Galaxy代码会自动转转义8和16位格式字符串（\0及\x）为ASCII值（数字）,再转为控制字符使用
        /// 如十六进制"\x4C"表示十进制的84，Galaxy脚本中识别为"T"
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        public static string ConvertStringToHex(string input)
        {
            string result = "";
            foreach (byte b in Encoding.UTF8.GetBytes(input))
            {
                //result += $"\\x{b:X2}";
                result += string.Format("\\x{b:X2}", b);
            }
            return result;
        }

        /// <summary>
        /// 去掉代码里的注释
        /// </summary>
        /// <param name="code"></param>
        /// <returns></returns>
        public static string RemoveComments(string code)
        {
            string pattern = @"//.*?$|/\*.*?\*/";
            //使用 RegexOptions.Multiline 选项来指定模式应在多个行上进行匹配，并使用 RegexOptions.Singleline 选项来指定模式应在单个连续字符串上进行匹配
            RegexOptions options = RegexOptions.Multiline | RegexOptions.Singleline;
            string result = Regex.Replace(code, pattern, string.Empty, options);
            return result;
        }

        /// <summary>
        /// 去掉代码里的空行
        /// </summary>
        /// <param name="code"></param>
        /// <returns></returns>
        public static string RemoveEmptyLines(string code)
        {
            string pattern = @"^\s*$";
            RegexOptions options = RegexOptions.Multiline;
            string result = Regex.Replace(code, pattern, string.Empty, options);
            return result;
        }

        #region 判断文件是否被占用

        [DllImport("kernel32.dll")]
        public static extern IntPtr _lopen(string lpPathName, int iReadWrite);

        [DllImport("kernel32.dll")]
        public static extern bool CloseHandle(IntPtr hObject);

        public const int OF_READWRITE = 2;
        public const int OF_SHARE_DENY_NONE = 0x40;
        public static readonly IntPtr HFILE_ERROR = new IntPtr(-1);

        /// <summary>
        /// 【MM_函数库】文件是否被占用（WIN32 API调用）
        /// </summary>
        /// <param name="fileFullNmae"></param>
        /// <returns></returns>
        public static bool IsOccupied(string fileFullNmae)
        {
            if (!File.Exists(fileFullNmae)) return false;
            IntPtr vHandle = _lopen(fileFullNmae, OF_READWRITE | OF_SHARE_DENY_NONE);
            var flag = vHandle == HFILE_ERROR;
            CloseHandle(vHandle);
            return flag;
        }

        /// <summary>
        /// 【MM_函数库】文件是否被占用（文件流判断法）
        /// </summary>
        /// <param name="fileName"></param>
        /// <returns>true表示正在使用,false没有使用 </returns>
        public static bool IsFileInUse(string fileName)
        {
            bool inUse = true;
            FileStream fs = null;
            try
            {
                fs = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.None);
                inUse = false;
            }
            catch { }
            finally
            {
                if (fs != null) fs.Dispose();
            }
            return inUse;
        }

        #endregion

        /// <summary>
        /// 【MM_函数库】递归方式强制删除文件夹（进最里层删除文件使文件夹为空后删除这个空文件夹，层层递出时重复动作），删除前会去掉文件（夹）的Archive、ReadOnly、Hidden属性以确保删除
        /// </summary>
        /// <param name="dirInfo"></param>
        public static void DelDirectoryRecursively(DirectoryInfo dirInfo)
        {
            foreach (DirectoryInfo newInfo in dirInfo.GetDirectories())
            {
                DelDirectoryRecursively(newInfo);//递归遍历子文件夹
            }
            foreach (FileInfo newInfo in dirInfo.GetFiles())
            {
                //处理每个文件夹内部的文件（从里层开始删除）
                newInfo.Attributes &= ~(FileAttributes.Archive | FileAttributes.ReadOnly | FileAttributes.Hidden);
                newInfo.Delete();
            }
            //对每个文件夹处理（从里层开始删除）
            dirInfo.Attributes &= ~(FileAttributes.Archive | FileAttributes.ReadOnly | FileAttributes.Hidden);
            dirInfo.Delete(true);
        }

        /// <summary>
        /// 【MM_函数库】递归方式强制删除文件夹（进最里层删除文件使文件夹为空后删除这个空文件夹，层层递出时重复动作），删除前会去掉文件（夹）的Archive、ReadOnly、Hidden属性以确保删除
        /// </summary>
        /// <param name="dirPath"></param>
        public static void DelDirectoryRecursively(string dirPath)
        {
            DirectoryInfo dirInfo = new DirectoryInfo(dirPath);
            foreach (DirectoryInfo newInfo in dirInfo.GetDirectories())
            {
                DelDirectoryRecursively(newInfo);
            }
            foreach (FileInfo newInfo in dirInfo.GetFiles())
            {
                newInfo.Attributes &= ~(FileAttributes.Archive | FileAttributes.ReadOnly | FileAttributes.Hidden);
                newInfo.Delete();
            }
            dirInfo.Attributes &= ~(FileAttributes.Archive | FileAttributes.ReadOnly | FileAttributes.Hidden);
            dirInfo.Delete(true);

        }

        /// <summary>
        /// 【MM_函数库】删除文件夹
        /// </summary>
        /// <param name="dirInfo"></param>
        /// <returns>删除成功返回真，否则返回假</returns>
        public static bool DelDirectory(DirectoryInfo dirInfo)
        {
            bool torf = false;
            if (dirInfo.Exists)
            {
                dirInfo.Delete(true);
                if (!dirInfo.Exists) { torf = true; }
            }
            return torf;
        }

        /// <summary>
        /// 【MM_函数库】删除文件夹
        /// </summary>
        /// <param name="dirPath"></param>
        /// <returns>删除返回真，否则返回假</returns>
        public static bool DelDirectory(string dirPath)
        {
            bool torf = false;
            if (Directory.Exists(dirPath))
            {
                DirectoryInfo dirInfo = new DirectoryInfo(dirPath);
                dirInfo.Delete(true);
                if (!dirInfo.Exists) { torf = true; }
            }
            return torf;
        }

        /// <summary>
        /// 【MM_函数库】删除文件到回收站功能专用属性，已添加Shell API特性[DllImport("shell32.dll", CharSet = CharSet.Unicode)]
        /// </summary>
        /// <param name="lpFileOp"></param>
        /// <returns></returns>
        [DllImport("shell32.dll", CharSet = CharSet.Unicode)]
        public static extern int SHFileOperation(ref SHFILEOPSTRUCT lpFileOp);

        /// <summary>
        /// 【MM_函数库】删除文件到回收站功能专用结构体，已添加特性[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        public struct SHFILEOPSTRUCT
        {
            public IntPtr hwnd;
            public uint wFunc;
            public string pFrom;
            public string pTo;
            public ushort fFlags;
            public bool fAnyOperationsAborted;
            public IntPtr hNameMappings;
            public string lpszProgressTitle;
        }

        /// <summary>
        /// 【MM_函数库】删除文件到回收站功能专用枚举，已添加特性[Flags]
        /// </summary>
        [Flags]
        public enum SHFileOperationFlags : ushort
        {
            /// <summary>
            /// 不出现错误确认或询问用户的对话框
            /// </summary>
            FOF_SILENT = 0x0004,
            /// <summary>
            /// 不出现任何对话框
            /// </summary>
            FOF_NOCONFIRMATION = 0x0010,
            /// <summary>
            /// 文件删除后可以放到回收站
            /// </summary>
            FOF_ALLOWUNDO = 0x0040,
            /// <summary>
            /// 不出现错误对话框
            /// </summary>
            FOF_NOERRORUI = 0x0400,
        }

        /// <summary>
        /// 【MM_函数库】删除文件到回收站
        /// </summary>
        /// <param name="filePath"></param>
        /// <param name="torf"></param>
        public static void DelFileToRecycleBin(string filePath, bool torf)
        {
            if (!File.Exists(filePath))
            {
                return;
            }
            SHFILEOPSTRUCT fileop = new SHFILEOPSTRUCT
            {
                wFunc = 0x003,//删除文件到回收站
                pFrom = filePath + '\0'//多个文件以 \0 分隔
            };
            if (!torf)
            {
                //不确认直接删除（通过或运算符集成准许撤销+不出现任何对话框）
                fileop.fFlags = (ushort)(SHFileOperationFlags.FOF_ALLOWUNDO | SHFileOperationFlags.FOF_NOCONFIRMATION);
            }
            else
            {
                //需要用户确认删除，文件操作属性清空
                fileop.fFlags = 0;
            }
            SHFileOperation(ref fileop);
        }

        /// <summary>
        /// 【MM_函数库】删除文件夹到回收站
        /// </summary>
        /// <param name="dirPath"></param>
        /// <param name="torf">回收站删除提示</param>
        public static void DelDirectoryToRecycleBin(string dirPath, bool torf)
        {
            if (!Directory.Exists(dirPath))
            {
                return;
            }
            SHFILEOPSTRUCT fileop = new SHFILEOPSTRUCT
            {
                wFunc = 0x003,//删除文件到回收站
                pFrom = dirPath + '\0'//多个文件以 \0 分隔
            };
            if (!torf)
            {
                //不确认直接删除（通过或运算符集成准许撤销+不出现任何对话框）
                fileop.fFlags = (ushort)(SHFileOperationFlags.FOF_ALLOWUNDO | SHFileOperationFlags.FOF_NOCONFIRMATION);
            }
            else
            {
                //需要用户确认删除，文件操作属性清空
                fileop.fFlags = 0;
            }
            SHFileOperation(ref fileop);
        }

        /// <summary>
        /// 【MM_函数库】将字节大小转字符串Byte、KB、MB、GB、TB、PB、EB、ZB、YB、NB形式
        /// </summary>
        /// <param name="Size">字节大小</param>
        /// <param name="Byte">true=强制输出字节单位</param>
        /// <returns></returns>
        public static string CountSize(long Size, bool Byte)
        {
            string strSize = "";
            if (Byte)
            {
                strSize = StrAddSymbol(Size.ToString(), 3, ",") + " Byte";
            }
            else
            {
                if (Size < 1024.00)
                    strSize = Size.ToString() + " Byte";
                else if (Size >= 1024.00 && Size < Math.Pow(1024, 2))
                    strSize = (Size / 1024.00).ToString("F2") + " KB";
                else if (Size >= Math.Pow(1024, 2) && Size < Math.Pow(1024, 3))
                    strSize = (Size / Math.Pow(1024, 2)).ToString("F2") + " MB";
                else if (Size >= Math.Pow(1024, 3) && Size < Math.Pow(1024, 4))
                    strSize = (Size / Math.Pow(1024, 3)).ToString("F2") + " GB";
                else if (Size >= Math.Pow(1024, 4) && Size < Math.Pow(1024, 5))
                    strSize = (Size / Math.Pow(1024, 4)).ToString("F2") + " TB";
                else if (Size >= Math.Pow(1024, 5) && Size < Math.Pow(1024, 6))
                    strSize = (Size / Math.Pow(1024, 5)).ToString("F2") + " PB";
                else if (Size >= Math.Pow(1024, 6) && Size < Math.Pow(1024, 7))
                    strSize = (Size / Math.Pow(1024, 6)).ToString("F2") + " EB";
                else if (Size >= Math.Pow(1024, 7) && Size < Math.Pow(1024, 8))
                    strSize = (Size / Math.Pow(1024, 7)).ToString("F2") + " ZB";
                else if (Size >= Math.Pow(1024, 8) && Size < Math.Pow(1024, 9))
                    strSize = (Size / Math.Pow(1024, 8)).ToString("F2") + " YB";
                else if (Size >= Math.Pow(1024, 9) && Size < Math.Pow(1024, 10))
                    strSize = (Size / Math.Pow(1024, 9)).ToString("F2") + " NB";
                else if (Size >= Math.Pow(1024, 10))
                    strSize = (Size / Math.Pow(1024, 10)).ToString("F2") + " DB";
            }
            return strSize;
        }

        /// <summary>
        /// 【MM_函数库】将字节大小转字符串Byte、KB、MB、GB、TB、PB、EB、ZB、YB、NB形式
        /// </summary>
        /// <param name="Size">字节大小</param>
        /// <param name="Byte">true=强制输出字节单位</param>
        /// <returns></returns>
        public static string CountSize(double Size, bool Byte)
        {
            string strSize = "";
            if (Byte)
            {
                strSize = StrAddSymbol(Size.ToString(), 3, ",") + " Byte";
            }
            else
            {
                if (Size < 1024.00)
                    strSize = Size.ToString() + " Byte";
                else if (Size >= 1024.00 && Size < Math.Pow(1024, 2))
                    strSize = (Size / 1024.00).ToString("F2") + " KB";
                else if (Size >= Math.Pow(1024, 2) && Size < Math.Pow(1024, 3))
                    strSize = (Size / Math.Pow(1024, 2)).ToString("F2") + " MB";
                else if (Size >= Math.Pow(1024, 3) && Size < Math.Pow(1024, 4))
                    strSize = (Size / Math.Pow(1024, 3)).ToString("F2") + " GB";
                else if (Size >= Math.Pow(1024, 4) && Size < Math.Pow(1024, 5))
                    strSize = (Size / Math.Pow(1024, 4)).ToString("F2") + " TB";
                else if (Size >= Math.Pow(1024, 5) && Size < Math.Pow(1024, 6))
                    strSize = (Size / Math.Pow(1024, 5)).ToString("F2") + " PB";
                else if (Size >= Math.Pow(1024, 6) && Size < Math.Pow(1024, 7))
                    strSize = (Size / Math.Pow(1024, 6)).ToString("F2") + " EB";
                else if (Size >= Math.Pow(1024, 7) && Size < Math.Pow(1024, 8))
                    strSize = (Size / Math.Pow(1024, 7)).ToString("F2") + " ZB";
                else if (Size >= Math.Pow(1024, 8) && Size < Math.Pow(1024, 9))
                    strSize = (Size / Math.Pow(1024, 8)).ToString("F2") + " YB";
                else if (Size >= Math.Pow(1024, 9) && Size < Math.Pow(1024, 10))
                    strSize = (Size / Math.Pow(1024, 9)).ToString("F2") + " NB";
                else if (Size >= Math.Pow(1024, 10))
                    strSize = (Size / Math.Pow(1024, 10)).ToString("F2") + " DB";
            }
            return strSize;
        }

        /// <summary>
        /// 【MM_函数库】为字符串str每隔every位添加symbol
        /// </summary>
        /// <param name="str"></param>
        /// <param name="every"></param>
        /// <param name="symbol"></param>
        /// <returns></returns>
        public static string StrAddSymbol(string str, int every, string symbol)
        {
            string n = "";
            for (int i = str.Length - 1, j = 1; i >= 0; i--)
            {
                n = str[i].ToString() + n;
                if (j > 0 && i > 0 && (j % every == 0))
                {
                    n = symbol + n;
                    j = 0;
                }
                j++;
            }
            return n;
        }

        /// <summary>
        /// 【MM_函数库】获取文件大小
        /// </summary>
        /// <param name="fileInfo"></param>
        /// <returns></returns>
        public static long GetFileLength(FileInfo fileInfo)
        {
            long len = 0;
            if (fileInfo.Exists)
            {
                len = fileInfo.Length;
            }
            return len;
        }

        /// <summary>
        /// 【MM_函数库】获取文件大小
        /// </summary>
        /// <param name="filePath">文件名完整路径</param>
        /// <returns></returns>
        public static long GetFileLength(string filePath)
        {
            long len = 0;
            if (File.Exists(filePath))
            {
                len = new FileInfo(filePath).Length;
            }
            return len;
        }

        /// <summary>
        /// 【MM_函数库】递归方法获取文件夹大小
        /// </summary>
        /// <param name="dirPath">文件夹完整路径</param>
        /// <returns></returns>
        public static long GetDirectoryLength(string dirPath)
        {
            //判断给定的路径是否存在,如果不存在则退出
            if (!Directory.Exists(dirPath))
            {
                return 0;
            }
            long len = 0;
            //定义一个DirectoryInfo对象
            DirectoryInfo di = new DirectoryInfo(dirPath);
            //通过GetFiles方法,获取di目录中的所有文件的大小，量越大越慢
            foreach (FileInfo fi in di.GetFiles())
            {
                len += fi.Length;
            }
            //获取di中所有的文件夹,并存到一个新的对象数组中,以进行递归
            DirectoryInfo[] dis = di.GetDirectories();
            if (dis.Length > 0)
            {
                for (int i = 0; i < dis.Length; i++)
                {
                    len += GetDirectoryLength(dis[i].FullName);
                }
            }
            return len;
        }

        /// <summary>
        /// 【MM_函数库】取得设备硬盘的卷序列号（在Unity、MonoGame不适用）
        /// </summary>
        /// <param name="diskSymbol">盘符</param>
        /// <returns>成功返回卷序列号，失败返回"uHnIk"</returns>
        public static string GetHardDiskID(string diskSymbol)
        {
            try
            {
                string hdInfo = "";
                ManagementObject disk = new ManagementObject(
                    "win32_logicaldisk.deviceid=\"" + diskSymbol + ":\""
                );
                hdInfo = disk.Properties["VolumeSerialNumber"].Value.ToString();
                disk = null;
                return hdInfo.Trim();
            }
            catch
            {
                return "uHnIk";
            }
        }

        /// <summary>
        /// 【MM_函数库】验证字符串是否为整数
        /// </summary>
        /// <param name="str"></param>
        /// <returns></returns>
        public static bool IsNumeric(string str)
        {
            Regex reg1 = new Regex(@"^[0-9]\d*$");
            return reg1.IsMatch(str);
        }

        /// <summary>
        /// 【MM_函数库】验证字符串是否为合法文件（夹）名称，可以是虚拟路径（本函数不验证其真实存在）
        /// </summary>
        /// <param name="path">文件（夹）路径全名</param>
        /// <returns></returns>
        public static bool IsDFPath(string path)
        {
            //发现带中文符号会识别不出，为中文符号继续追加（）【】：
            Regex regex = new Regex(
                @"^([a-zA-Z]:\\)([-\u4e00-\u9fa5\w\s.（）【】：~!@#$%^&()\[\]{}+=]+\\?)*$"
            );
            Match result = regex.Match(path);
            return result.Success;
        }

        /// <summary>
        /// 【MM_函数库】验证字符串路径的文件（夹）是否真实存在
        /// </summary>
        /// <param name="path">文件（夹）路径全名</param>
        /// <returns></returns>
        public static bool IsDF(string path)
        {
            bool torf = false;
            if (Directory.Exists(path) || File.Exists(path))
            {
                torf = true;
            }
            return torf;
        }

        /// <summary>
        /// 【MM_函数库】判断目标属性是否为真实文件夹
        /// </summary>
        /// <param name="path">文件夹路径全名</param>
        /// <returns></returns>
        public static bool IsDirAttributes(string path)
        {
            FileInfo fi = new FileInfo(path);
            if ((fi.Attributes & FileAttributes.Directory) != 0)
            {
                //ReadOnly = 1,
                //Hidden = 2,
                //System = 4,
                //Directory = 16,
                //Archive = 32,
                //Device = 64,
                //如果设置了ReadOnly和Directory，则FileAttributes等于16+1=17，二进制为00001001
                //如果没有设置目录位，则会得到零：
                //File.GetAttributes(source) = 00000001
                //  FileAttributes.Directory = 00001000 &
                //-------------------------------------
                //                             00000000
                return true;
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        /// 【MM_函数库】验证字符串路径的文件夹是否真实存在
        /// </summary>
        /// <param name="path">文件夹路径全名</param>
        /// <returns></returns>
        public static bool IsDir(string path)
        {
            bool torf = false;
            if (Directory.Exists(path))
            {
                torf = true;
            }
            return torf;
        }

        /// <summary>
        /// 【MM_函数库】验证字符串路径的文件是否真实存在
        /// </summary>
        /// <param name="path">文件路径全名</param>
        /// <returns></returns>
        public static bool IsFile(string path)
        {
            bool torf = false;
            if (File.Exists(path))
            {
                torf = true;
            }
            return torf;
        }

        /// <summary>
        /// 【MM_函数库】验证目录是否为空
        /// </summary>
        /// <param name="path"></param>
        /// <returns></returns>
        public static bool IsDirectoryEmpty(string path)
        {
            bool torf = false;
            DirectoryInfo dir = new DirectoryInfo(path);
            //为了效率，只要验证当前层就可以了
            if (dir.GetFiles().Length + dir.GetDirectories().Length == 0)
            {
                torf = true;
            }
            return torf;
        }

        /// <summary>
        /// 【MM_函数库】验证路径是否为用户定义的空文件夹，通过MMCore.DirectoryEmptyUserDefIndex属性可定义空文件夹形式
        /// </summary>
        /// <param name="path"></param>
        /// <returns></returns>
        public static bool IsDirectoryEmptyUserDef(string path)
        {
            bool torf = false;
            switch (DirectoryEmptyUserDefIndex) //定义空文件夹形式
            {
                case 0:
                    if (IsDirectoryEmpty(path))
                    {
                        torf = true;
                    } //里面的子文件夹和文件数量均为0
                    break;
                case 1:
                    if (GetDirectoryLength(path) == 0)
                    {
                        torf = true;
                    } //文件夹大小为0
                    break;
                case 2:
                    if (IsDirectoryEmpty(path) && GetDirectoryLength(path) == 0)
                    {
                        torf = true;
                    } //以上两者
                    break;
                default:
                    if (IsDirectoryEmpty(path))
                    {
                        torf = true;
                    } //里面的子文件夹和文件数量均为0
                    break;
            }
            return torf;
        }

        /// <summary>
        /// 【MM_函数库】写文本每行，文件若不存在则自动新建
        /// </summary>
        /// <param name="path"></param>
        /// <param name="value"></param>
        /// <param name="torf">false是覆盖，true是追加文本</param>
        public static void WriteLine(string path, string value, bool torf)
        {
            using (StreamWriter sw = new StreamWriter(path, torf, Encoding.Unicode))
            {
                sw.WriteLine(value);
                //sw.Flush(); 不等待sw.Close()即刻写入，对于遍历大量写入来说并不效率，故此时不写
            }

        }

        /// <summary>
        /// 【MM_函数库】写文本，文件若不存在则自动新建
        /// </summary>
        /// <param name="path"></param>
        /// <param name="value"></param>
        /// <param name="torf">false是覆盖，true是追加文本</param>
        public static void Write(string path, string value, bool torf)
        {
            using (StreamWriter sw = new StreamWriter(path, torf, Encoding.Unicode))
            {
                sw.Write(value);
                //sw.Flush(); 不等待sw.Close()即刻写入，对于遍历大量写入来说并不效率，故此时不写
            }

        }

        /// <summary>
        /// 【MM_函数库】验证文件大小是否在用户定义的[a,b]范围
        /// </summary>
        /// <param name="path"></param>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool IsDFSizeInRange(string path, long a, long b)
        {
            bool torf = false;
            long x;
            for (int i = 0; i < 1; i++)
            {
                if (IsDir(path))
                {
                    x = GetDirectoryLength(path);
                }
                else if (IsFile(path))
                {
                    x = GetFileLength(path);
                }
                else { break; }
                if (x >= a && x <= b)
                {
                    torf = true;
                }
            }
            return torf;
        }

        /// <summary>
        /// 【MM_函数库】创建GET请求
        /// </summary>
        /// <param name="url"></param>
        /// <returns></returns>
        public static string CreateGetHttpResponse(string url)
        {
            HttpWebRequest request = WebRequest.Create(url) as HttpWebRequest;
            request.Method = "GET";
            request.UserAgent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36 Edg/113.0.1774.50";
            try
            {
                HttpWebResponse webresponse = request.GetResponse() as HttpWebResponse;
                using (Stream s = webresponse.GetResponseStream())
                {
                    StreamReader reader = new StreamReader(s, Encoding.UTF8);
                    return reader.ReadToEnd();
                }
            }
            catch (Exception)
            {
                return "requestFalse";
            }

        }

        /// <summary>
        /// 【MM_函数库】创建POST请求
        /// </summary>
        /// <param name="url"></param>
        /// <param name="parameters"></param>
        /// <param name="ContentType"></param>
        /// <returns></returns>
        public static string CreatePostHttpResponse(string url, IDictionary<string, string> parameters, string ContentType = "application/x-www-form-urlencoded")
        {
            HttpWebRequest request;
            //如果是发送HTTPS请求  
            if (url.StartsWith("https", StringComparison.OrdinalIgnoreCase))
            {
                request = WebRequest.Create(url) as HttpWebRequest;
            }
            else
            {
                request = WebRequest.Create(url) as HttpWebRequest;
            }
            request.Method = "POST";
            request.UserAgent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36 Edg/113.0.1774.50";
            request.ContentType = ContentType;
            //发送POST数据  
            if (!(parameters == null || parameters.Count == 0))
            {
                StringBuilder buffer = new StringBuilder();
                int i = 0;
                foreach (string key in parameters.Keys)
                {
                    if (i > 0)
                    {
                        buffer.AppendFormat("&{0}={1}", key, parameters[key]);
                    }
                    else
                    {
                        buffer.AppendFormat("{0}={1}", key, parameters[key]);
                        i++;
                    }
                }
                byte[] data = Encoding.ASCII.GetBytes(buffer.ToString());
                using (Stream stream = request.GetRequestStream())
                {
                    stream.Write(data, 0, data.Length);
                }
            }
            try
            {
                HttpWebResponse webresponse = request.GetResponse() as HttpWebResponse;
                using (Stream s = webresponse.GetResponseStream())
                {
                    StreamReader reader = new StreamReader(s, Encoding.UTF8);
                    return reader.ReadToEnd();
                }
            }
            catch (Exception)
            {
                return "requestFalse";
            }
        }

        /// <summary>
        /// 【MM_函数库】下载指定网站的指定节点内容到指定文件夹并保存为自定义文件名
        /// 使用范例：
        /// HtmlDocument doc = new();
        /// doc.LoadHtml(MMCore.CreateGetHttpResponse("https://ac.qq.com/Comic/ComicInfo/id/542330"));
        /// HtmlNode img = doc.DocumentNode.SelectSingleNode("/html/body/div[3]/div[3]/div[1]/div[1]/div[1]/a/img");
        /// string imgUal = img.Attributes["src"].Value;
        /// MMCore.Download(imgUal, "123.jpg", @"C:\Users\Admin\Desktop\Download\", true);
        /////Debug.WriteLine("下载完成！");
        /// </summary>
        /// <param name="url">浏览器网址</param>
        /// <param name="filename">自定义文件名</param>
        /// <param name="path">下载路径，如 @"C:\Users\Admin\Desktop\Download\"</param>
        /// <param name="cover">发生文件重复时覆盖</param>
        /// <returns></returns>
        public static bool Download(string url, string filename, string path, bool cover)
        {
            string tempPath = Path.Combine(Path.GetDirectoryName(path), "temp");//确定临时文件夹全名路径
            string filepath = Path.Combine(path, filename);//确定最终下载文件全名路径
            Directory.CreateDirectory(tempPath);  //创建临时文件夹
            string tempFile = tempPath + "\\" + filename + ".temp"; //确定临时下载文件全名路径
            if (File.Exists(tempFile))
            {
                File.Delete(tempFile);    //临时下载文件存在则删除
            }
            FileStream fs = new FileStream(tempFile, FileMode.Append, FileAccess.Write, FileShare.ReadWrite);
            try
            {
                // 设置参数
                HttpWebRequest request = WebRequest.Create(url) as HttpWebRequest;
                //发送请求并获取相应回应数据
                HttpWebResponse response = request.GetResponse() as HttpWebResponse;
                //直到request.GetResponse()程序才开始向目标网页发送Post请求
                Stream responseStream = response.GetResponseStream();
                byte[] bArr = new byte[1024];
                int size = responseStream.Read(bArr, 0, (int)bArr.Length);
                while (size > 0)
                {
                    fs.Write(bArr, 0, size);
                    size = responseStream.Read(bArr, 0, (int)bArr.Length);
                }
                responseStream.Close();
                responseStream.Dispose();
            }
            catch (Exception ex)
            {
                //Debug.Log(string.Format("错误: {0}", ex.Message));
                return false;
            }
            finally
            {
                fs.Close();
                fs.Dispose();
            }
            try
            {
                File.Move(tempFile, filepath);
            }
            catch
            {
                if (cover) { File.Delete(filepath); File.Move(tempFile, filepath); }
            }
            try
            {
                DelDirectory(tempPath);
            }
            catch
            {
                DelDirectoryRecursively(tempPath);
            }
            return true;
        }

        ///<summary>
        ///【MM_函数库】生成随机字符串 
        ///</summary>
        ///<param name="length">目标字符串的长度</param>
        ///<param name="useNum">是否包含数字，1=包含，默认为包含</param>
        ///<param name="useLow">是否包含小写字母，1=包含，默认为包含</param>
        ///<param name="useUpp">是否包含大写字母，1=包含，默认为包含</param>
        ///<param name="useSpe">是否包含特殊字符，1=包含，默认为不包含</param>
        ///<param name="custom">要包含的自定义字符，直接输入要包含的字符列表</param>
        ///<returns>指定长度的随机字符串</returns>
        public static string GetRandomString(int length, bool useNum = true, bool useLow = true, bool useUpp = true, bool useSpe = false, string custom = null)
        {
            byte[] b = new byte[4];
            new System.Security.Cryptography.RNGCryptoServiceProvider().GetBytes(b);
            System.Random r = new System.Random(BitConverter.ToInt32(b, 0));
            string s = null, str = custom;
            if (useNum == true) { str += "0123456789"; }
            if (useLow == true) { str += "abcdefghijklmnopqrstuvwxyz"; }
            if (useUpp == true) { str += "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; }
            if (useSpe == true) { str += "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~"; }
            for (int i = 0; i < length; i++)
            {
                s += str.Substring(r.Next(0, str.Length - 1), 1);
            }
            return s;
        }

        /// <summary>
        /// 【MM_函数库】创建文件夹，若已存在则什么也不干
        /// </summary>
        /// <param name="path"></param>
        public static void CreatDirectory(string path)
        {
            if (!Directory.Exists(path))
            {
                DirectoryInfo directory = new DirectoryInfo(path);
                directory.Create();
            }
        }

        /// <summary>
        /// 【MM_函数库】创建文件，若已存在则什么也不干
        /// </summary>
        /// <param name="filepath"></param>
        public static void CreatFile(string filepath)
        {
            if (!File.Exists(filepath))
            {
                File.Create(filepath);
            }
        }

        /// <summary>
        /// 【MM_函数库】用WinRAR解压带密码的压缩包（在Unity、MonoGame不适用）
        /// </summary>
        /// <param name="zipFilePath">压缩包路径</param>
        /// <param name="unZipPath">解压后文件夹的路径</param>
        /// <param name="password">压缩包密码</param>
        /// <returns></returns>
        public static bool UnZip(string zipFilePath, string unZipPath, string password)
        {
            if (!IsOwnWinRAR())
            {
                MessageBox.Show("本机并未安装WinRAR,请安装该压缩软件!", "温馨提示");
                return false;
            }

            Process Process1 = new Process();
            Process1.StartInfo.FileName = "WinRAR.exe";
            Process1.StartInfo.CreateNoWindow = true;
            Process1.StartInfo.Arguments = " x -p" + password + " " + zipFilePath + " " + unZipPath;
            Process1.Start();
            if (Process1.HasExited)
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        /// 【MM_函数库】判断系统上是否安装WinRAR（在Unity、MonoGame不适用）
        /// </summary>
        /// <returns></returns>
        public static bool IsOwnWinRAR()
        {
            RegistryKey the_Reg =
                Registry.LocalMachine.OpenSubKey(
                    @"SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\WinRAR.exe");
            return !string.IsNullOrEmpty(the_Reg.GetValue("").ToString());
        }

        #region 弹幕爬取

        //功能出处：https://blog.csdn.net/qq_15505341/article/details/79212070/

        /// <summary>
        /// 【MM_函数库】获取弹幕信息（本函数待改中请勿使用）
        /// </summary>
        /// <param name="room"></param>
        /// <returns></returns>
        public static string Post(string room)
        {
            string postString = "roomid=" + room + "&token=&csrf_token=我是图中的马赛克";//要发送的数据
            byte[] postData = Encoding.UTF8.GetBytes(postString);//编码，尤其是汉字，事先要看下抓取网页的编码方式  
            string url = @"http://api.live.bilibili.com/ajax/msg";//地址  

            WebClient webClient = new WebClient();
            webClient.Headers.Add("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36");
            webClient.Headers.Add("Content-Type", "application/x-www-form-urlencoded");//采取POST方式必须加的header，如果改为GET方式的话就去掉这句话即可  
            webClient.Headers.Add("Cookie",
                "可耻的马赛克"
                );
            byte[] responseData = webClient.UploadData(url, "POST", postData);//得到返回字符流  
            string srcString = Encoding.UTF8.GetString(responseData);//解码  
            return srcString;
        }

        /// <summary>
        /// 【MM_函数库】处理弹幕信息为中文（本函数待改中请勿使用）
        /// </summary>
        /// <param name="room"></param>
        /// <returns></returns>
        public static List<string> GetDanMu(string room)
        {
            string danmu = Post(room);
            List<string> list = new List<string>();
            //正则匹配
            foreach (Match item in Regex.Matches(danmu, "text\":\".*?\""))
            {
                //截取字符串，将unicode码转换为中文
                list.Add(Regex.Unescape(item.Value.Substring(7, item.Value.Length - 8)));
            }
            return list;
        }


        #endregion

        #endregion

        #region Functions 数据表功能

        //注：用户与基础数据表通用键名，用户数据表的键名默认添加前缀"HD_"进行区分，用数据表设计其他功能时应再次添加不重复前缀以免与用户数据表键区重叠（参互动管理功能）

        #region 用户数据表

        //建议使用泛型字典，值与引用类型不混用

        #region 引用类型

        #region Object

        /// <summary>
        /// 【MM_函数库】判断数据表键是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DataTableObjectKeyExists(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableKeyExists(place, "HD_" + key);
                default:
                    return DictionaryObjectKeyExists(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】判断数据表值是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool DataTableObjectValueExists(bool place, object value)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableValueExists(place, value);
                default:
                    return DictionaryObjectValueExists(place, value);
            }

        }

        /// <summary>
        /// 【MM_函数库】获取数据表键对应的值
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static object DataTableObjectGetValue(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableGetValue(place, "HD_" + key);
                default:
                    return DictionaryObjectGetValue(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        public static void DataTableObjectClear0(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    DictionaryObjectClear0(place, "HD_" + key);
                    break;
                default:
                    HashTableClear0(place, "HD_" + key);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[]，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        public static void DataTableObjectClear1(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear1(place, "HD_" + key, lp_1);
                    break;
                default:
                    DictionaryObjectClear1(place, "HD_" + key, lp_1);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,]，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        public static void DataTableObjectClear2(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear2(place, "HD_" + key, lp_1, lp_2);
                    break;
                default:
                    DictionaryObjectClear2(place, "HD_" + key, lp_1, lp_2);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,,]，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        public static void DataTableObjectClear3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear3(place, "HD_" + key, lp_1, lp_2, lp_3);
                    break;
                default:
                    DictionaryObjectClear3(place, "HD_" + key, lp_1, lp_2, lp_3);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,,,]，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        public static void DataTableObjectClear4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                    break;
                default:
                    DictionaryObjectClear4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】移除数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        private static void DataTableObjectRemove(bool place, string key)//内部函数
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableRemove(place, "HD_" + key);
                    break;
                default:
                    DictionaryObjectRemove(place, "HD_" + key);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        public static void DataTableObjectSave0(bool place, string key, object val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave0(place, "HD_" + key, val);
                    break;
                default:
                    DictionaryObjectSave0(place, "HD_" + key, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="val"></param>
        public static void DataTableObjectSave1(bool place, string key, int lp_1, object val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave1(place, "HD_" + key, lp_1, val);
                    break;
                default:
                    DictionaryObjectSave1(place, "HD_" + key, lp_1, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="val"></param>
        public static void DataTableObjectSave2(bool place, string key, int lp_1, int lp_2, object val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave2(place, "HD_" + key, lp_1, lp_2, val);
                    break;
                default:
                    DictionaryObjectSave2(place, "HD_" + key, lp_1, lp_2, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="val"></param>
        public static void DataTableObjectSave3(bool place, string key, int lp_1, int lp_2, int lp_3, object val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave3(place, "HD_" + key, lp_1, lp_2, lp_3, val);
                    break;
                default:
                    DictionaryObjectSave3(place, "HD_" + key, lp_1, lp_2, lp_3, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <param name="val"></param>
        public static void DataTableObjectSave4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4, object val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4, val);
                    break;
                default:
                    DictionaryObjectSave4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static object DataTableObjectLoad0(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableLoad0(place, "HD_" + key);
                default:
                    return DictionaryObjectLoad0(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns></returns>
        public static object DataTableObjectLoad1(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableLoad1(place, "HD_" + key, lp_1);
                default:
                    return DictionaryObjectLoad1(place, "HD_" + key, lp_1);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns></returns>
        public static object DataTableObjectLoad2(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableLoad2(place, "HD_" + key, lp_1, lp_2);
                default:
                    return DictionaryObjectLoad2(place, "HD_" + key, lp_1, lp_2);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns></returns>
        public static object DataTableObjectLoad3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
                default:
                    return DictionaryObjectLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns></returns>
        public static object DataTableObjectLoad4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                default:
                    return DictionaryObjectLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
            }
        }

        #endregion

        #region Vector

        /// <summary>
        /// 【MM_函数库】判断数据表键是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DataTableVectorKeyExists(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableKeyExists(place, "HD_" + key);
                default:
                    return DictionaryVectorKeyExists(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】判断数据表值是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool DataTableVectorValueExists(bool place, Vector2F value)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableValueExists(place, value);
                default:
                    return DictionaryVectorValueExists(place, value);
            }
        }

        /// <summary>
        /// 【MM_函数库】获取数据表键对应的值
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static Vector2F DataTableVectorGetValue(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (Vector2F)HashTableGetValue(place, "HD_" + key);
                default:
                    return DictionaryVectorGetValue(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        public static void DataTableVectorClear0(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear0(place, "HD_" + key);
                    break;
                default:
                    DictionaryVectorClear0(place, "HD_" + key);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[]，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        public static void DataTableVectorClear1(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear1(place, "HD_" + key, lp_1);
                    break;
                default:
                    DictionaryVectorClear1(place, "HD_" + key, lp_1);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,]，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        public static void DataTableVectorClear2(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear2(place, "HD_" + key, lp_1, lp_2);
                    break;
                default:
                    DictionaryVectorClear2(place, "HD_" + key, lp_1, lp_2);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,,]，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        public static void DataTableVectorClear3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear3(place, "HD_" + key, lp_1, lp_2, lp_3);
                    break;
                default:
                    DictionaryVectorClear3(place, "HD_" + key, lp_1, lp_2, lp_3);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,,,]，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        public static void DataTableVectorClear4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                    break;
                default:
                    DictionaryVectorClear4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】移除数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        private static void DataTableVectorRemove(bool place, string key)//内部函数
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableRemove(place, "HD_" + key);
                    break;
                default:
                    DictionaryVectorRemove(place, "HD_" + key);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        public static void DataTableVectorSave0(bool place, string key, Vector2F val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave0(place, "HD_" + key, val);
                    break;
                default:
                    DictionaryVectorSave0(place, "HD_" + key, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="val"></param>
        public static void DataTableVectorSave1(bool place, string key, int lp_1, Vector2F val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave1(place, "HD_" + key, lp_1, val);
                    break;
                default:
                    DictionaryVectorSave1(place, "HD_" + key, lp_1, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="val"></param>
        public static void DataTableVectorSave2(bool place, string key, int lp_1, int lp_2, Vector2F val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave2(place, "HD_" + key, lp_1, lp_2, val);
                    break;
                default:
                    DictionaryVectorSave2(place, "HD_" + key, lp_1, lp_2, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="val"></param>
        public static void DataTableVectorSave3(bool place, string key, int lp_1, int lp_2, int lp_3, Vector2F val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave3(place, "HD_" + key, lp_1, lp_2, lp_3, val);
                    break;
                default:
                    DictionaryVectorSave3(place, "HD_" + key, lp_1, lp_2, lp_3, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <param name="val"></param>
        public static void DataTableVectorSave4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4, Vector2F val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4, val);
                    break;
                default:
                    DictionaryVectorSave4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static Vector2F? DataTableVectorLoad0_N(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (Vector2F?)HashTableLoad0(place, "HD_" + key);
                default:
                    return DictionaryVectorLoad0_N(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns></returns>
        public static Vector2F? DataTableVectorLoad1_N(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (Vector2F?)HashTableLoad1(place, "HD_" + key, lp_1);
                default:
                    return DictionaryVectorLoad1_N(place, "HD_" + key, lp_1);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns></returns>
        public static Vector2F? DataTableVectorLoad2_N(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (Vector2F?)HashTableLoad2(place, "HD_" + key, lp_1, lp_2);
                default:
                    return DictionaryVectorLoad2_N(place, "HD_" + key, lp_1, lp_2);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns></returns>
        public static Vector2F? DataTableVectorLoad3_N(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (Vector2F?)HashTableLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
                default:
                    return DictionaryVectorLoad3_N(place, "HD_" + key, lp_1, lp_2, lp_3);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns></returns>
        public static Vector2F? DataTableVectorLoad4_N(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (Vector2F?)HashTableLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                default:
                    return DictionaryVectorLoad4_N(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns>错误时返回new Vector2F(0,0)</returns>
        public static Vector2F DataTableVectorLoad0(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (Vector2F)HashTableLoad0(place, "HD_" + key);
                default:
                    return DictionaryVectorLoad0(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns></returns>
        public static Vector2F DataTableVectorLoad1(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (Vector2F)HashTableLoad1(place, "HD_" + key, lp_1);
                default:
                    return DictionaryVectorLoad1(place, "HD_" + key, lp_1);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns></returns>
        public static Vector2F DataTableVectorLoad2(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (Vector2F)HashTableLoad2(place, "HD_" + key, lp_1, lp_2);
                default:
                    return DictionaryVectorLoad2(place, "HD_" + key, lp_1, lp_2);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns></returns>
        public static Vector2F DataTableVectorLoad3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (Vector2F)HashTableLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
                default:
                    return DictionaryVectorLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns></returns>
        public static Vector2F DataTableVectorLoad4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (Vector2F)HashTableLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                default:
                    return DictionaryVectorLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
            }
        }

        #endregion

        #region Timer

        /// <summary>
        /// 【MM_函数库】判断数据表键是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DataTableTimerKeyExists(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableKeyExists(place, "HD_" + key);
                default:
                    return DictionaryTimerKeyExists(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】判断数据表值是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool DataTableTimerValueExists(bool place, Timer value)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableValueExists(place, value);
                default:
                    return DictionaryTimerValueExists(place, value);
            }
        }

        /// <summary>
        /// 【MM_函数库】获取数据表键对应的值
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static Timer DataTableTimerGetValue(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (Timer)HashTableGetValue(place, "HD_" + key);
                default:
                    return DictionaryTimerGetValue(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        public static void DataTableTimerClear0(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear0(place, "HD_" + key);
                    break;
                default:
                    DictionaryTimerClear0(place, "HD_" + key);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[]，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        public static void DataTableTimerClear1(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear1(place, "HD_" + key, lp_1);
                    break;
                default:
                    DictionaryTimerClear1(place, "HD_" + key, lp_1);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,]，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        public static void DataTableTimerClear2(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear2(place, "HD_" + key, lp_1, lp_2);
                    break;
                default:
                    DictionaryTimerClear2(place, "HD_" + key, lp_1, lp_2);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,,]，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        public static void DataTableTimerClear3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear3(place, "HD_" + key, lp_1, lp_2, lp_3);
                    break;
                default:
                    DictionaryTimerClear3(place, "HD_" + key, lp_1, lp_2, lp_3);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,,,]，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        public static void DataTableTimerClear4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                    break;
                default:
                    DictionaryTimerClear4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】移除数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        private static void DataTableTimerRemove(bool place, string key)//内部函数
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableRemove(place, "HD_" + key);
                    break;
                default:
                    DictionaryTimerRemove(place, "HD_" + key);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        public static void DataTableTimerSave0(bool place, string key, Timer val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave0(place, "HD_" + key, val);
                    break;
                default:
                    DictionaryTimerSave0(place, "HD_" + key, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="val"></param>
        public static void DataTableTimerSave1(bool place, string key, int lp_1, Timer val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave1(place, "HD_" + key, lp_1, val);
                    break;
                default:
                    DictionaryTimerSave1(place, "HD_" + key, lp_1, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="val"></param>
        public static void DataTableTimerSave2(bool place, string key, int lp_1, int lp_2, Timer val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave2(place, "HD_" + key, lp_1, lp_2, val);
                    break;
                default:
                    DictionaryTimerSave2(place, "HD_" + key, lp_1, lp_2, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="val"></param>
        public static void DataTableTimerSave3(bool place, string key, int lp_1, int lp_2, int lp_3, Timer val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave3(place, "HD_" + key, lp_1, lp_2, lp_3, val);
                    break;
                default:
                    DictionaryTimerSave3(place, "HD_" + key, lp_1, lp_2, lp_3, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <param name="val"></param>
        public static void DataTableTimerSave4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4, Timer val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4, val);
                    break;
                default:
                    DictionaryTimerSave4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static Timer DataTableTimerLoad0(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (Timer)HashTableLoad0(place, "HD_" + key);
                default:
                    return DictionaryTimerLoad0(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns></returns>
        public static Timer DataTableTimerLoad1(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (Timer)HashTableLoad1(place, "HD_" + key, lp_1);
                default:
                    return DictionaryTimerLoad1(place, "HD_" + key, lp_1);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns></returns>
        public static Timer DataTableTimerLoad2(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (Timer)HashTableLoad2(place, "HD_" + key, lp_1, lp_2);
                default:
                    return DictionaryTimerLoad2(place, "HD_" + key, lp_1, lp_2);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns></returns>
        public static Timer DataTableTimerLoad3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (Timer)HashTableLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
                default:
                    return DictionaryTimerLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns></returns>
        public static Timer DataTableTimerLoad4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (Timer)HashTableLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                default:
                    return DictionaryTimerLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
            }
        }

        #endregion

        #region String

        /// <summary>
        /// 【MM_函数库】判断数据表键是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DataTableStringKeyExists(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableKeyExists(place, "HD_" + key);
                default:
                    return DictionaryStringKeyExists(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】判断数据表值是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool DataTableStringValueExists(bool place, string value)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableValueExists(place, value);
                default:
                    return DictionaryStringValueExists(place, value);
            }
        }

        /// <summary>
        /// 【MM_函数库】获取数据表键对应的值
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static string DataTableStringGetValue(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (string)HashTableGetValue(place, "HD_" + key);
                default:
                    return DictionaryStringGetValue(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        public static void DataTableStringClear0(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear0(place, "HD_" + key);
                    break;
                default:
                    DictionaryStringClear0(place, "HD_" + key);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[]，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        public static void DataTableStringClear1(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear1(place, "HD_" + key, lp_1);
                    break;
                default:
                    DictionaryStringClear1(place, "HD_" + key, lp_1);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,]，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        public static void DataTableStringClear2(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear2(place, "HD_" + key, lp_1, lp_2);
                    break;
                default:
                    DictionaryStringClear2(place, "HD_" + key, lp_1, lp_2);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,,]，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        public static void DataTableStringClear3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear3(place, "HD_" + key, lp_1, lp_2, lp_3);
                    break;
                default:
                    DictionaryStringClear3(place, "HD_" + key, lp_1, lp_2, lp_3);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,,,]，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        public static void DataTableStringClear4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                    break;
                default:
                    DictionaryStringClear4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】移除数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        private static void DataTableStringRemove(bool place, string key)//内部函数
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableRemove(place, "HD_" + key);
                    break;
                default:
                    DictionaryStringRemove(place, "HD_" + key);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        public static void DataTableStringSave0(bool place, string key, string val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave0(place, "HD_" + key, val);
                    break;
                default:
                    DictionaryStringSave0(place, "HD_" + key, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="val"></param>
        public static void DataTableStringSave1(bool place, string key, int lp_1, string val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave1(place, "HD_" + key, lp_1, val);
                    break;
                default:
                    DictionaryStringSave1(place, "HD_" + key, lp_1, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="val"></param>
        public static void DataTableStringSave2(bool place, string key, int lp_1, int lp_2, string val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave2(place, "HD_" + key, lp_1, lp_2, val);
                    break;
                default:
                    DictionaryStringSave2(place, "HD_" + key, lp_1, lp_2, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="val"></param>
        public static void DataTableStringSave3(bool place, string key, int lp_1, int lp_2, int lp_3, string val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave3(place, "HD_" + key, lp_1, lp_2, lp_3, val);
                    break;
                default:
                    DictionaryStringSave3(place, "HD_" + key, lp_1, lp_2, lp_3, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <param name="val"></param>
        public static void DataTableStringSave4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4, string val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4, val);
                    break;
                default:
                    DictionaryStringSave4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static string DataTableStringLoad0(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (string)HashTableLoad0(place, "HD_" + key);
                default:
                    return DictionaryStringLoad0(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns></returns>
        public static string DataTableStringLoad1(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (string)HashTableLoad1(place, "HD_" + key, lp_1);
                default:
                    return DictionaryStringLoad1(place, "HD_" + key, lp_1);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns></returns>
        public static string DataTableStringLoad2(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (string)HashTableLoad2(place, "HD_" + key, lp_1, lp_2);
                default:
                    return DictionaryStringLoad2(place, "HD_" + key, lp_1, lp_2);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns></returns>
        public static string DataTableStringLoad3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (string)HashTableLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
                default:
                    return DictionaryStringLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns></returns>
        public static string DataTableStringLoad4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (string)HashTableLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                default:
                    return DictionaryStringLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
            }
        }

        #endregion

        #endregion

        #region 值类型

        #region Int

        /// <summary>
        /// 【MM_函数库】判断数据表键是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DataTableIntKeyExists(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableKeyExists(place, "HD_" + key);
                default:
                    return DictionaryIntKeyExists(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】判断数据表值是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool DataTableIntValueExists(bool place, int value)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableValueExists(place, value);
                default:
                    return DictionaryIntValueExists(place, value);
            }
        }

        /// <summary>
        /// 【MM_函数库】获取数据表键对应的值
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static int DataTableIntGetValue(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (int)HashTableGetValue(place, "HD_" + key);
                default:
                    return DictionaryIntGetValue(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        public static void DataTableIntClear0(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear0(place, "HD_" + key);
                    break;
                default:
                    DictionaryIntClear0(place, "HD_" + key);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[]，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        public static void DataTableIntClear1(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear1(place, "HD_" + key, lp_1);
                    break;
                default:
                    DictionaryIntClear1(place, "HD_" + key, lp_1);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,]，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        public static void DataTableIntClear2(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear2(place, "HD_" + key, lp_1, lp_2);
                    break;
                default:
                    DictionaryIntClear2(place, "HD_" + key, lp_1, lp_2);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,,]，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        public static void DataTableIntClear3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear3(place, "HD_" + key, lp_1, lp_2, lp_3);
                    break;
                default:
                    DictionaryIntClear3(place, "HD_" + key, lp_1, lp_2, lp_3);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,,,]，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        public static void DataTableIntClear4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                    break;
                default:
                    DictionaryIntClear4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】移除数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        private static void DataTableIntRemove(bool place, string key)//内部函数
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableRemove(place, "HD_" + key);
                    break;
                default:
                    DictionaryIntRemove(place, "HD_" + key);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        public static void DataTableIntSave0(bool place, string key, int val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave0(place, "HD_" + key, val);
                    break;
                default:
                    DictionaryIntSave0(place, "HD_" + key, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="val"></param>
        public static void DataTableIntSave1(bool place, string key, int lp_1, int val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave1(place, "HD_" + key, lp_1, val);
                    break;
                default:
                    DictionaryIntSave1(place, "HD_" + key, lp_1, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="val"></param>
        public static void DataTableIntSave2(bool place, string key, int lp_1, int lp_2, int val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave2(place, "HD_" + key, lp_1, lp_2, val);
                    break;
                default:
                    DictionaryIntSave2(place, "HD_" + key, lp_1, lp_2, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="val"></param>
        public static void DataTableIntSave3(bool place, string key, int lp_1, int lp_2, int lp_3, int val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave3(place, "HD_" + key, lp_1, lp_2, lp_3, val);
                    break;
                default:
                    DictionaryIntSave3(place, "HD_" + key, lp_1, lp_2, lp_3, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <param name="val"></param>
        public static void DataTableIntSave4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4, int val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4, val);
                    break;
                default:
                    DictionaryIntSave4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static int? DataTableIntLoad0_N(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (int?)HashTableLoad0(place, "HD_" + key);
                default:
                    return DictionaryIntLoad0_N(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns></returns>
        public static int? DataTableIntLoad1_N(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (int?)HashTableLoad1(place, "HD_" + key, lp_1);
                default:
                    return DictionaryIntLoad1_N(place, "HD_" + key, lp_1);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns></returns>
        public static int? DataTableIntLoad2_N(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (int?)HashTableLoad2(place, "HD_" + key, lp_1, lp_2);
                default:
                    return DictionaryIntLoad2_N(place, "HD_" + key, lp_1, lp_2);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns></returns>
        public static int? DataTableIntLoad3_N(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (int?)HashTableLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
                default:
                    return DictionaryIntLoad3_N(place, "HD_" + key, lp_1, lp_2, lp_3);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns></returns>
        public static int? DataTableIntLoad4_N(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (int?)HashTableLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                default:
                    return DictionaryIntLoad4_N(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static int DataTableIntLoad0(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (int)HashTableLoad0(place, "HD_" + key);
                default:
                    return DictionaryIntLoad0(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns></returns>
        public static int DataTableIntLoad1(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (int)HashTableLoad1(place, "HD_" + key, lp_1);
                default:
                    return DictionaryIntLoad1(place, "HD_" + key, lp_1);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns></returns>
        public static int DataTableIntLoad2(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (int)HashTableLoad2(place, "HD_" + key, lp_1, lp_2);
                default:
                    return DictionaryIntLoad2(place, "HD_" + key, lp_1, lp_2);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns></returns>
        public static int DataTableIntLoad3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (int)HashTableLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
                default:
                    return DictionaryIntLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns></returns>
        public static int DataTableIntLoad4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (int)HashTableLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                default:
                    return DictionaryIntLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
            }
        }

        #endregion

        #region Long

        /// <summary>
        /// 【MM_函数库】判断数据表键是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DataTableLongKeyExists(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableKeyExists(place, "HD_" + key);
                default:
                    return DictionaryLongKeyExists(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】判断数据表值是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool DataTableLongValueExists(bool place, long value)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableValueExists(place, value);
                default:
                    return DictionaryLongValueExists(place, value);
            }
        }

        /// <summary>
        /// 【MM_函数库】获取数据表键对应的值
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static long DataTableLongGetValue(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (long)HashTableGetValue(place, "HD_" + key);
                default:
                    return DictionaryLongGetValue(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        public static void DataTableLongClear0(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear0(place, "HD_" + key);
                    break;
                default:
                    DictionaryLongClear0(place, "HD_" + key);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[]，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        public static void DataTableLongClear1(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear1(place, "HD_" + key, lp_1);
                    break;
                default:
                    DictionaryLongClear1(place, "HD_" + key, lp_1);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,]，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        public static void DataTableLongClear2(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear2(place, "HD_" + key, lp_1, lp_2);
                    break;
                default:
                    DictionaryLongClear2(place, "HD_" + key, lp_1, lp_2);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,,]，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        public static void DataTableLongClear3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear3(place, "HD_" + key, lp_1, lp_2, lp_3);
                    break;
                default:
                    DictionaryLongClear3(place, "HD_" + key, lp_1, lp_2, lp_3);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,,,]，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        public static void DataTableLongClear4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                    break;
                default:
                    DictionaryLongClear4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】移除数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        private static void DataTableLongRemove(bool place, string key)//内部函数
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableRemove(place, "HD_" + key);
                    break;
                default:
                    DictionaryLongRemove(place, "HD_" + key);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        public static void DataTableLongSave0(bool place, string key, long val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave0(place, "HD_" + key, val);
                    break;
                default:
                    DictionaryLongSave0(place, "HD_" + key, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="val"></param>
        public static void DataTableLongSave1(bool place, string key, int lp_1, long val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave1(place, "HD_" + key, lp_1, val);
                    break;
                default:
                    DictionaryLongSave1(place, "HD_" + key, lp_1, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="val"></param>
        public static void DataTableLongSave2(bool place, string key, int lp_1, int lp_2, long val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave2(place, "HD_" + key, lp_1, lp_2, val);
                    break;
                default:
                    DictionaryLongSave2(place, "HD_" + key, lp_1, lp_2, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="val"></param>
        public static void DataTableLongSave3(bool place, string key, int lp_1, int lp_2, int lp_3, long val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave3(place, "HD_" + key, lp_1, lp_2, lp_3, val);
                    break;
                default:
                    DictionaryLongSave3(place, "HD_" + key, lp_1, lp_2, lp_3, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <param name="val"></param>
        public static void DataTableLongSave4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4, long val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4, val);
                    break;
                default:
                    DictionaryLongSave4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static long? DataTableLongLoad0_N(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (long?)HashTableLoad0(place, "HD_" + key);
                default:
                    return DictionaryLongLoad0_N(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns></returns>
        public static long? DataTableLongLoad1_N(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (long?)HashTableLoad1(place, "HD_" + key, lp_1);
                default:
                    return DictionaryLongLoad1_N(place, "HD_" + key, lp_1);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns></returns>
        public static long? DataTableLongLoad2_N(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (long?)HashTableLoad2(place, "HD_" + key, lp_1, lp_2);
                default:
                    return DictionaryLongLoad2_N(place, "HD_" + key, lp_1, lp_2);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns></returns>
        public static long? DataTableLongLoad3_N(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (long?)HashTableLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
                default:
                    return DictionaryLongLoad3_N(place, "HD_" + key, lp_1, lp_2, lp_3);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns></returns>
        public static long? DataTableLongLoad4_N(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (long?)HashTableLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                default:
                    return DictionaryLongLoad4_N(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static long DataTableLongLoad0(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (long)HashTableLoad0(place, "HD_" + key);
                default:
                    return DictionaryLongLoad0(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns></returns>
        public static long DataTableLongLoad1(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (long)HashTableLoad1(place, "HD_" + key, lp_1);
                default:
                    return DictionaryLongLoad1(place, "HD_" + key, lp_1);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns></returns>
        public static long DataTableLongLoad2(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (long)HashTableLoad2(place, "HD_" + key, lp_1, lp_2);
                default:
                    return DictionaryLongLoad2(place, "HD_" + key, lp_1, lp_2);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns></returns>
        public static long DataTableLongLoad3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (long)HashTableLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
                default:
                    return DictionaryLongLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns></returns>
        public static long DataTableLongLoad4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (long)HashTableLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                default:
                    return DictionaryLongLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
            }
        }

        #endregion

        #region Char

        /// <summary>
        /// 【MM_函数库】判断数据表键是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DataTableCharKeyExists(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableKeyExists(place, "HD_" + key);
                default:
                    return DictionaryCharKeyExists(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】判断数据表值是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool DataTableCharValueExists(bool place, char value)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableValueExists(place, value);
                default:
                    return DictionaryCharValueExists(place, value);
            }
        }

        /// <summary>
        /// 【MM_函数库】获取数据表键对应的值
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static char DataTableCharGetValue(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (char)HashTableGetValue(place, "HD_" + key);
                default:
                    return DictionaryCharGetValue(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        public static void DataTableCharClear0(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear0(place, "HD_" + key);
                    break;
                default:
                    DictionaryCharClear0(place, "HD_" + key);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[]，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        public static void DataTableCharClear1(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear1(place, "HD_" + key, lp_1);
                    break;
                default:
                    DictionaryCharClear1(place, "HD_" + key, lp_1);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,]，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        public static void DataTableCharClear2(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear2(place, "HD_" + key, lp_1, lp_2);
                    break;
                default:
                    DictionaryCharClear2(place, "HD_" + key, lp_1, lp_2);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,,]，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        public static void DataTableCharClear3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear3(place, "HD_" + key, lp_1, lp_2, lp_3);
                    break;
                default:
                    DictionaryCharClear3(place, "HD_" + key, lp_1, lp_2, lp_3);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,,,]，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        public static void DataTableCharClear4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                    break;
                default:
                    DictionaryCharClear4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】移除数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        private static void DataTableCharRemove(bool place, string key)//内部函数
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableRemove(place, "HD_" + key);
                    break;
                default:
                    DictionaryCharRemove(place, "HD_" + key);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        public static void DataTableCharSave0(bool place, string key, char val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave0(place, "HD_" + key, val);
                    break;
                default:
                    DictionaryCharSave0(place, "HD_" + key, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="val"></param>
        public static void DataTableCharSave1(bool place, string key, int lp_1, char val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave1(place, "HD_" + key, lp_1, val);
                    break;
                default:
                    DictionaryCharSave1(place, "HD_" + key, lp_1, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="val"></param>
        public static void DataTableCharSave2(bool place, string key, int lp_1, int lp_2, char val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave2(place, "HD_" + key, lp_1, lp_2, val);
                    break;
                default:
                    DictionaryCharSave2(place, "HD_" + key, lp_1, lp_2, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="val"></param>
        public static void DataTableCharSave3(bool place, string key, int lp_1, int lp_2, int lp_3, char val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave3(place, "HD_" + key, lp_1, lp_2, lp_3, val);
                    break;
                default:
                    DictionaryCharSave3(place, "HD_" + key, lp_1, lp_2, lp_3, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <param name="val"></param>
        public static void DataTableCharSave4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4, char val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4, val);
                    break;
                default:
                    DictionaryCharSave4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static char? DataTableCharLoad0_N(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (char?)HashTableLoad0(place, "HD_" + key);
                default:
                    return DictionaryCharLoad0_N(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns></returns>
        public static char? DataTableCharLoad1_N(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (char?)HashTableLoad1(place, "HD_" + key, lp_1);
                default:
                    return DictionaryCharLoad1_N(place, "HD_" + key, lp_1);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns></returns>
        public static char? DataTableCharLoad2_N(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (char?)HashTableLoad2(place, "HD_" + key, lp_1, lp_2);
                default:
                    return DictionaryCharLoad2_N(place, "HD_" + key, lp_1, lp_2);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns></returns>
        public static char? DataTableCharLoad3_N(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (char?)HashTableLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
                default:
                    return DictionaryCharLoad3_N(place, "HD_" + key, lp_1, lp_2, lp_3);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns></returns>
        public static char? DataTableCharLoad4_N(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (char?)HashTableLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                default:
                    return DictionaryCharLoad4_N(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static char DataTableCharLoad0(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (char)HashTableLoad0(place, "HD_" + key);
                default:
                    return DictionaryCharLoad0(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns></returns>
        public static char DataTableCharLoad1(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (char)HashTableLoad1(place, "HD_" + key, lp_1);
                default:
                    return DictionaryCharLoad1(place, "HD_" + key, lp_1);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns></returns>
        public static char DataTableCharLoad2(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (char)HashTableLoad2(place, "HD_" + key, lp_1, lp_2);
                default:
                    return DictionaryCharLoad2(place, "HD_" + key, lp_1, lp_2);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns></returns>
        public static char DataTableCharLoad3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (char)HashTableLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
                default:
                    return DictionaryCharLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns></returns>
        public static char DataTableCharLoad4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (char)HashTableLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                default:
                    return DictionaryCharLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
            }
        }

        #endregion

        #region Float

        /// <summary>
        /// 【MM_函数库】判断数据表键是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DataTableFloatKeyExists(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableKeyExists(place, "HD_" + key);
                default:
                    return DictionaryFloatKeyExists(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】判断数据表值是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool DataTableFloatValueExists(bool place, float value)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableValueExists(place, value);
                default:
                    return DictionaryFloatValueExists(place, value);
            }
        }

        /// <summary>
        /// 【MM_函数库】获取数据表键对应的值
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static float DataTableFloatGetValue(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (float)HashTableGetValue(place, "HD_" + key);
                default:
                    return DictionaryFloatGetValue(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        public static void DataTableFloatClear0(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear0(place, "HD_" + key);
                    break;
                default:
                    DictionaryFloatClear0(place, "HD_" + key);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[]，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        public static void DataTableFloatClear1(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear1(place, "HD_" + key, lp_1);
                    break;
                default:
                    DictionaryFloatClear1(place, "HD_" + key, lp_1);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,]，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        public static void DataTableFloatClear2(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear2(place, "HD_" + key, lp_1, lp_2);
                    break;
                default:
                    DictionaryFloatClear2(place, "HD_" + key, lp_1, lp_2);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,,]，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        public static void DataTableFloatClear3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear3(place, "HD_" + key, lp_1, lp_2, lp_3);
                    break;
                default:
                    DictionaryFloatClear3(place, "HD_" + key, lp_1, lp_2, lp_3);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,,,]，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        public static void DataTableFloatClear4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                    break;
                default:
                    DictionaryFloatClear4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】移除数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        private static void DataTableFloatRemove(bool place, string key)//内部函数
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableRemove(place, "HD_" + key);
                    break;
                default:
                    DictionaryFloatRemove(place, "HD_" + key);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        public static void DataTableFloatSave0(bool place, string key, float val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave0(place, "HD_" + key, val);
                    break;
                default:
                    DictionaryFloatSave0(place, "HD_" + key, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="val"></param>
        public static void DataTableFloatSave1(bool place, string key, int lp_1, float val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave1(place, "HD_" + key, lp_1, val);
                    break;
                default:
                    DictionaryFloatSave1(place, "HD_" + key, lp_1, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="val"></param>
        public static void DataTableFloatSave2(bool place, string key, int lp_1, int lp_2, float val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave2(place, "HD_" + key, lp_1, lp_2, val);
                    break;
                default:
                    DictionaryFloatSave2(place, "HD_" + key, lp_1, lp_2, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="val"></param>
        public static void DataTableFloatSave3(bool place, string key, int lp_1, int lp_2, int lp_3, float val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave3(place, "HD_" + key, lp_1, lp_2, lp_3, val);
                    break;
                default:
                    DictionaryFloatSave3(place, "HD_" + key, lp_1, lp_2, lp_3, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <param name="val"></param>
        public static void DataTableFloatSave4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4, float val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4, val);
                    break;
                default:
                    DictionaryFloatSave4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static float? DataTableFloatLoad0_N(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (float?)HashTableLoad0(place, "HD_" + key);
                default:
                    return DictionaryFloatLoad0_N(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns></returns>
        public static float? DataTableFloatLoad1_N(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (float?)HashTableLoad1(place, "HD_" + key, lp_1);
                default:
                    return DictionaryFloatLoad1_N(place, "HD_" + key, lp_1);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns></returns>
        public static float? DataTableFloatLoad2_N(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (float?)HashTableLoad2(place, "HD_" + key, lp_1, lp_2);
                default:
                    return DictionaryFloatLoad2_N(place, "HD_" + key, lp_1, lp_2);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns></returns>
        public static float? DataTableFloatLoad3_N(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (float?)HashTableLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
                default:
                    return DictionaryFloatLoad3_N(place, "HD_" + key, lp_1, lp_2, lp_3);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns></returns>
        public static float? DataTableFloatLoad4_N(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (float?)HashTableLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                default:
                    return DictionaryFloatLoad4_N(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static float DataTableFloatLoad0(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (float)HashTableLoad0(place, "HD_" + key);
                default:
                    return DictionaryFloatLoad0(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns></returns>
        public static float DataTableFloatLoad1(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (float)HashTableLoad1(place, "HD_" + key, lp_1);
                default:
                    return DictionaryFloatLoad1(place, "HD_" + key, lp_1);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns></returns>
        public static float DataTableFloatLoad2(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (float)HashTableLoad2(place, "HD_" + key, lp_1, lp_2);
                default:
                    return DictionaryFloatLoad2(place, "HD_" + key, lp_1, lp_2);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns></returns>
        public static float DataTableFloatLoad3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (float)HashTableLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
                default:
                    return DictionaryFloatLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns></returns>
        public static float DataTableFloatLoad4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (float)HashTableLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                default:
                    return DictionaryFloatLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
            }
        }

        #endregion

        #region Double

        /// <summary>
        /// 【MM_函数库】判断数据表键是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DataTableDoubleKeyExists(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableKeyExists(place, "HD_" + key);
                default:
                    return DictionaryDoubleKeyExists(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】判断数据表值是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool DataTableDoubleValueExists(bool place, double value)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableValueExists(place, value);
                default:
                    return DictionaryDoubleValueExists(place, value);
            }
        }

        /// <summary>
        /// 【MM_函数库】获取数据表键对应的值
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static double DataTableDoubleGetValue(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (double)HashTableGetValue(place, "HD_" + key);
                default:
                    return DictionaryDoubleGetValue(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        public static void DataTableDoubleClear0(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear0(place, "HD_" + key);
                    break;
                default:
                    DictionaryDoubleClear0(place, "HD_" + key);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[]，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        public static void DataTableDoubleClear1(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear1(place, "HD_" + key, lp_1);
                    break;
                default:
                    DictionaryDoubleClear1(place, "HD_" + key, lp_1);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,]，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        public static void DataTableDoubleClear2(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear2(place, "HD_" + key, lp_1, lp_2);
                    break;
                default:
                    DictionaryDoubleClear2(place, "HD_" + key, lp_1, lp_2);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,,]，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        public static void DataTableDoubleClear3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear3(place, "HD_" + key, lp_1, lp_2, lp_3);
                    break;
                default:
                    DictionaryDoubleClear3(place, "HD_" + key, lp_1, lp_2, lp_3);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,,,]，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        public static void DataTableDoubleClear4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                    break;
                default:
                    DictionaryDoubleClear4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】移除数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        private static void DataTableDoubleRemove(bool place, string key)//内部函数
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableRemove(place, "HD_" + key);
                    break;
                default:
                    DictionaryDoubleRemove(place, "HD_" + key);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        public static void DataTableDoubleSave0(bool place, string key, double val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave0(place, "HD_" + key, val);
                    break;
                default:
                    DictionaryDoubleSave0(place, "HD_" + key, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="val"></param>
        public static void DataTableDoubleSave1(bool place, string key, int lp_1, double val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave1(place, "HD_" + key, lp_1, val);
                    break;
                default:
                    DictionaryDoubleSave1(place, "HD_" + key, lp_1, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="val"></param>
        public static void DataTableDoubleSave2(bool place, string key, int lp_1, int lp_2, double val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave2(place, "HD_" + key, lp_1, lp_2, val);
                    break;
                default:
                    DictionaryDoubleSave2(place, "HD_" + key, lp_1, lp_2, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="val"></param>
        public static void DataTableDoubleSave3(bool place, string key, int lp_1, int lp_2, int lp_3, double val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave3(place, "HD_" + key, lp_1, lp_2, lp_3, val);
                    break;
                default:
                    DictionaryDoubleSave3(place, "HD_" + key, lp_1, lp_2, lp_3, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <param name="val"></param>
        public static void DataTableDoubleSave4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4, double val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4, val);
                    break;
                default:
                    DictionaryDoubleSave4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static double? DataTableDoubleLoad0_N(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (double?)HashTableLoad0(place, "HD_" + key);
                default:
                    return DictionaryDoubleLoad0_N(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns></returns>
        public static double? DataTableDoubleLoad1_N(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (double?)HashTableLoad1(place, "HD_" + key, lp_1);
                default:
                    return DictionaryDoubleLoad1_N(place, "HD_" + key, lp_1);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns></returns>
        public static double? DataTableDoubleLoad2_N(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (double?)HashTableLoad2(place, "HD_" + key, lp_1, lp_2);
                default:
                    return DictionaryDoubleLoad2_N(place, "HD_" + key, lp_1, lp_2);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns></returns>
        public static double? DataTableDoubleLoad3_N(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (double?)HashTableLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
                default:
                    return DictionaryDoubleLoad3_N(place, "HD_" + key, lp_1, lp_2, lp_3);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns></returns>
        public static double? DataTableDoubleLoad4_N(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (double?)HashTableLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                default:
                    return DictionaryDoubleLoad4_N(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static double DataTableDoubleLoad0(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (double)HashTableLoad0(place, "HD_" + key);
                default:
                    return DictionaryDoubleLoad0(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns></returns>
        public static double DataTableDoubleLoad1(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (double)HashTableLoad1(place, "HD_" + key, lp_1);
                default:
                    return DictionaryDoubleLoad1(place, "HD_" + key, lp_1);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns></returns>
        public static double DataTableDoubleLoad2(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (double)HashTableLoad2(place, "HD_" + key, lp_1, lp_2);
                default:
                    return DictionaryDoubleLoad2(place, "HD_" + key, lp_1, lp_2);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns></returns>
        public static double DataTableDoubleLoad3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (double)HashTableLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
                default:
                    return DictionaryDoubleLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns></returns>
        public static double DataTableDoubleLoad4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (double)HashTableLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                default:
                    return DictionaryDoubleLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
            }
        }

        #endregion

        #region Bool

        /// <summary>
        /// 【MM_函数库】判断数据表键是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DataTableBoolKeyExists(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableKeyExists(place, "HD_" + key);
                default:
                    return DictionaryBoolKeyExists(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】判断数据表值是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool DataTableBoolValueExists(bool place, bool value)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableValueExists(place, value);
                default:
                    return DictionaryBoolValueExists(place, value);
            }
        }

        /// <summary>
        /// 【MM_函数库】获取数据表键对应的值
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DataTableBoolGetValue(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (bool)HashTableGetValue(place, "HD_" + key);
                default:
                    return DictionaryBoolGetValue(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        public static void DataTableBoolClear0(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear0(place, "HD_" + key);
                    break;
                default:
                    DictionaryBoolClear0(place, "HD_" + key);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[]，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        public static void DataTableBoolClear1(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear1(place, "HD_" + key, lp_1);
                    break;
                default:
                    DictionaryBoolClear1(place, "HD_" + key, lp_1);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,]，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        public static void DataTableBoolClear2(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear2(place, "HD_" + key, lp_1, lp_2);
                    break;
                default:
                    DictionaryBoolClear2(place, "HD_" + key, lp_1, lp_2);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,,]，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        public static void DataTableBoolClear3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear3(place, "HD_" + key, lp_1, lp_2, lp_3);
                    break;
                default:
                    DictionaryBoolClear3(place, "HD_" + key, lp_1, lp_2, lp_3);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,,,]，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        public static void DataTableBoolClear4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                    break;
                default:
                    DictionaryBoolClear4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】移除数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        private static void DataTableBoolRemove(bool place, string key)//内部函数
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableRemove(place, "HD_" + key);
                    break;
                default:
                    DictionaryBoolRemove(place, "HD_" + key);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        public static void DataTableBoolSave0(bool place, string key, bool val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave0(place, "HD_" + key, val);
                    break;
                default:
                    DictionaryBoolSave0(place, "HD_" + key, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="val"></param>
        public static void DataTableBoolSave1(bool place, string key, int lp_1, bool val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave1(place, "HD_" + key, lp_1, val);
                    break;
                default:
                    DictionaryBoolSave1(place, "HD_" + key, lp_1, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="val"></param>
        public static void DataTableBoolSave2(bool place, string key, int lp_1, int lp_2, bool val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave2(place, "HD_" + key, lp_1, lp_2, val);
                    break;
                default:
                    DictionaryBoolSave2(place, "HD_" + key, lp_1, lp_2, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="val"></param>
        public static void DataTableBoolSave3(bool place, string key, int lp_1, int lp_2, int lp_3, bool val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave3(place, "HD_" + key, lp_1, lp_2, lp_3, val);
                    break;
                default:
                    DictionaryBoolSave3(place, "HD_" + key, lp_1, lp_2, lp_3, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <param name="val"></param>
        public static void DataTableBoolSave4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4, bool val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4, val);
                    break;
                default:
                    DictionaryBoolSave4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool? DataTableBoolLoad0_N(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (bool?)HashTableLoad0(place, "HD_" + key);
                default:
                    return DictionaryBoolLoad0_N(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns></returns>
        public static bool? DataTableBoolLoad1_N(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (bool?)HashTableLoad1(place, "HD_" + key, lp_1);
                default:
                    return DictionaryBoolLoad1_N(place, "HD_" + key, lp_1);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns></returns>
        public static bool? DataTableBoolLoad2_N(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (bool?)HashTableLoad2(place, "HD_" + key, lp_1, lp_2);
                default:
                    return DictionaryBoolLoad2_N(place, "HD_" + key, lp_1, lp_2);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns></returns>
        public static bool? DataTableBoolLoad3_N(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (bool?)HashTableLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
                default:
                    return DictionaryBoolLoad3_N(place, "HD_" + key, lp_1, lp_2, lp_3);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns></returns>
        public static bool? DataTableBoolLoad4_N(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (bool?)HashTableLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                default:
                    return DictionaryBoolLoad4_N(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DataTableBoolLoad0(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (bool)HashTableLoad0(place, "HD_" + key);
                default:
                    return DictionaryBoolLoad0(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns></returns>
        public static bool DataTableBoolLoad1(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (bool)HashTableLoad1(place, "HD_" + key, lp_1);
                default:
                    return DictionaryBoolLoad1(place, "HD_" + key, lp_1);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns></returns>
        public static bool DataTableBoolLoad2(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (bool)HashTableLoad2(place, "HD_" + key, lp_1, lp_2);
                default:
                    return DictionaryBoolLoad2(place, "HD_" + key, lp_1, lp_2);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns></returns>
        public static bool DataTableBoolLoad3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (bool)HashTableLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
                default:
                    return DictionaryBoolLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns></returns>
        public static bool DataTableBoolLoad4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (bool)HashTableLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                default:
                    return DictionaryBoolLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
            }
        }

        #endregion

        #region Byte

        /// <summary>
        /// 【MM_函数库】判断数据表键是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DataTableByteKeyExists(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableKeyExists(place, "HD_" + key);
                default:
                    return DictionaryByteKeyExists(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】判断数据表值是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool DataTableByteValueExists(bool place, byte value)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableValueExists(place, value);
                default:
                    return DictionaryByteValueExists(place, value);
            }
        }

        /// <summary>
        /// 【MM_函数库】获取数据表键对应的值
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static byte DataTableByteGetValue(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (byte)HashTableGetValue(place, "HD_" + key);
                default:
                    return DictionaryByteGetValue(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        public static void DataTableByteClear0(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear0(place, "HD_" + key);
                    break;
                default:
                    DictionaryByteClear0(place, "HD_" + key);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[]，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        public static void DataTableByteClear1(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear1(place, "HD_" + key, lp_1);
                    break;
                default:
                    DictionaryByteClear1(place, "HD_" + key, lp_1);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,]，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        public static void DataTableByteClear2(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear2(place, "HD_" + key, lp_1, lp_2);
                    break;
                default:
                    DictionaryByteClear2(place, "HD_" + key, lp_1, lp_2);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,,]，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        public static void DataTableByteClear3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear3(place, "HD_" + key, lp_1, lp_2, lp_3);
                    break;
                default:
                    DictionaryByteClear3(place, "HD_" + key, lp_1, lp_2, lp_3);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,,,]，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        public static void DataTableByteClear4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                    break;
                default:
                    DictionaryByteClear4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】移除数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        private static void DataTableByteRemove(bool place, string key)//内部函数
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableRemove(place, "HD_" + key);
                    break;
                default:
                    DictionaryByteRemove(place, "HD_" + key);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        public static void DataTableByteSave0(bool place, string key, byte val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave0(place, "HD_" + key, val);
                    break;
                default:
                    DictionaryByteSave0(place, "HD_" + key, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="val"></param>
        public static void DataTableByteSave1(bool place, string key, int lp_1, byte val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave1(place, "HD_" + key, lp_1, val);
                    break;
                default:
                    DictionaryByteSave1(place, "HD_" + key, lp_1, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="val"></param>
        public static void DataTableByteSave2(bool place, string key, int lp_1, int lp_2, byte val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave2(place, "HD_" + key, lp_1, lp_2, val);
                    break;
                default:
                    DictionaryByteSave2(place, "HD_" + key, lp_1, lp_2, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="val"></param>
        public static void DataTableByteSave3(bool place, string key, int lp_1, int lp_2, int lp_3, byte val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave3(place, "HD_" + key, lp_1, lp_2, lp_3, val);
                    break;
                default:
                    DictionaryByteSave3(place, "HD_" + key, lp_1, lp_2, lp_3, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <param name="val"></param>
        public static void DataTableByteSave4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4, byte val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4, val);
                    break;
                default:
                    DictionaryByteSave4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static byte? DataTableByteLoad0_N(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (byte?)HashTableLoad0(place, "HD_" + key);
                default:
                    return DictionaryByteLoad0_N(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns></returns>
        public static byte? DataTableByteLoad1_N(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (byte?)HashTableLoad1(place, "HD_" + key, lp_1);
                default:
                    return DictionaryByteLoad1_N(place, "HD_" + key, lp_1);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns></returns>
        public static byte? DataTableByteLoad2_N(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (byte?)HashTableLoad2(place, "HD_" + key, lp_1, lp_2);
                default:
                    return DictionaryByteLoad2_N(place, "HD_" + key, lp_1, lp_2);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns></returns>
        public static byte? DataTableByteLoad3_N(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (byte?)HashTableLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
                default:
                    return DictionaryByteLoad3_N(place, "HD_" + key, lp_1, lp_2, lp_3);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns></returns>
        public static byte? DataTableByteLoad4_N(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (byte?)HashTableLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                default:
                    return DictionaryByteLoad4_N(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static byte DataTableByteLoad0(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (byte)HashTableLoad0(place, "HD_" + key);
                default:
                    return DictionaryByteLoad0(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns></returns>
        public static byte DataTableByteLoad1(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (byte)HashTableLoad1(place, "HD_" + key, lp_1);
                default:
                    return DictionaryByteLoad1(place, "HD_" + key, lp_1);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns></returns>
        public static byte DataTableByteLoad2(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (byte)HashTableLoad2(place, "HD_" + key, lp_1, lp_2);
                default:
                    return DictionaryByteLoad2(place, "HD_" + key, lp_1, lp_2);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns></returns>
        public static byte DataTableByteLoad3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (byte)HashTableLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
                default:
                    return DictionaryByteLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns></returns>
        public static byte DataTableByteLoad4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (byte)HashTableLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                default:
                    return DictionaryByteLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
            }
        }

        #endregion

        #endregion

        #endregion

        #region 基础数据表

        #region 哈希表

        //使用哈希表设计存取任意类型

        /// <summary>
        /// 【MM_函数库】添加哈希表键值对（重复添加则覆盖）
        /// </summary>
        /// <param name="place">true=全局，false=临时</param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        private static void HashTableSet(bool place, string key, object val)//内部使用
        {
            if (place)
            {
                //存入全局哈希表
                systemHashTable[key] = val;

                //if (systemHashTable.Contains(key)) 
                //{
                //    systemHashTable.Remove(key);
                //}
                //systemHashTable.Add(key, val);

            }
            else
            {
                //存入局部哈希表
                tempHashTable[key] = val;

                //if (tempHashTable.Contains(key)) { tempHashTable.Remove(key); }
                //tempHashTable.Add(key, val);
            }
        }

        /// <summary>
        /// 【MM_函数库】判断哈希表键是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool HashTableKeyExists(bool place, string key)
        {
            if (place) { return systemHashTable.ContainsKey(key); }
            else { return tempHashTable.ContainsKey(key); }
        }

        /// <summary>
        /// 【MM_函数库】判断哈希表值是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool HashTableValueExists(bool place, object value)
        {
            if (place) { return systemHashTable.ContainsValue(value); }
            else { return tempHashTable.ContainsValue(value); }
        }

        /// <summary>
        /// 【MM_函数库】获取哈希表键对应的值
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static object HashTableGetValue(bool place, string key)
        {
            if (place) { return systemHashTable[key]; }
            else { return tempHashTable[key]; }
        }

        /// <summary>
        /// 【MM_函数库】从哈希表中清除Key
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        public static void HashTableClear0(bool place, string key)
        {
            HashTableRemove(place, key);
        }

        /// <summary>
        /// 【MM_函数库】从哈希表中清除Key[]，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        public static void HashTableClear1(bool place, string key, int lp_1)
        {
            HashTableRemove(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从哈希表中清除Key[,]，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        public static void HashTableClear2(bool place, string key, int lp_1, int lp_2)
        {
            HashTableRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从哈希表中清除Key[,,]，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        public static void HashTableClear3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            HashTableRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从哈希表中清除Key[,,,]，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        public static void HashTableClear4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            HashTableRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】移除哈希表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        private static void HashTableRemove(bool place, string key)//内部函数
        {
            if (place) { systemHashTable.Remove(key); }
            else { tempHashTable.Remove(key); }
        }

        /// <summary>
        /// 【MM_函数库】保存哈希表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        public static void HashTableSave0(bool place, string key, object val)
        {
            HashTableSet(place, key, val);
        }

        /// <summary>
        /// 【MM_函数库】保存哈希表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="val"></param>
        public static void HashTableSave1(bool place, string key, int lp_1, object val)
        {
            HashTableSet(place, (key + "_" + lp_1.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存哈希表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="val"></param>
        public static void HashTableSave2(bool place, string key, int lp_1, int lp_2, object val)
        {
            HashTableSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存哈希表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="val"></param>
        public static void HashTableSave3(bool place, string key, int lp_1, int lp_2, int lp_3, object val)
        {
            HashTableSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存哈希表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <param name="val"></param>
        public static void HashTableSave4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4, object val)
        {
            HashTableSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】读取哈希表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static object HashTableLoad0(bool place, string key)
        {
            if ((HashTableKeyExists(place, key) == false))
            {
                return null;
            }
            return HashTableGetValue(place, key);
        }

        /// <summary>
        /// 【MM_函数库】读取哈希表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns></returns>
        public static object HashTableLoad1(bool place, string key, int lp_1)
        {
            if ((HashTableKeyExists(place, (key + "_" + lp_1.ToString())) == false))
            {
                return null;
            }
            return HashTableGetValue(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取哈希表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns></returns>
        public static object HashTableLoad2(bool place, string key, int lp_1, int lp_2)
        {
            if ((HashTableKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString())) == false))
            {
                return null;
            }
            return HashTableGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取哈希表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns></returns>
        public static object HashTableLoad3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            if ((HashTableKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString())) == false))
            {
                return null;
            }
            return HashTableGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取哈希表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns></returns>
        public static object HashTableLoad4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            if ((HashTableKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString())) == false))
            {
                return null;
            }
            return HashTableGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        #endregion

        #region 字典

        //使用字典设计存取指定类型

        #region 值类型

        #region Int字典

        /// <summary>
        /// 【MM_函数库】添加字典键值对（重复添加则覆盖）
        /// </summary>
        /// <param name="place">true=全局，false=局部</param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        private static void DictionaryIntSet(bool place, string key, int val)//内部使用
        {
            if (place)
            {
                //存入全局字典
                systemDictionaryInt[key] = val;

                //if (systemDictionaryInt.Contains(key)) 
                //{
                //    systemDictionaryInt.Remove(key);
                //}
                //systemDictionaryInt.Add(key, val);

            }
            else
            {
                //存入局部字典
                tempDictionaryInt[key] = val;

                //if (tempDictionaryInt.Contains(key)) { tempDictionaryInt.Remove(key); }
                //tempDictionaryInt.Add(key, val);
            }
        }

        /// <summary>
        /// 【MM_函数库】判断字典键是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DictionaryIntKeyExists(bool place, string key)
        {
            if (place) { return systemDictionaryInt.ContainsKey(key); }
            else { return tempDictionaryInt.ContainsKey(key); }
        }

        /// <summary>
        /// 【MM_函数库】判断字典值是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool DictionaryIntValueExists(bool place, int value)
        {
            if (place) { return systemDictionaryInt.ContainsValue(value); }
            else { return tempDictionaryInt.ContainsValue(value); }
        }

        /// <summary>
        /// 【MM_函数库】获取字典键对应的值
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static int DictionaryIntGetValue(bool place, string key)
        {
            if (place) { return systemDictionaryInt[key]; }
            else { return tempDictionaryInt[key]; }
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        public static void DictionaryIntClear0(bool place, string key)
        {
            DictionaryIntRemove(place, key);
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[]，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        public static void DictionaryIntClear1(bool place, string key, int lp_1)
        {
            DictionaryIntRemove(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,]，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        public static void DictionaryIntClear2(bool place, string key, int lp_1, int lp_2)
        {
            DictionaryIntRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,,]，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        public static void DictionaryIntClear3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            DictionaryIntRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,,,]，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        public static void DictionaryIntClear4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            DictionaryIntRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】移除字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        private static void DictionaryIntRemove(bool place, string key)//内部函数
        {
            if (place) { systemDictionaryInt.Remove(key); }
            else { tempDictionaryInt.Remove(key); }
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        public static void DictionaryIntSave0(bool place, string key, int val)
        {
            DictionaryIntSet(place, key, val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="val"></param>
        public static void DictionaryIntSave1(bool place, string key, int lp_1, int val)
        {
            DictionaryIntSet(place, (key + "_" + lp_1.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="val"></param>
        public static void DictionaryIntSave2(bool place, string key, int lp_1, int lp_2, int val)
        {
            DictionaryIntSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="val"></param>
        public static void DictionaryIntSave3(bool place, string key, int lp_1, int lp_2, int lp_3, int val)
        {
            DictionaryIntSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <param name="val"></param>
        public static void DictionaryIntSave4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4, int val)
        {
            DictionaryIntSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns>错误时返回null</returns>
        public static int? DictionaryIntLoad0_N(bool place, string key)
        {
            if ((DictionaryIntKeyExists(place, key) == false))
            {
                return null;
            }
            return DictionaryIntGetValue(place, key);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns>错误时返回null</returns>
        public static int? DictionaryIntLoad1_N(bool place, string key, int lp_1)
        {
            if ((DictionaryIntKeyExists(place, (key + "_" + lp_1.ToString())) == false))
            {
                return null;
            }
            return DictionaryIntGetValue(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns>错误时返回null</returns>
        public static int? DictionaryIntLoad2_N(bool place, string key, int lp_1, int lp_2)
        {
            if ((DictionaryIntKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString())) == false))
            {
                return null;
            }
            return DictionaryIntGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns>错误时返回null</returns>
        public static int? DictionaryIntLoad3_N(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            if ((DictionaryIntKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString())) == false))
            {
                return null;
            }
            return DictionaryIntGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns>错误时返回null</returns>
        public static int? DictionaryIntLoad4_N(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            if ((DictionaryIntKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString())) == false))
            {
                return null;
            }
            return DictionaryIntGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns>错误时返回0</returns>
        public static int DictionaryIntLoad0(bool place, string key)
        {
            if ((DictionaryIntKeyExists(place, key) == false))
            {
                return 0;
            }
            return DictionaryIntGetValue(place, key);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns>错误时返回0</returns>
        public static int DictionaryIntLoad1(bool place, string key, int lp_1)
        {
            if ((DictionaryIntKeyExists(place, (key + "_" + lp_1.ToString())) == false))
            {
                return 0;
            }
            return DictionaryIntGetValue(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns>错误时返回0</returns>
        public static int DictionaryIntLoad2(bool place, string key, int lp_1, int lp_2)
        {
            if ((DictionaryIntKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString())) == false))
            {
                return 0;
            }
            return DictionaryIntGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns>错误时返回0</returns>
        public static int DictionaryIntLoad3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            if ((DictionaryIntKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString())) == false))
            {
                return 0;
            }
            return DictionaryIntGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns>错误时返回0</returns>
        public static int DictionaryIntLoad4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            if ((DictionaryIntKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString())) == false))
            {
                return 0;
            }
            return DictionaryIntGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        #endregion

        #region Long字典

        /// <summary>
        /// 【MM_函数库】添加字典键值对（重复添加则覆盖）
        /// </summary>
        /// <param name="place">true=全局，false=局部</param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        private static void DictionaryLongSet(bool place, string key, long val)//内部使用
        {
            if (place)
            {
                //存入全局字典
                systemDictionaryLong[key] = val;

                //if (systemDictionaryLong.Contains(key)) 
                //{
                //    systemDictionaryLong.Remove(key);
                //}
                //systemDictionaryLong.Add(key, val);

            }
            else
            {
                //存入局部字典
                tempDictionaryLong[key] = val;

                //if (tempDictionaryLong.Contains(key)) { tempDictionaryLong.Remove(key); }
                //tempDictionaryLong.Add(key, val);
            }
        }

        /// <summary>
        /// 【MM_函数库】判断字典键是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DictionaryLongKeyExists(bool place, string key)
        {
            if (place) { return systemDictionaryLong.ContainsKey(key); }
            else { return tempDictionaryLong.ContainsKey(key); }
        }

        /// <summary>
        /// 【MM_函数库】判断字典值是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool DictionaryLongValueExists(bool place, long value)
        {
            if (place) { return systemDictionaryLong.ContainsValue(value); }
            else { return tempDictionaryLong.ContainsValue(value); }
        }

        /// <summary>
        /// 【MM_函数库】获取字典键对应的值
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static long DictionaryLongGetValue(bool place, string key)
        {
            if (place) { return systemDictionaryLong[key]; }
            else { return tempDictionaryLong[key]; }
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        public static void DictionaryLongClear0(bool place, string key)
        {
            DictionaryLongRemove(place, key);
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[]，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        public static void DictionaryLongClear1(bool place, string key, int lp_1)
        {
            DictionaryLongRemove(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,]，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        public static void DictionaryLongClear2(bool place, string key, int lp_1, int lp_2)
        {
            DictionaryLongRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,,]，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        public static void DictionaryLongClear3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            DictionaryLongRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,,,]，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        public static void DictionaryLongClear4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            DictionaryLongRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】移除字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        private static void DictionaryLongRemove(bool place, string key)//内部函数
        {
            if (place) { systemDictionaryLong.Remove(key); }
            else { tempDictionaryLong.Remove(key); }
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        public static void DictionaryLongSave0(bool place, string key, long val)
        {
            DictionaryLongSet(place, key, val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="val"></param>
        public static void DictionaryLongSave1(bool place, string key, int lp_1, long val)
        {
            DictionaryLongSet(place, (key + "_" + lp_1.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="val"></param>
        public static void DictionaryLongSave2(bool place, string key, int lp_1, int lp_2, long val)
        {
            DictionaryLongSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="val"></param>
        public static void DictionaryLongSave3(bool place, string key, int lp_1, int lp_2, int lp_3, long val)
        {
            DictionaryLongSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <param name="val"></param>
        public static void DictionaryLongSave4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4, long val)
        {
            DictionaryLongSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns>错误时返回null</returns>
        public static long? DictionaryLongLoad0_N(bool place, string key)
        {
            if ((DictionaryLongKeyExists(place, key) == false))
            {
                return null;
            }
            return DictionaryLongGetValue(place, key);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns>错误时返回null</returns>
        public static long? DictionaryLongLoad1_N(bool place, string key, int lp_1)
        {
            if ((DictionaryLongKeyExists(place, (key + "_" + lp_1.ToString())) == false))
            {
                return null;
            }
            return DictionaryLongGetValue(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns>错误时返回null</returns>
        public static long? DictionaryLongLoad2_N(bool place, string key, int lp_1, int lp_2)
        {
            if ((DictionaryLongKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString())) == false))
            {
                return null;
            }
            return DictionaryLongGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns>错误时返回null</returns>
        public static long? DictionaryLongLoad3_N(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            if ((DictionaryLongKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString())) == false))
            {
                return null;
            }
            return DictionaryLongGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns>错误时返回null</returns>
        public static long? DictionaryLongLoad4_N(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            if ((DictionaryLongKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString())) == false))
            {
                return null;
            }
            return DictionaryLongGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns>错误时返回0</returns>
        public static long DictionaryLongLoad0(bool place, string key)
        {
            if ((DictionaryLongKeyExists(place, key) == false))
            {
                return 0;
            }
            return DictionaryLongGetValue(place, key);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns>错误时返回0</returns>
        public static long DictionaryLongLoad1(bool place, string key, int lp_1)
        {
            if ((DictionaryLongKeyExists(place, (key + "_" + lp_1.ToString())) == false))
            {
                return 0;
            }
            return DictionaryLongGetValue(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns>错误时返回0</returns>
        public static long DictionaryLongLoad2(bool place, string key, int lp_1, int lp_2)
        {
            if ((DictionaryLongKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString())) == false))
            {
                return 0;
            }
            return DictionaryLongGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns>错误时返回0</returns>
        public static long DictionaryLongLoad3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            if ((DictionaryLongKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString())) == false))
            {
                return 0;
            }
            return DictionaryLongGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns>错误时返回0</returns>
        public static long DictionaryLongLoad4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            if ((DictionaryLongKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString())) == false))
            {
                return 0;
            }
            return DictionaryLongGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        #endregion

        #region Char字典

        /// <summary>
        /// 【MM_函数库】添加字典键值对（重复添加则覆盖）
        /// </summary>
        /// <param name="place">true=全局，false=局部</param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        private static void DictionaryCharSet(bool place, string key, char val)//内部使用
        {
            if (place)
            {
                //存入全局字典
                systemDictionaryChar[key] = val;

                //if (systemDictionaryChar.Contains(key)) 
                //{
                //    systemDictionaryChar.Remove(key);
                //}
                //systemDictionaryChar.Add(key, val);

            }
            else
            {
                //存入局部字典
                tempDictionaryChar[key] = val;

                //if (tempDictionaryChar.Contains(key)) { tempDictionaryChar.Remove(key); }
                //tempDictionaryChar.Add(key, val);
            }
        }

        /// <summary>
        /// 【MM_函数库】判断字典键是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DictionaryCharKeyExists(bool place, string key)
        {
            if (place) { return systemDictionaryChar.ContainsKey(key); }
            else { return tempDictionaryChar.ContainsKey(key); }
        }

        /// <summary>
        /// 【MM_函数库】判断字典值是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool DictionaryCharValueExists(bool place, char value)
        {
            if (place) { return systemDictionaryChar.ContainsValue(value); }
            else { return tempDictionaryChar.ContainsValue(value); }
        }

        /// <summary>
        /// 【MM_函数库】获取字典键对应的值
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static char DictionaryCharGetValue(bool place, string key)
        {
            if (place) { return systemDictionaryChar[key]; }
            else { return tempDictionaryChar[key]; }
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        public static void DictionaryCharClear0(bool place, string key)
        {
            DictionaryCharRemove(place, key);
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[]，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        public static void DictionaryCharClear1(bool place, string key, int lp_1)
        {
            DictionaryCharRemove(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,]，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        public static void DictionaryCharClear2(bool place, string key, int lp_1, int lp_2)
        {
            DictionaryCharRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,,]，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        public static void DictionaryCharClear3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            DictionaryCharRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,,,]，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        public static void DictionaryCharClear4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            DictionaryCharRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】移除字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        private static void DictionaryCharRemove(bool place, string key)//内部函数
        {
            if (place) { systemDictionaryChar.Remove(key); }
            else { tempDictionaryChar.Remove(key); }
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        public static void DictionaryCharSave0(bool place, string key, char val)
        {
            DictionaryCharSet(place, key, val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="val"></param>
        public static void DictionaryCharSave1(bool place, string key, int lp_1, char val)
        {
            DictionaryCharSet(place, (key + "_" + lp_1.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="val"></param>
        public static void DictionaryCharSave2(bool place, string key, int lp_1, int lp_2, char val)
        {
            DictionaryCharSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="val"></param>
        public static void DictionaryCharSave3(bool place, string key, int lp_1, int lp_2, int lp_3, char val)
        {
            DictionaryCharSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <param name="val"></param>
        public static void DictionaryCharSave4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4, char val)
        {
            DictionaryCharSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns>错误时返回null</returns>
        public static char? DictionaryCharLoad0_N(bool place, string key)
        {
            if ((DictionaryCharKeyExists(place, key) == false))
            {
                return null;
            }
            return DictionaryCharGetValue(place, key);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns>错误时返回null</returns>
        public static char? DictionaryCharLoad1_N(bool place, string key, int lp_1)
        {
            if ((DictionaryCharKeyExists(place, (key + "_" + lp_1.ToString())) == false))
            {
                return null;
            }
            return DictionaryCharGetValue(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns>错误时返回null</returns>
        public static char? DictionaryCharLoad2_N(bool place, string key, int lp_1, int lp_2)
        {
            if ((DictionaryCharKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString())) == false))
            {
                return null;
            }
            return DictionaryCharGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns>错误时返回null</returns>
        public static char? DictionaryCharLoad3_N(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            if ((DictionaryCharKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString())) == false))
            {
                return null;
            }
            return DictionaryCharGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns>错误时返回null</returns>
        public static char? DictionaryCharLoad4_N(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            if ((DictionaryCharKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString())) == false))
            {
                return null;
            }
            return DictionaryCharGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns>错误时返回' '</returns>
        public static char DictionaryCharLoad0(bool place, string key)
        {
            if ((DictionaryCharKeyExists(place, key) == false))
            {
                return ' ';
            }
            return DictionaryCharGetValue(place, key);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns>错误时返回' '</returns>
        public static char DictionaryCharLoad1(bool place, string key, int lp_1)
        {
            if ((DictionaryCharKeyExists(place, (key + "_" + lp_1.ToString())) == false))
            {
                return ' ';
            }
            return DictionaryCharGetValue(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns>错误时返回' '</returns>
        public static char DictionaryCharLoad2(bool place, string key, int lp_1, int lp_2)
        {
            if ((DictionaryCharKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString())) == false))
            {
                return ' ';
            }
            return DictionaryCharGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns>错误时返回' '</returns>
        public static char DictionaryCharLoad3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            if ((DictionaryCharKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString())) == false))
            {
                return ' ';
            }
            return DictionaryCharGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns>错误时返回' '</returns>
        public static char DictionaryCharLoad4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            if ((DictionaryCharKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString())) == false))
            {
                return ' ';
            }
            return DictionaryCharGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        #endregion

        #region Float字典

        /// <summary>
        /// 【MM_函数库】添加字典键值对（重复添加则覆盖）
        /// </summary>
        /// <param name="place">true=全局，false=局部</param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        private static void DictionaryFloatSet(bool place, string key, float val)//内部使用
        {
            if (place)
            {
                //存入全局字典
                systemDictionaryFloat[key] = val;

                //if (systemDictionaryFloat.Contains(key)) 
                //{
                //    systemDictionaryFloat.Remove(key);
                //}
                //systemDictionaryFloat.Add(key, val);

            }
            else
            {
                //存入局部字典
                tempDictionaryFloat[key] = val;

                //if (tempDictionaryFloat.Contains(key)) { tempDictionaryFloat.Remove(key); }
                //tempDictionaryFloat.Add(key, val);
            }
        }

        /// <summary>
        /// 【MM_函数库】判断字典键是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DictionaryFloatKeyExists(bool place, string key)
        {
            if (place) { return systemDictionaryFloat.ContainsKey(key); }
            else { return tempDictionaryFloat.ContainsKey(key); }
        }

        /// <summary>
        /// 【MM_函数库】判断字典值是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool DictionaryFloatValueExists(bool place, float value)
        {
            if (place) { return systemDictionaryFloat.ContainsValue(value); }
            else { return tempDictionaryFloat.ContainsValue(value); }
        }

        /// <summary>
        /// 【MM_函数库】获取字典键对应的值
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static float DictionaryFloatGetValue(bool place, string key)
        {
            if (place) { return systemDictionaryFloat[key]; }
            else { return tempDictionaryFloat[key]; }
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        public static void DictionaryFloatClear0(bool place, string key)
        {
            DictionaryFloatRemove(place, key);
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[]，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        public static void DictionaryFloatClear1(bool place, string key, int lp_1)
        {
            DictionaryFloatRemove(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,]，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        public static void DictionaryFloatClear2(bool place, string key, int lp_1, int lp_2)
        {
            DictionaryFloatRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,,]，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        public static void DictionaryFloatClear3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            DictionaryFloatRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,,,]，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        public static void DictionaryFloatClear4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            DictionaryFloatRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】移除字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        private static void DictionaryFloatRemove(bool place, string key)//内部函数
        {
            if (place) { systemDictionaryFloat.Remove(key); }
            else { tempDictionaryFloat.Remove(key); }
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        public static void DictionaryFloatSave0(bool place, string key, float val)
        {
            DictionaryFloatSet(place, key, val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="val"></param>
        public static void DictionaryFloatSave1(bool place, string key, int lp_1, float val)
        {
            DictionaryFloatSet(place, (key + "_" + lp_1.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="val"></param>
        public static void DictionaryFloatSave2(bool place, string key, int lp_1, int lp_2, float val)
        {
            DictionaryFloatSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="val"></param>
        public static void DictionaryFloatSave3(bool place, string key, int lp_1, int lp_2, int lp_3, float val)
        {
            DictionaryFloatSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <param name="val"></param>
        public static void DictionaryFloatSave4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4, float val)
        {
            DictionaryFloatSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns>错误时返回null</returns>
        public static float? DictionaryFloatLoad0_N(bool place, string key)
        {
            if ((DictionaryFloatKeyExists(place, key) == false))
            {
                return null;
            }
            return DictionaryFloatGetValue(place, key);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns>错误时返回null</returns>
        public static float? DictionaryFloatLoad1_N(bool place, string key, int lp_1)
        {
            if ((DictionaryFloatKeyExists(place, (key + "_" + lp_1.ToString())) == false))
            {
                return null;
            }
            return DictionaryFloatGetValue(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns>错误时返回null</returns>
        public static float? DictionaryFloatLoad2_N(bool place, string key, int lp_1, int lp_2)
        {
            if ((DictionaryFloatKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString())) == false))
            {
                return null;
            }
            return DictionaryFloatGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns>错误时返回null</returns>
        public static float? DictionaryFloatLoad3_N(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            if ((DictionaryFloatKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString())) == false))
            {
                return null;
            }
            return DictionaryFloatGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns>错误时返回null</returns>
        public static float? DictionaryFloatLoad4_N(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            if ((DictionaryFloatKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString())) == false))
            {
                return null;
            }
            return DictionaryFloatGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns>错误时返回0.0f</returns>
        public static float DictionaryFloatLoad0(bool place, string key)
        {
            if ((DictionaryFloatKeyExists(place, key) == false))
            {
                return 0.0f;
            }
            return DictionaryFloatGetValue(place, key);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns>错误时返回0.0f</returns>
        public static float DictionaryFloatLoad1(bool place, string key, int lp_1)
        {
            if ((DictionaryFloatKeyExists(place, (key + "_" + lp_1.ToString())) == false))
            {
                return 0.0f;
            }
            return DictionaryFloatGetValue(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns>错误时返回0.0f</returns>
        public static float DictionaryFloatLoad2(bool place, string key, int lp_1, int lp_2)
        {
            if ((DictionaryFloatKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString())) == false))
            {
                return 0.0f;
            }
            return DictionaryFloatGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns>错误时返回0.0f</returns>
        public static float DictionaryFloatLoad3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            if ((DictionaryFloatKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString())) == false))
            {
                return 0.0f;
            }
            return DictionaryFloatGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns>错误时返回0.0f</returns>
        public static float DictionaryFloatLoad4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            if ((DictionaryFloatKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString())) == false))
            {
                return 0.0f;
            }
            return DictionaryFloatGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        #endregion

        #region Double字典

        /// <summary>
        /// 【MM_函数库】添加字典键值对（重复添加则覆盖）
        /// </summary>
        /// <param name="place">true=全局，false=局部</param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        private static void DictionaryDoubleSet(bool place, string key, double val)//内部使用
        {
            if (place)
            {
                //存入全局字典
                systemDictionaryDouble[key] = val;

                //if (systemDictionaryDouble.Contains(key)) 
                //{
                //    systemDictionaryDouble.Remove(key);
                //}
                //systemDictionaryDouble.Add(key, val);

            }
            else
            {
                //存入局部字典
                tempDictionaryDouble[key] = val;

                //if (tempDictionaryDouble.Contains(key)) { tempDictionaryDouble.Remove(key); }
                //tempDictionaryDouble.Add(key, val);
            }
        }

        /// <summary>
        /// 【MM_函数库】判断字典键是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DictionaryDoubleKeyExists(bool place, string key)
        {
            if (place) { return systemDictionaryDouble.ContainsKey(key); }
            else { return tempDictionaryDouble.ContainsKey(key); }
        }

        /// <summary>
        /// 【MM_函数库】判断字典值是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool DictionaryDoubleValueExists(bool place, double value)
        {
            if (place) { return systemDictionaryDouble.ContainsValue(value); }
            else { return tempDictionaryDouble.ContainsValue(value); }
        }

        /// <summary>
        /// 【MM_函数库】获取字典键对应的值
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static double DictionaryDoubleGetValue(bool place, string key)
        {
            if (place) { return systemDictionaryDouble[key]; }
            else { return tempDictionaryDouble[key]; }
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        public static void DictionaryDoubleClear0(bool place, string key)
        {
            DictionaryDoubleRemove(place, key);
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[]，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        public static void DictionaryDoubleClear1(bool place, string key, int lp_1)
        {
            DictionaryDoubleRemove(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,]，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        public static void DictionaryDoubleClear2(bool place, string key, int lp_1, int lp_2)
        {
            DictionaryDoubleRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,,]，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        public static void DictionaryDoubleClear3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            DictionaryDoubleRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,,,]，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        public static void DictionaryDoubleClear4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            DictionaryDoubleRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】移除字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        private static void DictionaryDoubleRemove(bool place, string key)//内部函数
        {
            if (place) { systemDictionaryDouble.Remove(key); }
            else { tempDictionaryDouble.Remove(key); }
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        public static void DictionaryDoubleSave0(bool place, string key, double val)
        {
            DictionaryDoubleSet(place, key, val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="val"></param>
        public static void DictionaryDoubleSave1(bool place, string key, int lp_1, double val)
        {
            DictionaryDoubleSet(place, (key + "_" + lp_1.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="val"></param>
        public static void DictionaryDoubleSave2(bool place, string key, int lp_1, int lp_2, double val)
        {
            DictionaryDoubleSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="val"></param>
        public static void DictionaryDoubleSave3(bool place, string key, int lp_1, int lp_2, int lp_3, double val)
        {
            DictionaryDoubleSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <param name="val"></param>
        public static void DictionaryDoubleSave4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4, double val)
        {
            DictionaryDoubleSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns>错误时返回null</returns>
        public static double? DictionaryDoubleLoad0_N(bool place, string key)
        {
            if (DictionaryDoubleKeyExists(place, key) == false)
            {
                return null;
            }
            return DictionaryDoubleGetValue(place, key);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns>错误时返回null</returns>
        public static double? DictionaryDoubleLoad1_N(bool place, string key, int lp_1)
        {
            if ((DictionaryDoubleKeyExists(place, (key + "_" + lp_1.ToString())) == false))
            {
                return null;
            }
            return DictionaryDoubleGetValue(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns>错误时返回null</returns>
        public static double? DictionaryDoubleLoad2_N(bool place, string key, int lp_1, int lp_2)
        {
            if ((DictionaryDoubleKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString())) == false))
            {
                return null;
            }
            return DictionaryDoubleGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns>错误时返回null</returns>
        public static double? DictionaryDoubleLoad3_N(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            if ((DictionaryDoubleKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString())) == false))
            {
                return null;
            }
            return DictionaryDoubleGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns>错误时返回null</returns>
        public static double? DictionaryDoubleLoad4_N(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            if ((DictionaryDoubleKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString())) == false))
            {
                return null;
            }
            return DictionaryDoubleGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns>错误时返回0.0</returns>
        public static double DictionaryDoubleLoad0(bool place, string key)
        {
            if (DictionaryDoubleKeyExists(place, key) == false)
            {
                return 0.0;
            }
            return DictionaryDoubleGetValue(place, key);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns>错误时返回0.0</returns>
        public static double DictionaryDoubleLoad1(bool place, string key, int lp_1)
        {
            if ((DictionaryDoubleKeyExists(place, (key + "_" + lp_1.ToString())) == false))
            {
                return 0.0;
            }
            return DictionaryDoubleGetValue(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns>错误时返回0.0</returns>
        public static double DictionaryDoubleLoad2(bool place, string key, int lp_1, int lp_2)
        {
            if ((DictionaryDoubleKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString())) == false))
            {
                return 0.0;
            }
            return DictionaryDoubleGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns>错误时返回0.0</returns>
        public static double DictionaryDoubleLoad3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            if ((DictionaryDoubleKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString())) == false))
            {
                return 0.0;
            }
            return DictionaryDoubleGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns>错误时返回0.0</returns>
        public static double DictionaryDoubleLoad4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            if ((DictionaryDoubleKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString())) == false))
            {
                return 0.0;
            }
            return DictionaryDoubleGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        #endregion

        #region Bool字典

        /// <summary>
        /// 【MM_函数库】添加字典键值对（重复添加则覆盖）
        /// </summary>
        /// <param name="place">true=全局，false=局部</param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        private static void DictionaryBoolSet(bool place, string key, bool val)//内部使用
        {
            if (place)
            {
                //存入全局字典
                systemDictionaryBool[key] = val;

                //if (systemDictionaryBool.Contains(key)) 
                //{
                //    systemDictionaryBool.Remove(key);
                //}
                //systemDictionaryBool.Add(key, val);

            }
            else
            {
                //存入局部字典
                tempDictionaryBool[key] = val;

                //if (tempDictionaryBool.Contains(key)) { tempDictionaryBool.Remove(key); }
                //tempDictionaryBool.Add(key, val);
            }
        }

        /// <summary>
        /// 【MM_函数库】判断字典键是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DictionaryBoolKeyExists(bool place, string key)
        {
            if (place)
            {
                return systemDictionaryBool.ContainsKey(key);
            }
            else { return tempDictionaryBool.ContainsKey(key); }
        }

        /// <summary>
        /// 【MM_函数库】判断字典值是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool DictionaryBoolValueExists(bool place, bool value)
        {
            if (place) { return systemDictionaryBool.ContainsValue(value); }
            else { return tempDictionaryBool.ContainsValue(value); }
        }

        /// <summary>
        /// 【MM_函数库】获取字典键对应的值
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DictionaryBoolGetValue(bool place, string key)
        {
            if (place) { return systemDictionaryBool[key]; }
            else { return tempDictionaryBool[key]; }
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        public static void DictionaryBoolClear0(bool place, string key)
        {
            DictionaryBoolRemove(place, key);
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[]，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        public static void DictionaryBoolClear1(bool place, string key, int lp_1)
        {
            DictionaryBoolRemove(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,]，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        public static void DictionaryBoolClear2(bool place, string key, int lp_1, int lp_2)
        {
            DictionaryBoolRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,,]，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        public static void DictionaryBoolClear3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            DictionaryBoolRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,,,]，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        public static void DictionaryBoolClear4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            DictionaryBoolRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】移除字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        private static void DictionaryBoolRemove(bool place, string key)//内部函数
        {
            if (place) { systemDictionaryBool.Remove(key); }
            else { tempDictionaryBool.Remove(key); }
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        public static void DictionaryBoolSave0(bool place, string key, bool val)
        {
            DictionaryBoolSet(place, key, val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="val"></param>
        public static void DictionaryBoolSave1(bool place, string key, int lp_1, bool val)
        {
            DictionaryBoolSet(place, (key + "_" + lp_1.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="val"></param>
        public static void DictionaryBoolSave2(bool place, string key, int lp_1, int lp_2, bool val)
        {
            DictionaryBoolSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="val"></param>
        public static void DictionaryBoolSave3(bool place, string key, int lp_1, int lp_2, int lp_3, bool val)
        {
            DictionaryBoolSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <param name="val"></param>
        public static void DictionaryBoolSave4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4, bool val)
        {
            DictionaryBoolSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns>错误时返回null</returns>
        public static bool? DictionaryBoolLoad0_N(bool place, string key)
        {
            if ((DictionaryBoolKeyExists(place, key) == false))
            {
                return null;
            }
            return DictionaryBoolGetValue(place, key);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns>错误时返回null</returns>
        public static bool? DictionaryBoolLoad1_N(bool place, string key, int lp_1)
        {
            if ((DictionaryBoolKeyExists(place, (key + "_" + lp_1.ToString())) == false))
            {
                return null;
            }
            return DictionaryBoolGetValue(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns>错误时返回null</returns>
        public static bool? DictionaryBoolLoad2_N(bool place, string key, int lp_1, int lp_2)
        {
            if ((DictionaryBoolKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString())) == false))
            {
                return null;
            }
            return DictionaryBoolGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns>错误时返回null</returns>
        public static bool? DictionaryBoolLoad3_N(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            if ((DictionaryBoolKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString())) == false))
            {
                return null;
            }
            return DictionaryBoolGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns>错误时返回null</returns>
        public static bool? DictionaryBoolLoad4_N(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            if ((DictionaryBoolKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString())) == false))
            {
                return null;
            }
            return DictionaryBoolGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns>错误时返回false</returns>
        public static bool DictionaryBoolLoad0(bool place, string key)
        {
            if ((DictionaryBoolKeyExists(place, key) == false))
            {
                return false;
            }
            return DictionaryBoolGetValue(place, key);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns>错误时返回false</returns>
        public static bool DictionaryBoolLoad1(bool place, string key, int lp_1)
        {
            if ((DictionaryBoolKeyExists(place, (key + "_" + lp_1.ToString())) == false))
            {
                return false;
            }
            return DictionaryBoolGetValue(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns>错误时返回false</returns>
        public static bool DictionaryBoolLoad2(bool place, string key, int lp_1, int lp_2)
        {
            if ((DictionaryBoolKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString())) == false))
            {
                return false;
            }
            return DictionaryBoolGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns>错误时返回false</returns>
        public static bool DictionaryBoolLoad3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            if ((DictionaryBoolKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString())) == false))
            {
                return false;
            }
            return DictionaryBoolGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns>错误时返回false</returns>
        public static bool DictionaryBoolLoad4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            if ((DictionaryBoolKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString())) == false))
            {
                return false;
            }
            return DictionaryBoolGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        #endregion

        #region Byte字典

        /// <summary>
        /// 【MM_函数库】添加字典键值对（重复添加则覆盖）
        /// </summary>
        /// <param name="place">true=全局，false=局部</param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        private static void DictionaryByteSet(bool place, string key, byte val)//内部使用
        {
            if (place)
            {
                //存入全局字典
                systemDictionaryByte[key] = val;

                //if (systemDictionaryByte.Contains(key)) 
                //{
                //    systemDictionaryByte.Remove(key);
                //}
                //systemDictionaryByte.Add(key, val);

            }
            else
            {
                //存入局部字典
                tempDictionaryByte[key] = val;

                //if (tempDictionaryByte.Contains(key)) { tempDictionaryByte.Remove(key); }
                //tempDictionaryByte.Add(key, val);
            }
        }

        /// <summary>
        /// 【MM_函数库】判断字典键是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DictionaryByteKeyExists(bool place, string key)
        {
            if (place) { return systemDictionaryByte.ContainsKey(key); }
            else { return tempDictionaryByte.ContainsKey(key); }
        }

        /// <summary>
        /// 【MM_函数库】判断字典值是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool DictionaryByteValueExists(bool place, byte value)
        {
            if (place) { return systemDictionaryByte.ContainsValue(value); }
            else { return tempDictionaryByte.ContainsValue(value); }
        }

        /// <summary>
        /// 【MM_函数库】获取字典键对应的值
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static byte DictionaryByteGetValue(bool place, string key)
        {
            if (place) { return systemDictionaryByte[key]; }
            else { return tempDictionaryByte[key]; }
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        public static void DictionaryByteClear0(bool place, string key)
        {
            DictionaryByteRemove(place, key);
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[]，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        public static void DictionaryByteClear1(bool place, string key, int lp_1)
        {
            DictionaryByteRemove(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,]，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        public static void DictionaryByteClear2(bool place, string key, int lp_1, int lp_2)
        {
            DictionaryByteRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,,]，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        public static void DictionaryByteClear3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            DictionaryByteRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,,,]，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        public static void DictionaryByteClear4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            DictionaryByteRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】移除字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        private static void DictionaryByteRemove(bool place, string key)//内部函数
        {
            if (place) { systemDictionaryByte.Remove(key); }
            else { tempDictionaryByte.Remove(key); }
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        public static void DictionaryByteSave0(bool place, string key, byte val)
        {
            DictionaryByteSet(place, key, val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="val"></param>
        public static void DictionaryByteSave1(bool place, string key, int lp_1, byte val)
        {
            DictionaryByteSet(place, (key + "_" + lp_1.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="val"></param>
        public static void DictionaryByteSave2(bool place, string key, int lp_1, int lp_2, byte val)
        {
            DictionaryByteSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="val"></param>
        public static void DictionaryByteSave3(bool place, string key, int lp_1, int lp_2, int lp_3, byte val)
        {
            DictionaryByteSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <param name="val"></param>
        public static void DictionaryByteSave4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4, byte val)
        {
            DictionaryByteSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns>错误时返回null</returns>
        public static byte? DictionaryByteLoad0_N(bool place, string key)
        {
            if ((DictionaryByteKeyExists(place, key) == false))
            {
                return null;
            }
            return DictionaryByteGetValue(place, key);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns>错误时返回null</returns>
        public static byte? DictionaryByteLoad1_N(bool place, string key, int lp_1)
        {
            if ((DictionaryByteKeyExists(place, (key + "_" + lp_1.ToString())) == false))
            {
                return null;
            }
            return DictionaryByteGetValue(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns>错误时返回null</returns>
        public static byte? DictionaryByteLoad2_N(bool place, string key, int lp_1, int lp_2)
        {
            if ((DictionaryByteKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString())) == false))
            {
                return null;
            }
            return DictionaryByteGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns>错误时返回null</returns>
        public static byte? DictionaryByteLoad3_N(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            if ((DictionaryByteKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString())) == false))
            {
                return null;
            }
            return DictionaryByteGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns>错误时返回null</returns>
        public static byte? DictionaryByteLoad4_N(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            if ((DictionaryByteKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString())) == false))
            {
                return null;
            }
            return DictionaryByteGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns>错误时返回0</returns>
        public static byte DictionaryByteLoad0(bool place, string key)
        {
            if ((DictionaryByteKeyExists(place, key) == false))
            {
                return 0;
            }
            return DictionaryByteGetValue(place, key);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns>错误时返回0</returns>
        public static byte DictionaryByteLoad1(bool place, string key, int lp_1)
        {
            if ((DictionaryByteKeyExists(place, (key + "_" + lp_1.ToString())) == false))
            {
                return 0;
            }
            return DictionaryByteGetValue(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns>错误时返回0</returns>
        public static byte DictionaryByteLoad2(bool place, string key, int lp_1, int lp_2)
        {
            if ((DictionaryByteKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString())) == false))
            {
                return 0;
            }
            return DictionaryByteGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns>错误时返回0</returns>
        public static byte DictionaryByteLoad3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            if ((DictionaryByteKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString())) == false))
            {
                return 0;
            }
            return DictionaryByteGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns>错误时返回0</returns>
        public static byte DictionaryByteLoad4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            if ((DictionaryByteKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString())) == false))
            {
                return 0;
            }
            return DictionaryByteGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        #endregion

        #endregion

        #region 引用类型

        #region Object字典

        /// <summary>
        /// 【MM_函数库】添加字典键值对（重复添加则覆盖）
        /// </summary>
        /// <param name="place">true=全局，false=局部</param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        private static void DictionaryObjectSet(bool place, string key, object val)//内部使用
        {
            if (place)
            {
                //存入全局字典
                systemDictionaryObject[key] = val;

                //if (systemDictionaryObject.Contains(key)) 
                //{
                //    systemDictionaryObject.Remove(key);
                //}
                //systemDictionaryObject.Add(key, val);

            }
            else
            {
                //存入局部字典
                tempDictionaryObject[key] = val;

                //if (tempDictionaryObject.Contains(key)) { tempDictionaryObject.Remove(key); }
                //tempDictionaryObject.Add(key, val);
            }
        }

        /// <summary>
        /// 【MM_函数库】判断字典键是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DictionaryObjectKeyExists(bool place, string key)
        {
            if (place) { return systemDictionaryObject.ContainsKey(key); }
            else { return tempDictionaryObject.ContainsKey(key); }
        }

        /// <summary>
        /// 【MM_函数库】判断字典值是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool DictionaryObjectValueExists(bool place, object value)
        {
            if (place) { return systemDictionaryObject.ContainsValue(value); }
            else { return tempDictionaryObject.ContainsValue(value); }
        }

        /// <summary>
        /// 【MM_函数库】获取字典键对应的值
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static object DictionaryObjectGetValue(bool place, string key)
        {
            if (place) { return systemDictionaryObject[key]; }
            else { return tempDictionaryObject[key]; }
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        public static void DictionaryObjectClear0(bool place, string key)
        {
            DictionaryObjectRemove(place, key);
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[]，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        public static void DictionaryObjectClear1(bool place, string key, int lp_1)
        {
            DictionaryObjectRemove(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,]，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        public static void DictionaryObjectClear2(bool place, string key, int lp_1, int lp_2)
        {
            DictionaryObjectRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,,]，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        public static void DictionaryObjectClear3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            DictionaryObjectRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,,,]，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        public static void DictionaryObjectClear4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            DictionaryObjectRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】移除字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        private static void DictionaryObjectRemove(bool place, string key)//内部函数
        {
            if (place) { systemDictionaryObject.Remove(key); }
            else { tempDictionaryObject.Remove(key); }
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        public static void DictionaryObjectSave0(bool place, string key, object val)
        {
            DictionaryObjectSet(place, key, val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="val"></param>
        public static void DictionaryObjectSave1(bool place, string key, int lp_1, object val)
        {
            DictionaryObjectSet(place, (key + "_" + lp_1.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="val"></param>
        public static void DictionaryObjectSave2(bool place, string key, int lp_1, int lp_2, object val)
        {
            DictionaryObjectSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="val"></param>
        public static void DictionaryObjectSave3(bool place, string key, int lp_1, int lp_2, int lp_3, object val)
        {
            DictionaryObjectSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <param name="val"></param>
        public static void DictionaryObjectSave4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4, object val)
        {
            DictionaryObjectSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns>错误时返回null</returns>
        public static object DictionaryObjectLoad0(bool place, string key)
        {
            if ((DictionaryObjectKeyExists(place, key) == false))
            {
                return null;
            }
            return DictionaryObjectGetValue(place, key);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns>错误时返回null</returns>
        public static object DictionaryObjectLoad1(bool place, string key, int lp_1)
        {
            if ((DictionaryObjectKeyExists(place, (key + "_" + lp_1.ToString())) == false))
            {
                return null;
            }
            return DictionaryObjectGetValue(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns>错误时返回null</returns>
        public static object DictionaryObjectLoad2(bool place, string key, int lp_1, int lp_2)
        {
            if ((DictionaryObjectKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString())) == false))
            {
                return null;
            }
            return DictionaryObjectGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns>错误时返回null</returns>
        public static object DictionaryObjectLoad3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            if ((DictionaryObjectKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString())) == false))
            {
                return null;
            }
            return DictionaryObjectGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns>错误时返回null</returns>
        public static object DictionaryObjectLoad4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            if ((DictionaryObjectKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString())) == false))
            {
                return null;
            }
            return DictionaryObjectGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        #endregion

        #region Vector字典

        /// <summary>
        /// 【MM_函数库】添加字典键值对（重复添加则覆盖）
        /// </summary>
        /// <param name="place">true=全局，false=局部</param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        private static void DictionaryVectorSet(bool place, string key, Vector2F val)//内部使用
        {
            if (place)
            {
                //存入全局字典
                systemDictionaryVector[key] = val;

                //if (systemDictionaryVector.Contains(key)) 
                //{
                //    systemDictionaryVector.Remove(key);
                //}
                //systemDictionaryVector.Add(key, val);

            }
            else
            {
                //存入局部字典
                tempDictionaryVector[key] = val;

                //if (tempDictionaryVector.Contains(key)) { tempDictionaryVector.Remove(key); }
                //tempDictionaryVector.Add(key, val);
            }
        }

        /// <summary>
        /// 【MM_函数库】判断字典键是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DictionaryVectorKeyExists(bool place, string key)
        {
            if (place) { return systemDictionaryVector.ContainsKey(key); }
            else { return tempDictionaryVector.ContainsKey(key); }
        }

        /// <summary>
        /// 【MM_函数库】判断字典值是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool DictionaryVectorValueExists(bool place, Vector2F value)
        {
            if (place) { return systemDictionaryVector.ContainsValue(value); }
            else { return tempDictionaryVector.ContainsValue(value); }
        }

        /// <summary>
        /// 【MM_函数库】获取字典键对应的值
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static Vector2F DictionaryVectorGetValue(bool place, string key)
        {
            if (place) { return systemDictionaryVector[key]; }
            else { return tempDictionaryVector[key]; }
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        public static void DictionaryVectorClear0(bool place, string key)
        {
            DictionaryVectorRemove(place, key);
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[]，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        public static void DictionaryVectorClear1(bool place, string key, int lp_1)
        {
            DictionaryVectorRemove(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,]，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        public static void DictionaryVectorClear2(bool place, string key, int lp_1, int lp_2)
        {
            DictionaryVectorRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,,]，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        public static void DictionaryVectorClear3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            DictionaryVectorRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,,,]，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        public static void DictionaryVectorClear4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            DictionaryVectorRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】移除字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        private static void DictionaryVectorRemove(bool place, string key)//内部函数
        {
            if (place) { systemDictionaryVector.Remove(key); }
            else { tempDictionaryVector.Remove(key); }
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        public static void DictionaryVectorSave0(bool place, string key, Vector2F val)
        {
            DictionaryVectorSet(place, key, val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="val"></param>
        public static void DictionaryVectorSave1(bool place, string key, int lp_1, Vector2F val)
        {
            DictionaryVectorSet(place, (key + "_" + lp_1.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="val"></param>
        public static void DictionaryVectorSave2(bool place, string key, int lp_1, int lp_2, Vector2F val)
        {
            DictionaryVectorSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="val"></param>
        public static void DictionaryVectorSave3(bool place, string key, int lp_1, int lp_2, int lp_3, Vector2F val)
        {
            DictionaryVectorSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <param name="val"></param>
        public static void DictionaryVectorSave4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4, Vector2F val)
        {
            DictionaryVectorSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns>错误时返回null</returns>
        public static Vector2F? DictionaryVectorLoad0_N(bool place, string key)
        {
            if ((DictionaryVectorKeyExists(place, key) == false))
            {
                return null;
            }
            return DictionaryVectorGetValue(place, key);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns>错误时返回null</returns>
        public static Vector2F? DictionaryVectorLoad1_N(bool place, string key, int lp_1)
        {
            if ((DictionaryVectorKeyExists(place, (key + "_" + lp_1.ToString())) == false))
            {
                return null;
            }
            return DictionaryVectorGetValue(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns>错误时返回null</returns>
        public static Vector2F? DictionaryVectorLoad2_N(bool place, string key, int lp_1, int lp_2)
        {
            if ((DictionaryVectorKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString())) == false))
            {
                return null;
            }
            return DictionaryVectorGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns>错误时返回null</returns>
        public static Vector2F? DictionaryVectorLoad3_N(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            if ((DictionaryVectorKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString())) == false))
            {
                return null;
            }
            return DictionaryVectorGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns>错误时返回null</returns>
        public static Vector2F? DictionaryVectorLoad4_N(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            if ((DictionaryVectorKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString())) == false))
            {
                return null;
            }
            return DictionaryVectorGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns>错误时返回new Vector2F(0,0)</returns>
        public static Vector2F DictionaryVectorLoad0(bool place, string key)
        {
            if ((DictionaryVectorKeyExists(place, key) == false))
            {
                return new Vector2F(0, 0);
            }
            return DictionaryVectorGetValue(place, key);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns>错误时返回new Vector2F(0,0)</returns>
        public static Vector2F DictionaryVectorLoad1(bool place, string key, int lp_1)
        {
            if ((DictionaryVectorKeyExists(place, (key + "_" + lp_1.ToString())) == false))
            {
                return new Vector2F(0, 0);
            }
            return DictionaryVectorGetValue(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns>错误时返回new Vector2F(0,0)</returns>
        public static Vector2F DictionaryVectorLoad2(bool place, string key, int lp_1, int lp_2)
        {
            if ((DictionaryVectorKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString())) == false))
            {
                return new Vector2F(0, 0);
            }
            return DictionaryVectorGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns>错误时返回new Vector2F(0,0)</returns>
        public static Vector2F DictionaryVectorLoad3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            if ((DictionaryVectorKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString())) == false))
            {
                return new Vector2F(0, 0);
            }
            return DictionaryVectorGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns>错误时返回new Vector2F(0,0)</returns>
        public static Vector2F DictionaryVectorLoad4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            if ((DictionaryVectorKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString())) == false))
            {
                return new Vector2F(0, 0);
            }
            return DictionaryVectorGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        #endregion

        #region Timer字典

        /// <summary>
        /// 【MM_函数库】添加字典键值对（重复添加则覆盖）
        /// </summary>
        /// <param name="place">true=全局，false=局部</param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        private static void DictionaryTimerSet(bool place, string key, Timer val)//内部使用
        {
            if (place)
            {
                //存入全局字典
                systemDictionaryTimer[key] = val;

                //if (systemDictionaryTimer.Contains(key)) 
                //{
                //    systemDictionaryTimer.Remove(key);
                //}
                //systemDictionaryTimer.Add(key, val);

            }
            else
            {
                //存入局部字典
                tempDictionaryTimer[key] = val;

                //if (tempDictionaryTimer.Contains(key)) { tempDictionaryTimer.Remove(key); }
                //tempDictionaryTimer.Add(key, val);
            }
        }

        /// <summary>
        /// 【MM_函数库】判断字典键是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DictionaryTimerKeyExists(bool place, string key)
        {
            if (place) { return systemDictionaryTimer.ContainsKey(key); }
            else { return tempDictionaryTimer.ContainsKey(key); }
        }

        /// <summary>
        /// 【MM_函数库】判断字典值是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool DictionaryTimerValueExists(bool place, Timer value)
        {
            if (place) { return systemDictionaryTimer.ContainsValue(value); }
            else { return tempDictionaryTimer.ContainsValue(value); }
        }

        /// <summary>
        /// 【MM_函数库】获取字典键对应的值
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static Timer DictionaryTimerGetValue(bool place, string key)
        {
            if (place) { return systemDictionaryTimer[key]; }
            else { return tempDictionaryTimer[key]; }
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        public static void DictionaryTimerClear0(bool place, string key)
        {
            DictionaryTimerRemove(place, key);
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[]，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        public static void DictionaryTimerClear1(bool place, string key, int lp_1)
        {
            DictionaryTimerRemove(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,]，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        public static void DictionaryTimerClear2(bool place, string key, int lp_1, int lp_2)
        {
            DictionaryTimerRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,,]，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        public static void DictionaryTimerClear3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            DictionaryTimerRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,,,]，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        public static void DictionaryTimerClear4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            DictionaryTimerRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】移除字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        private static void DictionaryTimerRemove(bool place, string key)//内部函数
        {
            if (place) { systemDictionaryTimer.Remove(key); }
            else { tempDictionaryTimer.Remove(key); }
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        public static void DictionaryTimerSave0(bool place, string key, Timer val)
        {
            DictionaryTimerSet(place, key, val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="val"></param>
        public static void DictionaryTimerSave1(bool place, string key, int lp_1, Timer val)
        {
            DictionaryTimerSet(place, (key + "_" + lp_1.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="val"></param>
        public static void DictionaryTimerSave2(bool place, string key, int lp_1, int lp_2, Timer val)
        {
            DictionaryTimerSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="val"></param>
        public static void DictionaryTimerSave3(bool place, string key, int lp_1, int lp_2, int lp_3, Timer val)
        {
            DictionaryTimerSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <param name="val"></param>
        public static void DictionaryTimerSave4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4, Timer val)
        {
            DictionaryTimerSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns>错误时返回null</returns>
        public static Timer DictionaryTimerLoad0(bool place, string key)
        {
            if ((DictionaryTimerKeyExists(place, key) == false))
            {
                return null;
            }
            return DictionaryTimerGetValue(place, key);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns>错误时返回null</returns>
        public static Timer DictionaryTimerLoad1(bool place, string key, int lp_1)
        {
            if ((DictionaryTimerKeyExists(place, (key + "_" + lp_1.ToString())) == false))
            {
                return null;
            }
            return DictionaryTimerGetValue(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns>错误时返回null</returns>
        public static Timer DictionaryTimerLoad2(bool place, string key, int lp_1, int lp_2)
        {
            if ((DictionaryTimerKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString())) == false))
            {
                return null;
            }
            return DictionaryTimerGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns>错误时返回null</returns>
        public static Timer DictionaryTimerLoad3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            if ((DictionaryTimerKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString())) == false))
            {
                return null;
            }
            return DictionaryTimerGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns>错误时返回null</returns>
        public static Timer DictionaryTimerLoad4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            if ((DictionaryTimerKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString())) == false))
            {
                return null;
            }
            return DictionaryTimerGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        #endregion

        #region String字典

        /// <summary>
        /// 【MM_函数库】添加字典键值对（重复添加则覆盖）
        /// </summary>
        /// <param name="place">true=全局，false=局部</param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        private static void DictionaryStringSet(bool place, string key, string val)//内部使用
        {
            if (place)
            {
                //存入全局字典
                systemDictionaryString[key] = val;

                //if (systemDictionaryString.Contains(key)) 
                //{
                //    systemDictionaryString.Remove(key);
                //}
                //systemDictionaryString.Add(key, val);

            }
            else
            {
                //存入局部字典
                tempDictionaryString[key] = val;

                //if (tempDictionaryString.Contains(key)) { tempDictionaryString.Remove(key); }
                //tempDictionaryString.Add(key, val);
            }
        }

        /// <summary>
        /// 【MM_函数库】判断字典键是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DictionaryStringKeyExists(bool place, string key)
        {
            if (place) { return systemDictionaryString.ContainsKey(key); }
            else { return tempDictionaryString.ContainsKey(key); }
        }

        /// <summary>
        /// 【MM_函数库】判断字典值是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool DictionaryStringValueExists(bool place, string value)
        {
            if (place) { return systemDictionaryString.ContainsValue(value); }
            else { return tempDictionaryString.ContainsValue(value); }
        }

        /// <summary>
        /// 【MM_函数库】获取字典键对应的值
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static string DictionaryStringGetValue(bool place, string key)
        {
            if (place) { return systemDictionaryString[key]; }
            else { return tempDictionaryString[key]; }
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        public static void DictionaryStringClear0(bool place, string key)
        {
            DictionaryStringRemove(place, key);
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[]，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        public static void DictionaryStringClear1(bool place, string key, int lp_1)
        {
            DictionaryStringRemove(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,]，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        public static void DictionaryStringClear2(bool place, string key, int lp_1, int lp_2)
        {
            DictionaryStringRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,,]，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        public static void DictionaryStringClear3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            DictionaryStringRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,,,]，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        public static void DictionaryStringClear4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            DictionaryStringRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】移除字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        private static void DictionaryStringRemove(bool place, string key)//内部函数
        {
            if (place) { systemDictionaryString.Remove(key); }
            else { tempDictionaryString.Remove(key); }
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        public static void DictionaryStringSave0(bool place, string key, string val)
        {
            DictionaryStringSet(place, key, val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="val"></param>
        public static void DictionaryStringSave1(bool place, string key, int lp_1, string val)
        {
            DictionaryStringSet(place, (key + "_" + lp_1.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="val"></param>
        public static void DictionaryStringSave2(bool place, string key, int lp_1, int lp_2, string val)
        {
            DictionaryStringSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="val"></param>
        public static void DictionaryStringSave3(bool place, string key, int lp_1, int lp_2, int lp_3, string val)
        {
            DictionaryStringSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <param name="val"></param>
        public static void DictionaryStringSave4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4, string val)
        {
            DictionaryStringSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns>错误时返回null</returns>
        public static string DictionaryStringLoad0(bool place, string key)
        {
            if ((DictionaryStringKeyExists(place, key) == false))
            {
                return null;
            }
            return DictionaryStringGetValue(place, key);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns>错误时返回null</returns>
        public static string DictionaryStringLoad1(bool place, string key, int lp_1)
        {
            if ((DictionaryStringKeyExists(place, (key + "_" + lp_1.ToString())) == false))
            {
                return null;
            }
            return DictionaryStringGetValue(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns>错误时返回null</returns>
        public static string DictionaryStringLoad2(bool place, string key, int lp_1, int lp_2)
        {
            if ((DictionaryStringKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString())) == false))
            {
                return null;
            }
            return DictionaryStringGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns>错误时返回null</returns>
        public static string DictionaryStringLoad3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            if ((DictionaryStringKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString())) == false))
            {
                return null;
            }
            return DictionaryStringGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns>错误时返回null</returns>
        public static string DictionaryStringLoad4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            if ((DictionaryStringKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString())) == false))
            {
                return null;
            }
            return DictionaryStringGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        #endregion

        #endregion

        #endregion

        #endregion

        #endregion

        #region Functions 互动管理

        //用数据表实现不同类型数据互动、信息管理

        #region 存储区状态队列管理

        /// <summary>
        /// 【MM_函数库】存储区容错处理函数，当哈希表键值存在时执行线程等待。常用于多线程触发器频繁写值，如大量注册注销动作使存储区数据重排序的，因哈希表正在使用需排队等待完成才给执行下一个。执行原理：将调用该函数的当前线程反复挂起50毫秒，直到动作要写入的存储区闲置
        /// </summary>
        /// <param name="key"></param>
        public static void ThreadWait(string key)
        {
            while (DataTableBoolLoad0(true, "MMCore_ThreadWait_" + key) == true)
            {
                Thread.Sleep(50); //将调用该函数的当前线程挂起
            }
        }

        /// <summary>
        /// 【MM_函数库】存储区容错处理函数，当哈希表键值存在时执行线程等待。常用于多线程触发器频繁写值，如大量注册注销动作使存储区数据重排序的，因哈希表正在使用需排队等待完成才给执行下一个。执行原理：将调用该函数的当前线程反复挂起period毫秒，直到动作要写入的存储区闲置
        /// </summary>
        /// <param name="key"></param>
        /// <param name="period"></param>
        public static void ThreadWait(string key, int period)
        {
            while (DataTableBoolLoad0(true, "MMCore_ThreadWait_" + key) == true)
            {
                Thread.Sleep(period); //将调用该函数的当前线程挂起
            }
        }

        /// <summary>
        /// 【MM_函数库】存储区容错处理函数，引发注册注销等存储区频繁重排序的动作，在函数开始/完成写入存储区时，应设置线程等待（val=1）/闲置（val=0）
        /// </summary>
        /// <param name="key"></param>
        /// <param name="val">函数动作完成，所写入存储区闲置时填false，反之填true</param>
        private static void ThreadWaitSet(string key, bool val)
        {
            DataTableBoolSave0(true, "MMCore_ThreadWait_" + key, val);
        }

        /// <summary>
        /// 【MM_函数库】存储区容错处理函数，当哈希表键值存在时执行线程等待。常用于多线程触发器频繁写值，如大量注册注销动作使存储区数据重排序的，因哈希表正在使用需排队等待完成才给执行下一个。执行原理：将调用该函数的当前线程反复挂起50毫秒，直到动作要写入的存储区闲置
        /// </summary>
        /// <param name="key"></param>
        public static void ThreadWait(bool place, string key)
        {
            while (DataTableBoolLoad0(place, "MMCore_ThreadWait_" + key) == true)
            {
                Thread.Sleep(50); //将调用该函数的当前线程挂起
            }
        }

        /// <summary>
        /// 【MM_函数库】存储区容错处理函数，当哈希表键值存在时执行线程等待。常用于多线程触发器频繁写值，如大量注册注销动作使存储区数据重排序的，因哈希表正在使用需排队等待完成才给执行下一个。执行原理：将调用该函数的当前线程反复挂起period毫秒，直到动作要写入的存储区闲置
        /// </summary>
        /// <param name="key"></param>
        /// <param name="period"></param>
        public static void ThreadWait(bool place, string key, int period)
        {
            while (DataTableBoolLoad0(place, "MMCore_ThreadWait_" + key) == true)
            {
                Thread.Sleep(period); //将调用该函数的当前线程挂起
            }
        }

        /// <summary>
        /// 【MM_函数库】存储区容错处理函数，引发注册注销等存储区频繁重排序的动作，在函数开始/完成写入存储区时，应设置线程等待（val=1）/闲置（val=0）
        /// </summary>
        /// <param name="key"></param>
        /// <param name="val">函数动作完成，所写入存储区闲置时填false，反之填true</param>
        private static void ThreadWaitSet(bool place, string key, bool val)
        {
            DataTableBoolSave0(place, "MMCore_ThreadWait_" + key, val);
        }

        #endregion

        //注：下方分用户和系统共计三种互动，用户互动即便填入与系统互动相同参数键名也会存储在不同键区位置，所以是安全的

        #region 用户互动

        #region 任意类型

        //提示：可以将本类型作为模板修改后产生其他类型
        //提示：尽可能使用对口类型，以防值类型与引用类型发生转换时拆装箱降低性能

        //--------------------------------------------------------------------------------------------------
        // 任意类型组Start
        //--------------------------------------------------------------------------------------------------

        /// <summary>
        /// 【MM_函数库】互动O_注册Object标签句柄并返回。为Object自动设置新的标签句柄，重复时会返回已注册的Object标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns>返回一个Object的已注册标签</returns>
        private static int HD_RegObjectTagAndReturn_Int(object lp_object)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = DataTableIntLoad0(true, "HD_ObjectJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                DataTableIntSave0(true, "HD_ObjectJBNum", lv_j);
                DataTableObjectSave0(true, ("HD_Object_" + lv_j.ToString()), lp_object);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if (DataTableObjectLoad0(true, ("HD_Object_" + lv_j.ToString())) == lp_object)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            DataTableIntSave0(true, "HD_ObjectJBNum", lv_j);
                            DataTableObjectSave0(true, ("HD_Object_" + lv_j.ToString()), lp_object);
                        }
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object已注册标签句柄
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns>返回一个Object的已注册标签，错误返回0</returns>
        public static int HD_ReturnObjectTag_Int(object lp_object)
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = DataTableIntLoad0(true, "HD_ObjectJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if (DataTableObjectLoad0(true, "HD_Object_" + lv_j.ToString()) == lp_object)
                {
                    break;
                }
                else
                {
                    if ((lv_j == lv_jBNum))
                    {
                        lv_j = 0;
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动O_注册Object标签句柄并返回。为Object自动设置新的标签句柄，重复时会返回已注册的Object标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns>返回一个Object的已注册标签""</returns>
        private static string HD_RegObjectTagAndReturn(object lp_object)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = DataTableIntLoad0(true, "HD_ObjectJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                DataTableIntSave0(true, "HD_ObjectJBNum", lv_j);
                DataTableObjectSave0(true, ("HD_Object_" + lv_j.ToString()), lp_object);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if (DataTableObjectLoad0(true, "HD_Object_" + lv_j.ToString()) == lp_object)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            DataTableIntSave0(true, "HD_ObjectJBNum", lv_j);
                            DataTableObjectSave0(true, ("HD_Object_" + lv_j.ToString()), lp_object);
                        }
                    }
                }
            }
            lv_tag = lv_j.ToString();
            //Console.WriteLine(("Tag：" + lv_tag));
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object已注册标签句柄
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns>返回一个Object的已注册标签，错误返回""</returns>
        public static string HD_ReturnObjectTag(object lp_object)
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag = "";
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = DataTableIntLoad0(true, "HD_ObjectJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if (DataTableObjectLoad0(true, "HD_Object_" + lv_j.ToString()) == lp_object)
                {
                    lv_tag = lv_j.ToString();
                    break;
                }
            }
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动O_注册Object(高级)。在指定Key存入Object，固有状态、自定义值是Object独一无二的标志（本函数重复注册会刷新），之后可用互动O_"返回Object注册总数"、"返回Object序号"、"返回序号对应Object"、"返回序号对应Object标签"、"返回Object自定义值"。Object组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Object组转为Key。首次注册时固有状态为true（相当于单位组单位活体），如需另外设置多个标记可使用"互动O_设定Object状态/自定义值"
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        /// <param name="lp_inherentStats">固有状态</param>
        /// <param name="lp_inherentCustomValue">固有自定义值</param>
        public static void HD_RegObject(object lp_object, string lp_key, string lp_inherentStats, string lp_inherentCustomValue)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;

            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_jBNum = DataTableIntLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = HD_RegObjectTagAndReturn(lp_object);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                DataTableIntSave0(true, (lv_str + "Num"), lv_i);
                DataTableStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                DataTableBoolSave0(true, (("HD_IfObjectTag" + "") + "_" + lv_tagStr), true);
                DataTableBoolSave1(true, ("HD_IfObjectTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if (DataTableIntLoad1(true, lv_str + "Tag", lv_i).ToString() == lv_tagStr)
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                DataTableIntSave0(true, (lv_str + "Num"), lv_i);
                                DataTableStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                DataTableBoolSave0(true, (("HD_IfObjectTag" + "") + "_" + lv_tagStr), true);
                                DataTableBoolSave1(true, ("HD_IfObjectTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            DataTableStringSave0(true, ("HD_ObjectState" + "" + "_" + lv_tagStr), lp_inherentStats);
            DataTableStringSave0(true, ("HD_ObjectCV" + "" + "_" + lv_tagStr), lp_inherentCustomValue);
        }

        /// <summary>
        /// 【MM_函数库】互动O_注册Object。在指定Key存入Object，固有状态、自定义值是Object独一无二的标志（本函数重复注册不会刷新），之后可用互动O_"返回Object注册总数"、"返回Object序号"、"返回序号对应Object"、"返回Object自定义值"。Object组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Object组转为Key。首次注册时固有状态为true（相当于单位组单位活体），之后只能通过"互动O_注册Object（高级）"改写，如需另外设置多个标记可使用"互动O_设定Object状态/自定义值"
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        public static void HD_RegObject_Simple(object lp_object, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;

            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_jBNum = DataTableIntLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = HD_RegObjectTagAndReturn(lp_object);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                DataTableIntSave0(true, (lv_str + "Num"), lv_i);
                DataTableStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                DataTableBoolSave0(true, (("HD_IfObjectTag" + "") + "_" + lv_tagStr), true);
                DataTableBoolSave1(true, ("HD_IfObjectTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if (DataTableIntLoad1(true, lv_str + "Tag", lv_i).ToString() == lv_tagStr)
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                DataTableIntSave0(true, (lv_str + "Num"), lv_i);
                                DataTableStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                DataTableBoolSave0(true, (("HD_IfObjectTag" + "") + "_" + lv_tagStr), true);
                                DataTableBoolSave1(true, ("HD_IfObjectTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            if ((DataTableBoolKeyExists(true, ("HD_Object" + "State" + "_" + lv_tag.ToString())) == false))
            {
                DataTableStringSave1(true, (("HD_Object" + "State")), lv_tag, "true");
            }
        }

        /// <summary>
        /// 【MM_函数库】互动O_注销Object。用"互动O_注册Object"到Key，之后可用本函数彻底摧毁注册信息并将序号重排（包括Object标签有效状态、固有状态及自定义值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动O_设定Object状态"让Object状态失效（类似单位组的单位活体状态）。Object组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Object组转为Key。本函数无法摧毁用"互动O_设定Object状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Object组变量ID时会清空Object组专用状态
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        public static void HD_DestroyObject(object lp_object, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag;
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_tag = HD_ReturnObjectTag(lp_object);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                ThreadWaitSet(true, "Key_ObjectGroup" + lv_str, true);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((DataTableIntLoad1(true, (lp_key + "ObjectTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        DataTableBoolClear0(true, "HD_IfObjectTag_" + lv_tag);
                        DataTableBoolClear0(true, "HD_IfObjectTag" + lv_str + "_" + lv_tag);
                        DataTableObjectClear0(true, "HD_Object_" + lv_tag);
                        DataTableStringClear0(true, "HD_ObjectCV_" + lv_tag);
                        DataTableStringClear0(true, "HD_ObjectState_" + lv_tag);
                        DataTableStringClear0(true, "HD_ObjectCV" + lv_str + "_" + lv_tag);
                        DataTableStringClear0(true, "HD_ObjectState" + lv_str + "_" + lv_tag);
                        DataTableIntSave0(true, (lp_key + "ObjectNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = DataTableIntLoad1(true, (lp_key + "ObjectTag"), lv_b + 1).ToString();
                            DataTableStringSave1(true, (lp_key + "ObjectTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                ThreadWaitSet(true, "Key_ObjectGroup" + lv_str, false);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动O_移除Object。用"互动O_注册Object"到Key，之后可用本函数仅摧毁Key区注册的信息并将序号重排，用于Object组或多个键区仅移除Object（保留Object标签有效状态、固有值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动O_设定Object状态"让Object状态失效（类似单位组的单位活体状态）。Object组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Object组转为Key。本函数无法摧毁用"互动O_设定Object状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Object组变量ID时会清空Object组专用状态
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        public static void HD_RemoveObject(object lp_object, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag;
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_tag = HD_ReturnObjectTag(lp_object);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                ThreadWaitSet(true, "Key_ObjectGroup" + lv_str, true);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((DataTableIntLoad1(true, (lp_key + "ObjectTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        DataTableBoolClear0(true, "HD_IfObjectTag" + lv_str + "_" + lv_tag);
                        DataTableStringClear0(true, "HD_ObjectCV" + lv_str + "_" + lv_tag);
                        DataTableStringClear0(true, "HD_ObjectState" + lv_str + "_" + lv_tag);
                        DataTableIntSave0(true, (lp_key + "ObjectNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = DataTableIntLoad1(true, (lp_key + "ObjectTag"), lv_b + 1).ToString();
                            DataTableStringSave1(true, (lp_key + "ObjectTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                ThreadWaitSet(true, "Key_ObjectGroup" + lv_str, false);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object注册总数。必须先使用"互动O_注册Object"才能返回指定Key里的注册总数。Object组使用时，可用"获取变量的内部名称"将Object组转为Key。
        /// </summary>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        /// <returns></returns>
        public static int HD_ReturnObjectNumMax(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            // Implementation
            return lv_num;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object序号。使用"互动O_注册Object"后使用本函数可返回Key里的注册序号，Key无元素返回0，Key有元素但对象不在里面则返回-1，Object标签尚未注册则返回-2。Object组使用时，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        /// <returns></returns>
        public static int HD_ReturnObjectNum(object lp_object, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_i;
            string lv_tag;
            int lv_torf;
            // Automatic Variable Declarations
            const int auto_n = 1;
            int auto_i;
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_tag = HD_ReturnObjectTag(lp_object);
            lv_torf = -1;
            // Implementation
            for (auto_i = 1; auto_i <= auto_n; auto_i += 1)
            {
                if ((lv_tag != null))
                {
                    lv_torf = -2;
                    break;
                }
                if ((lv_num == 0))
                {
                    lv_torf = 0;
                }
                else
                {
                    if ((lv_num >= 1))
                    {
                        auto_ae = lv_num;
                        auto_var = 1;
                        for (; auto_var <= auto_ae; auto_var += 1)
                        {
                            lv_i = auto_var;
                            if ((DataTableIntLoad1(true, (lv_str + "Tag"), lv_i).ToString() == lv_tag))
                            {
                                lv_torf = lv_i;
                                break;
                            }
                        }
                    }
                }
            }
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回序号对应Object。使用"互动O_注册Object"后，在参数填入注册序号可返回Object。Object组使用时，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_regNum"></param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        /// <returns></returns>
        public static object HD_ReturnObjectFromRegNum(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag;
            object lv_object;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = DataTableIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            lv_object = DataTableObjectLoad0(true, ("HD_Object_" + lv_tag));
            // Implementation
            return lv_object;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回句柄标签对应Object。使用"互动O_注册Object"后，在参数填入句柄标签（整数）可返回Object，标签是Object的句柄。Object组使用时，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_tag">句柄标签</param>
        /// <returns></returns>
        public static object HD_ReturnObjectFromTag(int lp_tag)
        {
            // Variable Declarations
            string lv_tag;
            object lv_object;
            // Variable Initialization
            lv_tag = lp_tag.ToString();
            lv_object = DataTableObjectLoad0(true, ("HD_Object_" + lv_tag));
            // Implementation
            return lv_object;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回序号对应Object标签句柄。使用"互动O_注册Object"后，在参数填入注册序号可返回Object标签（字符串）。Object组使用时，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        /// <returns></returns>
        public static string HD_ReturnObjectTagFromRegNum_String(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = DataTableIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回序号对应Object标签句柄。使用"互动O_注册Object"后，在参数填入注册序号可返回Object标签（整数）。Object组使用时，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        /// <returns></returns>
        public static int HD_ReturnObjectTagFromRegNum_Int(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = DataTableIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return Convert.ToInt32(lv_tag);
        }

        /// <summary>
        /// 【MM_函数库】互动O_设置Object状态。必须先"注册"获得功能库内部句柄，再使用本函数给Object设定一个状态值，之后可用"互动O_返回Object状态"。类型参数用以记录多个不同状态，仅当"类型"参数填Object组ID转的Object串时，状态值"true"和"false"是Object的Object组专用状态值，用于内部函数筛选Object状态（相当于单位组单位索引是否有效），其他类型不会干扰系统内部，可随意填写。虽然注销时反向清空注册信息，但用"互动O_设定Object状态/自定义值"创建的值需要手工填入""来排泄（非大量注销则提升内存量极小，可不管）。注：固有状态值是注册函数赋予的系统内部变量（相当于单位组单位是否活体），只能通过"互动O_注册Object（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <param name="lp_stats">状态</param>
        public static void HD_SetObjectState(object lp_object, string lp_key, string lp_stats)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = HD_RegObjectTagAndReturn(lp_object);
            // Implementation
            DataTableStringSave0(true, ("HD_ObjectState" + lv_str + "_" + lv_tag), lp_stats);
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object状态。使用"互动O_设定Object状态"后可使用本函数，将本函数参数"类型"设为空时返回固有值。类型参数用以记录多个不同状态，仅当"类型"参数为Object组ID转的字符串时，返回的状态值"true"和"false"是Object的Object组专用状态值，用于内部函数筛选Object状态（相当于单位组单位索引是否有效）
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <returns></returns>
        public static string HD_ReturnObjectState(object lp_object, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag;
            string lv_stats;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = HD_ReturnObjectTag(lp_object);
            lv_stats = DataTableStringLoad0(true, ("HD_ObjectState" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动O_设置Object自定义值。必须先"注册"获得功能库内部句柄，再使用本函数设定Object的自定义值，之后可使用"互动O_返回Object自定义值"，类型参数用以记录多个不同自定义值。注：固有自定义值是注册函数赋予的系统内部变量，只能通过"互动O_注册Object（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <param name="lp_customValue">自定义值</param>
        public static void HD_SetObjectCV(object lp_object, string lp_key, string lp_customValue)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = HD_RegObjectTagAndReturn(lp_object);
            // Implementation
            DataTableStringSave0(true, ("HD_ObjectCV" + lv_str + "_" + lv_tag), lp_customValue);
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object自定义值。使用"互动O_设定Object自定义值"后可使用本函数，将本函数参数"类型"设为空时返回固有值，该参数用以记录多个不同自定义值
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <returns></returns>
        public static string HD_ReturnObjectCV(object lp_object, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag;
            string lv_customValue;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = HD_ReturnObjectTag(lp_object);
            lv_customValue = DataTableStringLoad0(true, ("HD_ObjectCV" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object固有状态。必须先使用"互动O_注册Object"才能返回到该值，固有状态是独一无二的标记（相当于单位组单位是否活体）
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns></returns>
        public static string HD_ReturnObjectState_Only(object lp_object)
        {
            // Variable Declarations
            string lv_tag;
            string lv_stats;
            // Variable Initialization
            lv_tag = HD_ReturnObjectTag(lp_object);
            lv_stats = DataTableStringLoad0(true, ("HD_ObjectState" + "" + "_" + lv_tag));
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object固有自定义值。必须先使用"互动O_注册Object"才能返回到该值，固有值是独一无二的标记
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns></returns>
        public static string HD_ReturnObjectCV_Only(object lp_object)
        {
            // Variable Declarations
            string lv_tag;
            string lv_customValue;
            // Variable Initialization
            lv_tag = HD_ReturnObjectTag(lp_object);
            lv_customValue = DataTableStringLoad0(true, ("HD_ObjectCV" + "" + "_" + lv_tag));
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动O_设置Object的实数标记。必须先"注册"获得功能库内部句柄，再使用本函数让Object携带一个实数值，之后可使用"互动O_返回Object的实数标记"。Object组使用时，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_realNumTag">实数标记</param>
        public static void HD_SetObjectDouble(object lp_object, double lp_realNumTag)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = HD_RegObjectTagAndReturn(lp_object);
            // Implementation
            DataTableDoubleSave0(true, ("HD_CDDouble_Object_" + lv_tag), lp_realNumTag);
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object的实数标记。使用"互动O_设定Object的实数标记"后可使用本函数。Object组使用时，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns></returns>
        public static double HD_ReturnObjectDouble(object lp_object)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = HD_ReturnObjectTag(lp_object);
            // Implementation
            return DataTableDoubleLoad0(true, ("HD_CDDouble_Object_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object标签句柄有效状态。将Object视作独一无二的个体，标签是它本身，有效状态则类似"单位是否有效"，当使用"互动O_注册Object"或"互动OG_添加Object到Object组"后激活Object有效状态（值为"true"），除非使用"互动O_注册Object（高级）"改写，否则直到注销才会摧毁
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns></returns>
        public static bool HD_ReturnIfObjectTag(object lp_object)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = HD_ReturnObjectTag(lp_object);
            // Implementation
            return DataTableBoolLoad0(true, ("HD_IfObjectTag" + "" + "_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object注册状态。使用"互动O_注册Object"或"互动OG_添加Object到Object组"后可使用本函数获取注册Object在Key中的注册状态，该状态只能注销或从Object组中移除时清空。Object组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        /// <returns></returns>
        public static bool HD_ReturnIfObjectTagKey(object lp_object, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = HD_ReturnObjectTag(lp_object);
            // Implementation
            return DataTableBoolLoad0(true, ("HD_IfObjectTag" + lv_str + "_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动OG_根据自定义值类型将Object组排序。根据Object携带的自定义值类型，对指定的Object组元素进行冒泡排序。Object组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Object组名称</param>
        /// <param name="lp_cVStr">自定义值类型</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void HD_ObjectGSortCV(string lp_key, string lp_cVStr, bool lp_big)
        {
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            string lv_tagValuestr;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_ObjectGroup" + lv_str, true);
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = HD_ReturnObjectTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValuestr = HD_ReturnObjectCV(HD_ReturnObjectFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    DataTableIntSave1(false, "IntStackOutTag", 1, lv_tag);
                    DataTableIntSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < DataTableIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DataTableIntSave1(false, "IntStackOutTag", lv_c, DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    DataTableIntSave1(false, "IntStackOutTagValue", lv_c, DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_c, DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                DataTableIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                DataTableIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > DataTableIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(HD_ReturnObjectTagFromRegNum(lv_b, lp_key))+"值"+IntToString(DataTableIntLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DataTableIntSave1(false, "IntStackOutTag", lv_c, DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DataTableIntSave1(false, "IntStackOutTagValue", lv_c, DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_c, DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                DataTableIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DataTableIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        DataTableIntSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DataTableIntSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = DataTableIntLoad1(true, (lp_key + "ObjectTag"), lv_a).ToString(); //原始序号元素
                lv_tag = DataTableIntLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValuestr = HD_ReturnObjectCV(HD_ReturnObjectFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = DataTableIntLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    DataTableIntSave1(true, (lp_key + "ObjectTag"), lv_a, lv_tag); //lv_tag放入新序号
                    //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            ThreadWaitSet(true, "Key_ObjectGroup" + lv_str, false);
        }

        /// <summary>
        /// 【MM_函数库】互动OG_Object组排序。对指定的Object组元素进行冒泡排序（根据元素句柄）。Object组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Object组名称</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void HD_ObjectGSort(string lp_key, bool lp_big)
        {
            // Automatic Variable Declarations
            // Implementation
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_ObjectGroup" + lv_str, true);
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = HD_ReturnObjectTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValue = lv_tag;
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    DataTableIntSave1(false, "IntStackOutTag", 1, lv_tag);
                    DataTableIntSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < DataTableIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DataTableIntSave1(false, "IntStackOutTag", lv_c, DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    DataTableIntSave1(false, "IntStackOutTagValue", lv_c, DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_c, DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                DataTableIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                DataTableIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > DataTableIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(HD_ReturnObjectTagFromRegNum(lv_b, lp_key))+"值"+IntToString(DataTableIntLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DataTableIntSave1(false, "IntStackOutTag", lv_c, DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DataTableIntSave1(false, "IntStackOutTagValue", lv_c, DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_c, DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                DataTableIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DataTableIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        DataTableIntSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DataTableIntSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = DataTableIntLoad1(true, (lp_key + "ObjectTag"), lv_a).ToString(); //原始序号元素
                lv_tag = DataTableIntLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValue = lv_tag;
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = DataTableIntLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                                                                                  //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    DataTableIntSave1(true, (lp_key + "ObjectTag"), lv_a, lv_tag); //lv_tag放入新序号
                                                                                   //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            ThreadWaitSet(true, "Key_ObjectGroup" + lv_str, false);
        }

        /// <summary>
        /// 【MM_函数库】互动OG_设定Object的Object组专用状态。给Object组的Object设定一个状态值（字符串），之后可用"互动O_返回Object、互动OG_返回Object组的Object状态"。状态值"true"和"false"是Object的Object组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效），而本函数可以重设干预，影响函数"互动OG_返回Object组元素数量（仅检索XX状态）"。与"互动O_设定Object状态"功能相同，只是状态参数在Object组中被固定为"Object组变量的内部ID"。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_objectGroup"></param>
        /// <param name="lp_groupState"></param>
        public static void HD_SetObjectGState(object lp_object, string lp_objectGroup, string lp_groupState)
        {
            HD_SetObjectState(lp_object, lp_objectGroup, lp_groupState);
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object的Object组专用状态。使用"互动O_设定Object、互动OG_设定Object组的Object状态"后可使用本函数。与"互动O_返回Object状态"功能相同，只是状态参数在Object组中被固定为"Object组变量的内部ID"。状态值"true"和"false"是Object的Object组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效）。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_objectGroup"></param>
        public static void HD_ReturnObjectGState(object lp_object, string lp_objectGroup)
        {
            HD_ReturnObjectState(lp_object, lp_objectGroup);
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object组元素序号对应元素。返回Object组元素序号指定Object。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static object HD_ReturnObjectFromObjectGFunc(int lp_regNum, string lp_gs)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag;
            object lv_object;
            // Variable Initialization
            lv_str = (lp_gs + "Object");
            lv_tag = DataTableIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            lv_object = DataTableObjectLoad0(true, ("HD_Object_" + lv_tag));
            // Implementation
            return lv_object;
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object组元素总数。返回指定Object组的元素数量。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns>错误时返回0</returns>
        public static int HD_ReturnObjectGNumMax(string lp_gs)
        {
            return DataTableIntLoad0(true, lp_gs + "ObjectNum");
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object组元素总数（仅检测Object组专用状态="true"）。返回指定Object组的元素数量。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HD_ReturnObjectGNumMax_StateTrueFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            object lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HD_ReturnObjectNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HD_ReturnObjectFromRegNum(lv_a, lp_gs);
                lv_b = HD_ReturnObjectState(lv_c, lp_gs);
                if ((lv_b == "true"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object组元素总数（仅检测Object组专用状态="false"）。返回指定Object组的元素数量。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HD_ReturnObjectGNumMax_StateFalseFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            object lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HD_ReturnObjectNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HD_ReturnObjectFromRegNum(lv_a, lp_gs);
                lv_b = HD_ReturnObjectState(lv_c, lp_gs);
                if ((lv_b == "false"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object组元素总数（仅检测Object组无效专用状态："false"或""）。返回指定Object组的元素数量（false、""、null）。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HD_ReturnObjectGNumMax_StateUselessFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            object lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HD_ReturnObjectNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HD_ReturnObjectFromRegNum(lv_a, lp_gs);
                lv_b = HD_ReturnObjectState(lv_c, lp_gs);
                if (((lv_b == "false") || (lv_b == "") || (lv_b == null)))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object组元素总数（仅检测Object组指定专用状态）。返回指定Object组的元素数量。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_State">Object组专用状态</param>
        /// <returns></returns>
        public static int HD_ReturnObjectGNumMax_StateFunc_Specify(string lp_gs, string lp_State)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            object lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HD_ReturnObjectNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HD_ReturnObjectFromRegNum(lv_a, lp_gs);
                lv_b = HD_ReturnObjectState(lv_c, lp_gs);
                if ((lv_b == lp_State))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动OG_添加Object到Object组。相同Object被认为是同一个，非高级功能不提供专用状态检查，如果Object没有设置过Object组专用状态，那么首次添加到Object组不会赋予"true"（之后可通过"互动O_设定Object状态"、"互动OG_设定Object组的Object状态"修改）。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HD_AddObjectToGroup_Simple(object lp_object, string lp_gs)
        {
            HD_RegObject_Simple(lp_object, lp_gs);
        }

        /// <summary>
        /// 【MM_函数库】互动OG_添加Object到Object组（高级）。相同Object被认为是同一个，高级功能提供专用状态检查，如果Object没有设置过Object组专用状态，那么首次添加到Object组会赋予"true"（之后可通过"互动O_设定Object状态"、"互动OG_设定Object组的Object状态"修改）。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HD_AddObjectToGroup(object lp_object, string lp_gs)
        {
            HD_RegObject_Simple(lp_object, lp_gs);
            if (DataTableStringKeyExists(true, ("HD_ObjectState" + lp_gs + "Object_" + HD_RegObjectTagAndReturn(lp_object))) == false)
            {
                DataTableStringSave0(true, ("HD_ObjectState" + lp_gs + "Object_" + HD_RegObjectTagAndReturn(lp_object)), "true");
                //Console.WriteLine(lp_gs + "=>" + HD_RegObjectTagAndReturn(lp_object));
            }
        }

        /// <summary>
        /// 【MM_函数库】互动OG_移除Object组中的元素。使用"互动OG_添加Object到Object组"后可使用本函数进行移除元素。移除使用了"互动O_移除Object"，同一个存储区（Object组ID）序号重排，移除时该存储区如有其他操作会排队等待。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HD_ClearObjectFromGroup(object lp_object, string lp_gs)
        {
            HD_RemoveObject(lp_object, lp_gs);
        }

        //互动OG_为Object组中的每个序号
        //GE（星际2的Galaxy Editor）的宏让编辑器保存时自动生成脚本并整合进脚本进行格式调整，C#仅参考需自行编写
        // #AUTOVAR(vs, string) = "#PARAM(group)";//"#PARAM(group)"是与字段、变量名一致的元素组名称，宏去声明string类型名为“Auto随机编号_vs”的自动变量，然后=右侧字符
        // #AUTOVAR(ae) = HD_ReturnObjectNumMax(#AUTOVAR(vs));//宏去声明默认int类型名为“Auto随机编号_ae”的自动变量，然后=右侧字符
        // #INITAUTOVAR(ai,increment)//宏去声明int类型名为“Auto随机编号_ai”的自动变量，用于下面for循环增量（increment是传入参数）
        // #PARAM(var) = #PARAM(s);//#PARAM(var)是传进来的参数，用作“当前被挑选到的元素”（任意变量-整数 lp_var）， #PARAM(s)是传进来的参数用作"开始"（int lp_s）
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #PARAM(var) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #PARAM(var) >= #AUTOVAR(ae)) ) ; #PARAM(var) += #AUTOVAR(ai) ) {
        //     #SUBFUNCS(actions)//代表用户GUI填写的所有动作
        // }

        /// <summary>
        /// 【MM_函数库】互动OG_为Object组中的每个序号。每次挑选的元素序号会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素序号，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void HD_ForEachObjectNumFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            int lv_ae = HD_ReturnObjectNumMax(lp_gs);
            int lv_var = lp_start;
            int lv_ai = lp_increment;
            for (; (lv_ai >= 0 && lv_var <= lv_ae) || (lv_ai < 0 && lv_var >= lv_ae); lv_var += lv_ai)
            {
                lp_funcref(lv_var);//用户填写的所有动作
            }
        }

        //互动OG_为Object组中的每个元素
        // #AUTOVAR(vs, string) = "#PARAM(group)";
        // #AUTOVAR(ae) = HD_ReturnObjectNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= #PARAM(s);
        // #INITAUTOVAR(ai,increment)
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     DataTableSave(false, "ObjectGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)), HD_ReturnObjectFromRegNum(#AUTOVAR(va),#AUTOVAR(vs)));
        // }
        // #AUTOVAR(va)= #PARAM(s);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #PARAM(var) = DataTableLoad(false, "ObjectGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)));
        //     #SUBFUNCS(actions)
        // }

        /// <summary>
        /// 【MM_函数库】互动OG_为Object组中的每个元素。每次挑选的元素会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void HD_ForEachObjectFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            string lv_vs = lp_gs;
            int lv_ae = HD_ReturnObjectNumMax(lv_vs);
            int lv_va = lp_start;
            int lv_ai = lp_increment;
            object lv_object;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                DataTableObjectSave0(false, "ObjectGFor" + lv_vs + lv_va.ToString(), HD_ReturnObjectFromRegNum(lv_va, lv_vs));
            }
            lv_va = lp_start;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                lv_object = DataTableObjectLoad0(false, "ObjectGFor" + lv_vs + lv_va.ToString());
                lp_funcref(lv_object);//用户填写的所有动作
            }
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object组中随机元素。返回指定Object组中的随机Object。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static object HD_ReturnRandomObjectFromObjectGFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_num;
            int lv_a;
            object lv_c = null;
            // Variable Initialization
            lv_num = HD_ReturnObjectNumMax(lp_gs);
            // Implementation
            if ((lv_num >= 1))
            {
                lv_a = RandomInt(1, lv_num);
                lv_c = HD_ReturnObjectFromRegNum(lv_a, lp_gs);
            }
            return lv_c;
        }

        //互动OG_添加Object组到Object组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = HD_ReturnObjectNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = HD_ReturnObjectFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     HD_AddObjectToGroup(#AUTOVAR(var), #AUTOVAR(vsb));
        // }

        /// <summary>
        /// 【MM_函数库】互动OG_添加Object组到Object组。添加一个Object组A的元素到另一个Object组B，相同Object被认为是同一个。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void HD_AddObjectGToObjectG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = HD_ReturnObjectNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            object lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = HD_ReturnObjectFromRegNum(lv_va, lv_vsa);
                HD_AddObjectToGroup(lv_var, lv_vsb);
            }
        }

        //互动OG_从Object组移除Object组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = HD_ReturnObjectNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = HD_ReturnObjectFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     HD_RemoveObject(#AUTOVAR(var), #AUTOVAR(vsb));
        // }

        /// <summary>
        /// 【MM_函数库】互动OG_从Object组移除Object组。将Object组A的元素从Object组B中移除，相同Object被认为是同一个。移除使用了"互动O_移除Object"，同一个存储区（Object组ID）序号重排，移除时该存储区如有其他操作会排队等待。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void HD_ClearObjectGFromObjectG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = HD_ReturnObjectNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            object lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = HD_ReturnObjectFromRegNum(lv_va, lv_vsa);
                HD_RemoveObject(lv_var, lv_vsb);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动OG_移除Object组全部元素。将Object组（Key区）存储的元素全部移除，相同Object被认为是同一个。移除时同一个存储区（Object组ID）序号不进行重排，但该存储区如有其他操作会排队等待。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Object组名称</param>
        public static void HD_RemoveObjectGAll(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag = "";
            int lv_a;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            // Implementation
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_ObjectGroup" + lv_str, true);
            for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
            {
                lv_tag = DataTableIntLoad1(true, (lp_key + "ObjectTag"), lv_a).ToString();
                lv_num -= 1;
                DataTableBoolClear0(true, "HD_IfObjectTag" + lv_str + "_" + lv_tag);
                DataTableStringClear0(true, "HD_ObjectCV" + lv_str + "_" + lv_tag);
                DataTableStringClear0(true, "HD_ObjectState" + lv_str + "_" + lv_tag);
                DataTableIntSave0(true, (lp_key + "ObjectNum"), lv_num);
            }
            ThreadWaitSet(true, "Key_ObjectGroup" + lv_str, false);
        }

        //--------------------------------------------------------------------------------------------------
        // 任意类型组End
        //--------------------------------------------------------------------------------------------------

        #endregion

        #region 二维向量

        //提示：尽可能使用对口类型，以防值类型与引用类型发生转换时拆装箱降低性能

        //--------------------------------------------------------------------------------------------------
        // 二维向量组Start
        //--------------------------------------------------------------------------------------------------

        /// <summary>
        /// 【MM_函数库】互动V_注册Vector标签句柄并返回。为Vector自动设置新的标签句柄，重复时会返回已注册的Vector标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns>返回一个Vector的已注册标签</returns>
        private static int HD_RegVectorTagAndReturn_Int(Vector2F lp_vector)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = DataTableIntLoad0(true, "HD_VectorJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                DataTableIntSave0(true, "HD_VectorJBNum", lv_j);
                DataTableVectorSave0(true, ("HD_Vector_" + lv_j.ToString()), lp_vector);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if (DataTableVectorLoad0(true, ("HD_Vector_" + lv_j.ToString())) == lp_vector)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            DataTableIntSave0(true, "HD_VectorJBNum", lv_j);
                            DataTableVectorSave0(true, ("HD_Vector_" + lv_j.ToString()), lp_vector);
                        }
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector已注册标签句柄
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns>返回一个Vector的已注册标签，错误返回0</returns>
        public static int HD_ReturnVectorTag_Int(Vector2F lp_vector)
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = DataTableIntLoad0(true, "HD_VectorJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if (DataTableVectorLoad0(true, "HD_Vector_" + lv_j.ToString()) == lp_vector)
                {
                    break;
                }
                else
                {
                    if ((lv_j == lv_jBNum))
                    {
                        lv_j = 0;
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动V_注册Vector标签句柄并返回。为Vector自动设置新的标签句柄，重复时会返回已注册的Vector标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns>返回一个Vector的已注册标签</returns>
        private static string HD_RegVectorTagAndReturn(Vector2F lp_vector)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = DataTableIntLoad0(true, "HD_VectorJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                DataTableIntSave0(true, "HD_VectorJBNum", lv_j);
                DataTableVectorSave0(true, ("HD_Vector_" + lv_j.ToString()), lp_vector);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if (DataTableVectorLoad0(true, "HD_Vector_" + lv_j.ToString()) == lp_vector)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            DataTableIntSave0(true, "HD_VectorJBNum", lv_j);
                            DataTableVectorSave0(true, ("HD_Vector_" + lv_j.ToString()), lp_vector);
                        }
                    }
                }
            }
            lv_tag = lv_j.ToString();
            //Console.WriteLine(("Tag：" + lv_tag));
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector已注册标签句柄
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns>返回一个Vector的已注册标签，错误返回""</returns>
        public static string HD_ReturnVectorTag(Vector2F lp_vector)
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag = "";
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = DataTableIntLoad0(true, "HD_VectorJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if (DataTableVectorLoad0(true, "HD_Vector_" + lv_j.ToString()) == lp_vector)
                {
                    lv_tag = lv_j.ToString();
                    break;
                }
            }
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动V_注册Vector(高级)。在指定Key存入Vector，固有状态、自定义值是Vector独一无二的标志（本函数重复注册会刷新），之后可用互动V_"返回Vector注册总数"、"返回Vector序号"、"返回序号对应Vector"、"返回序号对应Vector标签"、"返回Vector自定义值"。Vector组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Vector组转为Key。首次注册时固有状态为true（相当于单位组单位活体），如需另外设置多个标记可使用"互动V_设定Vector状态/自定义值"
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        /// <param name="lp_inherentStats">固有状态</param>
        /// <param name="lp_inherentCustomValue">固有自定义值</param>
        public static void HD_RegVector(Vector2F lp_vector, string lp_key, string lp_inherentStats, string lp_inherentCustomValue)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;

            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_jBNum = DataTableIntLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = HD_RegVectorTagAndReturn(lp_vector);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                DataTableIntSave0(true, (lv_str + "Num"), lv_i);
                DataTableStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                DataTableBoolSave0(true, (("HD_IfVectorTag" + "") + "_" + lv_tagStr), true);
                DataTableBoolSave1(true, ("HD_IfVectorTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if (DataTableIntLoad1(true, lv_str + "Tag", lv_i).ToString() == lv_tagStr)
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                DataTableIntSave0(true, (lv_str + "Num"), lv_i);
                                DataTableStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                DataTableBoolSave0(true, (("HD_IfVectorTag" + "") + "_" + lv_tagStr), true);
                                DataTableBoolSave1(true, ("HD_IfVectorTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            DataTableStringSave0(true, ("HD_VectorState" + "" + "_" + lv_tagStr), lp_inherentStats);
            DataTableStringSave0(true, ("HD_VectorCV" + "" + "_" + lv_tagStr), lp_inherentCustomValue);
        }

        /// <summary>
        /// 【MM_函数库】互动V_注册Vector。在指定Key存入Vector，固有状态、自定义值是Vector独一无二的标志（本函数重复注册不会刷新），之后可用互动V_"返回Vector注册总数"、"返回Vector序号"、"返回序号对应Vector"、"返回Vector自定义值"。Vector组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Vector组转为Key。首次注册时固有状态为true（相当于单位组单位活体），之后只能通过"互动V_注册Vector（高级）"改写，如需另外设置多个标记可使用"互动V_设定Vector状态/自定义值"
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        public static void HD_RegVector_Simple(Vector2F lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;

            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_jBNum = DataTableIntLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = HD_RegVectorTagAndReturn(lp_vector);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                DataTableIntSave0(true, (lv_str + "Num"), lv_i);
                DataTableStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                DataTableBoolSave0(true, (("HD_IfVectorTag" + "") + "_" + lv_tagStr), true);
                DataTableBoolSave1(true, ("HD_IfVectorTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if (DataTableIntLoad1(true, lv_str + "Tag", lv_i).ToString() == lv_tagStr)
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                DataTableIntSave0(true, (lv_str + "Num"), lv_i);
                                DataTableStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                DataTableBoolSave0(true, (("HD_IfVectorTag" + "") + "_" + lv_tagStr), true);
                                DataTableBoolSave1(true, ("HD_IfVectorTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            if ((DataTableBoolKeyExists(true, ("HD_Vector" + "State" + "_" + lv_tag.ToString())) == false))
            {
                DataTableStringSave1(true, (("HD_Vector" + "State")), lv_tag, "true");
            }
        }

        /// <summary>
        /// 【MM_函数库】互动V_注销Vector。用"互动V_注册Vector"到Key，之后可用本函数彻底摧毁注册信息并将序号重排（包括Vector标签有效状态、固有状态及自定义值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动V_设定Vector状态"让Vector状态失效（类似单位组的单位活体状态）。Vector组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Vector组转为Key。本函数无法摧毁用"互动V_设定Vector状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Vector组变量ID时会清空Vector组专用状态
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        public static void HD_DestroyVector(Vector2F lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag;
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_tag = HD_ReturnVectorTag(lp_vector);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                ThreadWaitSet(true, "Key_VectorGroup" + lv_str, true);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((DataTableIntLoad1(true, (lp_key + "VectorTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        DataTableBoolClear0(true, "HD_IfVectorTag_" + lv_tag);
                        DataTableBoolClear0(true, "HD_IfVectorTag" + lv_str + "_" + lv_tag);
                        DataTableVectorClear0(true, "HD_Vector_" + lv_tag);
                        DataTableStringClear0(true, "HD_VectorCV_" + lv_tag);
                        DataTableStringClear0(true, "HD_VectorState_" + lv_tag);
                        DataTableStringClear0(true, "HD_VectorCV" + lv_str + "_" + lv_tag);
                        DataTableStringClear0(true, "HD_VectorState" + lv_str + "_" + lv_tag);
                        DataTableIntSave0(true, (lp_key + "VectorNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = DataTableIntLoad1(true, (lp_key + "VectorTag"), lv_b + 1).ToString();
                            DataTableStringSave1(true, (lp_key + "VectorTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                ThreadWaitSet(true, "Key_VectorGroup" + lv_str, false);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动V_移除Vector。用"互动V_注册Vector"到Key，之后可用本函数仅摧毁Key区注册的信息并将序号重排，用于Vector组或多个键区仅移除Vector（保留Vector标签有效状态、固有值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动V_设定Vector状态"让Vector状态失效（类似单位组的单位活体状态）。Vector组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Vector组转为Key。本函数无法摧毁用"互动V_设定Vector状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Vector组变量ID时会清空Vector组专用状态
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        public static void HD_RemoveVector(Vector2F lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag;
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_tag = HD_ReturnVectorTag(lp_vector);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                ThreadWaitSet(true, "Key_VectorGroup" + lv_str, true);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((DataTableIntLoad1(true, (lp_key + "VectorTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        DataTableBoolClear0(true, "HD_IfVectorTag" + lv_str + "_" + lv_tag);
                        DataTableStringClear0(true, "HD_VectorCV" + lv_str + "_" + lv_tag);
                        DataTableStringClear0(true, "HD_VectorState" + lv_str + "_" + lv_tag);
                        DataTableIntSave0(true, (lp_key + "VectorNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = DataTableIntLoad1(true, (lp_key + "VectorTag"), lv_b + 1).ToString();
                            DataTableStringSave1(true, (lp_key + "VectorTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                ThreadWaitSet(true, "Key_VectorGroup" + lv_str, false);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector注册总数。必须先使用"互动V_注册Vector"才能返回指定Key里的注册总数。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key。
        /// </summary>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        /// <returns></returns>
        public static int HD_ReturnVectorNumMax(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            // Implementation
            return lv_num;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector序号。使用"互动V_注册Vector"后使用本函数可返回Key里的注册序号，Key无元素返回0，Key有元素但对象不在里面则返回-1，Vector标签尚未注册则返回-2。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        /// <returns></returns>
        public static int HD_ReturnVectorNum(Vector2F lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_i;
            string lv_tag;
            int lv_torf;
            // Automatic Variable Declarations
            const int auto_n = 1;
            int auto_i;
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_tag = HD_ReturnVectorTag(lp_vector);
            lv_torf = -1;
            // Implementation
            for (auto_i = 1; auto_i <= auto_n; auto_i += 1)
            {
                if ((lv_tag != null))
                {
                    lv_torf = -2;
                    break;
                }
                if ((lv_num == 0))
                {
                    lv_torf = 0;
                }
                else
                {
                    if ((lv_num >= 1))
                    {
                        auto_ae = lv_num;
                        auto_var = 1;
                        for (; auto_var <= auto_ae; auto_var += 1)
                        {
                            lv_i = auto_var;
                            if ((DataTableIntLoad1(true, (lv_str + "Tag"), lv_i).ToString() == lv_tag))
                            {
                                lv_torf = lv_i;
                                break;
                            }
                        }
                    }
                }
            }
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回序号对应Vector。使用"互动V_注册Vector"后，在参数填入注册序号可返回Vector。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_regNum"></param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        /// <returns>错误时返回new Vector2F(0,0)</returns>
        public static Vector2F HD_ReturnVectorFromRegNum(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            lv_tag = DataTableIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return DataTableVectorLoad0(true, ("HD_Vector_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回句柄标签对应Vector。使用"互动V_注册Vector"后，在参数填入句柄标签（整数）可返回Vector，标签是Vector的句柄。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_tag">句柄标签</param>
        /// <returns>错误时返回new Vector2F(0,0)</returns>
        public static Vector2F HD_ReturnVectorFromTag(int lp_tag)
        {
            // Variable Declarations
            string lv_tag;
            // Variable Initialization
            lv_tag = lp_tag.ToString();
            // Implementation
            return DataTableVectorLoad0(true, ("HD_Vector_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回序号对应Vector标签句柄。使用"互动V_注册Vector"后，在参数填入注册序号可返回Vector标签（字符串）。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        /// <returns></returns>
        public static string HD_ReturnVectorTagFromRegNum_String(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            lv_tag = DataTableIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回序号对应Vector标签句柄。使用"互动V_注册Vector"后，在参数填入注册序号可返回Vector标签（整数）。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        /// <returns></returns>
        public static int HD_ReturnVectorTagFromRegNum_Int(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            lv_tag = DataTableIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return Convert.ToInt32(lv_tag);
        }

        /// <summary>
        /// 【MM_函数库】互动V_设置Vector状态。必须先"注册"获得功能库内部句柄，再使用本函数给Vector设定一个状态值，之后可用"互动V_返回Vector状态"。类型参数用以记录多个不同状态，仅当"类型"参数填Vector组ID转的Vector串时，状态值"true"和"false"是Vector的Vector组专用状态值，用于内部函数筛选Vector状态（相当于单位组单位索引是否有效），其他类型不会干扰系统内部，可随意填写。虽然注销时反向清空注册信息，但用"互动V_设定Vector状态/自定义值"创建的值需要手工填入""来排泄（非大量注销则提升内存量极小，可不管）。注：固有状态值是注册函数赋予的系统内部变量（相当于单位组单位是否活体），只能通过"互动V_注册Vector（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <param name="lp_stats">状态</param>
        public static void HD_SetVectorState(Vector2F lp_vector, string lp_key, string lp_stats)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            lv_tag = HD_RegVectorTagAndReturn(lp_vector);
            // Implementation
            DataTableStringSave0(true, ("HD_VectorState" + lv_str + "_" + lv_tag), lp_stats);
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector状态。使用"互动V_设定Vector状态"后可使用本函数，将本函数参数"类型"设为空时返回固有值。类型参数用以记录多个不同状态，仅当"类型"参数为Vector组ID转的字符串时，返回的状态值"true"和"false"是Vector的Vector组专用状态值，用于内部函数筛选Vector状态（相当于单位组单位索引是否有效）
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <returns></returns>
        public static string HD_ReturnVectorState(Vector2F lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            lv_tag = HD_ReturnVectorTag(lp_vector);
            lv_stats = DataTableStringLoad0(true, ("HD_VectorState" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动V_设置Vector自定义值。必须先"注册"获得功能库内部句柄，再使用本函数设定Vector的自定义值，之后可使用"互动V_返回Vector自定义值"，类型参数用以记录多个不同自定义值。注：固有自定义值是注册函数赋予的系统内部变量，只能通过"互动V_注册Vector（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <param name="lp_customValue">自定义值</param>
        public static void HD_SetVectorCV(Vector2F lp_vector, string lp_key, string lp_customValue)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            lv_tag = HD_RegVectorTagAndReturn(lp_vector);
            // Implementation
            DataTableStringSave0(true, ("HD_VectorCV" + lv_str + "_" + lv_tag), lp_customValue);
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector自定义值。使用"互动V_设定Vector自定义值"后可使用本函数，将本函数参数"类型"设为空时返回固有值，该参数用以记录多个不同自定义值
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <returns></returns>
        public static string HD_ReturnVectorCV(Vector2F lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            lv_tag = HD_ReturnVectorTag(lp_vector);
            lv_customValue = DataTableStringLoad0(true, ("HD_VectorCV" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector固有状态。必须先使用"互动V_注册Vector"才能返回到该值，固有状态是独一无二的标记（相当于单位组单位是否活体）
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns></returns>
        public static string HD_ReturnVectorState_Only(Vector2F lp_vector)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_tag = HD_ReturnVectorTag(lp_vector);
            lv_stats = DataTableStringLoad0(true, ("HD_VectorState" + "" + "_" + lv_tag));
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector固有自定义值。必须先使用"互动V_注册Vector"才能返回到该值，固有值是独一无二的标记
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns></returns>
        public static string HD_ReturnVectorCV_Only(Vector2F lp_vector)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_tag = HD_ReturnVectorTag(lp_vector);
            lv_customValue = DataTableStringLoad0(true, ("HD_VectorCV" + "" + "_" + lv_tag));
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动V_设置Vector的实数标记。必须先"注册"获得功能库内部句柄，再使用本函数让Vector携带一个实数值，之后可使用"互动V_返回Vector的实数标记"。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_realNumTag">实数标记</param>
        public static void HD_SetVectorDouble(Vector2F lp_vector, double lp_realNumTag)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = HD_RegVectorTagAndReturn(lp_vector);
            // Implementation
            DataTableDoubleSave0(true, ("HD_CDDouble_Vector_" + lv_tag), lp_realNumTag);
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector的实数标记。使用"互动V_设定Vector的实数标记"后可使用本函数。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns></returns>
        public static double HD_ReturnVectorDouble(Vector2F lp_vector)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = HD_ReturnVectorTag(lp_vector);
            // Implementation
            return DataTableDoubleLoad0(true, ("HD_CDDouble_Vector_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector标签句柄有效状态。将Vector视作独一无二的个体，标签是它本身，有效状态则类似"单位是否有效"，当使用"互动V_注册Vector"或"互动VG_添加Vector到Vector组"后激活Vector有效状态（值为"true"），除非使用"互动V_注册Vector（高级）"改写，否则直到注销才会摧毁
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns></returns>
        public static bool HD_ReturnIfVectorTag(Vector2F lp_vector)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = HD_ReturnVectorTag(lp_vector);
            // Implementation
            return DataTableBoolLoad0(true, ("HD_IfVectorTag" + "" + "_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector注册状态。使用"互动V_注册Vector"或"互动VG_添加Vector到Vector组"后可使用本函数获取注册Vector在Key中的注册状态，该状态只能注销或从Vector组中移除时清空。Vector组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        /// <returns></returns>
        public static bool HD_ReturnIfVectorTagKey(Vector2F lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            lv_tag = HD_ReturnVectorTag(lp_vector);
            // Implementation
            return DataTableBoolLoad0(true, ("HD_IfVectorTag" + lv_str + "_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动VG_根据自定义值类型将Vector组排序。根据Vector携带的自定义值类型，对指定的Vector组元素进行冒泡排序。Vector组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Vector组名称</param>
        /// <param name="lp_cVStr">自定义值类型</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void HD_VectorGSortCV(string lp_key, string lp_cVStr, bool lp_big)
        {
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            string lv_tagValuestr;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_VectorGroup" + lv_str, true);
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = HD_ReturnVectorTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValuestr = HD_ReturnVectorCV((Vector2F)HD_ReturnVectorFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    DataTableIntSave1(false, "IntStackOutTag", 1, lv_tag);
                    DataTableIntSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < DataTableIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DataTableIntSave1(false, "IntStackOutTag", lv_c, DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    DataTableIntSave1(false, "IntStackOutTagValue", lv_c, DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_c, DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                DataTableIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                DataTableIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > DataTableIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(HD_ReturnVectorTagFromRegNum(lv_b, lp_key))+"值"+IntToString(DataTableIntLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DataTableIntSave1(false, "IntStackOutTag", lv_c, DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DataTableIntSave1(false, "IntStackOutTagValue", lv_c, DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_c, DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                DataTableIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DataTableIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        DataTableIntSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DataTableIntSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = DataTableIntLoad1(true, (lp_key + "VectorTag"), lv_a).ToString(); //原始序号元素
                lv_tag = DataTableIntLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValuestr = HD_ReturnVectorCV((Vector2F)HD_ReturnVectorFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = DataTableIntLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    DataTableIntSave1(true, (lp_key + "VectorTag"), lv_a, lv_tag); //lv_tag放入新序号
                    //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            ThreadWaitSet(true, "Key_VectorGroup" + lv_str, false);
        }

        /// <summary>
        /// 【MM_函数库】互动VG_Vector组排序。对指定的Vector组元素进行冒泡排序（根据元素句柄）。Vector组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Vector组名称</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void HD_VectorGSort(string lp_key, bool lp_big)
        {
            // Automatic Variable Declarations
            // Implementation
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_VectorGroup" + lv_str, true);
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = HD_ReturnVectorTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValue = lv_tag;
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    DataTableIntSave1(false, "IntStackOutTag", 1, lv_tag);
                    DataTableIntSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < DataTableIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DataTableIntSave1(false, "IntStackOutTag", lv_c, DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    DataTableIntSave1(false, "IntStackOutTagValue", lv_c, DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_c, DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                DataTableIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                DataTableIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > DataTableIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(HD_ReturnVectorTagFromRegNum(lv_b, lp_key))+"值"+IntToString(DataTableIntLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DataTableIntSave1(false, "IntStackOutTag", lv_c, DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DataTableIntSave1(false, "IntStackOutTagValue", lv_c, DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_c, DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                DataTableIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DataTableIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        DataTableIntSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DataTableIntSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = DataTableIntLoad1(true, (lp_key + "VectorTag"), lv_a).ToString(); //原始序号元素
                lv_tag = DataTableIntLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValue = lv_tag;
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = DataTableIntLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                                                                                  //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    DataTableIntSave1(true, (lp_key + "VectorTag"), lv_a, lv_tag); //lv_tag放入新序号
                                                                                   //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            ThreadWaitSet(true, "Key_VectorGroup" + lv_str, false);
        }

        /// <summary>
        /// 【MM_函数库】互动VG_设定Vector的Vector组专用状态。给Vector组的Vector设定一个状态值（字符串），之后可用"互动V_返回Vector、互动VG_返回Vector组的Vector状态"。状态值"true"和"false"是Vector的Vector组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效），而本函数可以重设干预，影响函数"互动VG_返回Vector组元素数量（仅检索XX状态）"。与"互动V_设定Vector状态"功能相同，只是状态参数在Vector组中被固定为"Vector组变量的内部ID"。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_vectorGroup"></param>
        /// <param name="lp_groupState"></param>
        public static void HD_SetVectorGState(Vector2F lp_vector, string lp_vectorGroup, string lp_groupState)
        {
            HD_SetVectorState(lp_vector, lp_vectorGroup, lp_groupState);
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector的Vector组专用状态。使用"互动V_设定Vector、互动VG_设定Vector组的Vector状态"后可使用本函数。与"互动V_返回Vector状态"功能相同，只是状态参数在Vector组中被固定为"Vector组变量的内部ID"。状态值"true"和"false"是Vector的Vector组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效）。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_vectorGroup"></param>
        public static void HD_ReturnVectorGState(Vector2F lp_vector, string lp_vectorGroup)
        {
            HD_ReturnVectorState(lp_vector, lp_vectorGroup);
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector组元素序号对应元素。返回Vector组元素序号指定Vector。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static Vector2F HD_ReturnVectorFromVectorGFunc(int lp_regNum, string lp_gs)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_gs + "Vector2F");
            lv_tag = DataTableIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return DataTableVectorLoad0(true, ("HD_Vector_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector组元素总数。返回指定Vector组的元素数量。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HD_ReturnVectorGNumMax(string lp_gs)
        {
            return DataTableIntLoad0(true, lp_gs + "VectorNum");
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector组元素总数（仅检测Vector组专用状态="true"）。返回指定Vector组的元素数量。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HD_ReturnVectorGNumMax_StateTrueFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Vector2F lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HD_ReturnVectorNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (Vector2F)HD_ReturnVectorFromRegNum(lv_a, lp_gs);
                lv_b = HD_ReturnVectorState(lv_c, lp_gs);
                if ((lv_b == "true"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector组元素总数（仅检测Vector组专用状态="false"）。返回指定Vector组的元素数量。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HD_ReturnVectorGNumMax_StateFalseFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Vector2F lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HD_ReturnVectorNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (Vector2F)HD_ReturnVectorFromRegNum(lv_a, lp_gs);
                lv_b = HD_ReturnVectorState(lv_c, lp_gs);
                if ((lv_b == "false"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector组元素总数（仅检测Vector组无效专用状态："false"或""）。返回指定Vector组的元素数量（false、""、null）。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HD_ReturnVectorGNumMax_StateUselessFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Vector2F lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HD_ReturnVectorNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (Vector2F)HD_ReturnVectorFromRegNum(lv_a, lp_gs);
                lv_b = HD_ReturnVectorState(lv_c, lp_gs);
                if (((lv_b == "false") || (lv_b == "") || (lv_b == null)))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector组元素总数（仅检测Vector组指定专用状态）。返回指定Vector组的元素数量。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_State">Vector组专用状态</param>
        /// <returns></returns>
        public static int HD_ReturnVectorGNumMax_StateFunc_Specify(string lp_gs, string lp_State)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Vector2F lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HD_ReturnVectorNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (Vector2F)HD_ReturnVectorFromRegNum(lv_a, lp_gs);
                lv_b = HD_ReturnVectorState(lv_c, lp_gs);
                if ((lv_b == lp_State))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动VG_添加Vector到Vector组。相同Vector被认为是同一个，非高级功能不提供专用状态检查，如果Vector没有设置过Vector组专用状态，那么首次添加到Vector组不会赋予"true"（之后可通过"互动V_设定Vector状态"、"互动VG_设定Vector组的Vector状态"修改）。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HD_AddVectorToGroup_Simple(Vector2F lp_vector, string lp_gs)
        {
            HD_RegVector_Simple(lp_vector, lp_gs);
        }

        /// <summary>
        /// 【MM_函数库】互动VG_添加Vector到Vector组（高级）。相同Vector被认为是同一个，高级功能提供专用状态检查，如果Vector没有设置过Vector组专用状态，那么首次添加到Vector组会赋予"true"（之后可通过"互动V_设定Vector状态"、"互动VG_设定Vector组的Vector状态"修改）。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HD_AddVectorToGroup(Vector2F lp_vector, string lp_gs)
        {
            HD_RegVector_Simple(lp_vector, lp_gs);
            if (DataTableStringKeyExists(true, ("HD_VectorState" + lp_gs + "Vector_" + HD_RegVectorTagAndReturn(lp_vector))) == false)
            {
                DataTableStringSave0(true, ("HD_VectorState" + lp_gs + "Vector_" + HD_RegVectorTagAndReturn(lp_vector)), "true");
                //Console.WriteLine(lp_gs + "=>" + HD_RegVectorTagAndReturn(lp_vector));
            }
        }

        /// <summary>
        /// 【MM_函数库】互动VG_移除Vector组中的元素。使用"互动VG_添加Vector到Vector组"后可使用本函数进行移除元素。移除使用了"互动V_移除Vector"，同一个存储区（Vector组ID）序号重排，移除时该存储区如有其他操作会排队等待。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HD_ClearVectorFromGroup(Vector2F lp_vector, string lp_gs)
        {
            HD_RemoveVector(lp_vector, lp_gs);
        }

        //互动VG_为Vector组中的每个序号
        //GE（星际2的Galaxy Editor）的宏让编辑器保存时自动生成脚本并整合进脚本进行格式调整，C#仅参考需自行编写
        // #AUTOVAR(vs, string) = "#PARAM(group)";//"#PARAM(group)"是与字段、变量名一致的元素组名称，宏去声明string类型名为“Auto随机编号_vs”的自动变量，然后=右侧字符
        // #AUTOVAR(ae) = HD_ReturnVectorNumMax(#AUTOVAR(vs));//宏去声明默认int类型名为“Auto随机编号_ae”的自动变量，然后=右侧字符
        // #INITAUTOVAR(ai,increment)//宏去声明int类型名为“Auto随机编号_ai”的自动变量，用于下面for循环增量（increment是传入参数）
        // #PARAM(var) = #PARAM(s);//#PARAM(var)是传进来的参数，用作“当前被挑选到的元素”（任意变量-整数 lp_var）， #PARAM(s)是传进来的参数用作"开始"（int lp_s）
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #PARAM(var) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #PARAM(var) >= #AUTOVAR(ae)) ) ; #PARAM(var) += #AUTOVAR(ai) ) {
        //     #SUBFUNCS(actions)//代表用户GUI填写的所有动作
        // }

        /// <summary>
        /// 【MM_函数库】互动VG_为Vector组中的每个序号。每次挑选的元素序号会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素序号，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void HD_ForEachVectorNumFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            int lv_ae = HD_ReturnVectorNumMax(lp_gs);
            int lv_var = lp_start;
            int lv_ai = lp_increment;
            for (; (lv_ai >= 0 && lv_var <= lv_ae) || (lv_ai < 0 && lv_var >= lv_ae); lv_var += lv_ai)
            {
                lp_funcref(lv_var);//用户填写的所有动作
            }
        }

        //互动VG_为Vector组中的每个元素
        // #AUTOVAR(vs, string) = "#PARAM(group)";
        // #AUTOVAR(ae) = HD_ReturnVectorNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= #PARAM(s);
        // #INITAUTOVAR(ai,increment)
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     DataTableSave(false, "VectorGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)), HD_ReturnVectorFromRegNum(#AUTOVAR(va),#AUTOVAR(vs)));
        // }
        // #AUTOVAR(va)= #PARAM(s);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #PARAM(var) = DataTableLoad(false, "VectorGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)));
        //     #SUBFUNCS(actions)
        // }

        /// <summary>
        /// 【MM_函数库】互动VG_为Vector组中的每个元素。每次挑选的元素会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void HD_ForEachVectorFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            string lv_vs = lp_gs;
            int lv_ae = HD_ReturnVectorNumMax(lv_vs);
            int lv_va = lp_start;
            int lv_ai = lp_increment;
            Vector2F lv_vector;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                DataTableVectorSave0(false, "VectorGFor" + lv_vs + lv_va.ToString(), (Vector2F)HD_ReturnVectorFromRegNum(lv_va, lv_vs));
            }
            lv_va = lp_start;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                lv_vector = (Vector2F)DataTableVectorLoad0(false, "VectorGFor" + lv_vs + lv_va.ToString());
                lp_funcref(lv_vector);//用户填写的所有动作
            }
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector组中随机元素。返回指定Vector组中的随机Vector。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns>错误时返回new Vector2F(0,0)</returns>
        public static Vector2F HD_ReturnRandomVectorFromVectorGFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_num;
            int lv_a;
            Vector2F lv_c = new Vector2F(0, 0);
            // Variable Initialization
            lv_num = HD_ReturnVectorNumMax(lp_gs);
            // Implementation
            if ((lv_num >= 1))
            {
                lv_a = RandomInt(1, lv_num);
                lv_c = (Vector2F)HD_ReturnVectorFromRegNum(lv_a, lp_gs);
            }
            return lv_c;
        }

        //互动VG_添加Vector组到Vector组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = HD_ReturnVectorNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = HD_ReturnVectorFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     HD_AddVectorToGroup(#AUTOVAR(var), #AUTOVAR(vsb));
        // }


        /// <summary>
        /// 【MM_函数库】互动VG_添加Vector组到Vector组。添加一个Vector组A的元素到另一个Vector组B，相同Vector被认为是同一个。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void HD_AddVectorGToVectorG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = HD_ReturnVectorNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            Vector2F lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = (Vector2F)HD_ReturnVectorFromRegNum(lv_va, lv_vsa);
                HD_AddVectorToGroup(lv_var, lv_vsb);
            }
        }

        //互动VG_从Vector组移除Vector组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = HD_ReturnVectorNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = HD_ReturnVectorFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     HD_RemoveVector(#AUTOVAR(var), #AUTOVAR(vsb));
        // }

        /// <summary>
        /// 【MM_函数库】互动VG_从Vector组移除Vector组。将Vector组A的元素从Vector组B中移除，相同Vector被认为是同一个。移除使用了"互动V_移除Vector"，同一个存储区（Vector组ID）序号重排，移除时该存储区如有其他操作会排队等待。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void HD_ClearVectorGFromVectorG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = HD_ReturnVectorNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            Vector2F lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = (Vector2F)HD_ReturnVectorFromRegNum(lv_va, lv_vsa);
                HD_RemoveVector(lv_var, lv_vsb);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动VG_移除Vector组全部元素。将Vector组（Key区）存储的元素全部移除，相同Vector被认为是同一个。移除时同一个存储区（Vector组ID）序号不进行重排，但该存储区如有其他操作会排队等待。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Vector组名称</param>
        public static void HD_RemoveVectorGAll(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag = "";
            int lv_a;
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            // Implementation
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_VectorGroup" + lv_str, true);
            for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
            {
                lv_tag = DataTableIntLoad1(true, (lp_key + "VectorTag"), lv_a).ToString();
                lv_num -= 1;
                DataTableBoolClear0(true, "HD_IfVectorTag" + lv_str + "_" + lv_tag);
                DataTableStringClear0(true, "HD_VectorCV" + lv_str + "_" + lv_tag);
                DataTableStringClear0(true, "HD_VectorState" + lv_str + "_" + lv_tag);
                DataTableIntSave0(true, (lp_key + "VectorNum"), lv_num);
            }
            ThreadWaitSet(true, "Key_VectorGroup" + lv_str, false);
        }

        //--------------------------------------------------------------------------------------------------
        // 二维向量组End
        //--------------------------------------------------------------------------------------------------

        #endregion

        #region 计时器

        //提示：尽可能使用对口类型，以防值类型与引用类型发生转换时拆装箱降低性能

        //--------------------------------------------------------------------------------------------------
        // 计时器组Start
        //--------------------------------------------------------------------------------------------------

        /// <summary>
        /// 【MM_函数库】互动T_注册Timer标签句柄并返回。为Timer自动设置新的标签句柄，重复时会返回已注册的Timer标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns>返回一个Timer的已注册标签</returns>
        private static int HD_RegTimerTagAndReturn_Int(Timer lp_timer)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = DataTableIntLoad0(true, "HD_TimerJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                DataTableIntSave0(true, "HD_TimerJBNum", lv_j);
                DataTableTimerSave0(true, ("HD_Timer_" + lv_j.ToString()), lp_timer);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if (DataTableTimerLoad0(true, ("HD_Timer_" + lv_j.ToString())) == lp_timer)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            DataTableIntSave0(true, "HD_TimerJBNum", lv_j);
                            DataTableTimerSave0(true, ("HD_Timer_" + lv_j.ToString()), lp_timer);
                        }
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer已注册标签句柄
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns>返回一个Timer的已注册标签，错误返回0</returns>
        public static int HD_ReturnTimerTag_Int(Timer lp_timer)
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = DataTableIntLoad0(true, "HD_TimerJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if (DataTableTimerLoad0(true, "HD_Timer_" + lv_j.ToString()) == lp_timer)
                {
                    break;
                }
                else
                {
                    if ((lv_j == lv_jBNum))
                    {
                        lv_j = 0;
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动T_注册Timer标签句柄并返回。为Timer自动设置新的标签句柄，重复时会返回已注册的Timer标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns>返回一个Timer的已注册标签</returns>
        private static string HD_RegTimerTagAndReturn(Timer lp_timer)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = DataTableIntLoad0(true, "HD_TimerJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                DataTableIntSave0(true, "HD_TimerJBNum", lv_j);
                DataTableTimerSave0(true, ("HD_Timer_" + lv_j.ToString()), lp_timer);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if (DataTableTimerLoad0(true, "HD_Timer_" + lv_j.ToString()) == lp_timer)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            DataTableIntSave0(true, "HD_TimerJBNum", lv_j);
                            DataTableTimerSave0(true, ("HD_Timer_" + lv_j.ToString()), lp_timer);
                        }
                    }
                }
            }
            lv_tag = lv_j.ToString();
            //Console.WriteLine(("Tag：" + lv_tag));
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer已注册标签句柄
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns>返回一个Timer的已注册标签，错误返回""</returns>
        public static string HD_ReturnTimerTag(Timer lp_timer)
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag = "";
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = DataTableIntLoad0(true, "HD_TimerJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if (DataTableTimerLoad0(true, "HD_Timer_" + lv_j.ToString()) == lp_timer)
                {
                    lv_tag = lv_j.ToString();
                    break;
                }
            }
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动T_注册Timer(高级)。在指定Key存入Timer，固有状态、自定义值是Timer独一无二的标志（本函数重复注册会刷新），之后可用互动T_"返回Timer注册总数"、"返回Timer序号"、"返回序号对应Timer"、"返回序号对应Timer标签"、"返回Timer自定义值"。Timer组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Timer组转为Key。首次注册时固有状态为true（相当于单位组单位活体），如需另外设置多个标记可使用"互动T_设定Timer状态/自定义值"
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        /// <param name="lp_inherentStats">固有状态</param>
        /// <param name="lp_inherentCustomValue">固有自定义值</param>
        public static void HD_RegTimer(Timer lp_timer, string lp_key, string lp_inherentStats, string lp_inherentCustomValue)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;

            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_jBNum = DataTableIntLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = HD_RegTimerTagAndReturn(lp_timer);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                DataTableIntSave0(true, (lv_str + "Num"), lv_i);
                DataTableStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                DataTableBoolSave0(true, (("HD_IfTimerTag" + "") + "_" + lv_tagStr), true);
                DataTableBoolSave1(true, ("HD_IfTimerTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if (DataTableIntLoad1(true, lv_str + "Tag", lv_i).ToString() == lv_tagStr)
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                DataTableIntSave0(true, (lv_str + "Num"), lv_i);
                                DataTableStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                DataTableBoolSave0(true, (("HD_IfTimerTag" + "") + "_" + lv_tagStr), true);
                                DataTableBoolSave1(true, ("HD_IfTimerTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            DataTableStringSave0(true, ("HD_TimerState" + "" + "_" + lv_tagStr), lp_inherentStats);
            DataTableStringSave0(true, ("HD_TimerCV" + "" + "_" + lv_tagStr), lp_inherentCustomValue);
        }

        /// <summary>
        /// 【MM_函数库】互动T_注册Timer。在指定Key存入Timer，固有状态、自定义值是Timer独一无二的标志（本函数重复注册不会刷新），之后可用互动T_"返回Timer注册总数"、"返回Timer序号"、"返回序号对应Timer"、"返回Timer自定义值"。Timer组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Timer组转为Key。首次注册时固有状态为true（相当于单位组单位活体），之后只能通过"互动T_注册Timer（高级）"改写，如需另外设置多个标记可使用"互动T_设定Timer状态/自定义值"
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        public static void HD_RegTimer_Simple(Timer lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;

            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_jBNum = DataTableIntLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = HD_RegTimerTagAndReturn(lp_timer);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                DataTableIntSave0(true, (lv_str + "Num"), lv_i);
                DataTableStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                DataTableBoolSave0(true, (("HD_IfTimerTag" + "") + "_" + lv_tagStr), true);
                DataTableBoolSave1(true, ("HD_IfTimerTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if (DataTableIntLoad1(true, lv_str + "Tag", lv_i).ToString() == lv_tagStr)
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                DataTableIntSave0(true, (lv_str + "Num"), lv_i);
                                DataTableStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                DataTableBoolSave0(true, (("HD_IfTimerTag" + "") + "_" + lv_tagStr), true);
                                DataTableBoolSave1(true, ("HD_IfTimerTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            if ((DataTableBoolKeyExists(true, ("HD_Timer" + "State" + "_" + lv_tag.ToString())) == false))
            {
                DataTableStringSave1(true, (("HD_Timer" + "State")), lv_tag, "true");
            }
        }

        /// <summary>
        /// 【MM_函数库】互动T_注销Timer。用"互动T_注册Timer"到Key，之后可用本函数彻底摧毁注册信息并将序号重排（包括Timer标签有效状态、固有状态及自定义值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动T_设定Timer状态"让Timer状态失效（类似单位组的单位活体状态）。Timer组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Timer组转为Key。本函数无法摧毁用"互动T_设定Timer状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Timer组变量ID时会清空Timer组专用状态
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        public static void HD_DestroyTimer(Timer lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag;
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_tag = HD_ReturnTimerTag(lp_timer);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                ThreadWaitSet(true, "Key_TimerGroup" + lv_str, true);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((DataTableIntLoad1(true, (lp_key + "TimerTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        DataTableBoolClear0(true, "HD_IfTimerTag_" + lv_tag);
                        DataTableBoolClear0(true, "HD_IfTimerTag" + lv_str + "_" + lv_tag);
                        DataTableTimerClear0(true, "HD_Timer_" + lv_tag);
                        DataTableStringClear0(true, "HD_TimerCV_" + lv_tag);
                        DataTableStringClear0(true, "HD_TimerState_" + lv_tag);
                        DataTableStringClear0(true, "HD_TimerCV" + lv_str + "_" + lv_tag);
                        DataTableStringClear0(true, "HD_TimerState" + lv_str + "_" + lv_tag);
                        DataTableIntSave0(true, (lp_key + "TimerNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = DataTableIntLoad1(true, (lp_key + "TimerTag"), lv_b + 1).ToString();
                            DataTableStringSave1(true, (lp_key + "TimerTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                ThreadWaitSet(true, "Key_TimerGroup" + lv_str, false);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动T_移除Timer。用"互动T_注册Timer"到Key，之后可用本函数仅摧毁Key区注册的信息并将序号重排，用于Timer组或多个键区仅移除Timer（保留Timer标签有效状态、固有值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动T_设定Timer状态"让Timer状态失效（类似单位组的单位活体状态）。Timer组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Timer组转为Key。本函数无法摧毁用"互动T_设定Timer状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Timer组变量ID时会清空Timer组专用状态
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        public static void HD_RemoveTimer(Timer lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag;
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_tag = HD_ReturnTimerTag(lp_timer);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                ThreadWaitSet(true, "Key_TimerGroup" + lv_str, true);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((DataTableIntLoad1(true, (lp_key + "TimerTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        DataTableBoolClear0(true, "HD_IfTimerTag" + lv_str + "_" + lv_tag);
                        DataTableStringClear0(true, "HD_TimerCV" + lv_str + "_" + lv_tag);
                        DataTableStringClear0(true, "HD_TimerState" + lv_str + "_" + lv_tag);
                        DataTableIntSave0(true, (lp_key + "TimerNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = DataTableIntLoad1(true, (lp_key + "TimerTag"), lv_b + 1).ToString();
                            DataTableStringSave1(true, (lp_key + "TimerTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                ThreadWaitSet(true, "Key_TimerGroup" + lv_str, false);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer注册总数。必须先使用"互动T_注册Timer"才能返回指定Key里的注册总数。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key。
        /// </summary>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        /// <returns></returns>
        public static int HD_ReturnTimerNumMax(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            // Implementation
            return lv_num;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer序号。使用"互动T_注册Timer"后使用本函数可返回Key里的注册序号，Key无元素返回0，Key有元素但对象不在里面则返回-1，Timer标签尚未注册则返回-2。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        /// <returns></returns>
        public static int HD_ReturnTimerNum(Timer lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_i;
            string lv_tag;
            int lv_torf;
            // Automatic Variable Declarations
            const int auto_n = 1;
            int auto_i;
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_tag = HD_ReturnTimerTag(lp_timer);
            lv_torf = -1;
            // Implementation
            for (auto_i = 1; auto_i <= auto_n; auto_i += 1)
            {
                if ((lv_tag != null))
                {
                    lv_torf = -2;
                    break;
                }
                if ((lv_num == 0))
                {
                    lv_torf = 0;
                }
                else
                {
                    if ((lv_num >= 1))
                    {
                        auto_ae = lv_num;
                        auto_var = 1;
                        for (; auto_var <= auto_ae; auto_var += 1)
                        {
                            lv_i = auto_var;
                            if ((DataTableIntLoad1(true, (lv_str + "Tag"), lv_i).ToString() == lv_tag))
                            {
                                lv_torf = lv_i;
                                break;
                            }
                        }
                    }
                }
            }
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回序号对应Timer。使用"互动T_注册Timer"后，在参数填入注册序号可返回Timer。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_regNum"></param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        /// <returns></returns>
        public static Timer HD_ReturnTimerFromRegNum(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = DataTableIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return DataTableTimerLoad0(true, ("HD_Timer_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回句柄标签对应Timer。使用"互动T_注册Timer"后，在参数填入句柄标签（整数）可返回Timer，标签是Timer的句柄。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_tag">句柄标签</param>
        /// <returns></returns>
        public static Timer HD_ReturnTimerFromTag(int lp_tag)
        {
            // Variable Declarations
            string lv_tag;
            // Variable Initialization
            lv_tag = lp_tag.ToString();
            // Implementation
            return DataTableTimerLoad0(true, ("HD_Timer_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回序号对应Timer标签句柄。使用"互动T_注册Timer"后，在参数填入注册序号可返回Timer标签（字符串）。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        /// <returns></returns>
        public static string HD_ReturnTimerTagFromRegNum_String(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = DataTableIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回序号对应Timer标签句柄。使用"互动T_注册Timer"后，在参数填入注册序号可返回Timer标签（整数）。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        /// <returns></returns>
        public static int HD_ReturnTimerTagFromRegNum_Int(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = DataTableIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return Convert.ToInt32(lv_tag);
        }

        /// <summary>
        /// 【MM_函数库】互动T_设置Timer状态。必须先"注册"获得功能库内部句柄，再使用本函数给Timer设定一个状态值，之后可用"互动T_返回Timer状态"。类型参数用以记录多个不同状态，仅当"类型"参数填Timer组ID转的Timer串时，状态值"true"和"false"是Timer的Timer组专用状态值，用于内部函数筛选Timer状态（相当于单位组单位索引是否有效），其他类型不会干扰系统内部，可随意填写。虽然注销时反向清空注册信息，但用"互动T_设定Timer状态/自定义值"创建的值需要手工填入""来排泄（非大量注销则提升内存量极小，可不管）。注：固有状态值是注册函数赋予的系统内部变量（相当于单位组单位是否活体），只能通过"互动T_注册Timer（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <param name="lp_stats">状态</param>
        public static void HD_SetTimerState(Timer lp_timer, string lp_key, string lp_stats)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = HD_RegTimerTagAndReturn(lp_timer);
            // Implementation
            DataTableStringSave0(true, ("HD_TimerState" + lv_str + "_" + lv_tag), lp_stats);
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer状态。使用"互动T_设定Timer状态"后可使用本函数，将本函数参数"类型"设为空时返回固有值。类型参数用以记录多个不同状态，仅当"类型"参数为Timer组ID转的字符串时，返回的状态值"true"和"false"是Timer的Timer组专用状态值，用于内部函数筛选Timer状态（相当于单位组单位索引是否有效）
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <returns></returns>
        public static string HD_ReturnTimerState(Timer lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = HD_ReturnTimerTag(lp_timer);
            lv_stats = DataTableStringLoad0(true, ("HD_TimerState" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动T_设置Timer自定义值。必须先"注册"获得功能库内部句柄，再使用本函数设定Timer的自定义值，之后可使用"互动T_返回Timer自定义值"，类型参数用以记录多个不同自定义值。注：固有自定义值是注册函数赋予的系统内部变量，只能通过"互动T_注册Timer（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <param name="lp_customValue">自定义值</param>
        public static void HD_SetTimerCV(Timer lp_timer, string lp_key, string lp_customValue)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = HD_RegTimerTagAndReturn(lp_timer);
            // Implementation
            DataTableStringSave0(true, ("HD_TimerCV" + lv_str + "_" + lv_tag), lp_customValue);
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer自定义值。使用"互动T_设定Timer自定义值"后可使用本函数，将本函数参数"类型"设为空时返回固有值，该参数用以记录多个不同自定义值
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <returns></returns>
        public static string HD_ReturnTimerCV(Timer lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = HD_ReturnTimerTag(lp_timer);
            lv_customValue = DataTableStringLoad0(true, ("HD_TimerCV" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer固有状态。必须先使用"互动T_注册Timer"才能返回到该值，固有状态是独一无二的标记（相当于单位组单位是否活体）
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns></returns>
        public static string HD_ReturnTimerState_Only(Timer lp_timer)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_tag = HD_ReturnTimerTag(lp_timer);
            lv_stats = DataTableStringLoad0(true, ("HD_TimerState" + "" + "_" + lv_tag));
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer固有自定义值。必须先使用"互动T_注册Timer"才能返回到该值，固有值是独一无二的标记
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns></returns>
        public static string HD_ReturnTimerCV_Only(Timer lp_timer)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_tag = HD_ReturnTimerTag(lp_timer);
            lv_customValue = DataTableStringLoad0(true, ("HD_TimerCV" + "" + "_" + lv_tag));
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动T_设置Timer的实数标记。必须先"注册"获得功能库内部句柄，再使用本函数让Timer携带一个实数值，之后可使用"互动T_返回Timer的实数标记"。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_realNumTag">实数标记</param>
        public static void HD_SetTimerDouble(Timer lp_timer, double lp_realNumTag)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = HD_RegTimerTagAndReturn(lp_timer);
            // Implementation
            DataTableDoubleSave0(true, ("HD_CDDouble_Timer_" + lv_tag), lp_realNumTag);
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer的实数标记。使用"互动T_设定Timer的实数标记"后可使用本函数。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns>错误时返回null</returns>
        public static double HD_ReturnTimerDouble(Timer lp_timer)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = HD_ReturnTimerTag(lp_timer);
            // Implementation
            return DataTableDoubleLoad0(true, ("HD_CDDouble_Timer_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer标签句柄有效状态。将Timer视作独一无二的个体，标签是它本身，有效状态则类似"单位是否有效"，当使用"互动T_注册Timer"或"互动TG_添加Timer到Timer组"后激活Timer有效状态（值为"true"），除非使用"互动T_注册Timer（高级）"改写，否则直到注销才会摧毁
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns>错误时返回null</returns>
        public static bool HD_ReturnIfTimerTag(Timer lp_timer)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = HD_ReturnTimerTag(lp_timer);
            // Implementation
            return DataTableBoolLoad0(true, ("HD_IfTimerTag" + "" + "_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer注册状态。使用"互动T_注册Timer"或"互动TG_添加Timer到Timer组"后可使用本函数获取注册Timer在Key中的注册状态，该状态只能注销或从Timer组中移除时清空。Timer组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        /// <returns>错误时返回null</returns>
        public static bool HD_ReturnIfTimerTagKey(Timer lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = HD_ReturnTimerTag(lp_timer);
            // Implementation
            return DataTableBoolLoad0(true, ("HD_IfTimerTag" + lv_str + "_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动TG_根据自定义值类型将Timer组排序。根据Timer携带的自定义值类型，对指定的Timer组元素进行冒泡排序。Timer组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Timer组名称</param>
        /// <param name="lp_cVStr">自定义值类型</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void HD_TimerGSortCV(string lp_key, string lp_cVStr, bool lp_big)
        {
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            string lv_tagValuestr;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_TimerGroup" + lv_str, true);
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = HD_ReturnTimerTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValuestr = HD_ReturnTimerCV((Timer)HD_ReturnTimerFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    DataTableIntSave1(false, "IntStackOutTag", 1, lv_tag);
                    DataTableIntSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < DataTableIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DataTableIntSave1(false, "IntStackOutTag", lv_c, DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    DataTableIntSave1(false, "IntStackOutTagValue", lv_c, DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_c, DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                DataTableIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                DataTableIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > DataTableIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(HD_ReturnTimerTagFromRegNum(lv_b, lp_key))+"值"+IntToString(DataTableIntLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DataTableIntSave1(false, "IntStackOutTag", lv_c, DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DataTableIntSave1(false, "IntStackOutTagValue", lv_c, DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_c, DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                DataTableIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DataTableIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        DataTableIntSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DataTableIntSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = DataTableIntLoad1(true, (lp_key + "TimerTag"), lv_a).ToString(); //原始序号元素
                lv_tag = DataTableIntLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValuestr = HD_ReturnTimerCV((Timer)HD_ReturnTimerFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = DataTableIntLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    DataTableIntSave1(true, (lp_key + "TimerTag"), lv_a, lv_tag); //lv_tag放入新序号
                    //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            ThreadWaitSet(true, "Key_TimerGroup" + lv_str, false);
        }

        /// <summary>
        /// 【MM_函数库】互动TG_Timer组排序。对指定的Timer组元素进行冒泡排序（根据元素句柄）。Timer组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Timer组名称</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void HD_TimerGSort(string lp_key, bool lp_big)
        {
            // Automatic Variable Declarations
            // Implementation
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_TimerGroup" + lv_str, true);
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = HD_ReturnTimerTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValue = lv_tag;
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    DataTableIntSave1(false, "IntStackOutTag", 1, lv_tag);
                    DataTableIntSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < DataTableIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DataTableIntSave1(false, "IntStackOutTag", lv_c, DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    DataTableIntSave1(false, "IntStackOutTagValue", lv_c, DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_c, DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                DataTableIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                DataTableIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > DataTableIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(HD_ReturnTimerTagFromRegNum(lv_b, lp_key))+"值"+IntToString(DataTableIntLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DataTableIntSave1(false, "IntStackOutTag", lv_c, DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DataTableIntSave1(false, "IntStackOutTagValue", lv_c, DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_c, DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                DataTableIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DataTableIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        DataTableIntSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DataTableIntSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = DataTableIntLoad1(true, (lp_key + "TimerTag"), lv_a).ToString(); //原始序号元素
                lv_tag = DataTableIntLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValue = lv_tag;
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = DataTableIntLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                                                                                  //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    DataTableIntSave1(true, (lp_key + "TimerTag"), lv_a, lv_tag); //lv_tag放入新序号
                                                                                  //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            ThreadWaitSet(true, "Key_TimerGroup" + lv_str, false);
        }

        /// <summary>
        /// 【MM_函数库】互动TG_设定Timer的Timer组专用状态。给Timer组的Timer设定一个状态值（字符串），之后可用"互动T_返回Timer、互动TG_返回Timer组的Timer状态"。状态值"true"和"false"是Timer的Timer组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效），而本函数可以重设干预，影响函数"互动TG_返回Timer组元素数量（仅检索XX状态）"。与"互动T_设定Timer状态"功能相同，只是状态参数在Timer组中被固定为"Timer组变量的内部ID"。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_timerGroup"></param>
        /// <param name="lp_groupState"></param>
        public static void HD_SetTimerGState(Timer lp_timer, string lp_timerGroup, string lp_groupState)
        {
            HD_SetTimerState(lp_timer, lp_timerGroup, lp_groupState);
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer的Timer组专用状态。使用"互动T_设定Timer、互动TG_设定Timer组的Timer状态"后可使用本函数。与"互动T_返回Timer状态"功能相同，只是状态参数在Timer组中被固定为"Timer组变量的内部ID"。状态值"true"和"false"是Timer的Timer组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效）。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_timerGroup"></param>
        public static void HD_ReturnTimerGState(Timer lp_timer, string lp_timerGroup)
        {
            HD_ReturnTimerState(lp_timer, lp_timerGroup);
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer组元素序号对应元素。返回Timer组元素序号指定Timer。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static Timer HD_ReturnTimerFromTimerGFunc(int lp_regNum, string lp_gs)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_gs + "Timer");
            lv_tag = DataTableIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return DataTableTimerLoad0(true, ("HD_Timer_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer组元素总数。返回指定Timer组的元素数量。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HD_ReturnTimerGNumMax(string lp_gs)
        {
            return DataTableIntLoad0(true, lp_gs + "TimerNum");
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer组元素总数（仅检测Timer组专用状态="true"）。返回指定Timer组的元素数量。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HD_ReturnTimerGNumMax_StateTrueFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Timer lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HD_ReturnTimerNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (Timer)HD_ReturnTimerFromRegNum(lv_a, lp_gs);
                lv_b = HD_ReturnTimerState(lv_c, lp_gs);
                if ((lv_b == "true"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer组元素总数（仅检测Timer组专用状态="false"）。返回指定Timer组的元素数量。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HD_ReturnTimerGNumMax_StateFalseFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Timer lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HD_ReturnTimerNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (Timer)HD_ReturnTimerFromRegNum(lv_a, lp_gs);
                lv_b = HD_ReturnTimerState(lv_c, lp_gs);
                if ((lv_b == "false"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer组元素总数（仅检测Timer组无效专用状态："false"或""）。返回指定Timer组的元素数量（false、""、null）。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HD_ReturnTimerGNumMax_StateUselessFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Timer lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HD_ReturnTimerNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (Timer)HD_ReturnTimerFromRegNum(lv_a, lp_gs);
                lv_b = HD_ReturnTimerState(lv_c, lp_gs);
                if (((lv_b == "false") || (lv_b == "") || (lv_b == null)))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer组元素总数（仅检测Timer组指定专用状态）。返回指定Timer组的元素数量。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_State">Timer组专用状态</param>
        /// <returns></returns>
        public static int HD_ReturnTimerGNumMax_StateFunc_Specify(string lp_gs, string lp_State)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Timer lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HD_ReturnTimerNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (Timer)HD_ReturnTimerFromRegNum(lv_a, lp_gs);
                lv_b = HD_ReturnTimerState(lv_c, lp_gs);
                if ((lv_b == lp_State))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动TG_添加Timer到Timer组。相同Timer被认为是同一个，非高级功能不提供专用状态检查，如果Timer没有设置过Timer组专用状态，那么首次添加到Timer组不会赋予"true"（之后可通过"互动T_设定Timer状态"、"互动TG_设定Timer组的Timer状态"修改）。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HD_AddTimerToGroup_Simple(Timer lp_timer, string lp_gs)
        {
            HD_RegTimer_Simple(lp_timer, lp_gs);
        }

        /// <summary>
        /// 【MM_函数库】互动TG_添加Timer到Timer组（高级）。相同Timer被认为是同一个，高级功能提供专用状态检查，如果Timer没有设置过Timer组专用状态，那么首次添加到Timer组会赋予"true"（之后可通过"互动T_设定Timer状态"、"互动TG_设定Timer组的Timer状态"修改）。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HD_AddTimerToGroup(Timer lp_timer, string lp_gs)
        {
            HD_RegTimer_Simple(lp_timer, lp_gs);
            if (DataTableStringKeyExists(true, ("HD_TimerState" + lp_gs + "Timer_" + HD_RegTimerTagAndReturn(lp_timer))) == false)
            {
                DataTableStringSave0(true, ("HD_TimerState" + lp_gs + "Timer_" + HD_RegTimerTagAndReturn(lp_timer)), "true");
                //Console.WriteLine(lp_gs + "=>" + HD_RegTimerTagAndReturn(lp_timer));
            }
        }

        /// <summary>
        /// 【MM_函数库】互动TG_移除Timer组中的元素。使用"互动TG_添加Timer到Timer组"后可使用本函数进行移除元素。移除使用了"互动T_移除Timer"，同一个存储区（Timer组ID）序号重排，移除时该存储区如有其他操作会排队等待。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HD_ClearTimerFromGroup(Timer lp_timer, string lp_gs)
        {
            HD_RemoveTimer(lp_timer, lp_gs);
        }

        //互动TG_为Timer组中的每个序号
        //GE（星际2的Galaxy Editor）的宏让编辑器保存时自动生成脚本并整合进脚本进行格式调整，C#仅参考需自行编写
        // #AUTOVAR(vs, string) = "#PARAM(group)";//"#PARAM(group)"是与字段、变量名一致的元素组名称，宏去声明string类型名为“Auto随机编号_vs”的自动变量，然后=右侧字符
        // #AUTOVAR(ae) = HD_ReturnTimerNumMax(#AUTOVAR(vs));//宏去声明默认int类型名为“Auto随机编号_ae”的自动变量，然后=右侧字符
        // #INITAUTOVAR(ai,increment)//宏去声明int类型名为“Auto随机编号_ai”的自动变量，用于下面for循环增量（increment是传入参数）
        // #PARAM(var) = #PARAM(s);//#PARAM(var)是传进来的参数，用作“当前被挑选到的元素”（任意变量-整数 lp_var）， #PARAM(s)是传进来的参数用作"开始"（int lp_s）
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #PARAM(var) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #PARAM(var) >= #AUTOVAR(ae)) ) ; #PARAM(var) += #AUTOVAR(ai) ) {
        //     #SUBFUNCS(actions)//代表用户GUI填写的所有动作
        // }

        /// <summary>
        /// 【MM_函数库】互动TG_为Timer组中的每个序号。每次挑选的元素序号会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素序号，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void HD_ForEachTimerNumFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            int lv_ae = HD_ReturnTimerNumMax(lp_gs);
            int lv_var = lp_start;
            int lv_ai = lp_increment;
            for (; (lv_ai >= 0 && lv_var <= lv_ae) || (lv_ai < 0 && lv_var >= lv_ae); lv_var += lv_ai)
            {
                lp_funcref(lv_var);//用户填写的所有动作
            }
        }

        //互动TG_为Timer组中的每个元素
        // #AUTOVAR(vs, string) = "#PARAM(group)";
        // #AUTOVAR(ae) = HD_ReturnTimerNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= #PARAM(s);
        // #INITAUTOVAR(ai,increment)
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     DataTableSave(false, "TimerGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)), HD_ReturnTimerFromRegNum(#AUTOVAR(va),#AUTOVAR(vs)));
        // }
        // #AUTOVAR(va)= #PARAM(s);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #PARAM(var) = DataTableLoad(false, "TimerGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)));
        //     #SUBFUNCS(actions)
        // }

        /// <summary>
        /// 【MM_函数库】互动TG_为Timer组中的每个元素。每次挑选的元素会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void HD_ForEachTimerFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            string lv_vs = lp_gs;
            int lv_ae = HD_ReturnTimerNumMax(lv_vs);
            int lv_va = lp_start;
            int lv_ai = lp_increment;
            Timer lv_timer;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                DataTableTimerSave0(false, "TimerGFor" + lv_vs + lv_va.ToString(), (Timer)HD_ReturnTimerFromRegNum(lv_va, lv_vs));
            }
            lv_va = lp_start;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                lv_timer = (Timer)DataTableTimerLoad0(false, "TimerGFor" + lv_vs + lv_va.ToString());
                lp_funcref(lv_timer);//用户填写的所有动作
            }
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer组中随机元素。返回指定Timer组中的随机Timer。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static Timer HD_ReturnRandomTimerFromTimerGFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_num;
            int lv_a;
            Timer lv_c = null;
            // Variable Initialization
            lv_num = HD_ReturnTimerNumMax(lp_gs);
            // Implementation
            if ((lv_num >= 1))
            {
                lv_a = RandomInt(1, lv_num);
                lv_c = (Timer)HD_ReturnTimerFromRegNum(lv_a, lp_gs);
            }
            return lv_c;
        }

        //互动TG_添加Timer组到Timer组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = HD_ReturnTimerNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = HD_ReturnTimerFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     HD_AddTimerToGroup(#AUTOVAR(var), #AUTOVAR(vsb));
        // }


        /// <summary>
        /// 【MM_函数库】互动TG_添加Timer组到Timer组。添加一个Timer组A的元素到另一个Timer组B，相同Timer被认为是同一个。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void HD_AddTimerGToTimerG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = HD_ReturnTimerNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            Timer lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = (Timer)HD_ReturnTimerFromRegNum(lv_va, lv_vsa);
                HD_AddTimerToGroup(lv_var, lv_vsb);
            }
        }

        //互动TG_从Timer组移除Timer组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = HD_ReturnTimerNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = HD_ReturnTimerFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     HD_RemoveTimer(#AUTOVAR(var), #AUTOVAR(vsb));
        // }

        /// <summary>
        /// 【MM_函数库】互动TG_从Timer组移除Timer组。将Timer组A的元素从Timer组B中移除，相同Timer被认为是同一个。移除使用了"互动T_移除Timer"，同一个存储区（Timer组ID）序号重排，移除时该存储区如有其他操作会排队等待。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void HD_ClearTimerGFromTimerG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = HD_ReturnTimerNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            Timer lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = (Timer)HD_ReturnTimerFromRegNum(lv_va, lv_vsa);
                HD_RemoveTimer(lv_var, lv_vsb);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动TG_移除Timer组全部元素。将Timer组（Key区）存储的元素全部移除，相同Timer被认为是同一个。移除时同一个存储区（Timer组ID）序号不进行重排，但该存储区如有其他操作会排队等待。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Timer组名称</param>
        public static void HD_RemoveTimerGAll(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag = "";
            int lv_a;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            // Implementation
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_TimerGroup" + lv_str, true);
            for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
            {
                lv_tag = DataTableIntLoad1(true, (lp_key + "TimerTag"), lv_a).ToString();
                lv_num -= 1;
                DataTableBoolClear0(true, "HD_IfTimerTag" + lv_str + "_" + lv_tag);
                DataTableStringClear0(true, "HD_TimerCV" + lv_str + "_" + lv_tag);
                DataTableStringClear0(true, "HD_TimerState" + lv_str + "_" + lv_tag);
                DataTableIntSave0(true, (lp_key + "TimerNum"), lv_num);
            }
            ThreadWaitSet(true, "Key_TimerGroup" + lv_str, false);
        }

        //--------------------------------------------------------------------------------------------------
        // 计时器组End
        //--------------------------------------------------------------------------------------------------

        #endregion

        #region 字符串

        //提示：尽可能使用对口类型，以防值类型与引用类型发生转换时拆装箱降低性能

        //--------------------------------------------------------------------------------------------------
        // 字符串组Start
        //--------------------------------------------------------------------------------------------------

        /// <summary>
        /// 【MM_函数库】互动S_注册String标签句柄并返回。为String自动设置新的标签句柄，重复时会返回已注册的String标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns>返回一个String的已注册标签</returns>
        private static int HD_RegStringTagAndReturn_Int(string lp_timer)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = DataTableIntLoad0(true, "HD_StringJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                DataTableIntSave0(true, "HD_StringJBNum", lv_j);
                DataTableStringSave0(true, ("HD_String_" + lv_j.ToString()), lp_timer);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if (DataTableStringLoad0(true, ("HD_String_" + lv_j.ToString())) == lp_timer)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            DataTableIntSave0(true, "HD_StringJBNum", lv_j);
                            DataTableStringSave0(true, ("HD_String_" + lv_j.ToString()), lp_timer);
                        }
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String已注册标签句柄
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns>返回一个String的已注册标签，错误返回0</returns>
        public static int HD_ReturnStringTag_Int(string lp_timer)
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = DataTableIntLoad0(true, "HD_StringJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if (DataTableStringLoad0(true, "HD_String_" + lv_j.ToString()) == lp_timer)
                {
                    break;
                }
                else
                {
                    if ((lv_j == lv_jBNum))
                    {
                        lv_j = 0;
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动S_注册String标签句柄并返回。为String自动设置新的标签句柄，重复时会返回已注册的String标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns>返回一个String的已注册标签</returns>
        private static string HD_RegStringTagAndReturn(string lp_timer)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = DataTableIntLoad0(true, "HD_StringJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                DataTableIntSave0(true, "HD_StringJBNum", lv_j);
                DataTableStringSave0(true, ("HD_String_" + lv_j.ToString()), lp_timer);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if (DataTableStringLoad0(true, "HD_String_" + lv_j.ToString()) == lp_timer)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            DataTableIntSave0(true, "HD_StringJBNum", lv_j);
                            DataTableStringSave0(true, ("HD_String_" + lv_j.ToString()), lp_timer);
                        }
                    }
                }
            }
            lv_tag = lv_j.ToString();
            //Console.WriteLine(("Tag：" + lv_tag));
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String已注册标签句柄
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns>返回一个String的已注册标签，错误返回""</returns>
        public static string HD_ReturnStringTag(string lp_timer)
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag = "";
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = DataTableIntLoad0(true, "HD_StringJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if (DataTableStringLoad0(true, "HD_String_" + lv_j.ToString()) == lp_timer)
                {
                    lv_tag = lv_j.ToString();
                    break;
                }
            }
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动S_注册String(高级)。在指定Key存入String，固有状态、自定义值是String独一无二的标志（本函数重复注册会刷新），之后可用互动S_"返回String注册总数"、"返回String序号"、"返回序号对应String"、"返回序号对应String标签"、"返回String自定义值"。String组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将String组转为Key。首次注册时固有状态为true（相当于单位组单位活体），如需另外设置多个标记可使用"互动S_设定String状态/自定义值"
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        /// <param name="lp_inherentStats">固有状态</param>
        /// <param name="lp_inherentCustomValue">固有自定义值</param>
        public static void HD_RegString(string lp_timer, string lp_key, string lp_inherentStats, string lp_inherentCustomValue)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;

            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_jBNum = DataTableIntLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = HD_RegStringTagAndReturn(lp_timer);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                DataTableIntSave0(true, (lv_str + "Num"), lv_i);
                DataTableStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                DataTableBoolSave0(true, (("HD_IfStringTag" + "") + "_" + lv_tagStr), true);
                DataTableBoolSave1(true, ("HD_IfStringTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if (DataTableIntLoad1(true, lv_str + "Tag", lv_i).ToString() == lv_tagStr)
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                DataTableIntSave0(true, (lv_str + "Num"), lv_i);
                                DataTableStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                DataTableBoolSave0(true, (("HD_IfStringTag" + "") + "_" + lv_tagStr), true);
                                DataTableBoolSave1(true, ("HD_IfStringTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            DataTableStringSave0(true, ("HD_StringState" + "" + "_" + lv_tagStr), lp_inherentStats);
            DataTableStringSave0(true, ("HD_StringCV" + "" + "_" + lv_tagStr), lp_inherentCustomValue);
        }

        /// <summary>
        /// 【MM_函数库】互动S_注册String。在指定Key存入String，固有状态、自定义值是String独一无二的标志（本函数重复注册不会刷新），之后可用互动S_"返回String注册总数"、"返回String序号"、"返回序号对应String"、"返回String自定义值"。String组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将String组转为Key。首次注册时固有状态为true（相当于单位组单位活体），之后只能通过"互动S_注册String（高级）"改写，如需另外设置多个标记可使用"互动S_设定String状态/自定义值"
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        public static void HD_RegString_Simple(string lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;

            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_jBNum = DataTableIntLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = HD_RegStringTagAndReturn(lp_timer);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                DataTableIntSave0(true, (lv_str + "Num"), lv_i);
                DataTableStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                DataTableBoolSave0(true, (("HD_IfStringTag" + "") + "_" + lv_tagStr), true);
                DataTableBoolSave1(true, ("HD_IfStringTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if (DataTableIntLoad1(true, lv_str + "Tag", lv_i).ToString() == lv_tagStr)
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                DataTableIntSave0(true, (lv_str + "Num"), lv_i);
                                DataTableStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                DataTableBoolSave0(true, (("HD_IfStringTag" + "") + "_" + lv_tagStr), true);
                                DataTableBoolSave1(true, ("HD_IfStringTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            if ((DataTableBoolKeyExists(true, ("HD_String" + "State" + "_" + lv_tag.ToString())) == false))
            {
                DataTableStringSave1(true, (("HD_String" + "State")), lv_tag, "true");
            }
        }

        /// <summary>
        /// 【MM_函数库】互动S_注销String。用"互动S_注册String"到Key，之后可用本函数彻底摧毁注册信息并将序号重排（包括String标签有效状态、固有状态及自定义值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动S_设定String状态"让String状态失效（类似单位组的单位活体状态）。String组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将String组转为Key。本函数无法摧毁用"互动S_设定String状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填String组变量ID时会清空String组专用状态
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        public static void HD_DestroyString(string lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag;
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_tag = HD_ReturnStringTag(lp_timer);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                ThreadWaitSet(true, "Key_StringGroup" + lv_str, true);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((DataTableIntLoad1(true, (lp_key + "StringTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        DataTableBoolClear0(true, "HD_IfStringTag_" + lv_tag);
                        DataTableBoolClear0(true, "HD_IfStringTag" + lv_str + "_" + lv_tag);
                        DataTableStringClear0(true, "HD_String_" + lv_tag);
                        DataTableStringClear0(true, "HD_StringCV_" + lv_tag);
                        DataTableStringClear0(true, "HD_StringState_" + lv_tag);
                        DataTableStringClear0(true, "HD_StringCV" + lv_str + "_" + lv_tag);
                        DataTableStringClear0(true, "HD_StringState" + lv_str + "_" + lv_tag);
                        DataTableIntSave0(true, (lp_key + "StringNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = DataTableIntLoad1(true, (lp_key + "StringTag"), lv_b + 1).ToString();
                            DataTableStringSave1(true, (lp_key + "StringTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                ThreadWaitSet(true, "Key_StringGroup" + lv_str, false);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动S_移除String。用"互动S_注册String"到Key，之后可用本函数仅摧毁Key区注册的信息并将序号重排，用于String组或多个键区仅移除String（保留String标签有效状态、固有值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动S_设定String状态"让String状态失效（类似单位组的单位活体状态）。String组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将String组转为Key。本函数无法摧毁用"互动S_设定String状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填String组变量ID时会清空String组专用状态
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        public static void HD_RemoveString(string lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag;
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_tag = HD_ReturnStringTag(lp_timer);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                ThreadWaitSet(true, "Key_StringGroup" + lv_str, true);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((DataTableIntLoad1(true, (lp_key + "StringTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        DataTableBoolClear0(true, "HD_IfStringTag" + lv_str + "_" + lv_tag);
                        DataTableStringClear0(true, "HD_StringCV" + lv_str + "_" + lv_tag);
                        DataTableStringClear0(true, "HD_StringState" + lv_str + "_" + lv_tag);
                        DataTableIntSave0(true, (lp_key + "StringNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = DataTableIntLoad1(true, (lp_key + "StringTag"), lv_b + 1).ToString();
                            DataTableStringSave1(true, (lp_key + "StringTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                ThreadWaitSet(true, "Key_StringGroup" + lv_str, false);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String注册总数。必须先使用"互动S_注册String"才能返回指定Key里的注册总数。String组使用时，可用"获取变量的内部名称"将String组转为Key。
        /// </summary>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        /// <returns></returns>
        public static int HD_ReturnStringNumMax(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            // Implementation
            return lv_num;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String序号。使用"互动S_注册String"后使用本函数可返回Key里的注册序号，Key无元素返回0，Key有元素但对象不在里面则返回-1，String标签尚未注册则返回-2。String组使用时，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        /// <returns></returns>
        public static int HD_ReturnStringNum(string lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_i;
            string lv_tag;
            int lv_torf;
            // Automatic Variable Declarations
            const int auto_n = 1;
            int auto_i;
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_tag = HD_ReturnStringTag(lp_timer);
            lv_torf = -1;
            // Implementation
            for (auto_i = 1; auto_i <= auto_n; auto_i += 1)
            {
                if ((lv_tag != null))
                {
                    lv_torf = -2;
                    break;
                }
                if ((lv_num == 0))
                {
                    lv_torf = 0;
                }
                else
                {
                    if ((lv_num >= 1))
                    {
                        auto_ae = lv_num;
                        auto_var = 1;
                        for (; auto_var <= auto_ae; auto_var += 1)
                        {
                            lv_i = auto_var;
                            if ((DataTableIntLoad1(true, (lv_str + "Tag"), lv_i).ToString() == lv_tag))
                            {
                                lv_torf = lv_i;
                                break;
                            }
                        }
                    }
                }
            }
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回序号对应String。使用"互动S_注册String"后，在参数填入注册序号可返回String。String组使用时，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_regNum"></param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        /// <returns></returns>
        public static string HD_ReturnStringFromRegNum(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = DataTableIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return DataTableStringLoad0(true, ("HD_String_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回句柄标签对应String。使用"互动S_注册String"后，在参数填入句柄标签（整数）可返回String，标签是String的句柄。String组使用时，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_tag">句柄标签</param>
        /// <returns></returns>
        public static string HD_ReturnStringFromTag(int lp_tag)
        {
            // Variable Declarations
            string lv_tag;
            // Variable Initialization
            lv_tag = lp_tag.ToString();
            // Implementation
            return DataTableStringLoad0(true, ("HD_String_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回序号对应String标签句柄。使用"互动S_注册String"后，在参数填入注册序号可返回String标签（字符串）。String组使用时，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        /// <returns></returns>
        public static string HD_ReturnStringTagFromRegNum_String(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = DataTableIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回序号对应String标签句柄。使用"互动S_注册String"后，在参数填入注册序号可返回String标签（整数）。String组使用时，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        /// <returns></returns>
        public static int HD_ReturnStringTagFromRegNum_Int(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = DataTableIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return Convert.ToInt32(lv_tag);
        }

        /// <summary>
        /// 【MM_函数库】互动S_设置String状态。必须先"注册"获得功能库内部句柄，再使用本函数给String设定一个状态值，之后可用"互动S_返回String状态"。类型参数用以记录多个不同状态，仅当"类型"参数填String组ID转的String串时，状态值"true"和"false"是String的String组专用状态值，用于内部函数筛选String状态（相当于单位组单位索引是否有效），其他类型不会干扰系统内部，可随意填写。虽然注销时反向清空注册信息，但用"互动S_设定String状态/自定义值"创建的值需要手工填入""来排泄（非大量注销则提升内存量极小，可不管）。注：固有状态值是注册函数赋予的系统内部变量（相当于单位组单位是否活体），只能通过"互动S_注册String（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <param name="lp_stats">状态</param>
        public static void HD_SetStringState(string lp_timer, string lp_key, string lp_stats)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = HD_RegStringTagAndReturn(lp_timer);
            // Implementation
            DataTableStringSave0(true, ("HD_StringState" + lv_str + "_" + lv_tag), lp_stats);
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String状态。使用"互动S_设定String状态"后可使用本函数，将本函数参数"类型"设为空时返回固有值。类型参数用以记录多个不同状态，仅当"类型"参数为String组ID转的字符串时，返回的状态值"true"和"false"是String的String组专用状态值，用于内部函数筛选String状态（相当于单位组单位索引是否有效）
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <returns></returns>
        public static string HD_ReturnStringState(string lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = HD_ReturnStringTag(lp_timer);
            lv_stats = DataTableStringLoad0(true, ("HD_StringState" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动S_设置String自定义值。必须先"注册"获得功能库内部句柄，再使用本函数设定String的自定义值，之后可使用"互动S_返回String自定义值"，类型参数用以记录多个不同自定义值。注：固有自定义值是注册函数赋予的系统内部变量，只能通过"互动S_注册String（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <param name="lp_customValue">自定义值</param>
        public static void HD_SetStringCV(string lp_timer, string lp_key, string lp_customValue)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = HD_RegStringTagAndReturn(lp_timer);
            // Implementation
            DataTableStringSave0(true, ("HD_StringCV" + lv_str + "_" + lv_tag), lp_customValue);
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String自定义值。使用"互动S_设定String自定义值"后可使用本函数，将本函数参数"类型"设为空时返回固有值，该参数用以记录多个不同自定义值
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <returns></returns>
        public static string HD_ReturnStringCV(string lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = HD_ReturnStringTag(lp_timer);
            lv_customValue = DataTableStringLoad0(true, ("HD_StringCV" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String固有状态。必须先使用"互动S_注册String"才能返回到该值，固有状态是独一无二的标记（相当于单位组单位是否活体）
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns></returns>
        public static string HD_ReturnStringState_Only(string lp_timer)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_tag = HD_ReturnStringTag(lp_timer);
            lv_stats = DataTableStringLoad0(true, ("HD_StringState" + "" + "_" + lv_tag));
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String固有自定义值。必须先使用"互动S_注册String"才能返回到该值，固有值是独一无二的标记
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns></returns>
        public static string HD_ReturnStringCV_Only(string lp_timer)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_tag = HD_ReturnStringTag(lp_timer);
            lv_customValue = DataTableStringLoad0(true, ("HD_StringCV" + "" + "_" + lv_tag));
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动S_设置String的实数标记。必须先"注册"获得功能库内部句柄，再使用本函数让String携带一个实数值，之后可使用"互动S_返回String的实数标记"。String组使用时，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_realNumTag">实数标记</param>
        public static void HD_SetStringDouble(string lp_timer, double lp_realNumTag)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = HD_RegStringTagAndReturn(lp_timer);
            // Implementation
            DataTableDoubleSave0(true, ("HD_CDDouble_String_" + lv_tag), lp_realNumTag);
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String的实数标记。使用"互动S_设定String的实数标记"后可使用本函数。String组使用时，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns></returns>
        public static double HD_ReturnStringDouble(string lp_timer)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = HD_ReturnStringTag(lp_timer);
            // Implementation
            return DataTableDoubleLoad0(true, ("HD_CDDouble_String_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String标签句柄有效状态。将String视作独一无二的个体，标签是它本身，有效状态则类似"单位是否有效"，当使用"互动S_注册String"或"互动SG_添加String到String组"后激活String有效状态（值为"true"），除非使用"互动S_注册String（高级）"改写，否则直到注销才会摧毁
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns></returns>
        public static bool HD_ReturnIfStringTag(string lp_timer)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = HD_ReturnStringTag(lp_timer);
            // Implementation
            return DataTableBoolLoad0(true, ("HD_IfStringTag" + "" + "_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String注册状态。使用"互动S_注册String"或"互动SG_添加String到String组"后可使用本函数获取注册String在Key中的注册状态，该状态只能注销或从String组中移除时清空。String组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        /// <returns></returns>
        public static bool HD_ReturnIfStringTagKey(string lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = HD_ReturnStringTag(lp_timer);
            // Implementation
            return DataTableBoolLoad0(true, ("HD_IfStringTag" + lv_str + "_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动SG_根据自定义值类型将String组排序。根据String携带的自定义值类型，对指定的String组元素进行冒泡排序。String组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填String组名称</param>
        /// <param name="lp_cVStr">自定义值类型</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void HD_StringGSortCV(string lp_key, string lp_cVStr, bool lp_big)
        {
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            string lv_tagValuestr;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "String");
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_StringGroup" + lv_str, true);
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = HD_ReturnStringTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValuestr = HD_ReturnStringCV((string)HD_ReturnStringFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    DataTableIntSave1(false, "IntStackOutTag", 1, lv_tag);
                    DataTableIntSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < DataTableIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DataTableIntSave1(false, "IntStackOutTag", lv_c, DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    DataTableIntSave1(false, "IntStackOutTagValue", lv_c, DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_c, DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                DataTableIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                DataTableIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > DataTableIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(HD_ReturnStringTagFromRegNum(lv_b, lp_key))+"值"+IntToString(DataTableIntLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DataTableIntSave1(false, "IntStackOutTag", lv_c, DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DataTableIntSave1(false, "IntStackOutTagValue", lv_c, DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_c, DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                DataTableIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DataTableIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        DataTableIntSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DataTableIntSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = DataTableIntLoad1(true, (lp_key + "StringTag"), lv_a).ToString(); //原始序号元素
                lv_tag = DataTableIntLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValuestr = HD_ReturnStringCV((string)HD_ReturnStringFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = DataTableIntLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    DataTableIntSave1(true, (lp_key + "StringTag"), lv_a, lv_tag); //lv_tag放入新序号
                    //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            ThreadWaitSet(true, "Key_StringGroup" + lv_str, false);
        }

        /// <summary>
        /// 【MM_函数库】互动SG_String组排序。对指定的String组元素进行冒泡排序（根据元素句柄）。String组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填String组名称</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void HD_StringGSort(string lp_key, bool lp_big)
        {
            // Automatic Variable Declarations
            // Implementation
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "String");
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_StringGroup" + lv_str, true);
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = HD_ReturnStringTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValue = lv_tag;
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    DataTableIntSave1(false, "IntStackOutTag", 1, lv_tag);
                    DataTableIntSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < DataTableIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DataTableIntSave1(false, "IntStackOutTag", lv_c, DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    DataTableIntSave1(false, "IntStackOutTagValue", lv_c, DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_c, DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                DataTableIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                DataTableIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > DataTableIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(HD_ReturnStringTagFromRegNum(lv_b, lp_key))+"值"+IntToString(DataTableIntLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DataTableIntSave1(false, "IntStackOutTag", lv_c, DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DataTableIntSave1(false, "IntStackOutTagValue", lv_c, DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_c, DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                DataTableIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DataTableIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        DataTableIntSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DataTableIntSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = DataTableIntLoad1(true, (lp_key + "StringTag"), lv_a).ToString(); //原始序号元素
                lv_tag = DataTableIntLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValue = lv_tag;
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = DataTableIntLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                                                                                  //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    DataTableIntSave1(true, (lp_key + "StringTag"), lv_a, lv_tag); //lv_tag放入新序号
                                                                                   //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            ThreadWaitSet(true, "Key_StringGroup" + lv_str, false);
        }

        /// <summary>
        /// 【MM_函数库】互动SG_设定String的String组专用状态。给String组的String设定一个状态值（字符串），之后可用"互动S_返回String、互动SG_返回String组的String状态"。状态值"true"和"false"是String的String组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效），而本函数可以重设干预，影响函数"互动SG_返回String组元素数量（仅检索XX状态）"。与"互动S_设定String状态"功能相同，只是状态参数在String组中被固定为"String组变量的内部ID"。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_timerGroup"></param>
        /// <param name="lp_groupState"></param>
        public static void HD_SetStringGState(string lp_timer, string lp_timerGroup, string lp_groupState)
        {
            HD_SetStringState(lp_timer, lp_timerGroup, lp_groupState);
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String的String组专用状态。使用"互动S_设定String、互动SG_设定String组的String状态"后可使用本函数。与"互动S_返回String状态"功能相同，只是状态参数在String组中被固定为"String组变量的内部ID"。状态值"true"和"false"是String的String组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效）。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_timerGroup"></param>
        public static void HD_ReturnStringGState(string lp_timer, string lp_timerGroup)
        {
            HD_ReturnStringState(lp_timer, lp_timerGroup);
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String组元素序号对应元素。返回String组元素序号指定String。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static string HD_ReturnStringFromStringGFunc(int lp_regNum, string lp_gs)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_gs + "String");
            lv_tag = DataTableIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return DataTableStringLoad0(true, ("HD_String_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String组元素总数。返回指定String组的元素数量。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HD_ReturnStringGNumMax(string lp_gs)
        {
            return DataTableIntLoad0(true, lp_gs + "StringNum");
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String组元素总数（仅检测String组专用状态="true"）。返回指定String组的元素数量。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HD_ReturnStringGNumMax_StateTrueFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            string lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HD_ReturnStringNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (string)HD_ReturnStringFromRegNum(lv_a, lp_gs);
                lv_b = HD_ReturnStringState(lv_c, lp_gs);
                if ((lv_b == "true"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String组元素总数（仅检测String组专用状态="false"）。返回指定String组的元素数量。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HD_ReturnStringGNumMax_StateFalseFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            string lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HD_ReturnStringNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (string)HD_ReturnStringFromRegNum(lv_a, lp_gs);
                lv_b = HD_ReturnStringState(lv_c, lp_gs);
                if ((lv_b == "false"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String组元素总数（仅检测String组无效专用状态："false"或""）。返回指定String组的元素数量（false、""、null）。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HD_ReturnStringGNumMax_StateUselessFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            string lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HD_ReturnStringNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (string)HD_ReturnStringFromRegNum(lv_a, lp_gs);
                lv_b = HD_ReturnStringState(lv_c, lp_gs);
                if (((lv_b == "false") || (lv_b == "") || (lv_b == null)))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String组元素总数（仅检测String组指定专用状态）。返回指定String组的元素数量。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_State">String组专用状态</param>
        /// <returns></returns>
        public static int HD_ReturnStringGNumMax_StateFunc_Specify(string lp_gs, string lp_State)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            string lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HD_ReturnStringNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (string)HD_ReturnStringFromRegNum(lv_a, lp_gs);
                lv_b = HD_ReturnStringState(lv_c, lp_gs);
                if ((lv_b == lp_State))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动SG_添加String到String组。相同String被认为是同一个，非高级功能不提供专用状态检查，如果String没有设置过String组专用状态，那么首次添加到String组不会赋予"true"（之后可通过"互动S_设定String状态"、"互动SG_设定String组的String状态"修改）。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HD_AddStringToGroup_Simple(string lp_timer, string lp_gs)
        {
            HD_RegString_Simple(lp_timer, lp_gs);
        }

        /// <summary>
        /// 【MM_函数库】互动SG_添加String到String组（高级）。相同String被认为是同一个，高级功能提供专用状态检查，如果String没有设置过String组专用状态，那么首次添加到String组会赋予"true"（之后可通过"互动S_设定String状态"、"互动SG_设定String组的String状态"修改）。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HD_AddStringToGroup(string lp_timer, string lp_gs)
        {
            HD_RegString_Simple(lp_timer, lp_gs);
            if (DataTableStringKeyExists(true, ("HD_StringState" + lp_gs + "String_" + HD_RegStringTagAndReturn(lp_timer))) == false)
            {
                DataTableStringSave0(true, ("HD_StringState" + lp_gs + "String_" + HD_RegStringTagAndReturn(lp_timer)), "true");
                //Console.WriteLine(lp_gs + "=>" + HD_RegStringTagAndReturn(lp_timer));
            }
        }

        /// <summary>
        /// 【MM_函数库】互动SG_移除String组中的元素。使用"互动SG_添加String到String组"后可使用本函数进行移除元素。移除使用了"互动S_移除String"，同一个存储区（String组ID）序号重排，移除时该存储区如有其他操作会排队等待。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HD_ClearStringFromGroup(string lp_timer, string lp_gs)
        {
            HD_RemoveString(lp_timer, lp_gs);
        }

        //互动SG_为String组中的每个序号
        //GE（星际2的Galaxy Editor）的宏让编辑器保存时自动生成脚本并整合进脚本进行格式调整，C#仅参考需自行编写
        // #AUTOVAR(vs, string) = "#PARAM(group)";//"#PARAM(group)"是与字段、变量名一致的元素组名称，宏去声明string类型名为“Auto随机编号_vs”的自动变量，然后=右侧字符
        // #AUTOVAR(ae) = HD_ReturnStringNumMax(#AUTOVAR(vs));//宏去声明默认int类型名为“Auto随机编号_ae”的自动变量，然后=右侧字符
        // #INITAUTOVAR(ai,increment)//宏去声明int类型名为“Auto随机编号_ai”的自动变量，用于下面for循环增量（increment是传入参数）
        // #PARAM(var) = #PARAM(s);//#PARAM(var)是传进来的参数，用作“当前被挑选到的元素”（任意变量-整数 lp_var）， #PARAM(s)是传进来的参数用作"开始"（int lp_s）
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #PARAM(var) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #PARAM(var) >= #AUTOVAR(ae)) ) ; #PARAM(var) += #AUTOVAR(ai) ) {
        //     #SUBFUNCS(actions)//代表用户GUI填写的所有动作
        // }

        /// <summary>
        /// 【MM_函数库】互动SG_为String组中的每个序号。每次挑选的元素序号会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素序号，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void HD_ForEachStringNumFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            int lv_ae = HD_ReturnStringNumMax(lp_gs);
            int lv_var = lp_start;
            int lv_ai = lp_increment;
            for (; (lv_ai >= 0 && lv_var <= lv_ae) || (lv_ai < 0 && lv_var >= lv_ae); lv_var += lv_ai)
            {
                lp_funcref(lv_var);//用户填写的所有动作
            }
        }

        //互动SG_为String组中的每个元素
        // #AUTOVAR(vs, string) = "#PARAM(group)";
        // #AUTOVAR(ae) = HD_ReturnStringNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= #PARAM(s);
        // #INITAUTOVAR(ai,increment)
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     DataTableSave(false, "StringGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)), HD_ReturnStringFromRegNum(#AUTOVAR(va),#AUTOVAR(vs)));
        // }
        // #AUTOVAR(va)= #PARAM(s);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #PARAM(var) = DataTableLoad(false, "StringGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)));
        //     #SUBFUNCS(actions)
        // }

        /// <summary>
        /// 【MM_函数库】互动SG_为String组中的每个元素。每次挑选的元素会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void HD_ForEachStringFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            string lv_vs = lp_gs;
            int lv_ae = HD_ReturnStringNumMax(lv_vs);
            int lv_va = lp_start;
            int lv_ai = lp_increment;
            string lv_timer;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                DataTableStringSave0(false, "StringGFor" + lv_vs + lv_va.ToString(), (string)HD_ReturnStringFromRegNum(lv_va, lv_vs));
            }
            lv_va = lp_start;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                lv_timer = (string)DataTableStringLoad0(false, "StringGFor" + lv_vs + lv_va.ToString());
                lp_funcref(lv_timer);//用户填写的所有动作
            }
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String组中随机元素。返回指定String组中的随机String。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static string HD_ReturnRandomStringFromStringGFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_num;
            int lv_a;
            string lv_c = null;
            // Variable Initialization
            lv_num = HD_ReturnStringNumMax(lp_gs);
            // Implementation
            if ((lv_num >= 1))
            {
                lv_a = RandomInt(1, lv_num);
                lv_c = (string)HD_ReturnStringFromRegNum(lv_a, lp_gs);
            }
            return lv_c;
        }

        //互动SG_添加String组到String组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = HD_ReturnStringNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = HD_ReturnStringFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     HD_AddStringToGroup(#AUTOVAR(var), #AUTOVAR(vsb));
        // }


        /// <summary>
        /// 【MM_函数库】互动SG_添加String组到String组。添加一个String组A的元素到另一个String组B，相同String被认为是同一个。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void HD_AddStringGToStringG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = HD_ReturnStringNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            string lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = (string)HD_ReturnStringFromRegNum(lv_va, lv_vsa);
                HD_AddStringToGroup(lv_var, lv_vsb);
            }
        }

        //互动SG_从String组移除String组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = HD_ReturnStringNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = HD_ReturnStringFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     HD_RemoveString(#AUTOVAR(var), #AUTOVAR(vsb));
        // }

        /// <summary>
        /// 【MM_函数库】互动SG_从String组移除String组。将String组A的元素从String组B中移除，相同String被认为是同一个。移除使用了"互动S_移除String"，同一个存储区（String组ID）序号重排，移除时该存储区如有其他操作会排队等待。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void HD_ClearStringGFromStringG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = HD_ReturnStringNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            string lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = (string)HD_ReturnStringFromRegNum(lv_va, lv_vsa);
                HD_RemoveString(lv_var, lv_vsb);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动SG_移除String组全部元素。将String组（Key区）存储的元素全部移除，相同String被认为是同一个。移除时同一个存储区（String组ID）序号不进行重排，但该存储区如有其他操作会排队等待。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_key">存储键区，默认填String组名称</param>
        public static void HD_RemoveStringGAll(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag = "";
            int lv_a;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            // Implementation
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_StringGroup" + lv_str, true);
            for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
            {
                lv_tag = DataTableIntLoad1(true, (lp_key + "StringTag"), lv_a).ToString();
                lv_num -= 1;
                DataTableBoolClear0(true, "HD_IfStringTag" + lv_str + "_" + lv_tag);
                DataTableStringClear0(true, "HD_StringCV" + lv_str + "_" + lv_tag);
                DataTableStringClear0(true, "HD_StringState" + lv_str + "_" + lv_tag);
                DataTableIntSave0(true, (lp_key + "StringNum"), lv_num);
            }
            ThreadWaitSet(true, "Key_StringGroup" + lv_str, false);
        }

        //--------------------------------------------------------------------------------------------------
        // 字符串组End
        //--------------------------------------------------------------------------------------------------

        #endregion

        #region 数字

        //提示：尽可能使用对口类型，以防值类型与引用类型发生转换时拆装箱降低性能

        //--------------------------------------------------------------------------------------------------
        // 数字组Start
        //--------------------------------------------------------------------------------------------------

        /// <summary>
        /// 【MM_函数库】互动I_注册Int标签句柄并返回。为Int自动设置新的标签句柄，重复时会返回已注册的Int标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns>返回一个Int的已注册标签</returns>
        private static int HD_RegIntTagAndReturn_Int(int lp_vector)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = DataTableIntLoad0(true, "HD_IntJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                DataTableIntSave0(true, "HD_IntJBNum", lv_j);
                DataTableIntSave0(true, ("HD_Int_" + lv_j.ToString()), lp_vector);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if (DataTableIntLoad0(true, ("HD_Int_" + lv_j.ToString())) == lp_vector)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            DataTableIntSave0(true, "HD_IntJBNum", lv_j);
                            DataTableIntSave0(true, ("HD_Int_" + lv_j.ToString()), lp_vector);
                        }
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Int已注册标签句柄
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns>返回一个Int的已注册标签，错误返回0</returns>
        public static int HD_ReturnIntTag_Int(int lp_vector)
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = DataTableIntLoad0(true, "HD_IntJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if (DataTableIntLoad0(true, "HD_Int_" + lv_j.ToString()) == lp_vector)
                {
                    break;
                }
                else
                {
                    if ((lv_j == lv_jBNum))
                    {
                        lv_j = 0;
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动I_注册Int标签句柄并返回。为Int自动设置新的标签句柄，重复时会返回已注册的Int标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns>返回一个Int的已注册标签</returns>
        private static string HD_RegIntTagAndReturn(int lp_vector)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            try { lv_jBNum = DataTableIntLoad0(true, "HD_IntJBNum"); } catch { lv_jBNum = 0; }
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                DataTableIntSave0(true, "HD_IntJBNum", lv_j);
                DataTableIntSave0(true, ("HD_Int_" + lv_j.ToString()), lp_vector);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if (DataTableIntLoad0(true, "HD_Int_" + lv_j.ToString()) == lp_vector)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            DataTableIntSave0(true, "HD_IntJBNum", lv_j);
                            DataTableIntSave0(true, ("HD_Int_" + lv_j.ToString()), lp_vector);
                        }
                    }
                }
            }
            lv_tag = lv_j.ToString();
            //Console.WriteLine(("Tag：" + lv_tag));
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Int已注册标签句柄
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns>返回一个Int的已注册标签，错误返回""</returns>
        public static string HD_ReturnIntTag(int lp_vector)
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag = "";
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = DataTableIntLoad0(true, "HD_IntJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if (DataTableIntLoad0(true, "HD_Int_" + lv_j.ToString()) == lp_vector)
                {
                    lv_tag = lv_j.ToString();
                    break;
                }
            }
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动I_注册Int(高级)。在指定Key存入Int，固有状态、自定义值是Int独一无二的标志（本函数重复注册会刷新），之后可用互动I_"返回Int注册总数"、"返回Int序号"、"返回序号对应Int"、"返回序号对应Int标签"、"返回Int自定义值"。Int组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Int组转为Key。首次注册时固有状态为true（相当于单位组单位活体），如需另外设置多个标记可使用"互动I_设定Int状态/自定义值"
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Int"</param>
        /// <param name="lp_inherentStats">固有状态</param>
        /// <param name="lp_inherentCustomValue">固有自定义值</param>
        public static void HD_RegInt(int lp_vector, string lp_key, string lp_inherentStats, string lp_inherentCustomValue)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;

            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_jBNum = DataTableIntLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = HD_RegIntTagAndReturn(lp_vector);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                DataTableIntSave0(true, (lv_str + "Num"), lv_i);
                DataTableStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                DataTableBoolSave0(true, (("HD_IfIntTag" + "") + "_" + lv_tagStr), true);
                DataTableBoolSave1(true, ("HD_IfIntTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if (DataTableIntLoad1(true, lv_str + "Tag", lv_i).ToString() == lv_tagStr)
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                DataTableIntSave0(true, (lv_str + "Num"), lv_i);
                                DataTableStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                DataTableBoolSave0(true, (("HD_IfIntTag" + "") + "_" + lv_tagStr), true);
                                DataTableBoolSave1(true, ("HD_IfIntTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            DataTableStringSave0(true, ("HD_IntState" + "" + "_" + lv_tagStr), lp_inherentStats);
            DataTableStringSave0(true, ("HD_IntCV" + "" + "_" + lv_tagStr), lp_inherentCustomValue);
        }

        /// <summary>
        /// 【MM_函数库】互动I_注册Int。在指定Key存入Int，固有状态、自定义值是Int独一无二的标志（本函数重复注册不会刷新），之后可用互动I_"返回Int注册总数"、"返回Int序号"、"返回序号对应Int"、"返回Int自定义值"。Int组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Int组转为Key。首次注册时固有状态为true（相当于单位组单位活体），之后只能通过"互动I_注册Int（高级）"改写，如需另外设置多个标记可使用"互动I_设定Int状态/自定义值"
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Int"</param>
        public static void HD_RegInt_Simple(int lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;

            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Int");
            try { lv_num = DataTableIntLoad0(true, (lv_str + "Num")); }
            catch { lv_num = 0; }
            try { lv_jBNum = DataTableIntLoad0(true, (lv_str + "JBNum")); }
            catch { lv_jBNum = 0; }
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = HD_RegIntTagAndReturn(lp_vector);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                DataTableIntSave0(true, (lv_str + "Num"), lv_i);
                DataTableStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                DataTableBoolSave0(true, (("HD_IfIntTag" + "") + "_" + lv_tagStr), true);
                DataTableBoolSave1(true, ("HD_IfIntTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if (DataTableIntLoad1(true, lv_str + "Tag", lv_i).ToString() == lv_tagStr)
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                DataTableIntSave0(true, (lv_str + "Num"), lv_i);
                                DataTableStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                DataTableBoolSave0(true, (("HD_IfIntTag" + "") + "_" + lv_tagStr), true);
                                DataTableBoolSave1(true, ("HD_IfIntTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            if ((DataTableBoolKeyExists(true, ("HD_Int" + "State" + "_" + lv_tag.ToString())) == false))
            {
                DataTableStringSave1(true, (("HD_Int" + "State")), lv_tag, "true");
            }
        }

        /// <summary>
        /// 【MM_函数库】互动I_注销Int。用"互动I_注册Int"到Key，之后可用本函数彻底摧毁注册信息并将序号重排（包括Int标签有效状态、固有状态及自定义值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动I_设定Int状态"让Int状态失效（类似单位组的单位活体状态）。Int组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Int组转为Key。本函数无法摧毁用"互动I_设定Int状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Int组变量ID时会清空Int组专用状态
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Int"</param>
        public static void HD_DestroyInt(int lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag;
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_tag = HD_ReturnIntTag(lp_vector);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                ThreadWaitSet(true, "Key_IntGroup" + lv_str, true);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((DataTableIntLoad1(true, (lp_key + "IntTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        DataTableBoolClear0(true, "HD_IfIntTag_" + lv_tag);
                        DataTableBoolClear0(true, "HD_IfIntTag" + lv_str + "_" + lv_tag);
                        DataTableIntClear0(true, "HD_Int_" + lv_tag);
                        DataTableStringClear0(true, "HD_IntCV_" + lv_tag);
                        DataTableStringClear0(true, "HD_IntState_" + lv_tag);
                        DataTableStringClear0(true, "HD_IntCV" + lv_str + "_" + lv_tag);
                        DataTableStringClear0(true, "HD_IntState" + lv_str + "_" + lv_tag);
                        DataTableIntSave0(true, (lp_key + "IntNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = DataTableIntLoad1(true, (lp_key + "IntTag"), lv_b + 1).ToString();
                            DataTableStringSave1(true, (lp_key + "IntTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                ThreadWaitSet(true, "Key_IntGroup" + lv_str, false);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动I_移除Int。用"互动I_注册Int"到Key，之后可用本函数仅摧毁Key区注册的信息并将序号重排，用于Int组或多个键区仅移除Int（保留Int标签有效状态、固有值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动I_设定Int状态"让Int状态失效（类似单位组的单位活体状态）。Int组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Int组转为Key。本函数无法摧毁用"互动I_设定Int状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Int组变量ID时会清空Int组专用状态
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Int"</param>
        public static void HD_RemoveInt(int lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag;
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_tag = HD_ReturnIntTag(lp_vector);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                ThreadWaitSet(true, "Key_IntGroup" + lv_str, true);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((DataTableIntLoad1(true, (lp_key + "IntTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        DataTableBoolClear0(true, "HD_IfIntTag" + lv_str + "_" + lv_tag);
                        DataTableStringClear0(true, "HD_IntCV" + lv_str + "_" + lv_tag);
                        DataTableStringClear0(true, "HD_IntState" + lv_str + "_" + lv_tag);
                        DataTableIntSave0(true, (lp_key + "IntNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = DataTableIntLoad1(true, (lp_key + "IntTag"), lv_b + 1).ToString();
                            DataTableStringSave1(true, (lp_key + "IntTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                ThreadWaitSet(true, "Key_IntGroup" + lv_str, false);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Int注册总数。必须先使用"互动I_注册Int"才能返回指定Key里的注册总数。Int组使用时，可用"获取变量的内部名称"将Int组转为Key。
        /// </summary>
        /// <param name="lp_key">存储键区，默认值"_Int"</param>
        /// <returns></returns>
        public static int HD_ReturnIntNumMax(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            // Implementation
            return lv_num;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Int序号。使用"互动I_注册Int"后使用本函数可返回Key里的注册序号，Key无元素返回0，Key有元素但对象不在里面则返回-1，Int标签尚未注册则返回-2。Int组使用时，可用"获取变量的内部名称"将Int组转为Key
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Int"</param>
        /// <returns></returns>
        public static int HD_ReturnIntNum(int lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_i;
            string lv_tag;
            int lv_torf;
            // Automatic Variable Declarations
            const int auto_n = 1;
            int auto_i;
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_tag = HD_ReturnIntTag(lp_vector);
            lv_torf = -1;
            // Implementation
            for (auto_i = 1; auto_i <= auto_n; auto_i += 1)
            {
                if ((lv_tag != null))
                {
                    lv_torf = -2;
                    break;
                }
                if ((lv_num == 0))
                {
                    lv_torf = 0;
                }
                else
                {
                    if ((lv_num >= 1))
                    {
                        auto_ae = lv_num;
                        auto_var = 1;
                        for (; auto_var <= auto_ae; auto_var += 1)
                        {
                            lv_i = auto_var;
                            if ((DataTableIntLoad1(true, (lv_str + "Tag"), lv_i).ToString() == lv_tag))
                            {
                                lv_torf = lv_i;
                                break;
                            }
                        }
                    }
                }
            }
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回序号对应Int。使用"互动I_注册Int"后，在参数填入注册序号可返回Int。Int组使用时，可用"获取变量的内部名称"将Int组转为Key
        /// </summary>
        /// <param name="lp_regNum"></param>
        /// <param name="lp_key">存储键区，默认值"_Int"</param>
        /// <returns></returns>
        public static int HD_ReturnIntFromRegNum(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_tag = DataTableIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return DataTableIntLoad0(true, ("HD_Int_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回句柄标签对应Int。使用"互动I_注册Int"后，在参数填入句柄标签（整数）可返回Int，标签是Int的句柄。Int组使用时，可用"获取变量的内部名称"将Int组转为Key
        /// </summary>
        /// <param name="lp_tag">句柄标签</param>
        /// <returns></returns>
        public static int HD_ReturnIntFromTag(int lp_tag)
        {
            // Variable Declarations
            string lv_tag;
            // Variable Initialization
            lv_tag = lp_tag.ToString();
            // Implementation
            return DataTableIntLoad0(true, ("HD_Int_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回序号对应Int标签句柄。使用"互动I_注册Int"后，在参数填入注册序号可返回Int标签（字符串）。Int组使用时，可用"获取变量的内部名称"将Int组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Int"</param>
        /// <returns></returns>
        public static string HD_ReturnIntTagFromRegNum_String(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_tag = DataTableIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回序号对应Int标签句柄。使用"互动I_注册Int"后，在参数填入注册序号可返回Int标签（整数）。Int组使用时，可用"获取变量的内部名称"将Int组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Int"</param>
        /// <returns></returns>
        public static int HD_ReturnIntTagFromRegNum_Int(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_tag = DataTableIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return Convert.ToInt32(lv_tag);
        }

        /// <summary>
        /// 【MM_函数库】互动I_设置Int状态。必须先"注册"获得功能库内部句柄，再使用本函数给Int设定一个状态值，之后可用"互动I_返回Int状态"。类型参数用以记录多个不同状态，仅当"类型"参数填Int组ID转的Int串时，状态值"true"和"false"是Int的Int组专用状态值，用于内部函数筛选Int状态（相当于单位组单位索引是否有效），其他类型不会干扰系统内部，可随意填写。虽然注销时反向清空注册信息，但用"互动I_设定Int状态/自定义值"创建的值需要手工填入""来排泄（非大量注销则提升内存量极小，可不管）。注：固有状态值是注册函数赋予的系统内部变量（相当于单位组单位是否活体），只能通过"互动I_注册Int（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <param name="lp_stats">状态</param>
        public static void HD_SetIntState(int lp_vector, string lp_key, string lp_stats)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_tag = HD_RegIntTagAndReturn(lp_vector);
            // Implementation
            DataTableStringSave0(true, ("HD_IntState" + lv_str + "_" + lv_tag), lp_stats);
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Int状态。使用"互动I_设定Int状态"后可使用本函数，将本函数参数"类型"设为空时返回固有值。类型参数用以记录多个不同状态，仅当"类型"参数为Int组ID转的字符串时，返回的状态值"true"和"false"是Int的Int组专用状态值，用于内部函数筛选Int状态（相当于单位组单位索引是否有效）
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <returns></returns>
        public static string HD_ReturnIntState(int lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_tag = HD_ReturnIntTag(lp_vector);
            lv_stats = DataTableStringLoad0(true, ("HD_IntState" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动I_设置Int自定义值。必须先"注册"获得功能库内部句柄，再使用本函数设定Int的自定义值，之后可使用"互动I_返回Int自定义值"，类型参数用以记录多个不同自定义值。注：固有自定义值是注册函数赋予的系统内部变量，只能通过"互动I_注册Int（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <param name="lp_customValue">自定义值</param>
        public static void HD_SetIntCV(int lp_vector, string lp_key, string lp_customValue)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_tag = HD_RegIntTagAndReturn(lp_vector);
            // Implementation
            DataTableStringSave0(true, ("HD_IntCV" + lv_str + "_" + lv_tag), lp_customValue);
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Int自定义值。使用"互动I_设定Int自定义值"后可使用本函数，将本函数参数"类型"设为空时返回固有值，该参数用以记录多个不同自定义值
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <returns></returns>
        public static string HD_ReturnIntCV(int lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_tag = HD_ReturnIntTag(lp_vector);
            lv_customValue = DataTableStringLoad0(true, ("HD_IntCV" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Int固有状态。必须先使用"互动I_注册Int"才能返回到该值，固有状态是独一无二的标记（相当于单位组单位是否活体）
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns></returns>
        public static string HD_ReturnIntState_Only(int lp_vector)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_tag = HD_ReturnIntTag(lp_vector);
            lv_stats = DataTableStringLoad0(true, ("HD_IntState" + "" + "_" + lv_tag));
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Int固有自定义值。必须先使用"互动I_注册Int"才能返回到该值，固有值是独一无二的标记
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns></returns>
        public static string HD_ReturnIntCV_Only(int lp_vector)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_tag = HD_ReturnIntTag(lp_vector);
            lv_customValue = DataTableStringLoad0(true, ("HD_IntCV" + "" + "_" + lv_tag));
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动I_设置Int的实数标记。必须先"注册"获得功能库内部句柄，再使用本函数让Int携带一个实数值，之后可使用"互动I_返回Int的实数标记"。Int组使用时，可用"获取变量的内部名称"将Int组转为Key
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_realNumTag">实数标记</param>
        public static void HD_SetIntDouble(int lp_vector, double lp_realNumTag)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = HD_RegIntTagAndReturn(lp_vector);
            // Implementation
            DataTableDoubleSave0(true, ("HD_CDDouble_Int_" + lv_tag), lp_realNumTag);
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Int的实数标记。使用"互动I_设定Int的实数标记"后可使用本函数。Int组使用时，可用"获取变量的内部名称"将Int组转为Key
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns></returns>
        public static double HD_ReturnIntDouble(int lp_vector)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = HD_ReturnIntTag(lp_vector);
            // Implementation
            return DataTableDoubleLoad0(true, ("HD_CDDouble_Int_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Int标签句柄有效状态。将Int视作独一无二的个体，标签是它本身，有效状态则类似"单位是否有效"，当使用"互动I_注册Int"或"互动IG_添加Int到Int组"后激活Int有效状态（值为"true"），除非使用"互动I_注册Int（高级）"改写，否则直到注销才会摧毁
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns></returns>
        public static bool HD_ReturnIfIntTag(int lp_vector)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = HD_ReturnIntTag(lp_vector);
            // Implementation
            return DataTableBoolLoad0(true, ("HD_IfIntTag" + "" + "_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Int注册状态。使用"互动I_注册Int"或"互动IG_添加Int到Int组"后可使用本函数获取注册Int在Key中的注册状态，该状态只能注销或从Int组中移除时清空。Int组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Int组转为Key
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Int"</param>
        /// <returns></returns>
        public static bool HD_ReturnIfIntTagKey(int lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_tag = HD_ReturnIntTag(lp_vector);
            // Implementation
            return DataTableBoolLoad0(true, ("HD_IfIntTag" + lv_str + "_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动IG_根据自定义值类型将Int组排序。根据Int携带的自定义值类型，对指定的Int组元素进行冒泡排序。Int组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Int组名称</param>
        /// <param name="lp_cVStr">自定义值类型</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void HD_IntGSortCV(string lp_key, string lp_cVStr, bool lp_big)
        {
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            string lv_tagValuestr;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Int");
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_IntGroup" + lv_str, true);
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = HD_ReturnIntTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValuestr = HD_ReturnIntCV(HD_ReturnIntFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    DataTableIntSave1(false, "IntStackOutTag", 1, lv_tag);
                    DataTableIntSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < DataTableIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DataTableIntSave1(false, "IntStackOutTag", lv_c, DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    DataTableIntSave1(false, "IntStackOutTagValue", lv_c, DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_c, DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                DataTableIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                DataTableIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > DataTableIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(HD_ReturnIntTagFromRegNum(lv_b, lp_key))+"值"+IntToString(DataTableIntLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DataTableIntSave1(false, "IntStackOutTag", lv_c, DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DataTableIntSave1(false, "IntStackOutTagValue", lv_c, DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_c, DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                DataTableIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DataTableIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        DataTableIntSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DataTableIntSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = DataTableIntLoad1(true, (lp_key + "IntTag"), lv_a).ToString(); //原始序号元素
                lv_tag = DataTableIntLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValuestr = HD_ReturnIntCV(HD_ReturnIntFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = DataTableIntLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    DataTableIntSave1(true, (lp_key + "IntTag"), lv_a, lv_tag); //lv_tag放入新序号
                    //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            ThreadWaitSet(true, "Key_IntGroup" + lv_str, false);
        }

        /// <summary>
        /// 【MM_函数库】互动IG_Int组排序。对指定的Int组元素进行冒泡排序（根据元素句柄）。Int组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Int组名称</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void HD_IntGSort(string lp_key, bool lp_big)
        {
            // Automatic Variable Declarations
            // Implementation
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Int");
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_IntGroup" + lv_str, true);
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = HD_ReturnIntTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValue = lv_tag;
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    DataTableIntSave1(false, "IntStackOutTag", 1, lv_tag);
                    DataTableIntSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < DataTableIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DataTableIntSave1(false, "IntStackOutTag", lv_c, DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    DataTableIntSave1(false, "IntStackOutTagValue", lv_c, DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_c, DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                DataTableIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                DataTableIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > DataTableIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(HD_ReturnIntTagFromRegNum(lv_b, lp_key))+"值"+IntToString(DataTableIntLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DataTableIntSave1(false, "IntStackOutTag", lv_c, DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DataTableIntSave1(false, "IntStackOutTagValue", lv_c, DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_c, DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                DataTableIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DataTableIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        DataTableIntSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DataTableIntSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = DataTableIntLoad1(true, (lp_key + "IntTag"), lv_a).ToString(); //原始序号元素
                lv_tag = DataTableIntLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValue = lv_tag;
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = DataTableIntLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                                                                                  //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    DataTableIntSave1(true, (lp_key + "IntTag"), lv_a, lv_tag); //lv_tag放入新序号
                                                                                //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            ThreadWaitSet(true, "Key_IntGroup" + lv_str, false);
        }

        /// <summary>
        /// 【MM_函数库】互动IG_设定Int的Int组专用状态。给Int组的Int设定一个状态值（字符串），之后可用"互动I_返回Int、互动IG_返回Int组的Int状态"。状态值"true"和"false"是Int的Int组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效），而本函数可以重设干预，影响函数"互动IG_返回Int组元素数量（仅检索XX状态）"。与"互动I_设定Int状态"功能相同，只是状态参数在Int组中被固定为"Int组变量的内部ID"。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_vectorGroup"></param>
        /// <param name="lp_groupState"></param>
        public static void HD_SetIntGState(int lp_vector, string lp_vectorGroup, string lp_groupState)
        {
            HD_SetIntState(lp_vector, lp_vectorGroup, lp_groupState);
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Int的Int组专用状态。使用"互动I_设定Int、互动IG_设定Int组的Int状态"后可使用本函数。与"互动I_返回Int状态"功能相同，只是状态参数在Int组中被固定为"Int组变量的内部ID"。状态值"true"和"false"是Int的Int组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效）。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_vectorGroup"></param>
        public static void HD_ReturnIntGState(int lp_vector, string lp_vectorGroup)
        {
            HD_ReturnIntState(lp_vector, lp_vectorGroup);
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Int组元素序号对应元素。返回Int组元素序号指定Int。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HD_ReturnIntFromIntGFunc(int lp_regNum, string lp_gs)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_gs + "Int");
            lv_tag = DataTableIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return DataTableIntLoad0(true, ("HD_Int_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Int组元素总数。返回指定Int组的元素数量。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HD_ReturnIntGNumMax(string lp_gs)
        {
            return DataTableIntLoad0(true, lp_gs + "IntNum");
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Int组元素总数（仅检测Int组专用状态="true"）。返回指定Int组的元素数量。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HD_ReturnIntGNumMax_StateTrueFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            int lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HD_ReturnIntNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HD_ReturnIntFromRegNum(lv_a, lp_gs);
                lv_b = HD_ReturnIntState(lv_c, lp_gs);
                if ((lv_b == "true"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Int组元素总数（仅检测Int组专用状态="false"）。返回指定Int组的元素数量。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HD_ReturnIntGNumMax_StateFalseFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            int lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HD_ReturnIntNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HD_ReturnIntFromRegNum(lv_a, lp_gs);
                lv_b = HD_ReturnIntState(lv_c, lp_gs);
                if ((lv_b == "false"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Int组元素总数（仅检测Int组无效专用状态："false"或""）。返回指定Int组的元素数量（false、""、null）。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HD_ReturnIntGNumMax_StateUselessFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            int lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HD_ReturnIntNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HD_ReturnIntFromRegNum(lv_a, lp_gs);
                lv_b = HD_ReturnIntState(lv_c, lp_gs);
                if (((lv_b == "false") || (lv_b == "") || (lv_b == null)))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Int组元素总数（仅检测Int组指定专用状态）。返回指定Int组的元素数量。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_State">Int组专用状态</param>
        /// <returns></returns>
        public static int HD_ReturnIntGNumMax_StateFunc_Specify(string lp_gs, string lp_State)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            int lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HD_ReturnIntNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HD_ReturnIntFromRegNum(lv_a, lp_gs);
                lv_b = HD_ReturnIntState(lv_c, lp_gs);
                if ((lv_b == lp_State))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动IG_添加Int到Int组。相同Int被认为是同一个，非高级功能不提供专用状态检查，如果Int没有设置过Int组专用状态，那么首次添加到Int组不会赋予"true"（之后可通过"互动I_设定Int状态"、"互动IG_设定Int组的Int状态"修改）。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HD_AddIntToGroup_Simple(int lp_vector, string lp_gs)
        {
            HD_RegInt_Simple(lp_vector, lp_gs);
        }

        /// <summary>
        /// 【MM_函数库】互动IG_添加Int到Int组（高级）。相同Int被认为是同一个，高级功能提供专用状态检查，如果Int没有设置过Int组专用状态，那么首次添加到Int组会赋予"true"（之后可通过"互动I_设定Int状态"、"互动IG_设定Int组的Int状态"修改）。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HD_AddIntToGroup(int lp_vector, string lp_gs)
        {
            HD_RegInt_Simple(lp_vector, lp_gs);
            if (DataTableStringKeyExists(true, ("HD_IntState" + lp_gs + "Int_" + HD_RegIntTagAndReturn(lp_vector))) == false)
            {
                DataTableStringSave0(true, ("HD_IntState" + lp_gs + "Int_" + HD_RegIntTagAndReturn(lp_vector)), "true");
                //Console.WriteLine(lp_gs + "=>" + HD_RegIntTagAndReturn(lp_vector));
            }
        }

        /// <summary>
        /// 【MM_函数库】互动IG_移除Int组中的元素。使用"互动IG_添加Int到Int组"后可使用本函数进行移除元素。移除使用了"互动I_移除Int"，同一个存储区（Int组ID）序号重排，移除时该存储区如有其他操作会排队等待。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HD_ClearIntFromGroup(int lp_vector, string lp_gs)
        {
            HD_RemoveInt(lp_vector, lp_gs);
        }

        //互动IG_为Int组中的每个序号
        //GE（星际2的Galaxy Editor）的宏让编辑器保存时自动生成脚本并整合进脚本进行格式调整，C#仅参考需自行编写
        // #AUTOVAR(vs, string) = "#PARAM(group)";//"#PARAM(group)"是与字段、变量名一致的元素组名称，宏去声明string类型名为“Auto随机编号_vs”的自动变量，然后=右侧字符
        // #AUTOVAR(ae) = HD_ReturnIntNumMax(#AUTOVAR(vs));//宏去声明默认int类型名为“Auto随机编号_ae”的自动变量，然后=右侧字符
        // #INITAUTOVAR(ai,increment)//宏去声明int类型名为“Auto随机编号_ai”的自动变量，用于下面for循环增量（increment是传入参数）
        // #PARAM(var) = #PARAM(s);//#PARAM(var)是传进来的参数，用作“当前被挑选到的元素”（任意变量-整数 lp_var）， #PARAM(s)是传进来的参数用作"开始"（int lp_s）
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #PARAM(var) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #PARAM(var) >= #AUTOVAR(ae)) ) ; #PARAM(var) += #AUTOVAR(ai) ) {
        //     #SUBFUNCS(actions)//代表用户GUI填写的所有动作
        // }

        /// <summary>
        /// 【MM_函数库】互动IG_为Int组中的每个序号。每次挑选的元素序号会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素序号，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void HD_ForEachIntNumFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            int lv_ae = HD_ReturnIntNumMax(lp_gs);
            int lv_var = lp_start;
            int lv_ai = lp_increment;
            for (; (lv_ai >= 0 && lv_var <= lv_ae) || (lv_ai < 0 && lv_var >= lv_ae); lv_var += lv_ai)
            {
                lp_funcref(lv_var);//用户填写的所有动作
            }
        }

        //互动IG_为Int组中的每个元素
        // #AUTOVAR(vs, string) = "#PARAM(group)";
        // #AUTOVAR(ae) = HD_ReturnIntNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= #PARAM(s);
        // #INITAUTOVAR(ai,increment)
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     DataTableSave(false, "IntGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)), HD_ReturnIntFromRegNum(#AUTOVAR(va),#AUTOVAR(vs)));
        // }
        // #AUTOVAR(va)= #PARAM(s);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #PARAM(var) = DataTableLoad(false, "IntGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)));
        //     #SUBFUNCS(actions)
        // }

        /// <summary>
        /// 【MM_函数库】互动IG_为Int组中的每个元素。每次挑选的元素会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void HD_ForEachIntFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            string lv_vs = lp_gs;
            int lv_ae = HD_ReturnIntNumMax(lv_vs);
            int lv_va = lp_start;
            int lv_ai = lp_increment;
            int lv_vector;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                DataTableIntSave0(false, "IntGFor" + lv_vs + lv_va.ToString(), HD_ReturnIntFromRegNum(lv_va, lv_vs));
            }
            lv_va = lp_start;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                lv_vector = DataTableIntLoad0(false, "IntGFor" + lv_vs + lv_va.ToString());
                lp_funcref(lv_vector);//用户填写的所有动作
            }
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Int组中随机元素。返回指定Int组中的随机Int。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HD_ReturnRandomIntFromIntGFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_num;
            int lv_a;
            int lv_c = 0;
            // Variable Initialization
            lv_num = HD_ReturnIntNumMax(lp_gs);
            // Implementation
            if ((lv_num >= 1))
            {
                lv_a = RandomInt(1, lv_num);
                lv_c = HD_ReturnIntFromRegNum(lv_a, lp_gs);
            }
            return lv_c;
        }

        //互动IG_添加Int组到Int组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = HD_ReturnIntNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = HD_ReturnIntFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     HD_AddIntToGroup(#AUTOVAR(var), #AUTOVAR(vsb));
        // }


        /// <summary>
        /// 【MM_函数库】互动IG_添加Int组到Int组。添加一个Int组A的元素到另一个Int组B，相同Int被认为是同一个。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void HD_AddIntGToIntG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = HD_ReturnIntNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            int lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = HD_ReturnIntFromRegNum(lv_va, lv_vsa);
                HD_AddIntToGroup(lv_var, lv_vsb);
            }
        }

        //互动IG_从Int组移除Int组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = HD_ReturnIntNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = HD_ReturnIntFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     HD_RemoveInt(#AUTOVAR(var), #AUTOVAR(vsb));
        // }

        /// <summary>
        /// 【MM_函数库】互动IG_从Int组移除Int组。将Int组A的元素从Int组B中移除，相同Int被认为是同一个。移除使用了"互动I_移除Int"，同一个存储区（Int组ID）序号重排，移除时该存储区如有其他操作会排队等待。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void HD_ClearIntGFromIntG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = HD_ReturnIntNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            int lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = HD_ReturnIntFromRegNum(lv_va, lv_vsa);
                HD_RemoveInt(lv_var, lv_vsb);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动IG_移除Int组全部元素。将Int组（Key区）存储的元素全部移除，相同Int被认为是同一个。移除时同一个存储区（Int组ID）序号不进行重排，但该存储区如有其他操作会排队等待。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Int组名称</param>
        public static void HD_RemoveIntGAll(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag = "";
            int lv_a;
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            // Implementation
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_IntGroup" + lv_str, true);
            for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
            {
                lv_tag = DataTableIntLoad1(true, (lp_key + "IntTag"), lv_a).ToString();
                lv_num -= 1;
                DataTableBoolClear0(true, "HD_IfIntTag" + lv_str + "_" + lv_tag);
                DataTableStringClear0(true, "HD_IntCV" + lv_str + "_" + lv_tag);
                DataTableStringClear0(true, "HD_IntState" + lv_str + "_" + lv_tag);
                DataTableIntSave0(true, (lp_key + "IntNum"), lv_num);
            }
            ThreadWaitSet(true, "Key_IntGroup" + lv_str, false);
        }

        //--------------------------------------------------------------------------------------------------
        // 数字组End
        //--------------------------------------------------------------------------------------------------

        #endregion

        #endregion

        #region 系统互动

        #region 字典互动

        #region 任意类型

        //提示：可以将任意类型作为模板修改后产生其他类型
        //提示：尽可能使用对口类型，以防值类型与引用类型发生转换时拆装箱降低性能

        //--------------------------------------------------------------------------------------------------
        // 任意类型组Start
        //--------------------------------------------------------------------------------------------------

        /// <summary>
        /// 【MM_函数库】互动O_注册Object标签句柄并返回。为Object自动设置新的标签句柄，重复时会返回已注册的Object标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns>返回一个Object的已注册标签</returns>
        private static int DHD_RegObjectTagAndReturn_Int(object lp_object)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)DictionaryIntLoad0(true, "DHD_ObjectJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                DictionaryIntSave0(true, "DHD_ObjectJBNum", lv_j);
                DictionaryObjectSave0(true, ("DHD_Object_" + lv_j.ToString()), lp_object);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if (DictionaryObjectLoad0(true, ("DHD_Object_" + lv_j.ToString())) == lp_object)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            DictionaryIntSave0(true, "DHD_ObjectJBNum", lv_j);
                            DictionaryObjectSave0(true, ("DHD_Object_" + lv_j.ToString()), lp_object);
                        }
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object已注册标签句柄
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns>返回一个Object的已注册标签，错误返回0</returns>
        public static int DHD_ReturnObjectTag_Int(object lp_object)
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)DictionaryIntLoad0(true, "DHD_ObjectJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if (DictionaryObjectLoad0(true, "DHD_Object_" + lv_j.ToString()) == lp_object)
                {
                    break;
                }
                else
                {
                    if ((lv_j == lv_jBNum))
                    {
                        lv_j = 0;
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动O_注册Object标签句柄并返回。为Object自动设置新的标签句柄，重复时会返回已注册的Object标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns>返回一个Object的已注册标签</returns>
        private static string DHD_RegObjectTagAndReturn(object lp_object)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)DictionaryIntLoad0(true, "DHD_ObjectJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                DictionaryIntSave0(true, "DHD_ObjectJBNum", lv_j);
                DictionaryObjectSave0(true, ("DHD_Object_" + lv_j.ToString()), lp_object);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if (DictionaryObjectLoad0(true, "DHD_Object_" + lv_j.ToString()) == lp_object)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            DictionaryIntSave0(true, "DHD_ObjectJBNum", lv_j);
                            DictionaryObjectSave0(true, ("DHD_Object_" + lv_j.ToString()), lp_object);
                        }
                    }
                }
            }
            lv_tag = lv_j.ToString();
            //Console.WriteLine(("Tag：" + lv_tag));
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object已注册标签句柄
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns>返回一个Object的已注册标签，错误返回""</returns>
        public static string DHD_ReturnObjectTag(object lp_object)
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag = "";
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)DictionaryIntLoad0(true, "DHD_ObjectJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if (DictionaryObjectLoad0(true, "DHD_Object_" + lv_j.ToString()) == lp_object)
                {
                    lv_tag = lv_j.ToString();
                    break;
                }
            }
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动O_注册Object(高级)。在指定Key存入Object，固有状态、自定义值是Object独一无二的标志（本函数重复注册会刷新），之后可用互动O_"返回Object注册总数"、"返回Object序号"、"返回序号对应Object"、"返回序号对应Object标签"、"返回Object自定义值"。Object组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Object组转为Key。首次注册时固有状态为true（相当于单位组单位活体），如需另外设置多个标记可使用"互动O_设定Object状态/自定义值"
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        /// <param name="lp_inherentStats">固有状态</param>
        /// <param name="lp_inherentCustomValue">固有自定义值</param>
        public static void DHD_RegObject(object lp_object, string lp_key, string lp_inherentStats, string lp_inherentCustomValue)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;

            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_jBNum = (int)DictionaryIntLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = DHD_RegObjectTagAndReturn(lp_object);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                DictionaryIntSave0(true, (lv_str + "Num"), lv_i);
                DictionaryStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                DictionaryBoolSave0(true, (("DHD_IfObjectTag" + "") + "_" + lv_tagStr), true);
                DictionaryBoolSave1(true, ("DHD_IfObjectTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if (DictionaryIntLoad1(true, lv_str + "Tag", lv_i).ToString() == lv_tagStr)
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                DictionaryIntSave0(true, (lv_str + "Num"), lv_i);
                                DictionaryStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                DictionaryBoolSave0(true, (("DHD_IfObjectTag" + "") + "_" + lv_tagStr), true);
                                DictionaryBoolSave1(true, ("DHD_IfObjectTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            DictionaryStringSave0(true, ("DHD_ObjectState" + "" + "_" + lv_tagStr), lp_inherentStats);
            DictionaryStringSave0(true, ("DHD_ObjectCV" + "" + "_" + lv_tagStr), lp_inherentCustomValue);
        }

        /// <summary>
        /// 【MM_函数库】互动O_注册Object。在指定Key存入Object，固有状态、自定义值是Object独一无二的标志（本函数重复注册不会刷新），之后可用互动O_"返回Object注册总数"、"返回Object序号"、"返回序号对应Object"、"返回Object自定义值"。Object组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Object组转为Key。首次注册时固有状态为true（相当于单位组单位活体），之后只能通过"互动O_注册Object（高级）"改写，如需另外设置多个标记可使用"互动O_设定Object状态/自定义值"
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        public static void DHD_RegObject_Simple(object lp_object, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;

            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_jBNum = (int)DictionaryIntLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = DHD_RegObjectTagAndReturn(lp_object);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                DictionaryIntSave0(true, (lv_str + "Num"), lv_i);
                DictionaryStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                DictionaryBoolSave0(true, (("DHD_IfObjectTag" + "") + "_" + lv_tagStr), true);
                DictionaryBoolSave1(true, ("DHD_IfObjectTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if (DictionaryIntLoad1(true, lv_str + "Tag", lv_i).ToString() == lv_tagStr)
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                DictionaryIntSave0(true, (lv_str + "Num"), lv_i);
                                DictionaryStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                DictionaryBoolSave0(true, (("DHD_IfObjectTag" + "") + "_" + lv_tagStr), true);
                                DictionaryBoolSave1(true, ("DHD_IfObjectTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            if ((DictionaryBoolKeyExists(true, ("DHD_Object" + "State" + "_" + lv_tag.ToString())) == false))
            {
                DictionaryStringSave1(true, (("DHD_Object" + "State")), lv_tag, "true");
            }
        }

        /// <summary>
        /// 【MM_函数库】互动O_注销Object。用"互动O_注册Object"到Key，之后可用本函数彻底摧毁注册信息并将序号重排（包括Object标签有效状态、固有状态及自定义值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动O_设定Object状态"让Object状态失效（类似单位组的单位活体状态）。Object组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Object组转为Key。本函数无法摧毁用"互动O_设定Object状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Object组变量ID时会清空Object组专用状态
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        public static void DHD_DestroyObject(object lp_object, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag;
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_tag = DHD_ReturnObjectTag(lp_object);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                ThreadWaitSet(true, "Key_ObjectGroup" + lv_str, true);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((DictionaryIntLoad1(true, (lp_key + "ObjectTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        DictionaryBoolClear0(true, "DHD_IfObjectTag_" + lv_tag);
                        DictionaryBoolClear0(true, "DHD_IfObjectTag" + lv_str + "_" + lv_tag);
                        DictionaryObjectClear0(true, "DHD_Object_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_ObjectCV_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_ObjectState_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_ObjectCV" + lv_str + "_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_ObjectState" + lv_str + "_" + lv_tag);
                        DictionaryIntSave0(true, (lp_key + "ObjectNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = DictionaryIntLoad1(true, (lp_key + "ObjectTag"), lv_b + 1).ToString();
                            DictionaryStringSave1(true, (lp_key + "ObjectTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                ThreadWaitSet(true, "Key_ObjectGroup" + lv_str, false);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动O_移除Object。用"互动O_注册Object"到Key，之后可用本函数仅摧毁Key区注册的信息并将序号重排，用于Object组或多个键区仅移除Object（保留Object标签有效状态、固有值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动O_设定Object状态"让Object状态失效（类似单位组的单位活体状态）。Object组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Object组转为Key。本函数无法摧毁用"互动O_设定Object状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Object组变量ID时会清空Object组专用状态
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        public static void DHD_RemoveObject(object lp_object, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag;
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_tag = DHD_ReturnObjectTag(lp_object);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                ThreadWaitSet(true, "Key_ObjectGroup" + lv_str, true);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((DictionaryIntLoad1(true, (lp_key + "ObjectTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        DictionaryBoolClear0(true, "DHD_IfObjectTag" + lv_str + "_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_ObjectCV" + lv_str + "_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_ObjectState" + lv_str + "_" + lv_tag);
                        DictionaryIntSave0(true, (lp_key + "ObjectNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = DictionaryIntLoad1(true, (lp_key + "ObjectTag"), lv_b + 1).ToString();
                            DictionaryStringSave1(true, (lp_key + "ObjectTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                ThreadWaitSet(true, "Key_ObjectGroup" + lv_str, false);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object注册总数。必须先使用"互动O_注册Object"才能返回指定Key里的注册总数。Object组使用时，可用"获取变量的内部名称"将Object组转为Key。
        /// </summary>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        /// <returns></returns>
        public static int DHD_ReturnObjectNumMax(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            // Implementation
            return lv_num;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object序号。使用"互动O_注册Object"后使用本函数可返回Key里的注册序号，Key无元素返回0，Key有元素但对象不在里面则返回-1，Object标签尚未注册则返回-2。Object组使用时，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        /// <returns></returns>
        public static int DHD_ReturnObjectNum(object lp_object, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_i;
            string lv_tag;
            int lv_torf;
            // Automatic Variable Declarations
            const int auto_n = 1;
            int auto_i;
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_tag = DHD_ReturnObjectTag(lp_object);
            lv_torf = -1;
            // Implementation
            for (auto_i = 1; auto_i <= auto_n; auto_i += 1)
            {
                if ((lv_tag != null))
                {
                    lv_torf = -2;
                    break;
                }
                if ((lv_num == 0))
                {
                    lv_torf = 0;
                }
                else
                {
                    if ((lv_num >= 1))
                    {
                        auto_ae = lv_num;
                        auto_var = 1;
                        for (; auto_var <= auto_ae; auto_var += 1)
                        {
                            lv_i = auto_var;
                            if ((DictionaryIntLoad1(true, (lv_str + "Tag"), lv_i).ToString() == lv_tag))
                            {
                                lv_torf = lv_i;
                                break;
                            }
                        }
                    }
                }
            }
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回序号对应Object。使用"互动O_注册Object"后，在参数填入注册序号可返回Object。Object组使用时，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_regNum"></param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        /// <returns></returns>
        public static object DHD_ReturnObjectFromRegNum(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            object lv_object;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = DictionaryIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            lv_object = DictionaryObjectLoad0(true, ("DHD_Object_" + lv_tag));
            // Implementation
            return lv_object;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回句柄标签对应Object。使用"互动O_注册Object"后，在参数填入句柄标签（整数）可返回Object，标签是Object的句柄。Object组使用时，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_tag">句柄标签</param>
        /// <returns></returns>
        public static object DHD_ReturnObjectFromTag(int lp_tag)
        {
            // Variable Declarations
            string lv_tag;
            object lv_object;
            // Variable Initialization
            lv_tag = lp_tag.ToString();
            lv_object = DictionaryObjectLoad0(true, ("DHD_Object_" + lv_tag));
            // Implementation
            return lv_object;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回序号对应Object标签句柄。使用"互动O_注册Object"后，在参数填入注册序号可返回Object标签（字符串）。Object组使用时，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        /// <returns></returns>
        public static string DHD_ReturnObjectTagFromRegNum_String(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = DictionaryIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回序号对应Object标签句柄。使用"互动O_注册Object"后，在参数填入注册序号可返回Object标签（整数）。Object组使用时，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        /// <returns></returns>
        public static int DHD_ReturnObjectTagFromRegNum_Int(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = DictionaryIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return Convert.ToInt32(lv_tag);
        }

        /// <summary>
        /// 【MM_函数库】互动O_设置Object状态。必须先"注册"获得功能库内部句柄，再使用本函数给Object设定一个状态值，之后可用"互动O_返回Object状态"。类型参数用以记录多个不同状态，仅当"类型"参数填Object组ID转的Object串时，状态值"true"和"false"是Object的Object组专用状态值，用于内部函数筛选Object状态（相当于单位组单位索引是否有效），其他类型不会干扰系统内部，可随意填写。虽然注销时反向清空注册信息，但用"互动O_设定Object状态/自定义值"创建的值需要手工填入""来排泄（非大量注销则提升内存量极小，可不管）。注：固有状态值是注册函数赋予的系统内部变量（相当于单位组单位是否活体），只能通过"互动O_注册Object（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <param name="lp_stats">状态</param>
        public static void DHD_SetObjectState(object lp_object, string lp_key, string lp_stats)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = DHD_RegObjectTagAndReturn(lp_object);
            // Implementation
            DictionaryStringSave0(true, ("DHD_ObjectState" + lv_str + "_" + lv_tag), lp_stats);
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object状态。使用"互动O_设定Object状态"后可使用本函数，将本函数参数"类型"设为空时返回固有值。类型参数用以记录多个不同状态，仅当"类型"参数为Object组ID转的字符串时，返回的状态值"true"和"false"是Object的Object组专用状态值，用于内部函数筛选Object状态（相当于单位组单位索引是否有效）
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <returns></returns>
        public static string DHD_ReturnObjectState(object lp_object, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = DHD_ReturnObjectTag(lp_object);
            lv_stats = DictionaryStringLoad0(true, ("DHD_ObjectState" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动O_设置Object自定义值。必须先"注册"获得功能库内部句柄，再使用本函数设定Object的自定义值，之后可使用"互动O_返回Object自定义值"，类型参数用以记录多个不同自定义值。注：固有自定义值是注册函数赋予的系统内部变量，只能通过"互动O_注册Object（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <param name="lp_customValue">自定义值</param>
        public static void DHD_SetObjectCV(object lp_object, string lp_key, string lp_customValue)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = DHD_RegObjectTagAndReturn(lp_object);
            // Implementation
            DictionaryStringSave0(true, ("DHD_ObjectCV" + lv_str + "_" + lv_tag), lp_customValue);
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object自定义值。使用"互动O_设定Object自定义值"后可使用本函数，将本函数参数"类型"设为空时返回固有值，该参数用以记录多个不同自定义值
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <returns></returns>
        public static string DHD_ReturnObjectCV(object lp_object, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = DHD_ReturnObjectTag(lp_object);
            lv_customValue = DictionaryStringLoad0(true, ("DHD_ObjectCV" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object固有状态。必须先使用"互动O_注册Object"才能返回到该值，固有状态是独一无二的标记（相当于单位组单位是否活体）
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns></returns>
        public static string DHD_ReturnObjectState_Only(object lp_object)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_tag = DHD_ReturnObjectTag(lp_object);
            lv_stats = DictionaryStringLoad0(true, ("DHD_ObjectState" + "" + "_" + lv_tag));
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object固有自定义值。必须先使用"互动O_注册Object"才能返回到该值，固有值是独一无二的标记
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns></returns>
        public static string DHD_ReturnObjectCV_Only(object lp_object)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_tag = DHD_ReturnObjectTag(lp_object);
            lv_customValue = DictionaryStringLoad0(true, ("DHD_ObjectCV" + "" + "_" + lv_tag));
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动O_设置Object的实数标记。必须先"注册"获得功能库内部句柄，再使用本函数让Object携带一个实数值，之后可使用"互动O_返回Object的实数标记"。Object组使用时，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_realNumTag">实数标记</param>
        public static void DHD_SetObjectDouble(object lp_object, double lp_realNumTag)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = DHD_RegObjectTagAndReturn(lp_object);
            // Implementation
            DictionaryDoubleSave0(true, ("DHD_CDDouble_Object_" + lv_tag), lp_realNumTag);
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object的实数标记。使用"互动O_设定Object的实数标记"后可使用本函数。Object组使用时，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns></returns>
        public static double DHD_ReturnObjectDouble(object lp_object)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = DHD_ReturnObjectTag(lp_object);
            // Implementation
            return DictionaryDoubleLoad0(true, ("DHD_CDDouble_Object_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object标签句柄有效状态。将Object视作独一无二的个体，标签是它本身，有效状态则类似"单位是否有效"，当使用"互动O_注册Object"或"互动OG_添加Object到Object组"后激活Object有效状态（值为"true"），除非使用"互动O_注册Object（高级）"改写，否则直到注销才会摧毁
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns></returns>
        public static bool DHD_ReturnIfObjectTag(object lp_object)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = DHD_ReturnObjectTag(lp_object);
            // Implementation
            return DictionaryBoolLoad0(true, ("DHD_IfObjectTag" + "" + "_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object注册状态。使用"互动O_注册Object"或"互动OG_添加Object到Object组"后可使用本函数获取注册Object在Key中的注册状态，该状态只能注销或从Object组中移除时清空。Object组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        /// <returns></returns>
        public static bool DHD_ReturnIfObjectTagKey(object lp_object, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = DHD_ReturnObjectTag(lp_object);
            // Implementation
            return DictionaryBoolLoad0(true, ("DHD_IfObjectTag" + lv_str + "_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动OG_根据自定义值类型将Object组排序。根据Object携带的自定义值类型，对指定的Object组元素进行冒泡排序。Object组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Object组名称</param>
        /// <param name="lp_cVStr">自定义值类型</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void DHD_ObjectGSortCV(string lp_key, string lp_cVStr, bool lp_big)
        {
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            string lv_tagValuestr;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_ObjectGroup" + lv_str, true);
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = DHD_ReturnObjectTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValuestr = DHD_ReturnObjectCV(DHD_ReturnObjectFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    DictionaryIntSave1(false, "IntStackOutTag", 1, lv_tag);
                    DictionaryIntSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DictionaryIntSave1(false, "IntStackOutTag", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    DictionaryIntSave1(false, "IntStackOutTagValue", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                DictionaryIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                DictionaryIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(DHD_ReturnObjectTagFromRegNum(lv_b, lp_key))+"值"+IntToString(DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DictionaryIntSave1(false, "IntStackOutTag", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DictionaryIntSave1(false, "IntStackOutTagValue", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                DictionaryIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DictionaryIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        DictionaryIntSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DictionaryIntSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = DictionaryIntLoad1(true, (lp_key + "ObjectTag"), lv_a).ToString(); //原始序号元素
                lv_tag = (int)DictionaryIntLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValuestr = DHD_ReturnObjectCV(DHD_ReturnObjectFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    DictionaryIntSave1(true, (lp_key + "ObjectTag"), lv_a, lv_tag); //lv_tag放入新序号
                    //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            ThreadWaitSet(true, "Key_ObjectGroup" + lv_str, false);
        }

        /// <summary>
        /// 【MM_函数库】互动OG_Object组排序。对指定的Object组元素进行冒泡排序（根据元素句柄）。Object组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Object组名称</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void DHD_ObjectGSort(string lp_key, bool lp_big)
        {
            // Automatic Variable Declarations
            // Implementation
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_ObjectGroup" + lv_str, true);
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = DHD_ReturnObjectTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValue = lv_tag;
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    DictionaryIntSave1(false, "IntStackOutTag", 1, lv_tag);
                    DictionaryIntSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DictionaryIntSave1(false, "IntStackOutTag", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    DictionaryIntSave1(false, "IntStackOutTagValue", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                DictionaryIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                DictionaryIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(DHD_ReturnObjectTagFromRegNum(lv_b, lp_key))+"值"+IntToString(DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DictionaryIntSave1(false, "IntStackOutTag", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DictionaryIntSave1(false, "IntStackOutTagValue", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                DictionaryIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DictionaryIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        DictionaryIntSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DictionaryIntSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = DictionaryIntLoad1(true, (lp_key + "ObjectTag"), lv_a).ToString(); //原始序号元素
                lv_tag = (int)DictionaryIntLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValue = lv_tag;
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                                                                                        //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    DictionaryIntSave1(true, (lp_key + "ObjectTag"), lv_a, lv_tag); //lv_tag放入新序号
                                                                                    //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            ThreadWaitSet(true, "Key_ObjectGroup" + lv_str, false);
        }

        /// <summary>
        /// 【MM_函数库】互动OG_设定Object的Object组专用状态。给Object组的Object设定一个状态值（字符串），之后可用"互动O_返回Object、互动OG_返回Object组的Object状态"。状态值"true"和"false"是Object的Object组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效），而本函数可以重设干预，影响函数"互动OG_返回Object组元素数量（仅检索XX状态）"。与"互动O_设定Object状态"功能相同，只是状态参数在Object组中被固定为"Object组变量的内部ID"。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_objectGroup"></param>
        /// <param name="lp_groupState"></param>
        public static void DHD_SetObjectGState(object lp_object, string lp_objectGroup, string lp_groupState)
        {
            DHD_SetObjectState(lp_object, lp_objectGroup, lp_groupState);
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object的Object组专用状态。使用"互动O_设定Object、互动OG_设定Object组的Object状态"后可使用本函数。与"互动O_返回Object状态"功能相同，只是状态参数在Object组中被固定为"Object组变量的内部ID"。状态值"true"和"false"是Object的Object组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效）。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_objectGroup"></param>
        public static void DHD_ReturnObjectGState(object lp_object, string lp_objectGroup)
        {
            DHD_ReturnObjectState(lp_object, lp_objectGroup);
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object组元素序号对应元素。返回Object组元素序号指定Object。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static object DHD_ReturnObjectFromObjectGFunc(int lp_regNum, string lp_gs)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            object lv_object;
            // Variable Initialization
            lv_str = (lp_gs + "Object");
            lv_tag = DictionaryIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            lv_object = DictionaryObjectLoad0(true, ("DHD_Object_" + lv_tag));
            // Implementation
            return lv_object;
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object组元素总数。返回指定Object组的元素数量。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int DHD_ReturnObjectGNumMax(string lp_gs)
        {
            return DictionaryIntLoad0(true, lp_gs + "ObjectNum");
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object组元素总数（仅检测Object组专用状态="true"）。返回指定Object组的元素数量。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int DHD_ReturnObjectGNumMax_StateTrueFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            object lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = DHD_ReturnObjectNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = DHD_ReturnObjectFromRegNum(lv_a, lp_gs);
                lv_b = DHD_ReturnObjectState(lv_c, lp_gs);
                if ((lv_b == "true"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object组元素总数（仅检测Object组专用状态="false"）。返回指定Object组的元素数量。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int DHD_ReturnObjectGNumMax_StateFalseFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            object lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = DHD_ReturnObjectNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = DHD_ReturnObjectFromRegNum(lv_a, lp_gs);
                lv_b = DHD_ReturnObjectState(lv_c, lp_gs);
                if ((lv_b == "false"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object组元素总数（仅检测Object组无效专用状态："false"或""）。返回指定Object组的元素数量（false、""、null）。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int DHD_ReturnObjectGNumMax_StateUselessFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            object lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = DHD_ReturnObjectNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = DHD_ReturnObjectFromRegNum(lv_a, lp_gs);
                lv_b = DHD_ReturnObjectState(lv_c, lp_gs);
                if (((lv_b == "false") || (lv_b == "") || (lv_b == null)))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object组元素总数（仅检测Object组指定专用状态）。返回指定Object组的元素数量。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_State">Object组专用状态</param>
        /// <returns></returns>
        public static int DHD_ReturnObjectGNumMax_StateFunc_Specify(string lp_gs, string lp_State)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            object lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = DHD_ReturnObjectNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = DHD_ReturnObjectFromRegNum(lv_a, lp_gs);
                lv_b = DHD_ReturnObjectState(lv_c, lp_gs);
                if ((lv_b == lp_State))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动OG_添加Object到Object组。相同Object被认为是同一个，非高级功能不提供专用状态检查，如果Object没有设置过Object组专用状态，那么首次添加到Object组不会赋予"true"（之后可通过"互动O_设定Object状态"、"互动OG_设定Object组的Object状态"修改）。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void DHD_AddObjectToGroup_Simple(object lp_object, string lp_gs)
        {
            DHD_RegObject_Simple(lp_object, lp_gs);
        }

        /// <summary>
        /// 【MM_函数库】互动OG_添加Object到Object组（高级）。相同Object被认为是同一个，高级功能提供专用状态检查，如果Object没有设置过Object组专用状态，那么首次添加到Object组会赋予"true"（之后可通过"互动O_设定Object状态"、"互动OG_设定Object组的Object状态"修改）。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void DHD_AddObjectToGroup(object lp_object, string lp_gs)
        {
            DHD_RegObject_Simple(lp_object, lp_gs);
            if (DictionaryStringKeyExists(true, ("DHD_ObjectState" + lp_gs + "Object_" + DHD_RegObjectTagAndReturn(lp_object))) == false)
            {
                DictionaryStringSave0(true, ("DHD_ObjectState" + lp_gs + "Object_" + DHD_RegObjectTagAndReturn(lp_object)), "true");
                //Console.WriteLine(lp_gs + "=>" + DHD_RegObjectTagAndReturn(lp_object));
            }
        }

        /// <summary>
        /// 【MM_函数库】互动OG_移除Object组中的元素。使用"互动OG_添加Object到Object组"后可使用本函数进行移除元素。移除使用了"互动O_移除Object"，同一个存储区（Object组ID）序号重排，移除时该存储区如有其他操作会排队等待。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void DHD_ClearObjectFromGroup(object lp_object, string lp_gs)
        {
            DHD_RemoveObject(lp_object, lp_gs);
        }

        //互动OG_为Object组中的每个序号
        //GE（星际2的Galaxy Editor）的宏让编辑器保存时自动生成脚本并整合进脚本进行格式调整，C#仅参考需自行编写
        // #AUTOVAR(vs, string) = "#PARAM(group)";//"#PARAM(group)"是与字段、变量名一致的元素组名称，宏去声明string类型名为“Auto随机编号_vs”的自动变量，然后=右侧字符
        // #AUTOVAR(ae) = DHD_ReturnObjectNumMax(#AUTOVAR(vs));//宏去声明默认int类型名为“Auto随机编号_ae”的自动变量，然后=右侧字符
        // #INITAUTOVAR(ai,increment)//宏去声明int类型名为“Auto随机编号_ai”的自动变量，用于下面for循环增量（increment是传入参数）
        // #PARAM(var) = #PARAM(s);//#PARAM(var)是传进来的参数，用作“当前被挑选到的元素”（任意变量-整数 lp_var）， #PARAM(s)是传进来的参数用作"开始"（int lp_s）
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #PARAM(var) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #PARAM(var) >= #AUTOVAR(ae)) ) ; #PARAM(var) += #AUTOVAR(ai) ) {
        //     #SUBFUNCS(actions)//代表用户GUI填写的所有动作
        // }

        /// <summary>
        /// 【MM_函数库】互动OG_为Object组中的每个序号。每次挑选的元素序号会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素序号，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void DHD_ForEachObjectNumFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            int lv_ae = DHD_ReturnObjectNumMax(lp_gs);
            int lv_var = lp_start;
            int lv_ai = lp_increment;
            for (; (lv_ai >= 0 && lv_var <= lv_ae) || (lv_ai < 0 && lv_var >= lv_ae); lv_var += lv_ai)
            {
                lp_funcref(lv_var);//用户填写的所有动作
            }
        }

        //互动OG_为Object组中的每个元素
        // #AUTOVAR(vs, string) = "#PARAM(group)";
        // #AUTOVAR(ae) = DHD_ReturnObjectNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= #PARAM(s);
        // #INITAUTOVAR(ai,increment)
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     DictionarySave(false, "ObjectGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)), DHD_ReturnObjectFromRegNum(#AUTOVAR(va),#AUTOVAR(vs)));
        // }
        // #AUTOVAR(va)= #PARAM(s);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #PARAM(var) = DictionaryLoad(false, "ObjectGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)));
        //     #SUBFUNCS(actions)
        // }

        /// <summary>
        /// 【MM_函数库】互动OG_为Object组中的每个元素。每次挑选的元素会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void DHD_ForEachObjectFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            string lv_vs = lp_gs;
            int lv_ae = DHD_ReturnObjectNumMax(lv_vs);
            int lv_va = lp_start;
            int lv_ai = lp_increment;
            object lv_object;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                DictionaryObjectSave0(false, "ObjectGFor" + lv_vs + lv_va.ToString(), DHD_ReturnObjectFromRegNum(lv_va, lv_vs));
            }
            lv_va = lp_start;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                lv_object = DictionaryObjectLoad0(false, "ObjectGFor" + lv_vs + lv_va.ToString());
                lp_funcref(lv_object);//用户填写的所有动作
            }
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object组中随机元素。返回指定Object组中的随机Object。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static object DHD_ReturnRandomObjectFromObjectGFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_num;
            int lv_a;
            object lv_c = null;
            // Variable Initialization
            lv_num = DHD_ReturnObjectNumMax(lp_gs);
            // Implementation
            if ((lv_num >= 1))
            {
                lv_a = RandomInt(1, lv_num);
                lv_c = DHD_ReturnObjectFromRegNum(lv_a, lp_gs);
            }
            return lv_c;
        }

        //互动OG_添加Object组到Object组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = DHD_ReturnObjectNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = DHD_ReturnObjectFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     DHD_AddObjectToGroup(#AUTOVAR(var), #AUTOVAR(vsb));
        // }


        /// <summary>
        /// 【MM_函数库】互动OG_添加Object组到Object组。添加一个Object组A的元素到另一个Object组B，相同Object被认为是同一个。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void DHD_AddObjectGToObjectG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = DHD_ReturnObjectNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            object lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = DHD_ReturnObjectFromRegNum(lv_va, lv_vsa);
                DHD_AddObjectToGroup(lv_var, lv_vsb);
            }
        }

        //互动OG_从Object组移除Object组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = DHD_ReturnObjectNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = DHD_ReturnObjectFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     DHD_RemoveObject(#AUTOVAR(var), #AUTOVAR(vsb));
        // }

        /// <summary>
        /// 【MM_函数库】互动OG_从Object组移除Object组。将Object组A的元素从Object组B中移除，相同Object被认为是同一个。移除使用了"互动O_移除Object"，同一个存储区（Object组ID）序号重排，移除时该存储区如有其他操作会排队等待。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void DHD_ClearObjectGFromObjectG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = DHD_ReturnObjectNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            object lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = DHD_ReturnObjectFromRegNum(lv_va, lv_vsa);
                DHD_RemoveObject(lv_var, lv_vsb);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动OG_移除Object组全部元素。将Object组（Key区）存储的元素全部移除，相同Object被认为是同一个。移除时同一个存储区（Object组ID）序号不进行重排，但该存储区如有其他操作会排队等待。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Object组名称</param>
        public static void DHD_RemoveObjectGAll(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag = "";
            int lv_a;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            // Implementation
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_ObjectGroup" + lv_str, true);
            for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
            {
                lv_tag = DictionaryIntLoad1(true, (lp_key + "ObjectTag"), lv_a).ToString();
                lv_num -= 1;
                DictionaryBoolClear0(true, "DHD_IfObjectTag" + lv_str + "_" + lv_tag);
                DictionaryStringClear0(true, "DHD_ObjectCV" + lv_str + "_" + lv_tag);
                DictionaryStringClear0(true, "DHD_ObjectState" + lv_str + "_" + lv_tag);
                DictionaryIntSave0(true, (lp_key + "ObjectNum"), lv_num);
            }
            ThreadWaitSet(true, "Key_ObjectGroup" + lv_str, false);
        }

        //--------------------------------------------------------------------------------------------------
        // 任意类型组End
        //--------------------------------------------------------------------------------------------------

        #endregion

        #region 二维向量

        //提示：尽可能使用对口类型，以防值类型与引用类型发生转换时拆装箱降低性能

        //--------------------------------------------------------------------------------------------------
        // 二维向量组Start
        //--------------------------------------------------------------------------------------------------

        /// <summary>
        /// 【MM_函数库】互动V_注册Vector标签句柄并返回。为Vector自动设置新的标签句柄，重复时会返回已注册的Vector标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns>返回一个Vector的已注册标签</returns>
        private static int DHD_RegVectorTagAndReturn_Int(Vector2F lp_vector)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)DictionaryIntLoad0(true, "DHD_VectorJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                DictionaryIntSave0(true, "DHD_VectorJBNum", lv_j);
                DictionaryVectorSave0(true, ("DHD_Vector_" + lv_j.ToString()), lp_vector);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if (DictionaryVectorLoad0(true, ("DHD_Vector_" + lv_j.ToString())) == lp_vector)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            DictionaryIntSave0(true, "DHD_VectorJBNum", lv_j);
                            DictionaryVectorSave0(true, ("DHD_Vector_" + lv_j.ToString()), lp_vector);
                        }
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector已注册标签句柄
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns>返回一个Vector的已注册标签，错误返回0</returns>
        public static int DHD_ReturnVectorTag_Int(Vector2F lp_vector)
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)DictionaryIntLoad0(true, "DHD_VectorJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if (DictionaryVectorLoad0(true, "DHD_Vector_" + lv_j.ToString()) == lp_vector)
                {
                    break;
                }
                else
                {
                    if ((lv_j == lv_jBNum))
                    {
                        lv_j = 0;
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动V_注册Vector标签句柄并返回。为Vector自动设置新的标签句柄，重复时会返回已注册的Vector标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns>返回一个Vector的已注册标签</returns>
        private static string DHD_RegVectorTagAndReturn(Vector2F lp_vector)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)DictionaryIntLoad0(true, "DHD_VectorJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                DictionaryIntSave0(true, "DHD_VectorJBNum", lv_j);
                DictionaryVectorSave0(true, ("DHD_Vector_" + lv_j.ToString()), lp_vector);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if (DictionaryVectorLoad0(true, "DHD_Vector_" + lv_j.ToString()) == lp_vector)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            DictionaryIntSave0(true, "DHD_VectorJBNum", lv_j);
                            DictionaryVectorSave0(true, ("DHD_Vector_" + lv_j.ToString()), lp_vector);
                        }
                    }
                }
            }
            lv_tag = lv_j.ToString();
            //Console.WriteLine(("Tag：" + lv_tag));
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector已注册标签句柄
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns>返回一个Vector的已注册标签，错误返回""</returns>
        public static string DHD_ReturnVectorTag(Vector2F lp_vector)
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag = "";
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)DictionaryIntLoad0(true, "DHD_VectorJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if (DictionaryVectorLoad0(true, "DHD_Vector_" + lv_j.ToString()) == lp_vector)
                {
                    lv_tag = lv_j.ToString();
                    break;
                }
            }
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动V_注册Vector(高级)。在指定Key存入Vector，固有状态、自定义值是Vector独一无二的标志（本函数重复注册会刷新），之后可用互动V_"返回Vector注册总数"、"返回Vector序号"、"返回序号对应Vector"、"返回序号对应Vector标签"、"返回Vector自定义值"。Vector组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Vector组转为Key。首次注册时固有状态为true（相当于单位组单位活体），如需另外设置多个标记可使用"互动V_设定Vector状态/自定义值"
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        /// <param name="lp_inherentStats">固有状态</param>
        /// <param name="lp_inherentCustomValue">固有自定义值</param>
        public static void DHD_RegVector(Vector2F lp_vector, string lp_key, string lp_inherentStats, string lp_inherentCustomValue)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;

            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_jBNum = (int)DictionaryIntLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = DHD_RegVectorTagAndReturn(lp_vector);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                DictionaryIntSave0(true, (lv_str + "Num"), lv_i);
                DictionaryStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                DictionaryBoolSave0(true, (("DHD_IfVectorTag" + "") + "_" + lv_tagStr), true);
                DictionaryBoolSave1(true, ("DHD_IfVectorTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if (DictionaryIntLoad1(true, lv_str + "Tag", lv_i).ToString() == lv_tagStr)
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                DictionaryIntSave0(true, (lv_str + "Num"), lv_i);
                                DictionaryStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                DictionaryBoolSave0(true, (("DHD_IfVectorTag" + "") + "_" + lv_tagStr), true);
                                DictionaryBoolSave1(true, ("DHD_IfVectorTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            DictionaryStringSave0(true, ("DHD_VectorState" + "" + "_" + lv_tagStr), lp_inherentStats);
            DictionaryStringSave0(true, ("DHD_VectorCV" + "" + "_" + lv_tagStr), lp_inherentCustomValue);
        }

        /// <summary>
        /// 【MM_函数库】互动V_注册Vector。在指定Key存入Vector，固有状态、自定义值是Vector独一无二的标志（本函数重复注册不会刷新），之后可用互动V_"返回Vector注册总数"、"返回Vector序号"、"返回序号对应Vector"、"返回Vector自定义值"。Vector组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Vector组转为Key。首次注册时固有状态为true（相当于单位组单位活体），之后只能通过"互动V_注册Vector（高级）"改写，如需另外设置多个标记可使用"互动V_设定Vector状态/自定义值"
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        public static void DHD_RegVector_Simple(Vector2F lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;

            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_jBNum = (int)DictionaryIntLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = DHD_RegVectorTagAndReturn(lp_vector);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                DictionaryIntSave0(true, (lv_str + "Num"), lv_i);
                DictionaryStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                DictionaryBoolSave0(true, (("DHD_IfVectorTag" + "") + "_" + lv_tagStr), true);
                DictionaryBoolSave1(true, ("DHD_IfVectorTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if (DictionaryIntLoad1(true, lv_str + "Tag", lv_i).ToString() == lv_tagStr)
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                DictionaryIntSave0(true, (lv_str + "Num"), lv_i);
                                DictionaryStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                DictionaryBoolSave0(true, (("DHD_IfVectorTag" + "") + "_" + lv_tagStr), true);
                                DictionaryBoolSave1(true, ("DHD_IfVectorTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            if ((DictionaryBoolKeyExists(true, ("DHD_Vector" + "State" + "_" + lv_tag.ToString())) == false))
            {
                DictionaryStringSave1(true, (("DHD_Vector" + "State")), lv_tag, "true");
            }
        }

        /// <summary>
        /// 【MM_函数库】互动V_注销Vector。用"互动V_注册Vector"到Key，之后可用本函数彻底摧毁注册信息并将序号重排（包括Vector标签有效状态、固有状态及自定义值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动V_设定Vector状态"让Vector状态失效（类似单位组的单位活体状态）。Vector组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Vector组转为Key。本函数无法摧毁用"互动V_设定Vector状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Vector组变量ID时会清空Vector组专用状态
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        public static void DHD_DestroyVector(Vector2F lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag;
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_tag = DHD_ReturnVectorTag(lp_vector);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                ThreadWaitSet(true, "Key_VectorGroup" + lv_str, true);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((DictionaryIntLoad1(true, (lp_key + "VectorTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        DictionaryBoolClear0(true, "DHD_IfVectorTag_" + lv_tag);
                        DictionaryBoolClear0(true, "DHD_IfVectorTag" + lv_str + "_" + lv_tag);
                        DictionaryVectorClear0(true, "DHD_Vector_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_VectorCV_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_VectorState_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_VectorCV" + lv_str + "_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_VectorState" + lv_str + "_" + lv_tag);
                        DictionaryIntSave0(true, (lp_key + "VectorNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = DictionaryIntLoad1(true, (lp_key + "VectorTag"), lv_b + 1).ToString();
                            DictionaryStringSave1(true, (lp_key + "VectorTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                ThreadWaitSet(true, "Key_VectorGroup" + lv_str, false);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动V_移除Vector。用"互动V_注册Vector"到Key，之后可用本函数仅摧毁Key区注册的信息并将序号重排，用于Vector组或多个键区仅移除Vector（保留Vector标签有效状态、固有值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动V_设定Vector状态"让Vector状态失效（类似单位组的单位活体状态）。Vector组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Vector组转为Key。本函数无法摧毁用"互动V_设定Vector状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Vector组变量ID时会清空Vector组专用状态
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        public static void DHD_RemoveVector(Vector2F lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag;
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_tag = DHD_ReturnVectorTag(lp_vector);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                ThreadWaitSet(true, "Key_VectorGroup" + lv_str, true);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((DictionaryIntLoad1(true, (lp_key + "VectorTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        DictionaryBoolClear0(true, "DHD_IfVectorTag" + lv_str + "_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_VectorCV" + lv_str + "_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_VectorState" + lv_str + "_" + lv_tag);
                        DictionaryIntSave0(true, (lp_key + "VectorNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = DictionaryIntLoad1(true, (lp_key + "VectorTag"), lv_b + 1).ToString();
                            DictionaryStringSave1(true, (lp_key + "VectorTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                ThreadWaitSet(true, "Key_VectorGroup" + lv_str, false);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector注册总数。必须先使用"互动V_注册Vector"才能返回指定Key里的注册总数。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key。
        /// </summary>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        /// <returns></returns>
        public static int DHD_ReturnVectorNumMax(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            // Implementation
            return lv_num;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector序号。使用"互动V_注册Vector"后使用本函数可返回Key里的注册序号，Key无元素返回0，Key有元素但对象不在里面则返回-1，Vector标签尚未注册则返回-2。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        /// <returns></returns>
        public static int DHD_ReturnVectorNum(Vector2F lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_i;
            string lv_tag;
            int lv_torf;
            // Automatic Variable Declarations
            const int auto_n = 1;
            int auto_i;
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_tag = DHD_ReturnVectorTag(lp_vector);
            lv_torf = -1;
            // Implementation
            for (auto_i = 1; auto_i <= auto_n; auto_i += 1)
            {
                if ((lv_tag != null))
                {
                    lv_torf = -2;
                    break;
                }
                if ((lv_num == 0))
                {
                    lv_torf = 0;
                }
                else
                {
                    if ((lv_num >= 1))
                    {
                        auto_ae = lv_num;
                        auto_var = 1;
                        for (; auto_var <= auto_ae; auto_var += 1)
                        {
                            lv_i = auto_var;
                            if ((DictionaryIntLoad1(true, (lv_str + "Tag"), lv_i).ToString() == lv_tag))
                            {
                                lv_torf = lv_i;
                                break;
                            }
                        }
                    }
                }
            }
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回序号对应Vector。使用"互动V_注册Vector"后，在参数填入注册序号可返回Vector。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_regNum"></param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        /// <returns></returns>
        public static Vector2F DHD_ReturnVectorFromRegNum(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            lv_tag = DictionaryIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return DictionaryVectorLoad0(true, ("DHD_Vector_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回句柄标签对应Vector。使用"互动V_注册Vector"后，在参数填入句柄标签（整数）可返回Vector，标签是Vector的句柄。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_tag">句柄标签</param>
        /// <returns></returns>
        public static Vector2F DHD_ReturnVectorFromTag(int lp_tag)
        {
            // Variable Declarations
            string lv_tag;
            // Variable Initialization
            lv_tag = lp_tag.ToString();
            // Implementation
            return DictionaryVectorLoad0(true, ("DHD_Vector_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回序号对应Vector标签句柄。使用"互动V_注册Vector"后，在参数填入注册序号可返回Vector标签（字符串）。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        /// <returns></returns>
        public static string DHD_ReturnVectorTagFromRegNum_String(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            lv_tag = DictionaryIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回序号对应Vector标签句柄。使用"互动V_注册Vector"后，在参数填入注册序号可返回Vector标签（整数）。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        /// <returns></returns>
        public static int DHD_ReturnVectorTagFromRegNum_Int(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            lv_tag = DictionaryIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return Convert.ToInt32(lv_tag);
        }

        /// <summary>
        /// 【MM_函数库】互动V_设置Vector状态。必须先"注册"获得功能库内部句柄，再使用本函数给Vector设定一个状态值，之后可用"互动V_返回Vector状态"。类型参数用以记录多个不同状态，仅当"类型"参数填Vector组ID转的Vector串时，状态值"true"和"false"是Vector的Vector组专用状态值，用于内部函数筛选Vector状态（相当于单位组单位索引是否有效），其他类型不会干扰系统内部，可随意填写。虽然注销时反向清空注册信息，但用"互动V_设定Vector状态/自定义值"创建的值需要手工填入""来排泄（非大量注销则提升内存量极小，可不管）。注：固有状态值是注册函数赋予的系统内部变量（相当于单位组单位是否活体），只能通过"互动V_注册Vector（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <param name="lp_stats">状态</param>
        public static void DHD_SetVectorState(Vector2F lp_vector, string lp_key, string lp_stats)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            lv_tag = DHD_RegVectorTagAndReturn(lp_vector);
            // Implementation
            DictionaryStringSave0(true, ("DHD_VectorState" + lv_str + "_" + lv_tag), lp_stats);
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector状态。使用"互动V_设定Vector状态"后可使用本函数，将本函数参数"类型"设为空时返回固有值。类型参数用以记录多个不同状态，仅当"类型"参数为Vector组ID转的字符串时，返回的状态值"true"和"false"是Vector的Vector组专用状态值，用于内部函数筛选Vector状态（相当于单位组单位索引是否有效）
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <returns></returns>
        public static string DHD_ReturnVectorState(Vector2F lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            lv_tag = DHD_ReturnVectorTag(lp_vector);
            lv_stats = DictionaryStringLoad0(true, ("DHD_VectorState" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动V_设置Vector自定义值。必须先"注册"获得功能库内部句柄，再使用本函数设定Vector的自定义值，之后可使用"互动V_返回Vector自定义值"，类型参数用以记录多个不同自定义值。注：固有自定义值是注册函数赋予的系统内部变量，只能通过"互动V_注册Vector（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <param name="lp_customValue">自定义值</param>
        public static void DHD_SetVectorCV(Vector2F lp_vector, string lp_key, string lp_customValue)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            lv_tag = DHD_RegVectorTagAndReturn(lp_vector);
            // Implementation
            DictionaryStringSave0(true, ("DHD_VectorCV" + lv_str + "_" + lv_tag), lp_customValue);
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector自定义值。使用"互动V_设定Vector自定义值"后可使用本函数，将本函数参数"类型"设为空时返回固有值，该参数用以记录多个不同自定义值
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <returns></returns>
        public static string DHD_ReturnVectorCV(Vector2F lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            lv_tag = DHD_ReturnVectorTag(lp_vector);
            lv_customValue = DictionaryStringLoad0(true, ("DHD_VectorCV" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector固有状态。必须先使用"互动V_注册Vector"才能返回到该值，固有状态是独一无二的标记（相当于单位组单位是否活体）
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns></returns>
        public static string DHD_ReturnVectorState_Only(Vector2F lp_vector)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_tag = DHD_ReturnVectorTag(lp_vector);
            lv_stats = DictionaryStringLoad0(true, ("DHD_VectorState" + "" + "_" + lv_tag));
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector固有自定义值。必须先使用"互动V_注册Vector"才能返回到该值，固有值是独一无二的标记
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns></returns>
        public static string DHD_ReturnVectorCV_Only(Vector2F lp_vector)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_tag = DHD_ReturnVectorTag(lp_vector);
            lv_customValue = DictionaryStringLoad0(true, ("DHD_VectorCV" + "" + "_" + lv_tag));
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动V_设置Vector的实数标记。必须先"注册"获得功能库内部句柄，再使用本函数让Vector携带一个实数值，之后可使用"互动V_返回Vector的实数标记"。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_realNumTag">实数标记</param>
        public static void DHD_SetVectorDouble(Vector2F lp_vector, double lp_realNumTag)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = DHD_RegVectorTagAndReturn(lp_vector);
            // Implementation
            DictionaryDoubleSave0(true, ("DHD_CDDouble_Vector_" + lv_tag), lp_realNumTag);
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector的实数标记。使用"互动V_设定Vector的实数标记"后可使用本函数。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns></returns>
        public static double DHD_ReturnVectorDouble(Vector2F lp_vector)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = DHD_ReturnVectorTag(lp_vector);
            // Implementation
            return DictionaryDoubleLoad0(true, ("DHD_CDDouble_Vector_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector标签句柄有效状态。将Vector视作独一无二的个体，标签是它本身，有效状态则类似"单位是否有效"，当使用"互动V_注册Vector"或"互动VG_添加Vector到Vector组"后激活Vector有效状态（值为"true"），除非使用"互动V_注册Vector（高级）"改写，否则直到注销才会摧毁
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns></returns>
        public static bool DHD_ReturnIfVectorTag(Vector2F lp_vector)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = DHD_ReturnVectorTag(lp_vector);
            // Implementation
            return DictionaryBoolLoad0(true, ("DHD_IfVectorTag" + "" + "_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector注册状态。使用"互动V_注册Vector"或"互动VG_添加Vector到Vector组"后可使用本函数获取注册Vector在Key中的注册状态，该状态只能注销或从Vector组中移除时清空。Vector组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        /// <returns></returns>
        public static bool DHD_ReturnIfVectorTagKey(Vector2F lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            lv_tag = DHD_ReturnVectorTag(lp_vector);
            // Implementation
            return DictionaryBoolLoad0(true, ("DHD_IfVectorTag" + lv_str + "_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动VG_根据自定义值类型将Vector组排序。根据Vector携带的自定义值类型，对指定的Vector组元素进行冒泡排序。Vector组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Vector组名称</param>
        /// <param name="lp_cVStr">自定义值类型</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void DHD_VectorGSortCV(string lp_key, string lp_cVStr, bool lp_big)
        {
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            string lv_tagValuestr;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_VectorGroup" + lv_str, true);
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = DHD_ReturnVectorTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValuestr = DHD_ReturnVectorCV((Vector2F)DHD_ReturnVectorFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    DictionaryIntSave1(false, "IntStackOutTag", 1, lv_tag);
                    DictionaryIntSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DictionaryIntSave1(false, "IntStackOutTag", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    DictionaryIntSave1(false, "IntStackOutTagValue", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                DictionaryIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                DictionaryIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(DHD_ReturnVectorTagFromRegNum(lv_b, lp_key))+"值"+IntToString(DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DictionaryIntSave1(false, "IntStackOutTag", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DictionaryIntSave1(false, "IntStackOutTagValue", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                DictionaryIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DictionaryIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        DictionaryIntSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DictionaryIntSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = DictionaryIntLoad1(true, (lp_key + "VectorTag"), lv_a).ToString(); //原始序号元素
                lv_tag = (int)DictionaryIntLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValuestr = DHD_ReturnVectorCV((Vector2F)DHD_ReturnVectorFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    DictionaryIntSave1(true, (lp_key + "VectorTag"), lv_a, lv_tag); //lv_tag放入新序号
                    //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            ThreadWaitSet(true, "Key_VectorGroup" + lv_str, false);
        }

        /// <summary>
        /// 【MM_函数库】互动VG_Vector组排序。对指定的Vector组元素进行冒泡排序（根据元素句柄）。Vector组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Vector组名称</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void DHD_VectorGSort(string lp_key, bool lp_big)
        {
            // Automatic Variable Declarations
            // Implementation
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_VectorGroup" + lv_str, true);
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = DHD_ReturnVectorTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValue = lv_tag;
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    DictionaryIntSave1(false, "IntStackOutTag", 1, lv_tag);
                    DictionaryIntSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DictionaryIntSave1(false, "IntStackOutTag", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    DictionaryIntSave1(false, "IntStackOutTagValue", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                DictionaryIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                DictionaryIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(DHD_ReturnVectorTagFromRegNum(lv_b, lp_key))+"值"+IntToString(DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DictionaryIntSave1(false, "IntStackOutTag", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DictionaryIntSave1(false, "IntStackOutTagValue", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                DictionaryIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DictionaryIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        DictionaryIntSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DictionaryIntSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = DictionaryIntLoad1(true, (lp_key + "VectorTag"), lv_a).ToString(); //原始序号元素
                lv_tag = (int)DictionaryIntLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValue = lv_tag;
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                                                                                        //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    DictionaryIntSave1(true, (lp_key + "VectorTag"), lv_a, lv_tag); //lv_tag放入新序号
                                                                                    //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            ThreadWaitSet(true, "Key_VectorGroup" + lv_str, false);
        }

        /// <summary>
        /// 【MM_函数库】互动VG_设定Vector的Vector组专用状态。给Vector组的Vector设定一个状态值（字符串），之后可用"互动V_返回Vector、互动VG_返回Vector组的Vector状态"。状态值"true"和"false"是Vector的Vector组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效），而本函数可以重设干预，影响函数"互动VG_返回Vector组元素数量（仅检索XX状态）"。与"互动V_设定Vector状态"功能相同，只是状态参数在Vector组中被固定为"Vector组变量的内部ID"。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_vectorGroup"></param>
        /// <param name="lp_groupState"></param>
        public static void DHD_SetVectorGState(Vector2F lp_vector, string lp_vectorGroup, string lp_groupState)
        {
            DHD_SetVectorState(lp_vector, lp_vectorGroup, lp_groupState);
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector的Vector组专用状态。使用"互动V_设定Vector、互动VG_设定Vector组的Vector状态"后可使用本函数。与"互动V_返回Vector状态"功能相同，只是状态参数在Vector组中被固定为"Vector组变量的内部ID"。状态值"true"和"false"是Vector的Vector组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效）。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_vectorGroup"></param>
        public static void DHD_ReturnVectorGState(Vector2F lp_vector, string lp_vectorGroup)
        {
            DHD_ReturnVectorState(lp_vector, lp_vectorGroup);
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector组元素序号对应元素。返回Vector组元素序号指定Vector。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static Vector2F DHD_ReturnVectorFromVectorGFunc(int lp_regNum, string lp_gs)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_gs + "Vector2F");
            lv_tag = DictionaryIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return DictionaryVectorLoad0(true, ("DHD_Vector_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector组元素总数。返回指定Vector组的元素数量。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int DHD_ReturnVectorGNumMax(string lp_gs)
        {
            return DictionaryIntLoad0(true, lp_gs + "VectorNum");
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector组元素总数（仅检测Vector组专用状态="true"）。返回指定Vector组的元素数量。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int DHD_ReturnVectorGNumMax_StateTrueFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Vector2F lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = DHD_ReturnVectorNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (Vector2F)DHD_ReturnVectorFromRegNum(lv_a, lp_gs);
                lv_b = DHD_ReturnVectorState(lv_c, lp_gs);
                if ((lv_b == "true"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector组元素总数（仅检测Vector组专用状态="false"）。返回指定Vector组的元素数量。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int DHD_ReturnVectorGNumMax_StateFalseFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Vector2F lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = DHD_ReturnVectorNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (Vector2F)DHD_ReturnVectorFromRegNum(lv_a, lp_gs);
                lv_b = DHD_ReturnVectorState(lv_c, lp_gs);
                if ((lv_b == "false"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector组元素总数（仅检测Vector组无效专用状态："false"或""）。返回指定Vector组的元素数量（false、""、null）。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int DHD_ReturnVectorGNumMax_StateUselessFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Vector2F lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = DHD_ReturnVectorNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (Vector2F)DHD_ReturnVectorFromRegNum(lv_a, lp_gs);
                lv_b = DHD_ReturnVectorState(lv_c, lp_gs);
                if (((lv_b == "false") || (lv_b == "") || (lv_b == null)))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector组元素总数（仅检测Vector组指定专用状态）。返回指定Vector组的元素数量。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_State">Vector组专用状态</param>
        /// <returns></returns>
        public static int DHD_ReturnVectorGNumMax_StateFunc_Specify(string lp_gs, string lp_State)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Vector2F lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = DHD_ReturnVectorNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (Vector2F)DHD_ReturnVectorFromRegNum(lv_a, lp_gs);
                lv_b = DHD_ReturnVectorState(lv_c, lp_gs);
                if ((lv_b == lp_State))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动VG_添加Vector到Vector组。相同Vector被认为是同一个，非高级功能不提供专用状态检查，如果Vector没有设置过Vector组专用状态，那么首次添加到Vector组不会赋予"true"（之后可通过"互动V_设定Vector状态"、"互动VG_设定Vector组的Vector状态"修改）。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void DHD_AddVectorToGroup_Simple(Vector2F lp_vector, string lp_gs)
        {
            DHD_RegVector_Simple(lp_vector, lp_gs);
        }

        /// <summary>
        /// 【MM_函数库】互动VG_添加Vector到Vector组（高级）。相同Vector被认为是同一个，高级功能提供专用状态检查，如果Vector没有设置过Vector组专用状态，那么首次添加到Vector组会赋予"true"（之后可通过"互动V_设定Vector状态"、"互动VG_设定Vector组的Vector状态"修改）。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void DHD_AddVectorToGroup(Vector2F lp_vector, string lp_gs)
        {
            DHD_RegVector_Simple(lp_vector, lp_gs);
            if (DictionaryStringKeyExists(true, ("DHD_VectorState" + lp_gs + "Vector_" + DHD_RegVectorTagAndReturn(lp_vector))) == false)
            {
                DictionaryStringSave0(true, ("DHD_VectorState" + lp_gs + "Vector_" + DHD_RegVectorTagAndReturn(lp_vector)), "true");
                //Console.WriteLine(lp_gs + "=>" + DHD_RegVectorTagAndReturn(lp_vector));
            }
        }

        /// <summary>
        /// 【MM_函数库】互动VG_移除Vector组中的元素。使用"互动VG_添加Vector到Vector组"后可使用本函数进行移除元素。移除使用了"互动V_移除Vector"，同一个存储区（Vector组ID）序号重排，移除时该存储区如有其他操作会排队等待。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void DHD_ClearVectorFromGroup(Vector2F lp_vector, string lp_gs)
        {
            DHD_RemoveVector(lp_vector, lp_gs);
        }

        //互动VG_为Vector组中的每个序号
        //GE（星际2的Galaxy Editor）的宏让编辑器保存时自动生成脚本并整合进脚本进行格式调整，C#仅参考需自行编写
        // #AUTOVAR(vs, string) = "#PARAM(group)";//"#PARAM(group)"是与字段、变量名一致的元素组名称，宏去声明string类型名为“Auto随机编号_vs”的自动变量，然后=右侧字符
        // #AUTOVAR(ae) = DHD_ReturnVectorNumMax(#AUTOVAR(vs));//宏去声明默认int类型名为“Auto随机编号_ae”的自动变量，然后=右侧字符
        // #INITAUTOVAR(ai,increment)//宏去声明int类型名为“Auto随机编号_ai”的自动变量，用于下面for循环增量（increment是传入参数）
        // #PARAM(var) = #PARAM(s);//#PARAM(var)是传进来的参数，用作“当前被挑选到的元素”（任意变量-整数 lp_var）， #PARAM(s)是传进来的参数用作"开始"（int lp_s）
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #PARAM(var) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #PARAM(var) >= #AUTOVAR(ae)) ) ; #PARAM(var) += #AUTOVAR(ai) ) {
        //     #SUBFUNCS(actions)//代表用户GUI填写的所有动作
        // }

        /// <summary>
        /// 【MM_函数库】互动VG_为Vector组中的每个序号。每次挑选的元素序号会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素序号，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void DHD_ForEachVectorNumFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            int lv_ae = DHD_ReturnVectorNumMax(lp_gs);
            int lv_var = lp_start;
            int lv_ai = lp_increment;
            for (; (lv_ai >= 0 && lv_var <= lv_ae) || (lv_ai < 0 && lv_var >= lv_ae); lv_var += lv_ai)
            {
                lp_funcref(lv_var);//用户填写的所有动作
            }
        }

        //互动VG_为Vector组中的每个元素
        // #AUTOVAR(vs, string) = "#PARAM(group)";
        // #AUTOVAR(ae) = DHD_ReturnVectorNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= #PARAM(s);
        // #INITAUTOVAR(ai,increment)
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     DictionarySave(false, "VectorGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)), DHD_ReturnVectorFromRegNum(#AUTOVAR(va),#AUTOVAR(vs)));
        // }
        // #AUTOVAR(va)= #PARAM(s);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #PARAM(var) = DictionaryLoad(false, "VectorGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)));
        //     #SUBFUNCS(actions)
        // }

        /// <summary>
        /// 【MM_函数库】互动VG_为Vector组中的每个元素。每次挑选的元素会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void DHD_ForEachVectorFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            string lv_vs = lp_gs;
            int lv_ae = DHD_ReturnVectorNumMax(lv_vs);
            int lv_va = lp_start;
            int lv_ai = lp_increment;
            Vector2F lv_vector;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                DictionaryVectorSave0(false, "VectorGFor" + lv_vs + lv_va.ToString(), (Vector2F)DHD_ReturnVectorFromRegNum(lv_va, lv_vs));
            }
            lv_va = lp_start;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                lv_vector = (Vector2F)DictionaryVectorLoad0(false, "VectorGFor" + lv_vs + lv_va.ToString());
                lp_funcref(lv_vector);//用户填写的所有动作
            }
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector组中随机元素。返回指定Vector组中的随机Vector。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static Vector2F DHD_ReturnRandomVectorFromVectorGFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_num;
            int lv_a;
            Vector2F lv_c = new Vector2F(0, 0);
            // Variable Initialization
            lv_num = DHD_ReturnVectorNumMax(lp_gs);
            // Implementation
            if ((lv_num >= 1))
            {
                lv_a = RandomInt(1, lv_num);
                lv_c = (Vector2F)DHD_ReturnVectorFromRegNum(lv_a, lp_gs);
            }
            return lv_c;
        }

        //互动VG_添加Vector组到Vector组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = DHD_ReturnVectorNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = DHD_ReturnVectorFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     DHD_AddVectorToGroup(#AUTOVAR(var), #AUTOVAR(vsb));
        // }


        /// <summary>
        /// 【MM_函数库】互动VG_添加Vector组到Vector组。添加一个Vector组A的元素到另一个Vector组B，相同Vector被认为是同一个。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void DHD_AddVectorGToVectorG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = DHD_ReturnVectorNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            Vector2F lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = (Vector2F)DHD_ReturnVectorFromRegNum(lv_va, lv_vsa);
                DHD_AddVectorToGroup(lv_var, lv_vsb);
            }
        }

        //互动VG_从Vector组移除Vector组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = DHD_ReturnVectorNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = DHD_ReturnVectorFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     DHD_RemoveVector(#AUTOVAR(var), #AUTOVAR(vsb));
        // }

        /// <summary>
        /// 【MM_函数库】互动VG_从Vector组移除Vector组。将Vector组A的元素从Vector组B中移除，相同Vector被认为是同一个。移除使用了"互动V_移除Vector"，同一个存储区（Vector组ID）序号重排，移除时该存储区如有其他操作会排队等待。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void DHD_ClearVectorGFromVectorG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = DHD_ReturnVectorNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            Vector2F lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = (Vector2F)DHD_ReturnVectorFromRegNum(lv_va, lv_vsa);
                DHD_RemoveVector(lv_var, lv_vsb);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动VG_移除Vector组全部元素。将Vector组（Key区）存储的元素全部移除，相同Vector被认为是同一个。移除时同一个存储区（Vector组ID）序号不进行重排，但该存储区如有其他操作会排队等待。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Vector组名称</param>
        public static void DHD_RemoveVectorGAll(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag = "";
            int lv_a;
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            // Implementation
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_VectorGroup" + lv_str, true);
            for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
            {
                lv_tag = DictionaryIntLoad1(true, (lp_key + "VectorTag"), lv_a).ToString();
                lv_num -= 1;
                DictionaryBoolClear0(true, "DHD_IfVectorTag" + lv_str + "_" + lv_tag);
                DictionaryStringClear0(true, "DHD_VectorCV" + lv_str + "_" + lv_tag);
                DictionaryStringClear0(true, "DHD_VectorState" + lv_str + "_" + lv_tag);
                DictionaryIntSave0(true, (lp_key + "VectorNum"), lv_num);
            }
            ThreadWaitSet(true, "Key_VectorGroup" + lv_str, false);
        }

        //--------------------------------------------------------------------------------------------------
        // 二维向量组End
        //--------------------------------------------------------------------------------------------------

        #endregion

        #region 计时器

        //提示：尽可能使用对口类型，以防值类型与引用类型发生转换时拆装箱降低性能

        //--------------------------------------------------------------------------------------------------
        // 计时器组Start
        //--------------------------------------------------------------------------------------------------

        /// <summary>
        /// 【MM_函数库】互动T_注册Timer标签句柄并返回。为Timer自动设置新的标签句柄，重复时会返回已注册的Timer标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns>返回一个Timer的已注册标签</returns>
        private static int DHD_RegTimerTagAndReturn_Int(Timer lp_timer)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)DictionaryIntLoad0(true, "DHD_TimerJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                DictionaryIntSave0(true, "DHD_TimerJBNum", lv_j);
                DictionaryTimerSave0(true, ("DHD_Timer_" + lv_j.ToString()), lp_timer);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if (DictionaryTimerLoad0(true, ("DHD_Timer_" + lv_j.ToString())) == lp_timer)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            DictionaryIntSave0(true, "DHD_TimerJBNum", lv_j);
                            DictionaryTimerSave0(true, ("DHD_Timer_" + lv_j.ToString()), lp_timer);
                        }
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer已注册标签句柄
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns>返回一个Timer的已注册标签，错误返回0</returns>
        public static int DHD_ReturnTimerTag_Int(Timer lp_timer)
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)DictionaryIntLoad0(true, "DHD_TimerJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if (DictionaryTimerLoad0(true, "DHD_Timer_" + lv_j.ToString()) == lp_timer)
                {
                    break;
                }
                else
                {
                    if ((lv_j == lv_jBNum))
                    {
                        lv_j = 0;
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动T_注册Timer标签句柄并返回。为Timer自动设置新的标签句柄，重复时会返回已注册的Timer标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns>返回一个Timer的已注册标签</returns>
        private static string DHD_RegTimerTagAndReturn(Timer lp_timer)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)DictionaryIntLoad0(true, "DHD_TimerJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                DictionaryIntSave0(true, "DHD_TimerJBNum", lv_j);
                DictionaryTimerSave0(true, ("DHD_Timer_" + lv_j.ToString()), lp_timer);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if (DictionaryTimerLoad0(true, "DHD_Timer_" + lv_j.ToString()) == lp_timer)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            DictionaryIntSave0(true, "DHD_TimerJBNum", lv_j);
                            DictionaryTimerSave0(true, ("DHD_Timer_" + lv_j.ToString()), lp_timer);
                        }
                    }
                }
            }
            lv_tag = lv_j.ToString();
            //Console.WriteLine(("Tag：" + lv_tag));
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer已注册标签句柄
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns>返回一个Timer的已注册标签，错误返回""</returns>
        public static string DHD_ReturnTimerTag(Timer lp_timer)
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag = "";
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)DictionaryIntLoad0(true, "DHD_TimerJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if (DictionaryTimerLoad0(true, "DHD_Timer_" + lv_j.ToString()) == lp_timer)
                {
                    lv_tag = lv_j.ToString();
                    break;
                }
            }
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动T_注册Timer(高级)。在指定Key存入Timer，固有状态、自定义值是Timer独一无二的标志（本函数重复注册会刷新），之后可用互动T_"返回Timer注册总数"、"返回Timer序号"、"返回序号对应Timer"、"返回序号对应Timer标签"、"返回Timer自定义值"。Timer组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Timer组转为Key。首次注册时固有状态为true（相当于单位组单位活体），如需另外设置多个标记可使用"互动T_设定Timer状态/自定义值"
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        /// <param name="lp_inherentStats">固有状态</param>
        /// <param name="lp_inherentCustomValue">固有自定义值</param>
        public static void DHD_RegTimer(Timer lp_timer, string lp_key, string lp_inherentStats, string lp_inherentCustomValue)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;

            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_jBNum = (int)DictionaryIntLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = DHD_RegTimerTagAndReturn(lp_timer);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                DictionaryIntSave0(true, (lv_str + "Num"), lv_i);
                DictionaryStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                DictionaryBoolSave0(true, (("DHD_IfTimerTag" + "") + "_" + lv_tagStr), true);
                DictionaryBoolSave1(true, ("DHD_IfTimerTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if (DictionaryIntLoad1(true, lv_str + "Tag", lv_i).ToString() == lv_tagStr)
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                DictionaryIntSave0(true, (lv_str + "Num"), lv_i);
                                DictionaryStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                DictionaryBoolSave0(true, (("DHD_IfTimerTag" + "") + "_" + lv_tagStr), true);
                                DictionaryBoolSave1(true, ("DHD_IfTimerTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            DictionaryStringSave0(true, ("DHD_TimerState" + "" + "_" + lv_tagStr), lp_inherentStats);
            DictionaryStringSave0(true, ("DHD_TimerCV" + "" + "_" + lv_tagStr), lp_inherentCustomValue);
        }

        /// <summary>
        /// 【MM_函数库】互动T_注册Timer。在指定Key存入Timer，固有状态、自定义值是Timer独一无二的标志（本函数重复注册不会刷新），之后可用互动T_"返回Timer注册总数"、"返回Timer序号"、"返回序号对应Timer"、"返回Timer自定义值"。Timer组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Timer组转为Key。首次注册时固有状态为true（相当于单位组单位活体），之后只能通过"互动T_注册Timer（高级）"改写，如需另外设置多个标记可使用"互动T_设定Timer状态/自定义值"
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        public static void DHD_RegTimer_Simple(Timer lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;

            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_jBNum = (int)DictionaryIntLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = DHD_RegTimerTagAndReturn(lp_timer);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                DictionaryIntSave0(true, (lv_str + "Num"), lv_i);
                DictionaryStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                DictionaryBoolSave0(true, (("DHD_IfTimerTag" + "") + "_" + lv_tagStr), true);
                DictionaryBoolSave1(true, ("DHD_IfTimerTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if (DictionaryIntLoad1(true, lv_str + "Tag", lv_i).ToString() == lv_tagStr)
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                DictionaryIntSave0(true, (lv_str + "Num"), lv_i);
                                DictionaryStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                DictionaryBoolSave0(true, (("DHD_IfTimerTag" + "") + "_" + lv_tagStr), true);
                                DictionaryBoolSave1(true, ("DHD_IfTimerTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            if ((DictionaryBoolKeyExists(true, ("DHD_Timer" + "State" + "_" + lv_tag.ToString())) == false))
            {
                DictionaryStringSave1(true, (("DHD_Timer" + "State")), lv_tag, "true");
            }
        }

        /// <summary>
        /// 【MM_函数库】互动T_注销Timer。用"互动T_注册Timer"到Key，之后可用本函数彻底摧毁注册信息并将序号重排（包括Timer标签有效状态、固有状态及自定义值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动T_设定Timer状态"让Timer状态失效（类似单位组的单位活体状态）。Timer组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Timer组转为Key。本函数无法摧毁用"互动T_设定Timer状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Timer组变量ID时会清空Timer组专用状态
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        public static void DHD_DestroyTimer(Timer lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag;
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_tag = DHD_ReturnTimerTag(lp_timer);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                ThreadWaitSet(true, "Key_TimerGroup" + lv_str, true);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((DictionaryIntLoad1(true, (lp_key + "TimerTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        DictionaryBoolClear0(true, "DHD_IfTimerTag_" + lv_tag);
                        DictionaryBoolClear0(true, "DHD_IfTimerTag" + lv_str + "_" + lv_tag);
                        DictionaryTimerClear0(true, "DHD_Timer_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_TimerCV_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_TimerState_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_TimerCV" + lv_str + "_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_TimerState" + lv_str + "_" + lv_tag);
                        DictionaryIntSave0(true, (lp_key + "TimerNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = DictionaryIntLoad1(true, (lp_key + "TimerTag"), lv_b + 1).ToString();
                            DictionaryStringSave1(true, (lp_key + "TimerTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                ThreadWaitSet(true, "Key_TimerGroup" + lv_str, false);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动T_移除Timer。用"互动T_注册Timer"到Key，之后可用本函数仅摧毁Key区注册的信息并将序号重排，用于Timer组或多个键区仅移除Timer（保留Timer标签有效状态、固有值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动T_设定Timer状态"让Timer状态失效（类似单位组的单位活体状态）。Timer组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Timer组转为Key。本函数无法摧毁用"互动T_设定Timer状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Timer组变量ID时会清空Timer组专用状态
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        public static void DHD_RemoveTimer(Timer lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag;
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_tag = DHD_ReturnTimerTag(lp_timer);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                ThreadWaitSet(true, "Key_TimerGroup" + lv_str, true);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((DictionaryIntLoad1(true, (lp_key + "TimerTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        DictionaryBoolClear0(true, "DHD_IfTimerTag" + lv_str + "_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_TimerCV" + lv_str + "_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_TimerState" + lv_str + "_" + lv_tag);
                        DictionaryIntSave0(true, (lp_key + "TimerNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = DictionaryIntLoad1(true, (lp_key + "TimerTag"), lv_b + 1).ToString();
                            DictionaryStringSave1(true, (lp_key + "TimerTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                ThreadWaitSet(true, "Key_TimerGroup" + lv_str, false);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer注册总数。必须先使用"互动T_注册Timer"才能返回指定Key里的注册总数。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key。
        /// </summary>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        /// <returns></returns>
        public static int DHD_ReturnTimerNumMax(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            // Implementation
            return lv_num;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer序号。使用"互动T_注册Timer"后使用本函数可返回Key里的注册序号，Key无元素返回0，Key有元素但对象不在里面则返回-1，Timer标签尚未注册则返回-2。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        /// <returns></returns>
        public static int DHD_ReturnTimerNum(Timer lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_i;
            string lv_tag;
            int lv_torf;
            // Automatic Variable Declarations
            const int auto_n = 1;
            int auto_i;
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_tag = DHD_ReturnTimerTag(lp_timer);
            lv_torf = -1;
            // Implementation
            for (auto_i = 1; auto_i <= auto_n; auto_i += 1)
            {
                if ((lv_tag != null))
                {
                    lv_torf = -2;
                    break;
                }
                if ((lv_num == 0))
                {
                    lv_torf = 0;
                }
                else
                {
                    if ((lv_num >= 1))
                    {
                        auto_ae = lv_num;
                        auto_var = 1;
                        for (; auto_var <= auto_ae; auto_var += 1)
                        {
                            lv_i = auto_var;
                            if ((DictionaryIntLoad1(true, (lv_str + "Tag"), lv_i).ToString() == lv_tag))
                            {
                                lv_torf = lv_i;
                                break;
                            }
                        }
                    }
                }
            }
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回序号对应Timer。使用"互动T_注册Timer"后，在参数填入注册序号可返回Timer。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_regNum"></param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        /// <returns></returns>
        public static Timer DHD_ReturnTimerFromRegNum(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = DictionaryIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return DictionaryTimerLoad0(true, ("DHD_Timer_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回句柄标签对应Timer。使用"互动T_注册Timer"后，在参数填入句柄标签（整数）可返回Timer，标签是Timer的句柄。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_tag">句柄标签</param>
        /// <returns></returns>
        public static Timer DHD_ReturnTimerFromTag(int lp_tag)
        {
            // Variable Declarations
            string lv_tag;
            // Variable Initialization
            lv_tag = lp_tag.ToString();
            // Implementation
            return DictionaryTimerLoad0(true, ("DHD_Timer_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回序号对应Timer标签句柄。使用"互动T_注册Timer"后，在参数填入注册序号可返回Timer标签（字符串）。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        /// <returns></returns>
        public static string DHD_ReturnTimerTagFromRegNum_String(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = DictionaryIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回序号对应Timer标签句柄。使用"互动T_注册Timer"后，在参数填入注册序号可返回Timer标签（整数）。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        /// <returns></returns>
        public static int DHD_ReturnTimerTagFromRegNum_Int(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = DictionaryIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return Convert.ToInt32(lv_tag);
        }

        /// <summary>
        /// 【MM_函数库】互动T_设置Timer状态。必须先"注册"获得功能库内部句柄，再使用本函数给Timer设定一个状态值，之后可用"互动T_返回Timer状态"。类型参数用以记录多个不同状态，仅当"类型"参数填Timer组ID转的Timer串时，状态值"true"和"false"是Timer的Timer组专用状态值，用于内部函数筛选Timer状态（相当于单位组单位索引是否有效），其他类型不会干扰系统内部，可随意填写。虽然注销时反向清空注册信息，但用"互动T_设定Timer状态/自定义值"创建的值需要手工填入""来排泄（非大量注销则提升内存量极小，可不管）。注：固有状态值是注册函数赋予的系统内部变量（相当于单位组单位是否活体），只能通过"互动T_注册Timer（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <param name="lp_stats">状态</param>
        public static void DHD_SetTimerState(Timer lp_timer, string lp_key, string lp_stats)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = DHD_RegTimerTagAndReturn(lp_timer);
            // Implementation
            DictionaryStringSave0(true, ("DHD_TimerState" + lv_str + "_" + lv_tag), lp_stats);
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer状态。使用"互动T_设定Timer状态"后可使用本函数，将本函数参数"类型"设为空时返回固有值。类型参数用以记录多个不同状态，仅当"类型"参数为Timer组ID转的字符串时，返回的状态值"true"和"false"是Timer的Timer组专用状态值，用于内部函数筛选Timer状态（相当于单位组单位索引是否有效）
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <returns></returns>
        public static string DHD_ReturnTimerState(Timer lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = DHD_ReturnTimerTag(lp_timer);
            lv_stats = DictionaryStringLoad0(true, ("DHD_TimerState" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动T_设置Timer自定义值。必须先"注册"获得功能库内部句柄，再使用本函数设定Timer的自定义值，之后可使用"互动T_返回Timer自定义值"，类型参数用以记录多个不同自定义值。注：固有自定义值是注册函数赋予的系统内部变量，只能通过"互动T_注册Timer（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <param name="lp_customValue">自定义值</param>
        public static void DHD_SetTimerCV(Timer lp_timer, string lp_key, string lp_customValue)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = DHD_RegTimerTagAndReturn(lp_timer);
            // Implementation
            DictionaryStringSave0(true, ("DHD_TimerCV" + lv_str + "_" + lv_tag), lp_customValue);
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer自定义值。使用"互动T_设定Timer自定义值"后可使用本函数，将本函数参数"类型"设为空时返回固有值，该参数用以记录多个不同自定义值
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <returns></returns>
        public static string DHD_ReturnTimerCV(Timer lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = DHD_ReturnTimerTag(lp_timer);
            lv_customValue = DictionaryStringLoad0(true, ("DHD_TimerCV" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer固有状态。必须先使用"互动T_注册Timer"才能返回到该值，固有状态是独一无二的标记（相当于单位组单位是否活体）
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns></returns>
        public static string DHD_ReturnTimerState_Only(Timer lp_timer)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_tag = DHD_ReturnTimerTag(lp_timer);
            lv_stats = DictionaryStringLoad0(true, ("DHD_TimerState" + "" + "_" + lv_tag));
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer固有自定义值。必须先使用"互动T_注册Timer"才能返回到该值，固有值是独一无二的标记
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns></returns>
        public static string DHD_ReturnTimerCV_Only(Timer lp_timer)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_tag = DHD_ReturnTimerTag(lp_timer);
            lv_customValue = DictionaryStringLoad0(true, ("DHD_TimerCV" + "" + "_" + lv_tag));
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动T_设置Timer的实数标记。必须先"注册"获得功能库内部句柄，再使用本函数让Timer携带一个实数值，之后可使用"互动T_返回Timer的实数标记"。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_realNumTag">实数标记</param>
        public static void DHD_SetTimerDouble(Timer lp_timer, double lp_realNumTag)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = DHD_RegTimerTagAndReturn(lp_timer);
            // Implementation
            DictionaryDoubleSave0(true, ("DHD_CDDouble_Timer_" + lv_tag), lp_realNumTag);
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer的实数标记。使用"互动T_设定Timer的实数标记"后可使用本函数。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns></returns>
        public static double DHD_ReturnTimerDouble(Timer lp_timer)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = DHD_ReturnTimerTag(lp_timer);
            // Implementation
            return DictionaryDoubleLoad0(true, ("DHD_CDDouble_Timer_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer标签句柄有效状态。将Timer视作独一无二的个体，标签是它本身，有效状态则类似"单位是否有效"，当使用"互动T_注册Timer"或"互动TG_添加Timer到Timer组"后激活Timer有效状态（值为"true"），除非使用"互动T_注册Timer（高级）"改写，否则直到注销才会摧毁
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns></returns>
        public static bool DHD_ReturnIfTimerTag(Timer lp_timer)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = DHD_ReturnTimerTag(lp_timer);
            // Implementation
            return DictionaryBoolLoad0(true, ("DHD_IfTimerTag" + "" + "_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer注册状态。使用"互动T_注册Timer"或"互动TG_添加Timer到Timer组"后可使用本函数获取注册Timer在Key中的注册状态，该状态只能注销或从Timer组中移除时清空。Timer组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        /// <returns></returns>
        public static bool DHD_ReturnIfTimerTagKey(Timer lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = DHD_ReturnTimerTag(lp_timer);
            // Implementation
            return DictionaryBoolLoad0(true, ("DHD_IfTimerTag" + lv_str + "_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动TG_根据自定义值类型将Timer组排序。根据Timer携带的自定义值类型，对指定的Timer组元素进行冒泡排序。Timer组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Timer组名称</param>
        /// <param name="lp_cVStr">自定义值类型</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void DHD_TimerGSortCV(string lp_key, string lp_cVStr, bool lp_big)
        {
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            string lv_tagValuestr;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_TimerGroup" + lv_str, true);
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = DHD_ReturnTimerTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValuestr = DHD_ReturnTimerCV((Timer)DHD_ReturnTimerFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    DictionaryIntSave1(false, "IntStackOutTag", 1, lv_tag);
                    DictionaryIntSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DictionaryIntSave1(false, "IntStackOutTag", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    DictionaryIntSave1(false, "IntStackOutTagValue", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                DictionaryIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                DictionaryIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(DHD_ReturnTimerTagFromRegNum(lv_b, lp_key))+"值"+IntToString(DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DictionaryIntSave1(false, "IntStackOutTag", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DictionaryIntSave1(false, "IntStackOutTagValue", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                DictionaryIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DictionaryIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        DictionaryIntSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DictionaryIntSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = DictionaryIntLoad1(true, (lp_key + "TimerTag"), lv_a).ToString(); //原始序号元素
                lv_tag = (int)DictionaryIntLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValuestr = DHD_ReturnTimerCV((Timer)DHD_ReturnTimerFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    DictionaryIntSave1(true, (lp_key + "TimerTag"), lv_a, lv_tag); //lv_tag放入新序号
                    //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            ThreadWaitSet(true, "Key_TimerGroup" + lv_str, false);
        }

        /// <summary>
        /// 【MM_函数库】互动TG_Timer组排序。对指定的Timer组元素进行冒泡排序（根据元素句柄）。Timer组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Timer组名称</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void DHD_TimerGSort(string lp_key, bool lp_big)
        {
            // Automatic Variable Declarations
            // Implementation
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_TimerGroup" + lv_str, true);
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = DHD_ReturnTimerTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValue = lv_tag;
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    DictionaryIntSave1(false, "IntStackOutTag", 1, lv_tag);
                    DictionaryIntSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DictionaryIntSave1(false, "IntStackOutTag", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    DictionaryIntSave1(false, "IntStackOutTagValue", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                DictionaryIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                DictionaryIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(DHD_ReturnTimerTagFromRegNum(lv_b, lp_key))+"值"+IntToString(DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DictionaryIntSave1(false, "IntStackOutTag", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DictionaryIntSave1(false, "IntStackOutTagValue", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                DictionaryIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DictionaryIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        DictionaryIntSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DictionaryIntSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = DictionaryIntLoad1(true, (lp_key + "TimerTag"), lv_a).ToString(); //原始序号元素
                lv_tag = (int)DictionaryIntLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValue = lv_tag;
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                                                                                        //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    DictionaryIntSave1(true, (lp_key + "TimerTag"), lv_a, lv_tag); //lv_tag放入新序号
                                                                                   //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            ThreadWaitSet(true, "Key_TimerGroup" + lv_str, false);
        }

        /// <summary>
        /// 【MM_函数库】互动TG_设定Timer的Timer组专用状态。给Timer组的Timer设定一个状态值（字符串），之后可用"互动T_返回Timer、互动TG_返回Timer组的Timer状态"。状态值"true"和"false"是Timer的Timer组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效），而本函数可以重设干预，影响函数"互动TG_返回Timer组元素数量（仅检索XX状态）"。与"互动T_设定Timer状态"功能相同，只是状态参数在Timer组中被固定为"Timer组变量的内部ID"。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_timerGroup"></param>
        /// <param name="lp_groupState"></param>
        public static void DHD_SetTimerGState(Timer lp_timer, string lp_timerGroup, string lp_groupState)
        {
            DHD_SetTimerState(lp_timer, lp_timerGroup, lp_groupState);
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer的Timer组专用状态。使用"互动T_设定Timer、互动TG_设定Timer组的Timer状态"后可使用本函数。与"互动T_返回Timer状态"功能相同，只是状态参数在Timer组中被固定为"Timer组变量的内部ID"。状态值"true"和"false"是Timer的Timer组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效）。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_timerGroup"></param>
        public static void DHD_ReturnTimerGState(Timer lp_timer, string lp_timerGroup)
        {
            DHD_ReturnTimerState(lp_timer, lp_timerGroup);
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer组元素序号对应元素。返回Timer组元素序号指定Timer。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static Timer DHD_ReturnTimerFromTimerGFunc(int lp_regNum, string lp_gs)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_gs + "Timer");
            lv_tag = DictionaryIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return DictionaryTimerLoad0(true, ("DHD_Timer_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer组元素总数。返回指定Timer组的元素数量。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int DHD_ReturnTimerGNumMax(string lp_gs)
        {
            return DictionaryIntLoad0(true, lp_gs + "TimerNum");
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer组元素总数（仅检测Timer组专用状态="true"）。返回指定Timer组的元素数量。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int DHD_ReturnTimerGNumMax_StateTrueFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Timer lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = DHD_ReturnTimerNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (Timer)DHD_ReturnTimerFromRegNum(lv_a, lp_gs);
                lv_b = DHD_ReturnTimerState(lv_c, lp_gs);
                if ((lv_b == "true"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer组元素总数（仅检测Timer组专用状态="false"）。返回指定Timer组的元素数量。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int DHD_ReturnTimerGNumMax_StateFalseFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Timer lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = DHD_ReturnTimerNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (Timer)DHD_ReturnTimerFromRegNum(lv_a, lp_gs);
                lv_b = DHD_ReturnTimerState(lv_c, lp_gs);
                if ((lv_b == "false"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer组元素总数（仅检测Timer组无效专用状态："false"或""）。返回指定Timer组的元素数量（false、""、null）。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int DHD_ReturnTimerGNumMax_StateUselessFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Timer lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = DHD_ReturnTimerNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (Timer)DHD_ReturnTimerFromRegNum(lv_a, lp_gs);
                lv_b = DHD_ReturnTimerState(lv_c, lp_gs);
                if (((lv_b == "false") || (lv_b == "") || (lv_b == null)))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer组元素总数（仅检测Timer组指定专用状态）。返回指定Timer组的元素数量。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_State">Timer组专用状态</param>
        /// <returns></returns>
        public static int DHD_ReturnTimerGNumMax_StateFunc_Specify(string lp_gs, string lp_State)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Timer lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = DHD_ReturnTimerNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (Timer)DHD_ReturnTimerFromRegNum(lv_a, lp_gs);
                lv_b = DHD_ReturnTimerState(lv_c, lp_gs);
                if ((lv_b == lp_State))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动TG_添加Timer到Timer组。相同Timer被认为是同一个，非高级功能不提供专用状态检查，如果Timer没有设置过Timer组专用状态，那么首次添加到Timer组不会赋予"true"（之后可通过"互动T_设定Timer状态"、"互动TG_设定Timer组的Timer状态"修改）。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void DHD_AddTimerToGroup_Simple(Timer lp_timer, string lp_gs)
        {
            DHD_RegTimer_Simple(lp_timer, lp_gs);
        }

        /// <summary>
        /// 【MM_函数库】互动TG_添加Timer到Timer组（高级）。相同Timer被认为是同一个，高级功能提供专用状态检查，如果Timer没有设置过Timer组专用状态，那么首次添加到Timer组会赋予"true"（之后可通过"互动T_设定Timer状态"、"互动TG_设定Timer组的Timer状态"修改）。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void DHD_AddTimerToGroup(Timer lp_timer, string lp_gs)
        {
            DHD_RegTimer_Simple(lp_timer, lp_gs);
            if (DictionaryStringKeyExists(true, ("DHD_TimerState" + lp_gs + "Timer_" + DHD_RegTimerTagAndReturn(lp_timer))) == false)
            {
                DictionaryStringSave0(true, ("DHD_TimerState" + lp_gs + "Timer_" + DHD_RegTimerTagAndReturn(lp_timer)), "true");
                //Console.WriteLine(lp_gs + "=>" + DHD_RegTimerTagAndReturn(lp_timer));
            }
        }

        /// <summary>
        /// 【MM_函数库】互动TG_移除Timer组中的元素。使用"互动TG_添加Timer到Timer组"后可使用本函数进行移除元素。移除使用了"互动T_移除Timer"，同一个存储区（Timer组ID）序号重排，移除时该存储区如有其他操作会排队等待。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void DHD_ClearTimerFromGroup(Timer lp_timer, string lp_gs)
        {
            DHD_RemoveTimer(lp_timer, lp_gs);
        }

        //互动TG_为Timer组中的每个序号
        //GE（星际2的Galaxy Editor）的宏让编辑器保存时自动生成脚本并整合进脚本进行格式调整，C#仅参考需自行编写
        // #AUTOVAR(vs, string) = "#PARAM(group)";//"#PARAM(group)"是与字段、变量名一致的元素组名称，宏去声明string类型名为“Auto随机编号_vs”的自动变量，然后=右侧字符
        // #AUTOVAR(ae) = DHD_ReturnTimerNumMax(#AUTOVAR(vs));//宏去声明默认int类型名为“Auto随机编号_ae”的自动变量，然后=右侧字符
        // #INITAUTOVAR(ai,increment)//宏去声明int类型名为“Auto随机编号_ai”的自动变量，用于下面for循环增量（increment是传入参数）
        // #PARAM(var) = #PARAM(s);//#PARAM(var)是传进来的参数，用作“当前被挑选到的元素”（任意变量-整数 lp_var）， #PARAM(s)是传进来的参数用作"开始"（int lp_s）
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #PARAM(var) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #PARAM(var) >= #AUTOVAR(ae)) ) ; #PARAM(var) += #AUTOVAR(ai) ) {
        //     #SUBFUNCS(actions)//代表用户GUI填写的所有动作
        // }

        /// <summary>
        /// 【MM_函数库】互动TG_为Timer组中的每个序号。每次挑选的元素序号会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素序号，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void DHD_ForEachTimerNumFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            int lv_ae = DHD_ReturnTimerNumMax(lp_gs);
            int lv_var = lp_start;
            int lv_ai = lp_increment;
            for (; (lv_ai >= 0 && lv_var <= lv_ae) || (lv_ai < 0 && lv_var >= lv_ae); lv_var += lv_ai)
            {
                lp_funcref(lv_var);//用户填写的所有动作
            }
        }

        //互动TG_为Timer组中的每个元素
        // #AUTOVAR(vs, string) = "#PARAM(group)";
        // #AUTOVAR(ae) = DHD_ReturnTimerNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= #PARAM(s);
        // #INITAUTOVAR(ai,increment)
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     DictionarySave(false, "TimerGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)), DHD_ReturnTimerFromRegNum(#AUTOVAR(va),#AUTOVAR(vs)));
        // }
        // #AUTOVAR(va)= #PARAM(s);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #PARAM(var) = DictionaryLoad(false, "TimerGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)));
        //     #SUBFUNCS(actions)
        // }

        /// <summary>
        /// 【MM_函数库】互动TG_为Timer组中的每个元素。每次挑选的元素会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void DHD_ForEachTimerFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            string lv_vs = lp_gs;
            int lv_ae = DHD_ReturnTimerNumMax(lv_vs);
            int lv_va = lp_start;
            int lv_ai = lp_increment;
            Timer lv_timer;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                DictionaryTimerSave0(false, "TimerGFor" + lv_vs + lv_va.ToString(), (Timer)DHD_ReturnTimerFromRegNum(lv_va, lv_vs));
            }
            lv_va = lp_start;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                lv_timer = (Timer)DictionaryTimerLoad0(false, "TimerGFor" + lv_vs + lv_va.ToString());
                lp_funcref(lv_timer);//用户填写的所有动作
            }
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer组中随机元素。返回指定Timer组中的随机Timer。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static Timer DHD_ReturnRandomTimerFromTimerGFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_num;
            int lv_a;
            Timer lv_c = null;
            // Variable Initialization
            lv_num = DHD_ReturnTimerNumMax(lp_gs);
            // Implementation
            if ((lv_num >= 1))
            {
                lv_a = RandomInt(1, lv_num);
                lv_c = (Timer)DHD_ReturnTimerFromRegNum(lv_a, lp_gs);
            }
            return lv_c;
        }

        //互动TG_添加Timer组到Timer组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = DHD_ReturnTimerNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = DHD_ReturnTimerFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     DHD_AddTimerToGroup(#AUTOVAR(var), #AUTOVAR(vsb));
        // }


        /// <summary>
        /// 【MM_函数库】互动TG_添加Timer组到Timer组。添加一个Timer组A的元素到另一个Timer组B，相同Timer被认为是同一个。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void DHD_AddTimerGToTimerG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = DHD_ReturnTimerNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            Timer lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = (Timer)DHD_ReturnTimerFromRegNum(lv_va, lv_vsa);
                DHD_AddTimerToGroup(lv_var, lv_vsb);
            }
        }

        //互动TG_从Timer组移除Timer组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = DHD_ReturnTimerNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = DHD_ReturnTimerFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     DHD_RemoveTimer(#AUTOVAR(var), #AUTOVAR(vsb));
        // }

        /// <summary>
        /// 【MM_函数库】互动TG_从Timer组移除Timer组。将Timer组A的元素从Timer组B中移除，相同Timer被认为是同一个。移除使用了"互动T_移除Timer"，同一个存储区（Timer组ID）序号重排，移除时该存储区如有其他操作会排队等待。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void DHD_ClearTimerGFromTimerG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = DHD_ReturnTimerNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            Timer lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = (Timer)DHD_ReturnTimerFromRegNum(lv_va, lv_vsa);
                DHD_RemoveTimer(lv_var, lv_vsb);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动TG_移除Timer组全部元素。将Timer组（Key区）存储的元素全部移除，相同Timer被认为是同一个。移除时同一个存储区（Timer组ID）序号不进行重排，但该存储区如有其他操作会排队等待。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Timer组名称</param>
        public static void DHD_RemoveTimerGAll(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag = "";
            int lv_a;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            // Implementation
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_TimerGroup" + lv_str, true);
            for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
            {
                lv_tag = DictionaryIntLoad1(true, (lp_key + "TimerTag"), lv_a).ToString();
                lv_num -= 1;
                DictionaryBoolClear0(true, "DHD_IfTimerTag" + lv_str + "_" + lv_tag);
                DictionaryStringClear0(true, "DHD_TimerCV" + lv_str + "_" + lv_tag);
                DictionaryStringClear0(true, "DHD_TimerState" + lv_str + "_" + lv_tag);
                DictionaryIntSave0(true, (lp_key + "TimerNum"), lv_num);
            }
            ThreadWaitSet(true, "Key_TimerGroup" + lv_str, false);
        }

        //--------------------------------------------------------------------------------------------------
        // 计时器组End
        //--------------------------------------------------------------------------------------------------

        #endregion

        #region 字符串

        //提示：尽可能使用对口类型，以防值类型与引用类型发生转换时拆装箱降低性能

        //--------------------------------------------------------------------------------------------------
        // 字符串组Start
        //--------------------------------------------------------------------------------------------------

        /// <summary>
        /// 【MM_函数库】互动S_注册String标签句柄并返回。为String自动设置新的标签句柄，重复时会返回已注册的String标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns>返回一个String的已注册标签</returns>
        private static int DHD_RegStringTagAndReturn_Int(string lp_timer)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)DictionaryIntLoad0(true, "DHD_StringJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                DictionaryIntSave0(true, "DHD_StringJBNum", lv_j);
                DictionaryStringSave0(true, ("DHD_String_" + lv_j.ToString()), lp_timer);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if (DictionaryStringLoad0(true, ("DHD_String_" + lv_j.ToString())) == lp_timer)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            DictionaryIntSave0(true, "DHD_StringJBNum", lv_j);
                            DictionaryStringSave0(true, ("DHD_String_" + lv_j.ToString()), lp_timer);
                        }
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String已注册标签句柄
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns>返回一个String的已注册标签，错误返回0</returns>
        public static int DHD_ReturnStringTag_Int(string lp_timer)
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)DictionaryIntLoad0(true, "DHD_StringJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if (DictionaryStringLoad0(true, "DHD_String_" + lv_j.ToString()) == lp_timer)
                {
                    break;
                }
                else
                {
                    if ((lv_j == lv_jBNum))
                    {
                        lv_j = 0;
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动S_注册String标签句柄并返回。为String自动设置新的标签句柄，重复时会返回已注册的String标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns>返回一个String的已注册标签</returns>
        private static string DHD_RegStringTagAndReturn(string lp_timer)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)DictionaryIntLoad0(true, "DHD_StringJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                DictionaryIntSave0(true, "DHD_StringJBNum", lv_j);
                DictionaryStringSave0(true, ("DHD_String_" + lv_j.ToString()), lp_timer);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if (DictionaryStringLoad0(true, "DHD_String_" + lv_j.ToString()) == lp_timer)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            DictionaryIntSave0(true, "DHD_StringJBNum", lv_j);
                            DictionaryStringSave0(true, ("DHD_String_" + lv_j.ToString()), lp_timer);
                        }
                    }
                }
            }
            lv_tag = lv_j.ToString();
            //Console.WriteLine(("Tag：" + lv_tag));
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String已注册标签句柄
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns>返回一个String的已注册标签，错误返回""</returns>
        public static string DHD_ReturnStringTag(string lp_timer)
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag = "";
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)DictionaryIntLoad0(true, "DHD_StringJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if (DictionaryStringLoad0(true, "DHD_String_" + lv_j.ToString()) == lp_timer)
                {
                    lv_tag = lv_j.ToString();
                    break;
                }
            }
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动S_注册String(高级)。在指定Key存入String，固有状态、自定义值是String独一无二的标志（本函数重复注册会刷新），之后可用互动S_"返回String注册总数"、"返回String序号"、"返回序号对应String"、"返回序号对应String标签"、"返回String自定义值"。String组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将String组转为Key。首次注册时固有状态为true（相当于单位组单位活体），如需另外设置多个标记可使用"互动S_设定String状态/自定义值"
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        /// <param name="lp_inherentStats">固有状态</param>
        /// <param name="lp_inherentCustomValue">固有自定义值</param>
        public static void DHD_RegString(string lp_timer, string lp_key, string lp_inherentStats, string lp_inherentCustomValue)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;

            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_jBNum = (int)DictionaryIntLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = DHD_RegStringTagAndReturn(lp_timer);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                DictionaryIntSave0(true, (lv_str + "Num"), lv_i);
                DictionaryStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                DictionaryBoolSave0(true, (("DHD_IfStringTag" + "") + "_" + lv_tagStr), true);
                DictionaryBoolSave1(true, ("DHD_IfStringTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if (DictionaryIntLoad1(true, lv_str + "Tag", lv_i).ToString() == lv_tagStr)
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                DictionaryIntSave0(true, (lv_str + "Num"), lv_i);
                                DictionaryStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                DictionaryBoolSave0(true, (("DHD_IfStringTag" + "") + "_" + lv_tagStr), true);
                                DictionaryBoolSave1(true, ("DHD_IfStringTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            DictionaryStringSave0(true, ("DHD_StringState" + "" + "_" + lv_tagStr), lp_inherentStats);
            DictionaryStringSave0(true, ("DHD_StringCV" + "" + "_" + lv_tagStr), lp_inherentCustomValue);
        }

        /// <summary>
        /// 【MM_函数库】互动S_注册String。在指定Key存入String，固有状态、自定义值是String独一无二的标志（本函数重复注册不会刷新），之后可用互动S_"返回String注册总数"、"返回String序号"、"返回序号对应String"、"返回String自定义值"。String组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将String组转为Key。首次注册时固有状态为true（相当于单位组单位活体），之后只能通过"互动S_注册String（高级）"改写，如需另外设置多个标记可使用"互动S_设定String状态/自定义值"
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        public static void DHD_RegString_Simple(string lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;

            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_jBNum = (int)DictionaryIntLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = DHD_RegStringTagAndReturn(lp_timer);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                DictionaryIntSave0(true, (lv_str + "Num"), lv_i);
                DictionaryStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                DictionaryBoolSave0(true, (("DHD_IfStringTag" + "") + "_" + lv_tagStr), true);
                DictionaryBoolSave1(true, ("DHD_IfStringTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if (DictionaryIntLoad1(true, lv_str + "Tag", lv_i).ToString() == lv_tagStr)
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                DictionaryIntSave0(true, (lv_str + "Num"), lv_i);
                                DictionaryStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                DictionaryBoolSave0(true, (("DHD_IfStringTag" + "") + "_" + lv_tagStr), true);
                                DictionaryBoolSave1(true, ("DHD_IfStringTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            if ((DictionaryBoolKeyExists(true, ("DHD_String" + "State" + "_" + lv_tag.ToString())) == false))
            {
                DictionaryStringSave1(true, (("DHD_String" + "State")), lv_tag, "true");
            }
        }

        /// <summary>
        /// 【MM_函数库】互动S_注销String。用"互动S_注册String"到Key，之后可用本函数彻底摧毁注册信息并将序号重排（包括String标签有效状态、固有状态及自定义值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动S_设定String状态"让String状态失效（类似单位组的单位活体状态）。String组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将String组转为Key。本函数无法摧毁用"互动S_设定String状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填String组变量ID时会清空String组专用状态
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        public static void DHD_DestroyString(string lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag;
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_tag = DHD_ReturnStringTag(lp_timer);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                ThreadWaitSet(true, "Key_StringGroup" + lv_str, true);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((DictionaryIntLoad1(true, (lp_key + "StringTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        DictionaryBoolClear0(true, "DHD_IfStringTag_" + lv_tag);
                        DictionaryBoolClear0(true, "DHD_IfStringTag" + lv_str + "_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_String_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_StringCV_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_StringState_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_StringCV" + lv_str + "_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_StringState" + lv_str + "_" + lv_tag);
                        DictionaryIntSave0(true, (lp_key + "StringNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = DictionaryIntLoad1(true, (lp_key + "StringTag"), lv_b + 1).ToString();
                            DictionaryStringSave1(true, (lp_key + "StringTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                ThreadWaitSet(true, "Key_StringGroup" + lv_str, false);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动S_移除String。用"互动S_注册String"到Key，之后可用本函数仅摧毁Key区注册的信息并将序号重排，用于String组或多个键区仅移除String（保留String标签有效状态、固有值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动S_设定String状态"让String状态失效（类似单位组的单位活体状态）。String组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将String组转为Key。本函数无法摧毁用"互动S_设定String状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填String组变量ID时会清空String组专用状态
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        public static void DHD_RemoveString(string lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag;
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_tag = DHD_ReturnStringTag(lp_timer);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                ThreadWaitSet(true, "Key_StringGroup" + lv_str, true);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((DictionaryIntLoad1(true, (lp_key + "StringTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        DictionaryBoolClear0(true, "DHD_IfStringTag" + lv_str + "_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_StringCV" + lv_str + "_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_StringState" + lv_str + "_" + lv_tag);
                        DictionaryIntSave0(true, (lp_key + "StringNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = DictionaryIntLoad1(true, (lp_key + "StringTag"), lv_b + 1).ToString();
                            DictionaryStringSave1(true, (lp_key + "StringTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                ThreadWaitSet(true, "Key_StringGroup" + lv_str, false);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String注册总数。必须先使用"互动S_注册String"才能返回指定Key里的注册总数。String组使用时，可用"获取变量的内部名称"将String组转为Key。
        /// </summary>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        /// <returns></returns>
        public static int DHD_ReturnStringNumMax(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            // Implementation
            return lv_num;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String序号。使用"互动S_注册String"后使用本函数可返回Key里的注册序号，Key无元素返回0，Key有元素但对象不在里面则返回-1，String标签尚未注册则返回-2。String组使用时，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        /// <returns></returns>
        public static int DHD_ReturnStringNum(string lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_i;
            string lv_tag;
            int lv_torf;
            // Automatic Variable Declarations
            const int auto_n = 1;
            int auto_i;
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_tag = DHD_ReturnStringTag(lp_timer);
            lv_torf = -1;
            // Implementation
            for (auto_i = 1; auto_i <= auto_n; auto_i += 1)
            {
                if ((lv_tag != null))
                {
                    lv_torf = -2;
                    break;
                }
                if ((lv_num == 0))
                {
                    lv_torf = 0;
                }
                else
                {
                    if ((lv_num >= 1))
                    {
                        auto_ae = lv_num;
                        auto_var = 1;
                        for (; auto_var <= auto_ae; auto_var += 1)
                        {
                            lv_i = auto_var;
                            if ((DictionaryIntLoad1(true, (lv_str + "Tag"), lv_i).ToString() == lv_tag))
                            {
                                lv_torf = lv_i;
                                break;
                            }
                        }
                    }
                }
            }
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回序号对应String。使用"互动S_注册String"后，在参数填入注册序号可返回String。String组使用时，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_regNum"></param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        /// <returns></returns>
        public static string DHD_ReturnStringFromRegNum(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = DictionaryIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return DictionaryStringLoad0(true, ("DHD_String_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回句柄标签对应String。使用"互动S_注册String"后，在参数填入句柄标签（整数）可返回String，标签是String的句柄。String组使用时，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_tag">句柄标签</param>
        /// <returns></returns>
        public static string DHD_ReturnStringFromTag(int lp_tag)
        {
            // Variable Declarations
            string lv_tag;
            // Variable Initialization
            lv_tag = lp_tag.ToString();
            // Implementation
            return DictionaryStringLoad0(true, ("DHD_String_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回序号对应String标签句柄。使用"互动S_注册String"后，在参数填入注册序号可返回String标签（字符串）。String组使用时，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        /// <returns></returns>
        public static string DHD_ReturnStringTagFromRegNum_String(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = DictionaryIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回序号对应String标签句柄。使用"互动S_注册String"后，在参数填入注册序号可返回String标签（整数）。String组使用时，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        /// <returns></returns>
        public static int DHD_ReturnStringTagFromRegNum_Int(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = DictionaryIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return Convert.ToInt32(lv_tag);
        }

        /// <summary>
        /// 【MM_函数库】互动S_设置String状态。必须先"注册"获得功能库内部句柄，再使用本函数给String设定一个状态值，之后可用"互动S_返回String状态"。类型参数用以记录多个不同状态，仅当"类型"参数填String组ID转的String串时，状态值"true"和"false"是String的String组专用状态值，用于内部函数筛选String状态（相当于单位组单位索引是否有效），其他类型不会干扰系统内部，可随意填写。虽然注销时反向清空注册信息，但用"互动S_设定String状态/自定义值"创建的值需要手工填入""来排泄（非大量注销则提升内存量极小，可不管）。注：固有状态值是注册函数赋予的系统内部变量（相当于单位组单位是否活体），只能通过"互动S_注册String（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <param name="lp_stats">状态</param>
        public static void DHD_SetStringState(string lp_timer, string lp_key, string lp_stats)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = DHD_RegStringTagAndReturn(lp_timer);
            // Implementation
            DictionaryStringSave0(true, ("DHD_StringState" + lv_str + "_" + lv_tag), lp_stats);
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String状态。使用"互动S_设定String状态"后可使用本函数，将本函数参数"类型"设为空时返回固有值。类型参数用以记录多个不同状态，仅当"类型"参数为String组ID转的字符串时，返回的状态值"true"和"false"是String的String组专用状态值，用于内部函数筛选String状态（相当于单位组单位索引是否有效）
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <returns></returns>
        public static string DHD_ReturnStringState(string lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = DHD_ReturnStringTag(lp_timer);
            lv_stats = DictionaryStringLoad0(true, ("DHD_StringState" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动S_设置String自定义值。必须先"注册"获得功能库内部句柄，再使用本函数设定String的自定义值，之后可使用"互动S_返回String自定义值"，类型参数用以记录多个不同自定义值。注：固有自定义值是注册函数赋予的系统内部变量，只能通过"互动S_注册String（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <param name="lp_customValue">自定义值</param>
        public static void DHD_SetStringCV(string lp_timer, string lp_key, string lp_customValue)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = DHD_RegStringTagAndReturn(lp_timer);
            // Implementation
            DictionaryStringSave0(true, ("DHD_StringCV" + lv_str + "_" + lv_tag), lp_customValue);
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String自定义值。使用"互动S_设定String自定义值"后可使用本函数，将本函数参数"类型"设为空时返回固有值，该参数用以记录多个不同自定义值
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <returns></returns>
        public static string DHD_ReturnStringCV(string lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = DHD_ReturnStringTag(lp_timer);
            lv_customValue = DictionaryStringLoad0(true, ("DHD_StringCV" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String固有状态。必须先使用"互动S_注册String"才能返回到该值，固有状态是独一无二的标记（相当于单位组单位是否活体）
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns></returns>
        public static string DHD_ReturnStringState_Only(string lp_timer)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_tag = DHD_ReturnStringTag(lp_timer);
            lv_stats = DictionaryStringLoad0(true, ("DHD_StringState" + "" + "_" + lv_tag));
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String固有自定义值。必须先使用"互动S_注册String"才能返回到该值，固有值是独一无二的标记
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns></returns>
        public static string DHD_ReturnStringCV_Only(string lp_timer)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_tag = DHD_ReturnStringTag(lp_timer);
            lv_customValue = DictionaryStringLoad0(true, ("DHD_StringCV" + "" + "_" + lv_tag));
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动S_设置String的实数标记。必须先"注册"获得功能库内部句柄，再使用本函数让String携带一个实数值，之后可使用"互动S_返回String的实数标记"。String组使用时，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_realNumTag">实数标记</param>
        public static void DHD_SetStringDouble(string lp_timer, double lp_realNumTag)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = DHD_RegStringTagAndReturn(lp_timer);
            // Implementation
            DictionaryDoubleSave0(true, ("DHD_CDDouble_String_" + lv_tag), lp_realNumTag);
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String的实数标记。使用"互动S_设定String的实数标记"后可使用本函数。String组使用时，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns></returns>
        public static double DHD_ReturnStringDouble(string lp_timer)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = DHD_ReturnStringTag(lp_timer);
            // Implementation
            return DictionaryDoubleLoad0(true, ("DHD_CDDouble_String_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String标签句柄有效状态。将String视作独一无二的个体，标签是它本身，有效状态则类似"单位是否有效"，当使用"互动S_注册String"或"互动SG_添加String到String组"后激活String有效状态（值为"true"），除非使用"互动S_注册String（高级）"改写，否则直到注销才会摧毁
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns></returns>
        public static bool DHD_ReturnIfStringTag(string lp_timer)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = DHD_ReturnStringTag(lp_timer);
            // Implementation
            return DictionaryBoolLoad0(true, ("DHD_IfStringTag" + "" + "_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String注册状态。使用"互动S_注册String"或"互动SG_添加String到String组"后可使用本函数获取注册String在Key中的注册状态，该状态只能注销或从String组中移除时清空。String组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        /// <returns></returns>
        public static bool DHD_ReturnIfStringTagKey(string lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = DHD_ReturnStringTag(lp_timer);
            // Implementation
            return DictionaryBoolLoad0(true, ("DHD_IfStringTag" + lv_str + "_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动SG_根据自定义值类型将String组排序。根据String携带的自定义值类型，对指定的String组元素进行冒泡排序。String组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填String组名称</param>
        /// <param name="lp_cVStr">自定义值类型</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void DHD_StringGSortCV(string lp_key, string lp_cVStr, bool lp_big)
        {
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            string lv_tagValuestr;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "String");
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_StringGroup" + lv_str, true);
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = DHD_ReturnStringTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValuestr = DHD_ReturnStringCV((string)DHD_ReturnStringFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    DictionaryIntSave1(false, "IntStackOutTag", 1, lv_tag);
                    DictionaryIntSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DictionaryIntSave1(false, "IntStackOutTag", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    DictionaryIntSave1(false, "IntStackOutTagValue", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                DictionaryIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                DictionaryIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(DHD_ReturnStringTagFromRegNum(lv_b, lp_key))+"值"+IntToString(DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DictionaryIntSave1(false, "IntStackOutTag", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DictionaryIntSave1(false, "IntStackOutTagValue", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                DictionaryIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DictionaryIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        DictionaryIntSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DictionaryIntSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = DictionaryIntLoad1(true, (lp_key + "StringTag"), lv_a).ToString(); //原始序号元素
                lv_tag = (int)DictionaryIntLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValuestr = DHD_ReturnStringCV((string)DHD_ReturnStringFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    DictionaryIntSave1(true, (lp_key + "StringTag"), lv_a, lv_tag); //lv_tag放入新序号
                    //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            ThreadWaitSet(true, "Key_StringGroup" + lv_str, false);
        }

        /// <summary>
        /// 【MM_函数库】互动SG_String组排序。对指定的String组元素进行冒泡排序（根据元素句柄）。String组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填String组名称</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void DHD_StringGSort(string lp_key, bool lp_big)
        {
            // Automatic Variable Declarations
            // Implementation
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "String");
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_StringGroup" + lv_str, true);
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = DHD_ReturnStringTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValue = lv_tag;
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    DictionaryIntSave1(false, "IntStackOutTag", 1, lv_tag);
                    DictionaryIntSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DictionaryIntSave1(false, "IntStackOutTag", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    DictionaryIntSave1(false, "IntStackOutTagValue", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                DictionaryIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                DictionaryIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(DHD_ReturnStringTagFromRegNum(lv_b, lp_key))+"值"+IntToString(DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DictionaryIntSave1(false, "IntStackOutTag", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DictionaryIntSave1(false, "IntStackOutTagValue", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                DictionaryIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DictionaryIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        DictionaryIntSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DictionaryIntSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = DictionaryIntLoad1(true, (lp_key + "StringTag"), lv_a).ToString(); //原始序号元素
                lv_tag = (int)DictionaryIntLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValue = lv_tag;
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                                                                                        //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    DictionaryIntSave1(true, (lp_key + "StringTag"), lv_a, lv_tag); //lv_tag放入新序号
                                                                                    //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            ThreadWaitSet(true, "Key_StringGroup" + lv_str, false);
        }

        /// <summary>
        /// 【MM_函数库】互动SG_设定String的String组专用状态。给String组的String设定一个状态值（字符串），之后可用"互动S_返回String、互动SG_返回String组的String状态"。状态值"true"和"false"是String的String组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效），而本函数可以重设干预，影响函数"互动SG_返回String组元素数量（仅检索XX状态）"。与"互动S_设定String状态"功能相同，只是状态参数在String组中被固定为"String组变量的内部ID"。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_timerGroup"></param>
        /// <param name="lp_groupState"></param>
        public static void DHD_SetStringGState(string lp_timer, string lp_timerGroup, string lp_groupState)
        {
            DHD_SetStringState(lp_timer, lp_timerGroup, lp_groupState);
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String的String组专用状态。使用"互动S_设定String、互动SG_设定String组的String状态"后可使用本函数。与"互动S_返回String状态"功能相同，只是状态参数在String组中被固定为"String组变量的内部ID"。状态值"true"和"false"是String的String组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效）。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_timerGroup"></param>
        public static void DHD_ReturnStringGState(string lp_timer, string lp_timerGroup)
        {
            DHD_ReturnStringState(lp_timer, lp_timerGroup);
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String组元素序号对应元素。返回String组元素序号指定String。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static string DHD_ReturnStringFromStringGFunc(int lp_regNum, string lp_gs)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_gs + "String");
            lv_tag = DictionaryIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return DictionaryStringLoad0(true, ("DHD_String_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String组元素总数。返回指定String组的元素数量。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int DHD_ReturnStringGNumMax(string lp_gs)
        {
            return DictionaryIntLoad0(true, lp_gs + "StringNum");
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String组元素总数（仅检测String组专用状态="true"）。返回指定String组的元素数量。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int DHD_ReturnStringGNumMax_StateTrueFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            string lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = DHD_ReturnStringNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (string)DHD_ReturnStringFromRegNum(lv_a, lp_gs);
                lv_b = DHD_ReturnStringState(lv_c, lp_gs);
                if ((lv_b == "true"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String组元素总数（仅检测String组专用状态="false"）。返回指定String组的元素数量。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int DHD_ReturnStringGNumMax_StateFalseFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            string lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = DHD_ReturnStringNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (string)DHD_ReturnStringFromRegNum(lv_a, lp_gs);
                lv_b = DHD_ReturnStringState(lv_c, lp_gs);
                if ((lv_b == "false"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String组元素总数（仅检测String组无效专用状态："false"或""）。返回指定String组的元素数量（false、""、null）。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int DHD_ReturnStringGNumMax_StateUselessFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            string lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = DHD_ReturnStringNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (string)DHD_ReturnStringFromRegNum(lv_a, lp_gs);
                lv_b = DHD_ReturnStringState(lv_c, lp_gs);
                if (((lv_b == "false") || (lv_b == "") || (lv_b == null)))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String组元素总数（仅检测String组指定专用状态）。返回指定String组的元素数量。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_State">String组专用状态</param>
        /// <returns></returns>
        public static int DHD_ReturnStringGNumMax_StateFunc_Specify(string lp_gs, string lp_State)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            string lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = DHD_ReturnStringNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (string)DHD_ReturnStringFromRegNum(lv_a, lp_gs);
                lv_b = DHD_ReturnStringState(lv_c, lp_gs);
                if ((lv_b == lp_State))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动SG_添加String到String组。相同String被认为是同一个，非高级功能不提供专用状态检查，如果String没有设置过String组专用状态，那么首次添加到String组不会赋予"true"（之后可通过"互动S_设定String状态"、"互动SG_设定String组的String状态"修改）。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void DHD_AddStringToGroup_Simple(string lp_timer, string lp_gs)
        {
            DHD_RegString_Simple(lp_timer, lp_gs);
        }

        /// <summary>
        /// 【MM_函数库】互动SG_添加String到String组（高级）。相同String被认为是同一个，高级功能提供专用状态检查，如果String没有设置过String组专用状态，那么首次添加到String组会赋予"true"（之后可通过"互动S_设定String状态"、"互动SG_设定String组的String状态"修改）。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void DHD_AddStringToGroup(string lp_timer, string lp_gs)
        {
            DHD_RegString_Simple(lp_timer, lp_gs);
            if (DictionaryStringKeyExists(true, ("DHD_StringState" + lp_gs + "String_" + DHD_RegStringTagAndReturn(lp_timer))) == false)
            {
                DictionaryStringSave0(true, ("DHD_StringState" + lp_gs + "String_" + DHD_RegStringTagAndReturn(lp_timer)), "true");
                //Console.WriteLine(lp_gs + "=>" + DHD_RegStringTagAndReturn(lp_timer));
            }
        }

        /// <summary>
        /// 【MM_函数库】互动SG_移除String组中的元素。使用"互动SG_添加String到String组"后可使用本函数进行移除元素。移除使用了"互动S_移除String"，同一个存储区（String组ID）序号重排，移除时该存储区如有其他操作会排队等待。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void DHD_ClearStringFromGroup(string lp_timer, string lp_gs)
        {
            DHD_RemoveString(lp_timer, lp_gs);
        }

        //互动SG_为String组中的每个序号
        //GE（星际2的Galaxy Editor）的宏让编辑器保存时自动生成脚本并整合进脚本进行格式调整，C#仅参考需自行编写
        // #AUTOVAR(vs, string) = "#PARAM(group)";//"#PARAM(group)"是与字段、变量名一致的元素组名称，宏去声明string类型名为“Auto随机编号_vs”的自动变量，然后=右侧字符
        // #AUTOVAR(ae) = DHD_ReturnStringNumMax(#AUTOVAR(vs));//宏去声明默认int类型名为“Auto随机编号_ae”的自动变量，然后=右侧字符
        // #INITAUTOVAR(ai,increment)//宏去声明int类型名为“Auto随机编号_ai”的自动变量，用于下面for循环增量（increment是传入参数）
        // #PARAM(var) = #PARAM(s);//#PARAM(var)是传进来的参数，用作“当前被挑选到的元素”（任意变量-整数 lp_var）， #PARAM(s)是传进来的参数用作"开始"（int lp_s）
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #PARAM(var) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #PARAM(var) >= #AUTOVAR(ae)) ) ; #PARAM(var) += #AUTOVAR(ai) ) {
        //     #SUBFUNCS(actions)//代表用户GUI填写的所有动作
        // }

        /// <summary>
        /// 【MM_函数库】互动SG_为String组中的每个序号。每次挑选的元素序号会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素序号，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void DHD_ForEachStringNumFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            int lv_ae = DHD_ReturnStringNumMax(lp_gs);
            int lv_var = lp_start;
            int lv_ai = lp_increment;
            for (; (lv_ai >= 0 && lv_var <= lv_ae) || (lv_ai < 0 && lv_var >= lv_ae); lv_var += lv_ai)
            {
                lp_funcref(lv_var);//用户填写的所有动作
            }
        }

        //互动SG_为String组中的每个元素
        // #AUTOVAR(vs, string) = "#PARAM(group)";
        // #AUTOVAR(ae) = DHD_ReturnStringNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= #PARAM(s);
        // #INITAUTOVAR(ai,increment)
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     DictionarySave(false, "StringGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)), DHD_ReturnStringFromRegNum(#AUTOVAR(va),#AUTOVAR(vs)));
        // }
        // #AUTOVAR(va)= #PARAM(s);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #PARAM(var) = DictionaryLoad(false, "StringGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)));
        //     #SUBFUNCS(actions)
        // }

        /// <summary>
        /// 【MM_函数库】互动SG_为String组中的每个元素。每次挑选的元素会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void DHD_ForEachStringFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            string lv_vs = lp_gs;
            int lv_ae = DHD_ReturnStringNumMax(lv_vs);
            int lv_va = lp_start;
            int lv_ai = lp_increment;
            string lv_timer;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                DictionaryStringSave0(false, "StringGFor" + lv_vs + lv_va.ToString(), (string)DHD_ReturnStringFromRegNum(lv_va, lv_vs));
            }
            lv_va = lp_start;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                lv_timer = (string)DictionaryStringLoad0(false, "StringGFor" + lv_vs + lv_va.ToString());
                lp_funcref(lv_timer);//用户填写的所有动作
            }
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String组中随机元素。返回指定String组中的随机String。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static string DHD_ReturnRandomStringFromStringGFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_num;
            int lv_a;
            string lv_c = null;
            // Variable Initialization
            lv_num = DHD_ReturnStringNumMax(lp_gs);
            // Implementation
            if ((lv_num >= 1))
            {
                lv_a = RandomInt(1, lv_num);
                lv_c = (string)DHD_ReturnStringFromRegNum(lv_a, lp_gs);
            }
            return lv_c;
        }

        //互动SG_添加String组到String组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = DHD_ReturnStringNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = DHD_ReturnStringFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     DHD_AddStringToGroup(#AUTOVAR(var), #AUTOVAR(vsb));
        // }


        /// <summary>
        /// 【MM_函数库】互动SG_添加String组到String组。添加一个String组A的元素到另一个String组B，相同String被认为是同一个。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void DHD_AddStringGToStringG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = DHD_ReturnStringNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            string lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = (string)DHD_ReturnStringFromRegNum(lv_va, lv_vsa);
                DHD_AddStringToGroup(lv_var, lv_vsb);
            }
        }

        //互动SG_从String组移除String组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = DHD_ReturnStringNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = DHD_ReturnStringFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     DHD_RemoveString(#AUTOVAR(var), #AUTOVAR(vsb));
        // }

        /// <summary>
        /// 【MM_函数库】互动SG_从String组移除String组。将String组A的元素从String组B中移除，相同String被认为是同一个。移除使用了"互动S_移除String"，同一个存储区（String组ID）序号重排，移除时该存储区如有其他操作会排队等待。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void DHD_ClearStringGFromStringG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = DHD_ReturnStringNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            string lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = (string)DHD_ReturnStringFromRegNum(lv_va, lv_vsa);
                DHD_RemoveString(lv_var, lv_vsb);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动SG_移除String组全部元素。将String组（Key区）存储的元素全部移除，相同String被认为是同一个。移除时同一个存储区（String组ID）序号不进行重排，但该存储区如有其他操作会排队等待。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_key">存储键区，默认填String组名称</param>
        public static void DHD_RemoveStringGAll(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag = "";
            int lv_a;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            // Implementation
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_StringGroup" + lv_str, true);
            for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
            {
                lv_tag = DictionaryIntLoad1(true, (lp_key + "StringTag"), lv_a).ToString();
                lv_num -= 1;
                DictionaryBoolClear0(true, "DHD_IfStringTag" + lv_str + "_" + lv_tag);
                DictionaryStringClear0(true, "DHD_StringCV" + lv_str + "_" + lv_tag);
                DictionaryStringClear0(true, "DHD_StringState" + lv_str + "_" + lv_tag);
                DictionaryIntSave0(true, (lp_key + "StringNum"), lv_num);
            }
            ThreadWaitSet(true, "Key_StringGroup" + lv_str, false);
        }

        //--------------------------------------------------------------------------------------------------
        // 字符串组End
        //--------------------------------------------------------------------------------------------------

        #endregion

        #region 数字

        //提示：尽可能使用对口类型，以防值类型与引用类型发生转换时拆装箱降低性能

        //--------------------------------------------------------------------------------------------------
        // 数字组Start
        //--------------------------------------------------------------------------------------------------

        /// <summary>
        /// 【MM_函数库】互动I_注册Int标签句柄并返回。为Int自动设置新的标签句柄，重复时会返回已注册的Int标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns>返回一个Int的已注册标签</returns>
        private static int DHD_RegIntTagAndReturn_Int(int lp_vector)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)DictionaryIntLoad0(true, "DHD_IntJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                DictionaryIntSave0(true, "DHD_IntJBNum", lv_j);
                DictionaryIntSave0(true, ("DHD_Int_" + lv_j.ToString()), lp_vector);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if (DictionaryIntLoad0(true, ("DHD_Int_" + lv_j.ToString())) == lp_vector)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            DictionaryIntSave0(true, "DHD_IntJBNum", lv_j);
                            DictionaryIntSave0(true, ("DHD_Int_" + lv_j.ToString()), lp_vector);
                        }
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Int已注册标签句柄
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns>返回一个Int的已注册标签，错误返回0</returns>
        public static int DHD_ReturnIntTag_Int(int lp_vector)
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)DictionaryIntLoad0(true, "DHD_IntJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if (DictionaryIntLoad0(true, "DHD_Int_" + lv_j.ToString()) == lp_vector)
                {
                    break;
                }
                else
                {
                    if ((lv_j == lv_jBNum))
                    {
                        lv_j = 0;
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动I_注册Int标签句柄并返回。为Int自动设置新的标签句柄，重复时会返回已注册的Int标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns>返回一个Int的已注册标签</returns>
        private static string DHD_RegIntTagAndReturn(int lp_vector)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)DictionaryIntLoad0(true, "DHD_IntJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                DictionaryIntSave0(true, "DHD_IntJBNum", lv_j);
                DictionaryIntSave0(true, ("DHD_Int_" + lv_j.ToString()), lp_vector);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if (DictionaryIntLoad0(true, "DHD_Int_" + lv_j.ToString()) == lp_vector)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            DictionaryIntSave0(true, "DHD_IntJBNum", lv_j);
                            DictionaryIntSave0(true, ("DHD_Int_" + lv_j.ToString()), lp_vector);
                        }
                    }
                }
            }
            lv_tag = lv_j.ToString();
            //Console.WriteLine(("Tag：" + lv_tag));
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Int已注册标签句柄
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns>返回一个Int的已注册标签，错误返回""</returns>
        public static string DHD_ReturnIntTag(int lp_vector)
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag = "";
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)DictionaryIntLoad0(true, "DHD_IntJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if (DictionaryIntLoad0(true, "DHD_Int_" + lv_j.ToString()) == lp_vector)
                {
                    lv_tag = lv_j.ToString();
                    break;
                }
            }
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动I_注册Int(高级)。在指定Key存入Int，固有状态、自定义值是Int独一无二的标志（本函数重复注册会刷新），之后可用互动I_"返回Int注册总数"、"返回Int序号"、"返回序号对应Int"、"返回序号对应Int标签"、"返回Int自定义值"。Int组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Int组转为Key。首次注册时固有状态为true（相当于单位组单位活体），如需另外设置多个标记可使用"互动I_设定Int状态/自定义值"
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Int"</param>
        /// <param name="lp_inherentStats">固有状态</param>
        /// <param name="lp_inherentCustomValue">固有自定义值</param>
        public static void DHD_RegInt(int lp_vector, string lp_key, string lp_inherentStats, string lp_inherentCustomValue)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;

            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_jBNum = (int)DictionaryIntLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = DHD_RegIntTagAndReturn(lp_vector);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                DictionaryIntSave0(true, (lv_str + "Num"), lv_i);
                DictionaryStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                DictionaryBoolSave0(true, (("DHD_IfIntTag" + "") + "_" + lv_tagStr), true);
                DictionaryBoolSave1(true, ("DHD_IfIntTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if (DictionaryIntLoad1(true, lv_str + "Tag", lv_i).ToString() == lv_tagStr)
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                DictionaryIntSave0(true, (lv_str + "Num"), lv_i);
                                DictionaryStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                DictionaryBoolSave0(true, (("DHD_IfIntTag" + "") + "_" + lv_tagStr), true);
                                DictionaryBoolSave1(true, ("DHD_IfIntTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            DictionaryStringSave0(true, ("DHD_IntState" + "" + "_" + lv_tagStr), lp_inherentStats);
            DictionaryStringSave0(true, ("DHD_IntCV" + "" + "_" + lv_tagStr), lp_inherentCustomValue);
        }

        /// <summary>
        /// 【MM_函数库】互动I_注册Int。在指定Key存入Int，固有状态、自定义值是Int独一无二的标志（本函数重复注册不会刷新），之后可用互动I_"返回Int注册总数"、"返回Int序号"、"返回序号对应Int"、"返回Int自定义值"。Int组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Int组转为Key。首次注册时固有状态为true（相当于单位组单位活体），之后只能通过"互动I_注册Int（高级）"改写，如需另外设置多个标记可使用"互动I_设定Int状态/自定义值"
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Int"</param>
        public static void DHD_RegInt_Simple(int lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;

            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_jBNum = (int)DictionaryIntLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = DHD_RegIntTagAndReturn(lp_vector);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                DictionaryIntSave0(true, (lv_str + "Num"), lv_i);
                DictionaryStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                DictionaryBoolSave0(true, (("DHD_IfIntTag" + "") + "_" + lv_tagStr), true);
                DictionaryBoolSave1(true, ("DHD_IfIntTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if (DictionaryIntLoad1(true, lv_str + "Tag", lv_i).ToString() == lv_tagStr)
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                DictionaryIntSave0(true, (lv_str + "Num"), lv_i);
                                DictionaryStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                DictionaryBoolSave0(true, (("DHD_IfIntTag" + "") + "_" + lv_tagStr), true);
                                DictionaryBoolSave1(true, ("DHD_IfIntTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            if ((DictionaryBoolKeyExists(true, ("DHD_Int" + "State" + "_" + lv_tag.ToString())) == false))
            {
                DictionaryStringSave1(true, (("DHD_Int" + "State")), lv_tag, "true");
            }
        }

        /// <summary>
        /// 【MM_函数库】互动I_注销Int。用"互动I_注册Int"到Key，之后可用本函数彻底摧毁注册信息并将序号重排（包括Int标签有效状态、固有状态及自定义值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动I_设定Int状态"让Int状态失效（类似单位组的单位活体状态）。Int组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Int组转为Key。本函数无法摧毁用"互动I_设定Int状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Int组变量ID时会清空Int组专用状态
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Int"</param>
        public static void DHD_DestroyInt(int lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag;
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_tag = DHD_ReturnIntTag(lp_vector);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                ThreadWaitSet(true, "Key_IntGroup" + lv_str, true);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((DictionaryIntLoad1(true, (lp_key + "IntTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        DictionaryBoolClear0(true, "DHD_IfIntTag_" + lv_tag);
                        DictionaryBoolClear0(true, "DHD_IfIntTag" + lv_str + "_" + lv_tag);
                        DictionaryIntClear0(true, "DHD_Int_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_IntCV_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_IntState_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_IntCV" + lv_str + "_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_IntState" + lv_str + "_" + lv_tag);
                        DictionaryIntSave0(true, (lp_key + "IntNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = DictionaryIntLoad1(true, (lp_key + "IntTag"), lv_b + 1).ToString();
                            DictionaryStringSave1(true, (lp_key + "IntTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                ThreadWaitSet(true, "Key_IntGroup" + lv_str, false);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动I_移除Int。用"互动I_注册Int"到Key，之后可用本函数仅摧毁Key区注册的信息并将序号重排，用于Int组或多个键区仅移除Int（保留Int标签有效状态、固有值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动I_设定Int状态"让Int状态失效（类似单位组的单位活体状态）。Int组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Int组转为Key。本函数无法摧毁用"互动I_设定Int状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Int组变量ID时会清空Int组专用状态
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Int"</param>
        public static void DHD_RemoveInt(int lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag;
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_tag = DHD_ReturnIntTag(lp_vector);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                ThreadWaitSet(true, "Key_IntGroup" + lv_str, true);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((DictionaryIntLoad1(true, (lp_key + "IntTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        DictionaryBoolClear0(true, "DHD_IfIntTag" + lv_str + "_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_IntCV" + lv_str + "_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_IntState" + lv_str + "_" + lv_tag);
                        DictionaryIntSave0(true, (lp_key + "IntNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = DictionaryIntLoad1(true, (lp_key + "IntTag"), lv_b + 1).ToString();
                            DictionaryStringSave1(true, (lp_key + "IntTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                ThreadWaitSet(true, "Key_IntGroup" + lv_str, false);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Int注册总数。必须先使用"互动I_注册Int"才能返回指定Key里的注册总数。Int组使用时，可用"获取变量的内部名称"将Int组转为Key。
        /// </summary>
        /// <param name="lp_key">存储键区，默认值"_Int"</param>
        /// <returns></returns>
        public static int DHD_ReturnIntNumMax(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            // Implementation
            return lv_num;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Int序号。使用"互动I_注册Int"后使用本函数可返回Key里的注册序号，Key无元素返回0，Key有元素但对象不在里面则返回-1，Int标签尚未注册则返回-2。Int组使用时，可用"获取变量的内部名称"将Int组转为Key
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Int"</param>
        /// <returns></returns>
        public static int DHD_ReturnIntNum(int lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_i;
            string lv_tag;
            int lv_torf;
            // Automatic Variable Declarations
            const int auto_n = 1;
            int auto_i;
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_tag = DHD_ReturnIntTag(lp_vector);
            lv_torf = -1;
            // Implementation
            for (auto_i = 1; auto_i <= auto_n; auto_i += 1)
            {
                if ((lv_tag != null))
                {
                    lv_torf = -2;
                    break;
                }
                if ((lv_num == 0))
                {
                    lv_torf = 0;
                }
                else
                {
                    if ((lv_num >= 1))
                    {
                        auto_ae = lv_num;
                        auto_var = 1;
                        for (; auto_var <= auto_ae; auto_var += 1)
                        {
                            lv_i = auto_var;
                            if ((DictionaryIntLoad1(true, (lv_str + "Tag"), lv_i).ToString() == lv_tag))
                            {
                                lv_torf = lv_i;
                                break;
                            }
                        }
                    }
                }
            }
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回序号对应Int。使用"互动I_注册Int"后，在参数填入注册序号可返回Int。Int组使用时，可用"获取变量的内部名称"将Int组转为Key
        /// </summary>
        /// <param name="lp_regNum"></param>
        /// <param name="lp_key">存储键区，默认值"_Int"</param>
        /// <returns></returns>
        public static int DHD_ReturnIntFromRegNum(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_tag = DictionaryIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return DictionaryIntLoad0(true, ("DHD_Int_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回句柄标签对应Int。使用"互动I_注册Int"后，在参数填入句柄标签（整数）可返回Int，标签是Int的句柄。Int组使用时，可用"获取变量的内部名称"将Int组转为Key
        /// </summary>
        /// <param name="lp_tag">句柄标签</param>
        /// <returns></returns>
        public static int DHD_ReturnIntFromTag(int lp_tag)
        {
            // Variable Declarations
            string lv_tag;
            // Variable Initialization
            lv_tag = lp_tag.ToString();
            // Implementation
            return DictionaryIntLoad0(true, ("DHD_Int_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回序号对应Int标签句柄。使用"互动I_注册Int"后，在参数填入注册序号可返回Int标签（字符串）。Int组使用时，可用"获取变量的内部名称"将Int组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Int"</param>
        /// <returns></returns>
        public static string DHD_ReturnIntTagFromRegNum_String(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_tag = DictionaryIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回序号对应Int标签句柄。使用"互动I_注册Int"后，在参数填入注册序号可返回Int标签（整数）。Int组使用时，可用"获取变量的内部名称"将Int组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Int"</param>
        /// <returns></returns>
        public static int DHD_ReturnIntTagFromRegNum_Int(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_tag = DictionaryIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return Convert.ToInt32(lv_tag);
        }

        /// <summary>
        /// 【MM_函数库】互动I_设置Int状态。必须先"注册"获得功能库内部句柄，再使用本函数给Int设定一个状态值，之后可用"互动I_返回Int状态"。类型参数用以记录多个不同状态，仅当"类型"参数填Int组ID转的Int串时，状态值"true"和"false"是Int的Int组专用状态值，用于内部函数筛选Int状态（相当于单位组单位索引是否有效），其他类型不会干扰系统内部，可随意填写。虽然注销时反向清空注册信息，但用"互动I_设定Int状态/自定义值"创建的值需要手工填入""来排泄（非大量注销则提升内存量极小，可不管）。注：固有状态值是注册函数赋予的系统内部变量（相当于单位组单位是否活体），只能通过"互动I_注册Int（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <param name="lp_stats">状态</param>
        public static void DHD_SetIntState(int lp_vector, string lp_key, string lp_stats)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_tag = DHD_RegIntTagAndReturn(lp_vector);
            // Implementation
            DictionaryStringSave0(true, ("DHD_IntState" + lv_str + "_" + lv_tag), lp_stats);
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Int状态。使用"互动I_设定Int状态"后可使用本函数，将本函数参数"类型"设为空时返回固有值。类型参数用以记录多个不同状态，仅当"类型"参数为Int组ID转的字符串时，返回的状态值"true"和"false"是Int的Int组专用状态值，用于内部函数筛选Int状态（相当于单位组单位索引是否有效）
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <returns></returns>
        public static string DHD_ReturnIntState(int lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_tag = DHD_ReturnIntTag(lp_vector);
            lv_stats = DictionaryStringLoad0(true, ("DHD_IntState" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动I_设置Int自定义值。必须先"注册"获得功能库内部句柄，再使用本函数设定Int的自定义值，之后可使用"互动I_返回Int自定义值"，类型参数用以记录多个不同自定义值。注：固有自定义值是注册函数赋予的系统内部变量，只能通过"互动I_注册Int（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <param name="lp_customValue">自定义值</param>
        public static void DHD_SetIntCV(int lp_vector, string lp_key, string lp_customValue)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_tag = DHD_RegIntTagAndReturn(lp_vector);
            // Implementation
            DictionaryStringSave0(true, ("DHD_IntCV" + lv_str + "_" + lv_tag), lp_customValue);
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Int自定义值。使用"互动I_设定Int自定义值"后可使用本函数，将本函数参数"类型"设为空时返回固有值，该参数用以记录多个不同自定义值
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <returns></returns>
        public static string DHD_ReturnIntCV(int lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_tag = DHD_ReturnIntTag(lp_vector);
            lv_customValue = DictionaryStringLoad0(true, ("DHD_IntCV" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Int固有状态。必须先使用"互动I_注册Int"才能返回到该值，固有状态是独一无二的标记（相当于单位组单位是否活体）
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns></returns>
        public static string DHD_ReturnIntState_Only(int lp_vector)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_tag = DHD_ReturnIntTag(lp_vector);
            lv_stats = DictionaryStringLoad0(true, ("DHD_IntState" + "" + "_" + lv_tag));
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Int固有自定义值。必须先使用"互动I_注册Int"才能返回到该值，固有值是独一无二的标记
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns></returns>
        public static string DHD_ReturnIntCV_Only(int lp_vector)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_tag = DHD_ReturnIntTag(lp_vector);
            lv_customValue = DictionaryStringLoad0(true, ("DHD_IntCV" + "" + "_" + lv_tag));
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动I_设置Int的实数标记。必须先"注册"获得功能库内部句柄，再使用本函数让Int携带一个实数值，之后可使用"互动I_返回Int的实数标记"。Int组使用时，可用"获取变量的内部名称"将Int组转为Key
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_realNumTag">实数标记</param>
        public static void DHD_SetIntDouble(int lp_vector, double lp_realNumTag)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = DHD_RegIntTagAndReturn(lp_vector);
            // Implementation
            DictionaryDoubleSave0(true, ("DHD_CDDouble_Int_" + lv_tag), lp_realNumTag);
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Int的实数标记。使用"互动I_设定Int的实数标记"后可使用本函数。Int组使用时，可用"获取变量的内部名称"将Int组转为Key
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns></returns>
        public static double DHD_ReturnIntDouble(int lp_vector)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = DHD_ReturnIntTag(lp_vector);
            // Implementation
            return DictionaryDoubleLoad0(true, ("DHD_CDDouble_Int_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Int标签句柄有效状态。将Int视作独一无二的个体，标签是它本身，有效状态则类似"单位是否有效"，当使用"互动I_注册Int"或"互动IG_添加Int到Int组"后激活Int有效状态（值为"true"），除非使用"互动I_注册Int（高级）"改写，否则直到注销才会摧毁
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns></returns>
        public static bool DHD_ReturnIfIntTag(int lp_vector)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = DHD_ReturnIntTag(lp_vector);
            // Implementation
            return DictionaryBoolLoad0(true, ("DHD_IfIntTag" + "" + "_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Int注册状态。使用"互动I_注册Int"或"互动IG_添加Int到Int组"后可使用本函数获取注册Int在Key中的注册状态，该状态只能注销或从Int组中移除时清空。Int组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Int组转为Key
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Int"</param>
        /// <returns></returns>
        public static bool DHD_ReturnIfIntTagKey(int lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_tag = DHD_ReturnIntTag(lp_vector);
            // Implementation
            return DictionaryBoolLoad0(true, ("DHD_IfIntTag" + lv_str + "_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动IG_根据自定义值类型将Int组排序。根据Int携带的自定义值类型，对指定的Int组元素进行冒泡排序。Int组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Int组名称</param>
        /// <param name="lp_cVStr">自定义值类型</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void DHD_IntGSortCV(string lp_key, string lp_cVStr, bool lp_big)
        {
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            string lv_tagValuestr;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Int");
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_IntGroup" + lv_str, true);
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = DHD_ReturnIntTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValuestr = DHD_ReturnIntCV((int)DHD_ReturnIntFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    DictionaryIntSave1(false, "IntStackOutTag", 1, lv_tag);
                    DictionaryIntSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DictionaryIntSave1(false, "IntStackOutTag", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    DictionaryIntSave1(false, "IntStackOutTagValue", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                DictionaryIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                DictionaryIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(DHD_ReturnIntTagFromRegNum(lv_b, lp_key))+"值"+IntToString(DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DictionaryIntSave1(false, "IntStackOutTag", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DictionaryIntSave1(false, "IntStackOutTagValue", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                DictionaryIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DictionaryIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        DictionaryIntSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DictionaryIntSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = DictionaryIntLoad1(true, (lp_key + "IntTag"), lv_a).ToString(); //原始序号元素
                lv_tag = (int)DictionaryIntLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValuestr = DHD_ReturnIntCV((int)DHD_ReturnIntFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    DictionaryIntSave1(true, (lp_key + "IntTag"), lv_a, lv_tag); //lv_tag放入新序号
                    //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            ThreadWaitSet(true, "Key_IntGroup" + lv_str, false);
        }

        /// <summary>
        /// 【MM_函数库】互动IG_Int组排序。对指定的Int组元素进行冒泡排序（根据元素句柄）。Int组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Int组名称</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void DHD_IntGSort(string lp_key, bool lp_big)
        {
            // Automatic Variable Declarations
            // Implementation
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Int");
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_IntGroup" + lv_str, true);
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = DHD_ReturnIntTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValue = lv_tag;
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    DictionaryIntSave1(false, "IntStackOutTag", 1, lv_tag);
                    DictionaryIntSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DictionaryIntSave1(false, "IntStackOutTag", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    DictionaryIntSave1(false, "IntStackOutTagValue", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                DictionaryIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                DictionaryIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(DHD_ReturnIntTagFromRegNum(lv_b, lp_key))+"值"+IntToString(DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DictionaryIntSave1(false, "IntStackOutTag", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DictionaryIntSave1(false, "IntStackOutTagValue", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                DictionaryIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DictionaryIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        DictionaryIntSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DictionaryIntSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = DictionaryIntLoad1(true, (lp_key + "IntTag"), lv_a).ToString(); //原始序号元素
                lv_tag = (int)DictionaryIntLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValue = lv_tag;
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                                                                                        //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    DictionaryIntSave1(true, (lp_key + "IntTag"), lv_a, lv_tag); //lv_tag放入新序号
                                                                                 //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            ThreadWaitSet(true, "Key_IntGroup" + lv_str, false);
        }

        /// <summary>
        /// 【MM_函数库】互动IG_设定Int的Int组专用状态。给Int组的Int设定一个状态值（字符串），之后可用"互动I_返回Int、互动IG_返回Int组的Int状态"。状态值"true"和"false"是Int的Int组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效），而本函数可以重设干预，影响函数"互动IG_返回Int组元素数量（仅检索XX状态）"。与"互动I_设定Int状态"功能相同，只是状态参数在Int组中被固定为"Int组变量的内部ID"。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_vectorGroup"></param>
        /// <param name="lp_groupState"></param>
        public static void DHD_SetIntGState(int lp_vector, string lp_vectorGroup, string lp_groupState)
        {
            DHD_SetIntState(lp_vector, lp_vectorGroup, lp_groupState);
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Int的Int组专用状态。使用"互动I_设定Int、互动IG_设定Int组的Int状态"后可使用本函数。与"互动I_返回Int状态"功能相同，只是状态参数在Int组中被固定为"Int组变量的内部ID"。状态值"true"和"false"是Int的Int组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效）。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_vectorGroup"></param>
        public static void DHD_ReturnIntGState(int lp_vector, string lp_vectorGroup)
        {
            DHD_ReturnIntState(lp_vector, lp_vectorGroup);
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Int组元素序号对应元素。返回Int组元素序号指定Int。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int DHD_ReturnIntFromIntGFunc(int lp_regNum, string lp_gs)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_gs + "Int");
            lv_tag = DictionaryIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return DictionaryIntLoad0(true, ("DHD_Int_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Int组元素总数。返回指定Int组的元素数量。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int DHD_ReturnIntGNumMax(string lp_gs)
        {
            return DictionaryIntLoad0(true, lp_gs + "IntNum");
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Int组元素总数（仅检测Int组专用状态="true"）。返回指定Int组的元素数量。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int DHD_ReturnIntGNumMax_StateTrueFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            int lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = DHD_ReturnIntNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (int)DHD_ReturnIntFromRegNum(lv_a, lp_gs);
                lv_b = DHD_ReturnIntState(lv_c, lp_gs);
                if ((lv_b == "true"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Int组元素总数（仅检测Int组专用状态="false"）。返回指定Int组的元素数量。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int DHD_ReturnIntGNumMax_StateFalseFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            int lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = DHD_ReturnIntNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (int)DHD_ReturnIntFromRegNum(lv_a, lp_gs);
                lv_b = DHD_ReturnIntState(lv_c, lp_gs);
                if ((lv_b == "false"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Int组元素总数（仅检测Int组无效专用状态："false"或""）。返回指定Int组的元素数量（false、""、null）。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int DHD_ReturnIntGNumMax_StateUselessFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            int lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = DHD_ReturnIntNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (int)DHD_ReturnIntFromRegNum(lv_a, lp_gs);
                lv_b = DHD_ReturnIntState(lv_c, lp_gs);
                if (((lv_b == "false") || (lv_b == "") || (lv_b == null)))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Int组元素总数（仅检测Int组指定专用状态）。返回指定Int组的元素数量。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_State">Int组专用状态</param>
        /// <returns></returns>
        public static int DHD_ReturnIntGNumMax_StateFunc_Specify(string lp_gs, string lp_State)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            int lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = DHD_ReturnIntNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (int)DHD_ReturnIntFromRegNum(lv_a, lp_gs);
                lv_b = DHD_ReturnIntState(lv_c, lp_gs);
                if ((lv_b == lp_State))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动IG_添加Int到Int组。相同Int被认为是同一个，非高级功能不提供专用状态检查，如果Int没有设置过Int组专用状态，那么首次添加到Int组不会赋予"true"（之后可通过"互动I_设定Int状态"、"互动IG_设定Int组的Int状态"修改）。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void DHD_AddIntToGroup_Simple(int lp_vector, string lp_gs)
        {
            DHD_RegInt_Simple(lp_vector, lp_gs);
        }

        /// <summary>
        /// 【MM_函数库】互动IG_添加Int到Int组（高级）。相同Int被认为是同一个，高级功能提供专用状态检查，如果Int没有设置过Int组专用状态，那么首次添加到Int组会赋予"true"（之后可通过"互动I_设定Int状态"、"互动IG_设定Int组的Int状态"修改）。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void DHD_AddIntToGroup(int lp_vector, string lp_gs)
        {
            DHD_RegInt_Simple(lp_vector, lp_gs);
            if (DictionaryStringKeyExists(true, ("DHD_IntState" + lp_gs + "Int_" + DHD_RegIntTagAndReturn(lp_vector))) == false)
            {
                DictionaryStringSave0(true, ("DHD_IntState" + lp_gs + "Int_" + DHD_RegIntTagAndReturn(lp_vector)), "true");
                //Console.WriteLine(lp_gs + "=>" + DHD_RegIntTagAndReturn(lp_vector));
            }
        }

        /// <summary>
        /// 【MM_函数库】互动IG_移除Int组中的元素。使用"互动IG_添加Int到Int组"后可使用本函数进行移除元素。移除使用了"互动I_移除Int"，同一个存储区（Int组ID）序号重排，移除时该存储区如有其他操作会排队等待。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void DHD_ClearIntFromGroup(int lp_vector, string lp_gs)
        {
            DHD_RemoveInt(lp_vector, lp_gs);
        }

        //互动IG_为Int组中的每个序号
        //GE（星际2的Galaxy Editor）的宏让编辑器保存时自动生成脚本并整合进脚本进行格式调整，C#仅参考需自行编写
        // #AUTOVAR(vs, string) = "#PARAM(group)";//"#PARAM(group)"是与字段、变量名一致的元素组名称，宏去声明string类型名为“Auto随机编号_vs”的自动变量，然后=右侧字符
        // #AUTOVAR(ae) = DHD_ReturnIntNumMax(#AUTOVAR(vs));//宏去声明默认int类型名为“Auto随机编号_ae”的自动变量，然后=右侧字符
        // #INITAUTOVAR(ai,increment)//宏去声明int类型名为“Auto随机编号_ai”的自动变量，用于下面for循环增量（increment是传入参数）
        // #PARAM(var) = #PARAM(s);//#PARAM(var)是传进来的参数，用作“当前被挑选到的元素”（任意变量-整数 lp_var）， #PARAM(s)是传进来的参数用作"开始"（int lp_s）
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #PARAM(var) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #PARAM(var) >= #AUTOVAR(ae)) ) ; #PARAM(var) += #AUTOVAR(ai) ) {
        //     #SUBFUNCS(actions)//代表用户GUI填写的所有动作
        // }

        /// <summary>
        /// 【MM_函数库】互动IG_为Int组中的每个序号。每次挑选的元素序号会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素序号，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void DHD_ForEachIntNumFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            int lv_ae = DHD_ReturnIntNumMax(lp_gs);
            int lv_var = lp_start;
            int lv_ai = lp_increment;
            for (; (lv_ai >= 0 && lv_var <= lv_ae) || (lv_ai < 0 && lv_var >= lv_ae); lv_var += lv_ai)
            {
                lp_funcref(lv_var);//用户填写的所有动作
            }
        }

        //互动IG_为Int组中的每个元素
        // #AUTOVAR(vs, string) = "#PARAM(group)";
        // #AUTOVAR(ae) = DHD_ReturnIntNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= #PARAM(s);
        // #INITAUTOVAR(ai,increment)
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     DictionarySave(false, "IntGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)), DHD_ReturnIntFromRegNum(#AUTOVAR(va),#AUTOVAR(vs)));
        // }
        // #AUTOVAR(va)= #PARAM(s);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #PARAM(var) = DictionaryLoad(false, "IntGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)));
        //     #SUBFUNCS(actions)
        // }

        /// <summary>
        /// 【MM_函数库】互动IG_为Int组中的每个元素。每次挑选的元素会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void DHD_ForEachIntFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            string lv_vs = lp_gs;
            int lv_ae = DHD_ReturnIntNumMax(lv_vs);
            int lv_va = lp_start;
            int lv_ai = lp_increment;
            int lv_vector;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                DictionaryIntSave0(false, "IntGFor" + lv_vs + lv_va.ToString(), (int)DHD_ReturnIntFromRegNum(lv_va, lv_vs));
            }
            lv_va = lp_start;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                lv_vector = (int)DictionaryIntLoad0(false, "IntGFor" + lv_vs + lv_va.ToString());
                lp_funcref(lv_vector);//用户填写的所有动作
            }
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Int组中随机元素。返回指定Int组中的随机Int。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int DHD_ReturnRandomIntFromIntGFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_num;
            int lv_a;
            int lv_c = 0;
            // Variable Initialization
            lv_num = DHD_ReturnIntNumMax(lp_gs);
            // Implementation
            if ((lv_num >= 1))
            {
                lv_a = RandomInt(1, lv_num);
                lv_c = DHD_ReturnIntFromRegNum(lv_a, lp_gs);
            }
            return lv_c;
        }

        //互动IG_添加Int组到Int组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = DHD_ReturnIntNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = DHD_ReturnIntFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     DHD_AddIntToGroup(#AUTOVAR(var), #AUTOVAR(vsb));
        // }


        /// <summary>
        /// 【MM_函数库】互动IG_添加Int组到Int组。添加一个Int组A的元素到另一个Int组B，相同Int被认为是同一个。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void DHD_AddIntGToIntG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = DHD_ReturnIntNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            int lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = (int)DHD_ReturnIntFromRegNum(lv_va, lv_vsa);
                DHD_AddIntToGroup(lv_var, lv_vsb);
            }
        }

        //互动IG_从Int组移除Int组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = DHD_ReturnIntNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = DHD_ReturnIntFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     DHD_RemoveInt(#AUTOVAR(var), #AUTOVAR(vsb));
        // }

        /// <summary>
        /// 【MM_函数库】互动IG_从Int组移除Int组。将Int组A的元素从Int组B中移除，相同Int被认为是同一个。移除使用了"互动I_移除Int"，同一个存储区（Int组ID）序号重排，移除时该存储区如有其他操作会排队等待。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void DHD_ClearIntGFromIntG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = DHD_ReturnIntNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            int lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = (int)DHD_ReturnIntFromRegNum(lv_va, lv_vsa);
                DHD_RemoveInt(lv_var, lv_vsb);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动IG_移除Int组全部元素。将Int组（Key区）存储的元素全部移除，相同Int被认为是同一个。移除时同一个存储区（Int组ID）序号不进行重排，但该存储区如有其他操作会排队等待。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Int组名称</param>
        public static void DHD_RemoveIntGAll(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag = "";
            int lv_a;
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            // Implementation
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_IntGroup" + lv_str, true);
            for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
            {
                lv_tag = DictionaryIntLoad1(true, (lp_key + "IntTag"), lv_a).ToString();
                lv_num -= 1;
                DictionaryBoolClear0(true, "DHD_IfIntTag" + lv_str + "_" + lv_tag);
                DictionaryStringClear0(true, "DHD_IntCV" + lv_str + "_" + lv_tag);
                DictionaryStringClear0(true, "DHD_IntState" + lv_str + "_" + lv_tag);
                DictionaryIntSave0(true, (lp_key + "IntNum"), lv_num);
            }
            ThreadWaitSet(true, "Key_IntGroup" + lv_str, false);
        }

        //--------------------------------------------------------------------------------------------------
        // 数字组End
        //--------------------------------------------------------------------------------------------------

        #endregion

        #endregion

        #region 哈希表互动

        //注：值与引用类型转换时没字典（Dictionary）效率，因为会发生拆装箱

        #region 任意类型

        //提示：可以将任意类型作为模板修改后产生其他类型
        //提示：尽可能使用对口类型，以防值类型与引用类型发生转换时拆装箱降低性能

        //--------------------------------------------------------------------------------------------------
        // 任意类型组Start
        //--------------------------------------------------------------------------------------------------

        /// <summary>
        /// 【MM_函数库】互动O_注册Object标签句柄并返回。为Object自动设置新的标签句柄，重复时会返回已注册的Object标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns>返回一个Object的已注册标签</returns>
        private static int HHD_RegObjectTagAndReturn_Int(object lp_object)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)HashTableLoad0(true, "HHD_ObjectJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                HashTableSave0(true, "HHD_ObjectJBNum", lv_j);
                HashTableSave0(true, ("HHD_Object_" + lv_j.ToString()), lp_object);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if ((object)HashTableLoad0(true, ("HHD_Object_" + lv_j.ToString())) == lp_object)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            HashTableSave0(true, "HHD_ObjectJBNum", lv_j);
                            HashTableSave0(true, ("HHD_Object_" + lv_j.ToString()), lp_object);
                        }
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object已注册标签句柄
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns>返回一个Object的已注册标签，错误返回0</returns>
        public static int HHD_ReturnObjectTag_Int(object lp_object)
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)HashTableLoad0(true, "HHD_ObjectJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if ((object)HashTableLoad0(true, "HHD_Object_" + lv_j.ToString()) == lp_object)
                {
                    break;
                }
                else
                {
                    if ((lv_j == lv_jBNum))
                    {
                        lv_j = 0;
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动O_注册Object标签句柄并返回。为Object自动设置新的标签句柄，重复时会返回已注册的Object标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns>返回一个Object的已注册标签</returns>
        private static string HHD_RegObjectTagAndReturn(object lp_object)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)HashTableLoad0(true, "HHD_ObjectJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                HashTableSave0(true, "HHD_ObjectJBNum", lv_j);
                HashTableSave0(true, ("HHD_Object_" + lv_j.ToString()), lp_object);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if ((object)HashTableLoad0(true, "HHD_Object_" + lv_j.ToString()) == lp_object)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            HashTableSave0(true, "HHD_ObjectJBNum", lv_j);
                            HashTableSave0(true, ("HHD_Object_" + lv_j.ToString()), lp_object);
                        }
                    }
                }
            }
            lv_tag = lv_j.ToString();
            //Console.WriteLine(("Tag：" + lv_tag));
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object已注册标签句柄
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns>返回一个Object的已注册标签，错误返回""</returns>
        public static string HHD_ReturnObjectTag(object lp_object)
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag = "";
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)HashTableLoad0(true, "HHD_ObjectJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if ((object)HashTableLoad0(true, "HHD_Object_" + lv_j.ToString()) == lp_object)
                {
                    lv_tag = lv_j.ToString();
                    break;
                }
            }
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动O_注册Object(高级)。在指定Key存入Object，固有状态、自定义值是Object独一无二的标志（本函数重复注册会刷新），之后可用互动O_"返回Object注册总数"、"返回Object序号"、"返回序号对应Object"、"返回序号对应Object标签"、"返回Object自定义值"。Object组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Object组转为Key。首次注册时固有状态为true（相当于单位组单位活体），如需另外设置多个标记可使用"互动O_设定Object状态/自定义值"
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        /// <param name="lp_inherentStats">固有状态</param>
        /// <param name="lp_inherentCustomValue">固有自定义值</param>
        public static void HHD_RegObject(object lp_object, string lp_key, string lp_inherentStats, string lp_inherentCustomValue)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;

            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_jBNum = (int)HashTableLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = HHD_RegObjectTagAndReturn(lp_object);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                HashTableSave0(true, (lv_str + "Num"), lv_i);
                HashTableSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                HashTableSave0(true, (("HHD_IfObjectTag" + "") + "_" + lv_tagStr), true);
                HashTableSave1(true, ("HHD_IfObjectTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if (HashTableLoad1(true, lv_str + "Tag", lv_i).ToString() == lv_tagStr)
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                HashTableSave0(true, (lv_str + "Num"), lv_i);
                                HashTableSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                HashTableSave0(true, (("HHD_IfObjectTag" + "") + "_" + lv_tagStr), true);
                                HashTableSave1(true, ("HHD_IfObjectTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            HashTableSave0(true, ("HHD_ObjectState" + "" + "_" + lv_tagStr), lp_inherentStats);
            HashTableSave0(true, ("HHD_ObjectCV" + "" + "_" + lv_tagStr), lp_inherentCustomValue);
        }

        /// <summary>
        /// 【MM_函数库】互动O_注册Object。在指定Key存入Object，固有状态、自定义值是Object独一无二的标志（本函数重复注册不会刷新），之后可用互动O_"返回Object注册总数"、"返回Object序号"、"返回序号对应Object"、"返回Object自定义值"。Object组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Object组转为Key。首次注册时固有状态为true（相当于单位组单位活体），之后只能通过"互动O_注册Object（高级）"改写，如需另外设置多个标记可使用"互动O_设定Object状态/自定义值"
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        public static void HHD_RegObject_Simple(object lp_object, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;

            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_jBNum = (int)HashTableLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = HHD_RegObjectTagAndReturn(lp_object);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                HashTableSave0(true, (lv_str + "Num"), lv_i);
                HashTableSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                HashTableSave0(true, (("HHD_IfObjectTag" + "") + "_" + lv_tagStr), true);
                HashTableSave1(true, ("HHD_IfObjectTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if (HashTableLoad1(true, lv_str + "Tag", lv_i).ToString() == lv_tagStr)
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                HashTableSave0(true, (lv_str + "Num"), lv_i);
                                HashTableSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                HashTableSave0(true, (("HHD_IfObjectTag" + "") + "_" + lv_tagStr), true);
                                HashTableSave1(true, ("HHD_IfObjectTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            if ((HashTableKeyExists(true, ("HHD_Object" + "State" + "_" + lv_tag.ToString())) == false))
            {
                HashTableSave1(true, (("HHD_Object" + "State")), lv_tag, "true");
            }
        }

        /// <summary>
        /// 【MM_函数库】互动O_注销Object。用"互动O_注册Object"到Key，之后可用本函数彻底摧毁注册信息并将序号重排（包括Object标签有效状态、固有状态及自定义值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动O_设定Object状态"让Object状态失效（类似单位组的单位活体状态）。Object组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Object组转为Key。本函数无法摧毁用"互动O_设定Object状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Object组变量ID时会清空Object组专用状态
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        public static void HHD_DestroyObject(object lp_object, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag;
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_tag = HHD_ReturnObjectTag(lp_object);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                HashTableSave0(true, "Key_ObjectGroup" + lv_str, 1);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((HashTableLoad1(true, (lp_key + "ObjectTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        HashTableClear0(true, "HHD_IfObjectTag_" + lv_tag);
                        HashTableClear0(true, "HHD_IfObjectTag" + lv_str + "_" + lv_tag);
                        HashTableClear0(true, "HHD_Object_" + lv_tag);
                        HashTableClear0(true, "HHD_ObjectCV_" + lv_tag);
                        HashTableClear0(true, "HHD_ObjectState_" + lv_tag);
                        HashTableClear0(true, "HHD_ObjectCV" + lv_str + "_" + lv_tag);
                        HashTableClear0(true, "HHD_ObjectState" + lv_str + "_" + lv_tag);
                        HashTableSave0(true, (lp_key + "ObjectNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = HashTableLoad1(true, (lp_key + "ObjectTag"), lv_b + 1).ToString();
                            HashTableSave1(true, (lp_key + "ObjectTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                HashTableSave0(true, "Key_ObjectGroup" + lv_str, 0);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动O_移除Object。用"互动O_注册Object"到Key，之后可用本函数仅摧毁Key区注册的信息并将序号重排，用于Object组或多个键区仅移除Object（保留Object标签有效状态、固有值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动O_设定Object状态"让Object状态失效（类似单位组的单位活体状态）。Object组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Object组转为Key。本函数无法摧毁用"互动O_设定Object状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Object组变量ID时会清空Object组专用状态
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        public static void HHD_RemoveObject(object lp_object, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag;
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_tag = HHD_ReturnObjectTag(lp_object);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                HashTableSave0(true, "Key_ObjectGroup" + lv_str, 1);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((HashTableLoad1(true, (lp_key + "ObjectTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        HashTableClear0(true, "HHD_IfObjectTag" + lv_str + "_" + lv_tag);
                        HashTableClear0(true, "HHD_ObjectCV" + lv_str + "_" + lv_tag);
                        HashTableClear0(true, "HHD_ObjectState" + lv_str + "_" + lv_tag);
                        HashTableSave0(true, (lp_key + "ObjectNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = HashTableLoad1(true, (lp_key + "ObjectTag"), lv_b + 1).ToString();
                            HashTableSave1(true, (lp_key + "ObjectTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                HashTableSave0(true, "Key_ObjectGroup" + lv_str, 0);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object注册总数。必须先使用"互动O_注册Object"才能返回指定Key里的注册总数。Object组使用时，可用"获取变量的内部名称"将Object组转为Key。
        /// </summary>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        /// <returns></returns>
        public static int HHD_ReturnObjectNumMax(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            // Implementation
            return lv_num;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object序号。使用"互动O_注册Object"后使用本函数可返回Key里的注册序号，Key无元素返回0，Key有元素但对象不在里面则返回-1，Object标签尚未注册则返回-2。Object组使用时，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        /// <returns></returns>
        public static int HHD_ReturnObjectNum(object lp_object, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_i;
            string lv_tag;
            int lv_torf;
            // Automatic Variable Declarations
            const int auto_n = 1;
            int auto_i;
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_tag = HHD_ReturnObjectTag(lp_object);
            lv_torf = -1;
            // Implementation
            for (auto_i = 1; auto_i <= auto_n; auto_i += 1)
            {
                if ((lv_tag != null))
                {
                    lv_torf = -2;
                    break;
                }
                if ((lv_num == 0))
                {
                    lv_torf = 0;
                }
                else
                {
                    if ((lv_num >= 1))
                    {
                        auto_ae = lv_num;
                        auto_var = 1;
                        for (; auto_var <= auto_ae; auto_var += 1)
                        {
                            lv_i = auto_var;
                            if ((HashTableLoad1(true, (lv_str + "Tag"), lv_i).ToString() == lv_tag))
                            {
                                lv_torf = lv_i;
                                break;
                            }
                        }
                    }
                }
            }
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回序号对应Object。使用"互动O_注册Object"后，在参数填入注册序号可返回Object。Object组使用时，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_regNum"></param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        /// <returns></returns>
        public static object HHD_ReturnObjectFromRegNum(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            object lv_object;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = HashTableLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            lv_object = (object)HashTableLoad0(true, ("HHD_Object_" + lv_tag));
            // Implementation
            return lv_object;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回句柄标签对应Object。使用"互动O_注册Object"后，在参数填入句柄标签（整数）可返回Object，标签是Object的句柄。Object组使用时，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_tag">句柄标签</param>
        /// <returns></returns>
        public static object HHD_ReturnObjectFromTag(int lp_tag)
        {
            // Variable Declarations
            string lv_tag;
            object lv_object;
            // Variable Initialization
            lv_tag = lp_tag.ToString();
            lv_object = (object)HashTableLoad0(true, ("HHD_Object_" + lv_tag));
            // Implementation
            return lv_object;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回序号对应Object标签句柄。使用"互动O_注册Object"后，在参数填入注册序号可返回Object标签（字符串）。Object组使用时，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        /// <returns></returns>
        public static string HHD_ReturnObjectTagFromRegNum_String(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = HashTableLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回序号对应Object标签句柄。使用"互动O_注册Object"后，在参数填入注册序号可返回Object标签（整数）。Object组使用时，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        /// <returns></returns>
        public static int HHD_ReturnObjectTagFromRegNum_Int(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = HashTableLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return Convert.ToInt32(lv_tag);
        }

        /// <summary>
        /// 【MM_函数库】互动O_设置Object状态。必须先"注册"获得功能库内部句柄，再使用本函数给Object设定一个状态值，之后可用"互动O_返回Object状态"。类型参数用以记录多个不同状态，仅当"类型"参数填Object组ID转的Object串时，状态值"true"和"false"是Object的Object组专用状态值，用于内部函数筛选Object状态（相当于单位组单位索引是否有效），其他类型不会干扰系统内部，可随意填写。虽然注销时反向清空注册信息，但用"互动O_设定Object状态/自定义值"创建的值需要手工填入""来排泄（非大量注销则提升内存量极小，可不管）。注：固有状态值是注册函数赋予的系统内部变量（相当于单位组单位是否活体），只能通过"互动O_注册Object（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <param name="lp_stats">状态</param>
        public static void HHD_SetObjectState(object lp_object, string lp_key, string lp_stats)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = HHD_RegObjectTagAndReturn(lp_object);
            // Implementation
            HashTableSave0(true, ("HHD_ObjectState" + lv_str + "_" + lv_tag), lp_stats);
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object状态。使用"互动O_设定Object状态"后可使用本函数，将本函数参数"类型"设为空时返回固有值。类型参数用以记录多个不同状态，仅当"类型"参数为Object组ID转的字符串时，返回的状态值"true"和"false"是Object的Object组专用状态值，用于内部函数筛选Object状态（相当于单位组单位索引是否有效）
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <returns></returns>
        public static string HHD_ReturnObjectState(object lp_object, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = HHD_ReturnObjectTag(lp_object);
            lv_stats = HashTableLoad0(true, ("HHD_ObjectState" + lv_str + "_" + lv_tag)).ToString();
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动O_设置Object自定义值。必须先"注册"获得功能库内部句柄，再使用本函数设定Object的自定义值，之后可使用"互动O_返回Object自定义值"，类型参数用以记录多个不同自定义值。注：固有自定义值是注册函数赋予的系统内部变量，只能通过"互动O_注册Object（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <param name="lp_customValue">自定义值</param>
        public static void HHD_SetObjectCV(object lp_object, string lp_key, string lp_customValue)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = HHD_RegObjectTagAndReturn(lp_object);
            // Implementation
            HashTableSave0(true, ("HHD_ObjectCV" + lv_str + "_" + lv_tag), lp_customValue);
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object自定义值。使用"互动O_设定Object自定义值"后可使用本函数，将本函数参数"类型"设为空时返回固有值，该参数用以记录多个不同自定义值
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <returns></returns>
        public static string HHD_ReturnObjectCV(object lp_object, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = HHD_ReturnObjectTag(lp_object);
            lv_customValue = HashTableLoad0(true, ("HHD_ObjectCV" + lv_str + "_" + lv_tag)).ToString();
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object固有状态。必须先使用"互动O_注册Object"才能返回到该值，固有状态是独一无二的标记（相当于单位组单位是否活体）
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns></returns>
        public static string HHD_ReturnObjectState_Only(object lp_object)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_tag = HHD_ReturnObjectTag(lp_object);
            lv_stats = HashTableLoad0(true, ("HHD_ObjectState" + "" + "_" + lv_tag)).ToString();
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object固有自定义值。必须先使用"互动O_注册Object"才能返回到该值，固有值是独一无二的标记
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns></returns>
        public static string HHD_ReturnObjectCV_Only(object lp_object)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_tag = HHD_ReturnObjectTag(lp_object);
            lv_customValue = HashTableLoad0(true, ("HHD_ObjectCV" + "" + "_" + lv_tag)).ToString();
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动O_设置Object的实数标记。必须先"注册"获得功能库内部句柄，再使用本函数让Object携带一个实数值，之后可使用"互动O_返回Object的实数标记"。Object组使用时，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_realNumTag">实数标记</param>
        public static void HHD_SetObjectDouble(object lp_object, double lp_realNumTag)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = HHD_RegObjectTagAndReturn(lp_object);
            // Implementation
            HashTableSave0(true, ("HHD_CDDouble_T_" + lv_tag), lp_realNumTag);
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object的实数标记。使用"互动O_设定Object的实数标记"后可使用本函数。Object组使用时，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns></returns>
        public static double HHD_ReturnObjectDouble(object lp_object)
        {
            // Variable Declarations
            string lv_tag = "";
            double lv_f;
            // Variable Initialization
            lv_tag = HHD_ReturnObjectTag(lp_object);
            lv_f = (double)HashTableLoad0(true, ("HHD_CDDouble_T_" + lv_tag));
            // Implementation
            return lv_f;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object标签句柄有效状态。将Object视作独一无二的个体，标签是它本身，有效状态则类似"单位是否有效"，当使用"互动O_注册Object"或"互动OG_添加Object到Object组"后激活Object有效状态（值为"true"），除非使用"互动O_注册Object（高级）"改写，否则直到注销才会摧毁
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns></returns>
        public static bool HHD_ReturnIfObjectTag(object lp_object)
        {
            // Variable Declarations
            string lv_tag = "";
            bool lv_torf;
            // Variable Initialization
            lv_tag = HHD_ReturnObjectTag(lp_object);
            lv_torf = (bool)HashTableLoad0(true, ("HHD_IfObjectTag" + "" + "_" + lv_tag));
            // Implementation
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object注册状态。使用"互动O_注册Object"或"互动OG_添加Object到Object组"后可使用本函数获取注册Object在Key中的注册状态，该状态只能注销或从Object组中移除时清空。Object组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        /// <returns></returns>
        public static bool HHD_ReturnIfObjectTagKey(object lp_object, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            bool lv_torf;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = HHD_ReturnObjectTag(lp_object);
            lv_torf = (bool)HashTableLoad0(true, ("HHD_IfObjectTag" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动OG_根据自定义值类型将Object组排序。根据Object携带的自定义值类型，对指定的Object组元素进行冒泡排序。Object组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Object组名称</param>
        /// <param name="lp_cVStr">自定义值类型</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void HHD_ObjectGSortCV(string lp_key, string lp_cVStr, bool lp_big)
        {
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            string lv_tagValuestr;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            ThreadWait(lv_str);
            HashTableSave0(true, "Key_ObjectGroup" + lv_str, 1);
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = HHD_ReturnObjectTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValuestr = HHD_ReturnObjectCV(HHD_ReturnObjectFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    HashTableSave1(false, "IntStackOutTag", 1, lv_tag);
                    HashTableSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    HashTableSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < (int)HashTableLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    HashTableSave1(false, "IntStackOutTag", lv_c, HashTableLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    HashTableSave1(false, "IntStackOutTagValue", lv_c, HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    HashTableSave1(false, "IntStackOutTagIteraOrig", lv_c, HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                HashTableSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                HashTableSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                HashTableSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > (int)HashTableLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(HHD_ReturnObjectTagFromRegNum(lv_b, lp_key))+"值"+IntToString(HashTableLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    HashTableSave1(false, "IntStackOutTag", lv_c, HashTableLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(HashTableLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    HashTableSave1(false, "IntStackOutTagValue", lv_c, HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    HashTableSave1(false, "IntStackOutTagIteraOrig", lv_c, HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                HashTableSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                HashTableSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                HashTableSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        HashTableSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        HashTableSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        HashTableSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = HashTableLoad1(true, (lp_key + "ObjectTag"), lv_a).ToString(); //原始序号元素
                lv_tag = (int)HashTableLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValuestr = HHD_ReturnObjectCV(HHD_ReturnObjectFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = (int)HashTableLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    HashTableSave1(true, (lp_key + "ObjectTag"), lv_a, lv_tag); //lv_tag放入新序号
                    //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            HashTableSave0(true, "Key_ObjectGroup" + lv_str, 0);
        }

        /// <summary>
        /// 【MM_函数库】互动OG_Object组排序。对指定的Object组元素进行冒泡排序（根据元素句柄）。Object组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Object组名称</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void HHD_ObjectGSort(string lp_key, bool lp_big)
        {
            // Automatic Variable Declarations
            // Implementation
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            ThreadWait(lv_str);
            HashTableSave0(true, "Key_ObjectGroup" + lv_str, 1);
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = HHD_ReturnObjectTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValue = lv_tag;
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    HashTableSave1(false, "IntStackOutTag", 1, lv_tag);
                    HashTableSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    HashTableSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < (int)HashTableLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    HashTableSave1(false, "IntStackOutTag", lv_c, HashTableLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    HashTableSave1(false, "IntStackOutTagValue", lv_c, HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    HashTableSave1(false, "IntStackOutTagIteraOrig", lv_c, HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                HashTableSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                HashTableSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                HashTableSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > (int)HashTableLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(HHD_ReturnObjectTagFromRegNum(lv_b, lp_key))+"值"+IntToString(HashTableLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    HashTableSave1(false, "IntStackOutTag", lv_c, HashTableLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(HashTableLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    HashTableSave1(false, "IntStackOutTagValue", lv_c, HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    HashTableSave1(false, "IntStackOutTagIteraOrig", lv_c, HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                HashTableSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                HashTableSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                HashTableSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        HashTableSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        HashTableSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        HashTableSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = HashTableLoad1(true, (lp_key + "ObjectTag"), lv_a).ToString(); //原始序号元素
                lv_tag = (int)HashTableLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValue = lv_tag;
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = (int)HashTableLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                                                                                    //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    HashTableSave1(true, (lp_key + "ObjectTag"), lv_a, lv_tag); //lv_tag放入新序号
                                                                                //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            HashTableSave0(true, "Key_ObjectGroup" + lv_str, 0);
        }

        /// <summary>
        /// 【MM_函数库】互动OG_设定Object的Object组专用状态。给Object组的Object设定一个状态值（字符串），之后可用"互动O_返回Object、互动OG_返回Object组的Object状态"。状态值"true"和"false"是Object的Object组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效），而本函数可以重设干预，影响函数"互动OG_返回Object组元素数量（仅检索XX状态）"。与"互动O_设定Object状态"功能相同，只是状态参数在Object组中被固定为"Object组变量的内部ID"。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_objectGroup"></param>
        /// <param name="lp_groupState"></param>
        public static void HHD_SetObjectGState(object lp_object, string lp_objectGroup, string lp_groupState)
        {
            HHD_SetObjectState(lp_object, lp_objectGroup, lp_groupState);
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object的Object组专用状态。使用"互动O_设定Object、互动OG_设定Object组的Object状态"后可使用本函数。与"互动O_返回Object状态"功能相同，只是状态参数在Object组中被固定为"Object组变量的内部ID"。状态值"true"和"false"是Object的Object组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效）。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_objectGroup"></param>
        public static void HHD_ReturnObjectGState(object lp_object, string lp_objectGroup)
        {
            HHD_ReturnObjectState(lp_object, lp_objectGroup);
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object组元素序号对应元素。返回Object组元素序号指定Object。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static object HHD_ReturnObjectFromObjectGFunc(int lp_regNum, string lp_gs)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            object lv_object;
            // Variable Initialization
            lv_str = (lp_gs + "Object");
            lv_tag = HashTableLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            lv_object = (object)HashTableLoad0(true, ("HHD_Object_" + lv_tag));
            // Implementation
            return lv_object;
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object组元素总数。返回指定Object组的元素数量。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HHD_ReturnObjectGNumMax(string lp_gs)
        {
            return (int)HashTableLoad0(true, lp_gs + "ObjectNum");
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object组元素总数（仅检测Object组专用状态="true"）。返回指定Object组的元素数量。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HHD_ReturnObjectGNumMax_StateTrueFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            object lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HHD_ReturnObjectNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HHD_ReturnObjectFromRegNum(lv_a, lp_gs);
                lv_b = HHD_ReturnObjectState(lv_c, lp_gs);
                if ((lv_b == "true"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object组元素总数（仅检测Object组专用状态="false"）。返回指定Object组的元素数量。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HHD_ReturnObjectGNumMax_StateFalseFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            object lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HHD_ReturnObjectNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HHD_ReturnObjectFromRegNum(lv_a, lp_gs);
                lv_b = HHD_ReturnObjectState(lv_c, lp_gs);
                if ((lv_b == "false"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object组元素总数（仅检测Object组无效专用状态："false"或""）。返回指定Object组的元素数量（false、""、null）。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HHD_ReturnObjectGNumMax_StateUselessFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            object lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HHD_ReturnObjectNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HHD_ReturnObjectFromRegNum(lv_a, lp_gs);
                lv_b = HHD_ReturnObjectState(lv_c, lp_gs);
                if (((lv_b == "false") || (lv_b == "") || (lv_b == null)))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object组元素总数（仅检测Object组指定专用状态）。返回指定Object组的元素数量。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_State">Object组专用状态</param>
        /// <returns></returns>
        public static int HHD_ReturnObjectGNumMax_StateFunc_Specify(string lp_gs, string lp_State)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            object lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HHD_ReturnObjectNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HHD_ReturnObjectFromRegNum(lv_a, lp_gs);
                lv_b = HHD_ReturnObjectState(lv_c, lp_gs);
                if ((lv_b == lp_State))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动OG_添加Object到Object组。相同Object被认为是同一个，非高级功能不提供专用状态检查，如果Object没有设置过Object组专用状态，那么首次添加到Object组不会赋予"true"（之后可通过"互动O_设定Object状态"、"互动OG_设定Object组的Object状态"修改）。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HHD_AddObjectToGroup_Simple(object lp_object, string lp_gs)
        {
            HHD_RegObject_Simple(lp_object, lp_gs);
        }

        /// <summary>
        /// 【MM_函数库】互动OG_添加Object到Object组（高级）。相同Object被认为是同一个，高级功能提供专用状态检查，如果Object没有设置过Object组专用状态，那么首次添加到Object组会赋予"true"（之后可通过"互动O_设定Object状态"、"互动OG_设定Object组的Object状态"修改）。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HHD_AddObjectToGroup(object lp_object, string lp_gs)
        {
            HHD_RegObject_Simple(lp_object, lp_gs);
            if (HashTableKeyExists(true, ("HHD_ObjectState" + lp_gs + "Object_" + HHD_RegObjectTagAndReturn(lp_object))) == false)
            {
                HashTableSave0(true, ("HHD_ObjectState" + lp_gs + "Object_" + HHD_RegObjectTagAndReturn(lp_object)), "true");
                //Console.WriteLine(lp_gs + "=>" + HHD_RegObjectTagAndReturn(lp_object));
            }
        }

        /// <summary>
        /// 【MM_函数库】互动OG_移除Object组中的元素。使用"互动OG_添加Object到Object组"后可使用本函数进行移除元素。移除使用了"互动O_移除Object"，同一个存储区（Object组ID）序号重排，移除时该存储区如有其他操作会排队等待。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HHD_ClearObjectFromGroup(object lp_object, string lp_gs)
        {
            HHD_RemoveObject(lp_object, lp_gs);
        }

        //互动OG_为Object组中的每个序号
        //GE（星际2的Galaxy Editor）的宏让编辑器保存时自动生成脚本并整合进脚本进行格式调整，C#仅参考需自行编写
        // #AUTOVAR(vs, string) = "#PARAM(group)";//"#PARAM(group)"是与字段、变量名一致的元素组名称，宏去声明string类型名为“Auto随机编号_vs”的自动变量，然后=右侧字符
        // #AUTOVAR(ae) = HHD_ReturnObjectNumMax(#AUTOVAR(vs));//宏去声明默认int类型名为“Auto随机编号_ae”的自动变量，然后=右侧字符
        // #INITAUTOVAR(ai,increment)//宏去声明int类型名为“Auto随机编号_ai”的自动变量，用于下面for循环增量（increment是传入参数）
        // #PARAM(var) = #PARAM(s);//#PARAM(var)是传进来的参数，用作“当前被挑选到的元素”（任意变量-整数 lp_var）， #PARAM(s)是传进来的参数用作"开始"（int lp_s）
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #PARAM(var) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #PARAM(var) >= #AUTOVAR(ae)) ) ; #PARAM(var) += #AUTOVAR(ai) ) {
        //     #SUBFUNCS(actions)//代表用户GUI填写的所有动作
        // }

        /// <summary>
        /// 【MM_函数库】互动OG_为Object组中的每个序号。每次挑选的元素序号会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素序号，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void HHD_ForEachObjectNumFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            int lv_ae = HHD_ReturnObjectNumMax(lp_gs);
            int lv_var = lp_start;
            int lv_ai = lp_increment;
            for (; (lv_ai >= 0 && lv_var <= lv_ae) || (lv_ai < 0 && lv_var >= lv_ae); lv_var += lv_ai)
            {
                lp_funcref(lv_var);//用户填写的所有动作
            }
        }

        //互动OG_为Object组中的每个元素
        // #AUTOVAR(vs, string) = "#PARAM(group)";
        // #AUTOVAR(ae) = HHD_ReturnObjectNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= #PARAM(s);
        // #INITAUTOVAR(ai,increment)
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     HashTableSave(false, "ObjectGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)), HHD_ReturnObjectFromRegNum(#AUTOVAR(va),#AUTOVAR(vs)));
        // }
        // #AUTOVAR(va)= #PARAM(s);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #PARAM(var) = HashTableLoad(false, "ObjectGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)));
        //     #SUBFUNCS(actions)
        // }

        /// <summary>
        /// 【MM_函数库】互动OG_为Object组中的每个元素。每次挑选的元素会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void HHD_ForEachObjectFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            string lv_vs = lp_gs;
            int lv_ae = HHD_ReturnObjectNumMax(lv_vs);
            int lv_va = lp_start;
            int lv_ai = lp_increment;
            object lv_object;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                HashTableSave0(false, "ObjectGFor" + lv_vs + lv_va.ToString(), HHD_ReturnObjectFromRegNum(lv_va, lv_vs));
            }
            lv_va = lp_start;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                lv_object = HashTableLoad0(false, "ObjectGFor" + lv_vs + lv_va.ToString());
                lp_funcref(lv_object);//用户填写的所有动作
            }
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object组中随机元素。返回指定Object组中的随机Object。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static object HHD_ReturnRandomObjectFromObjectGFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_num;
            int lv_a;
            object lv_c = null;
            // Variable Initialization
            lv_num = HHD_ReturnObjectNumMax(lp_gs);
            // Implementation
            if ((lv_num >= 1))
            {
                lv_a = RandomInt(1, lv_num);
                lv_c = HHD_ReturnObjectFromRegNum(lv_a, lp_gs);
            }
            return lv_c;
        }

        //互动OG_添加Object组到Object组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = HHD_ReturnObjectNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = HHD_ReturnObjectFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     HHD_AddObjectToGroup(#AUTOVAR(var), #AUTOVAR(vsb));
        // }


        /// <summary>
        /// 【MM_函数库】互动OG_添加Object组到Object组。添加一个Object组A的元素到另一个Object组B，相同Object被认为是同一个。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void HHD_AddObjectGToObjectG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = HHD_ReturnObjectNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            object lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = HHD_ReturnObjectFromRegNum(lv_va, lv_vsa);
                HHD_AddObjectToGroup(lv_var, lv_vsb);
            }
        }

        //互动OG_从Object组移除Object组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = HHD_ReturnObjectNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = HHD_ReturnObjectFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     HHD_RemoveObject(#AUTOVAR(var), #AUTOVAR(vsb));
        // }

        /// <summary>
        /// 【MM_函数库】互动OG_从Object组移除Object组。将Object组A的元素从Object组B中移除，相同Object被认为是同一个。移除使用了"互动O_移除Object"，同一个存储区（Object组ID）序号重排，移除时该存储区如有其他操作会排队等待。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void HHD_ClearObjectGFromObjectG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = HHD_ReturnObjectNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            object lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = HHD_ReturnObjectFromRegNum(lv_va, lv_vsa);
                HHD_RemoveObject(lv_var, lv_vsb);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动OG_移除Object组全部元素。将Object组（Key区）存储的元素全部移除，相同Object被认为是同一个。移除时同一个存储区（Object组ID）序号不进行重排，但该存储区如有其他操作会排队等待。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Object组名称</param>
        public static void HHD_RemoveObjectGAll(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag = "";
            int lv_a;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            // Implementation
            ThreadWait(lv_str);
            HashTableSave0(true, "Key_ObjectGroup" + lv_str, 1);
            for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
            {
                lv_tag = HashTableLoad1(true, (lp_key + "ObjectTag"), lv_a).ToString();
                lv_num -= 1;
                HashTableClear0(true, "HHD_IfObjectTag" + lv_str + "_" + lv_tag);
                HashTableClear0(true, "HHD_ObjectCV" + lv_str + "_" + lv_tag);
                HashTableClear0(true, "HHD_ObjectState" + lv_str + "_" + lv_tag);
                HashTableSave0(true, (lp_key + "ObjectNum"), lv_num);
            }
            HashTableSave0(true, "Key_ObjectGroup" + lv_str, 0);
        }

        //--------------------------------------------------------------------------------------------------
        // 任意类型组End
        //--------------------------------------------------------------------------------------------------

        #endregion

        #region 二维向量

        //提示：尽可能使用对口类型，以防值类型与引用类型发生转换时拆装箱降低性能

        //--------------------------------------------------------------------------------------------------
        // 二维向量组Start
        //--------------------------------------------------------------------------------------------------

        /// <summary>
        /// 【MM_函数库】互动V_注册Vector标签句柄并返回。为Vector自动设置新的标签句柄，重复时会返回已注册的Vector标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns>返回一个Vector的已注册标签</returns>
        private static int HHD_RegVectorTagAndReturn_Int(Vector2F lp_vector)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)HashTableLoad0(true, "HHD_VectorJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                HashTableSave0(true, "HHD_VectorJBNum", lv_j);
                HashTableSave0(true, ("HHD_Vector_" + lv_j.ToString()), lp_vector);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if ((Vector2F)HashTableLoad0(true, ("HHD_Vector_" + lv_j.ToString())) == lp_vector)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            HashTableSave0(true, "HHD_VectorJBNum", lv_j);
                            HashTableSave0(true, ("HHD_Vector_" + lv_j.ToString()), lp_vector);
                        }
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector已注册标签句柄
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns>返回一个Vector的已注册标签，错误返回0</returns>
        public static int HHD_ReturnVectorTag_Int(Vector2F lp_vector)
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)HashTableLoad0(true, "HHD_VectorJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if ((Vector2F)HashTableLoad0(true, "HHD_Vector_" + lv_j.ToString()) == lp_vector)
                {
                    break;
                }
                else
                {
                    if ((lv_j == lv_jBNum))
                    {
                        lv_j = 0;
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动V_注册Vector标签句柄并返回。为Vector自动设置新的标签句柄，重复时会返回已注册的Vector标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns>返回一个Vector的已注册标签</returns>
        private static string HHD_RegVectorTagAndReturn(Vector2F lp_vector)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag = "";
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)HashTableLoad0(true, "HHD_VectorJBNum");
            lv_tag = "";
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                HashTableSave0(true, "HHD_VectorJBNum", lv_j);
                HashTableSave0(true, ("HHD_Vector_" + lv_j.ToString()), lp_vector);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if ((Vector2F)HashTableLoad0(true, "HHD_Vector_" + lv_j.ToString()) == lp_vector)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            HashTableSave0(true, "HHD_VectorJBNum", lv_j);
                            HashTableSave0(true, ("HHD_Vector_" + lv_j.ToString()), lp_vector);
                        }
                    }
                }
            }
            lv_tag = lv_j.ToString();
            //Console.WriteLine(("Tag：" + lv_tag));
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector已注册标签句柄
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns>返回一个Vector的已注册标签，错误返回""</returns>
        public static string HHD_ReturnVectorTag(Vector2F lp_vector)
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag = "";
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)HashTableLoad0(true, "HHD_VectorJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if ((Vector2F)HashTableLoad0(true, "HHD_Vector_" + lv_j.ToString()) == lp_vector)
                {
                    lv_tag = lv_j.ToString();
                    break;
                }
            }
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动V_注册Vector(高级)。在指定Key存入Vector，固有状态、自定义值是Vector独一无二的标志（本函数重复注册会刷新），之后可用互动V_"返回Vector注册总数"、"返回Vector序号"、"返回序号对应Vector"、"返回序号对应Vector标签"、"返回Vector自定义值"。Vector组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Vector组转为Key。首次注册时固有状态为true（相当于单位组单位活体），如需另外设置多个标记可使用"互动V_设定Vector状态/自定义值"
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        /// <param name="lp_inherentStats">固有状态</param>
        /// <param name="lp_inherentCustomValue">固有自定义值</param>
        public static void HHD_RegVector(Vector2F lp_vector, string lp_key, string lp_inherentStats, string lp_inherentCustomValue)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_jBNum = (int)HashTableLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = HHD_RegVectorTagAndReturn(lp_vector);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                HashTableSave0(true, (lv_str + "Num"), lv_i);
                HashTableSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                HashTableSave0(true, (("HHD_IfVectorTag" + "") + "_" + lv_tagStr), true);
                HashTableSave1(true, ("HHD_IfVectorTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if ((HashTableLoad1(true, (lv_str + "Tag"), lv_i).ToString() == lv_tagStr))
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                HashTableSave0(true, (lv_str + "Num"), lv_i);
                                HashTableSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                HashTableSave0(true, (("HHD_IfVectorTag" + "") + "_" + lv_tagStr), true);
                                HashTableSave1(true, ("HHD_IfVectorTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            HashTableSave0(true, ("HHD_VectorState" + "" + "_" + lv_tagStr), lp_inherentStats);
            HashTableSave0(true, ("HHD_VectorCV" + "" + "_" + lv_tagStr), lp_inherentCustomValue);
        }

        /// <summary>
        /// 【MM_函数库】互动V_注册Vector。在指定Key存入Vector，固有状态、自定义值是Vector独一无二的标志（本函数重复注册不会刷新），之后可用互动V_"返回Vector注册总数"、"返回Vector序号"、"返回序号对应Vector"、"返回Vector自定义值"。Vector组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Vector组转为Key。首次注册时固有状态为true（相当于单位组单位活体），之后只能通过"互动V_注册Vector（高级）"改写，如需另外设置多个标记可使用"互动V_设定Vector状态/自定义值"
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        public static void HHD_RegVector_Simple(Vector2F lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_jBNum = (int)HashTableLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = HHD_RegVectorTagAndReturn(lp_vector);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                HashTableSave0(true, (lv_str + "Num"), lv_i);
                HashTableSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                HashTableSave0(true, (("HHD_IfVectorTag" + "") + "_" + lv_tagStr), true);
                HashTableSave1(true, ("HHD_IfVectorTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if ((HashTableLoad1(true, (lv_str + "Tag"), lv_i).ToString() == lv_tagStr))
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                HashTableSave0(true, (lv_str + "Num"), lv_i);
                                HashTableSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                HashTableSave0(true, (("HHD_IfVectorTag" + "") + "_" + lv_tagStr), true);
                                HashTableSave1(true, ("HHD_IfVectorTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            if ((HashTableKeyExists(true, ("HHD_Vector" + "State" + "_" + lv_tag.ToString())) == false))
            {
                HashTableSave1(true, (("HHD_Vector" + "State")), lv_tag, "true");
            }
        }

        /// <summary>
        /// 【MM_函数库】互动V_注销Vector。用"互动V_注册Vector"到Key，之后可用本函数彻底摧毁注册信息并将序号重排（包括Vector标签有效状态、固有状态及自定义值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动V_设定Vector状态"让Vector状态失效（类似单位组的单位活体状态）。Vector组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Vector组转为Key。本函数无法摧毁用"互动V_设定Vector状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Vector组变量ID时会清空Vector组专用状态
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        public static void HHD_DestroyVector(Vector2F lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag = "";
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_tag = HHD_ReturnVectorTag(lp_vector);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                HashTableSave0(true, "Key_VectorGroup" + lv_str, 1);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((HashTableLoad1(true, (lp_key + "VectorTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        HashTableClear0(true, "HHD_IfVectorTag_" + lv_tag);
                        HashTableClear0(true, "HHD_IfVectorTag" + lv_str + "_" + lv_tag);
                        HashTableClear0(true, "HHD_Vector_" + lv_tag);
                        HashTableClear0(true, "HHD_VectorCV_" + lv_tag);
                        HashTableClear0(true, "HHD_VectorState_" + lv_tag);
                        HashTableClear0(true, "HHD_VectorCV" + lv_str + "_" + lv_tag);
                        HashTableClear0(true, "HHD_VectorState" + lv_str + "_" + lv_tag);
                        HashTableSave0(true, (lp_key + "VectorNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = HashTableLoad1(true, (lp_key + "VectorTag"), lv_b + 1).ToString();
                            HashTableSave1(true, (lp_key + "VectorTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                HashTableSave0(true, "Key_VectorGroup" + lv_str, 0);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动V_移除Vector。用"互动V_注册Vector"到Key，之后可用本函数仅摧毁Key区注册的信息并将序号重排，用于Vector组或多个键区仅移除Vector（保留Vector标签有效状态、固有值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动V_设定Vector状态"让Vector状态失效（类似单位组的单位活体状态）。Vector组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Vector组转为Key。本函数无法摧毁用"互动V_设定Vector状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Vector组变量ID时会清空Vector组专用状态
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        public static void HHD_RemoveVector(Vector2F lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag = "";
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_tag = HHD_ReturnVectorTag(lp_vector);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                HashTableSave0(true, "Key_VectorGroup" + lv_str, 1);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((HashTableLoad1(true, (lp_key + "VectorTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        HashTableClear0(true, "HHD_IfVectorTag" + lv_str + "_" + lv_tag);
                        HashTableClear0(true, "HHD_VectorCV" + lv_str + "_" + lv_tag);
                        HashTableClear0(true, "HHD_VectorState" + lv_str + "_" + lv_tag);
                        HashTableSave0(true, (lp_key + "VectorNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = HashTableLoad1(true, (lp_key + "VectorTag"), lv_b + 1).ToString();
                            HashTableSave1(true, (lp_key + "VectorTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                HashTableSave0(true, "Key_VectorGroup" + lv_str, 0);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector注册总数。必须先使用"互动V_注册Vector"才能返回指定Key里的注册总数。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key。
        /// </summary>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        /// <returns></returns>
        public static int HHD_ReturnVectorNumMax(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            // Implementation
            return lv_num;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector序号。使用"互动V_注册Vector"后使用本函数可返回Key里的注册序号，Key无元素返回0，Key有元素但对象不在里面则返回-1，Vector标签尚未注册则返回-2。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        /// <returns></returns>
        public static int HHD_ReturnVectorNum(Vector2F lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_i;
            string lv_tag = "";
            int lv_torf;
            // Automatic Variable Declarations
            const int auto_n = 1;
            int auto_i;
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_tag = HHD_ReturnVectorTag(lp_vector);
            lv_torf = -1;
            // Implementation
            for (auto_i = 1; auto_i <= auto_n; auto_i += 1)
            {
                if ((lv_tag != null))
                {
                    lv_torf = -2;
                    break;
                }
                if ((lv_num == 0))
                {
                    lv_torf = 0;
                }
                else
                {
                    if ((lv_num >= 1))
                    {
                        auto_ae = lv_num;
                        auto_var = 1;
                        for (; auto_var <= auto_ae; auto_var += 1)
                        {
                            lv_i = auto_var;
                            if ((HashTableLoad1(true, (lv_str + "Tag"), lv_i).ToString() == lv_tag))
                            {
                                lv_torf = lv_i;
                                break;
                            }
                        }
                    }
                }
            }
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回序号对应Vector。使用"互动V_注册Vector"后，在参数填入注册序号可返回Vector。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_regNum"></param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        /// <returns></returns>
        public static Vector2F HHD_ReturnVectorFromRegNum(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            Vector2F lv_vector;
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            lv_tag = HashTableLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            lv_vector = (Vector2F)HashTableLoad0(true, ("HHD_Vector_" + lv_tag));
            // Implementation
            return lv_vector;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回句柄标签对应Vector。使用"互动V_注册Vector"后，在参数填入句柄标签（整数）可返回Vector，标签是Vector的句柄。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_tag">句柄标签</param>
        /// <returns></returns>
        public static Vector2F HHD_ReturnVectorFromTag(int lp_tag)
        {
            // Variable Declarations
            string lv_tag = "";
            Vector2F lv_vector;
            // Variable Initialization
            lv_tag = lp_tag.ToString();
            lv_vector = (Vector2F)HashTableLoad0(true, ("HHD_Vector_" + lv_tag));
            // Implementation
            return lv_vector;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回序号对应Vector标签句柄。使用"互动V_注册Vector"后，在参数填入注册序号可返回Vector标签（字符串）。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        /// <returns></returns>
        public static string HHD_ReturnVectorTagFromRegNum_String(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            lv_tag = HashTableLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回序号对应Vector标签句柄。使用"互动V_注册Vector"后，在参数填入注册序号可返回Vector标签（整数）。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        /// <returns></returns>
        public static int HHD_ReturnVectorTagFromRegNum_Int(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            lv_tag = HashTableLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return Convert.ToInt32(lv_tag);
        }

        /// <summary>
        /// 【MM_函数库】互动V_设置Vector状态。必须先"注册"获得功能库内部句柄，再使用本函数给Vector设定一个状态值，之后可用"互动V_返回Vector状态"。类型参数用以记录多个不同状态，仅当"类型"参数填Vector组ID转的Vector串时，状态值"true"和"false"是Vector的Vector组专用状态值，用于内部函数筛选Vector状态（相当于单位组单位索引是否有效），其他类型不会干扰系统内部，可随意填写。虽然注销时反向清空注册信息，但用"互动V_设定Vector状态/自定义值"创建的值需要手工填入""来排泄（非大量注销则提升内存量极小，可不管）。注：固有状态值是注册函数赋予的系统内部变量（相当于单位组单位是否活体），只能通过"互动V_注册Vector（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <param name="lp_stats">状态</param>
        public static void HHD_SetVectorState(Vector2F lp_vector, string lp_key, string lp_stats)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            lv_tag = HHD_RegVectorTagAndReturn(lp_vector);
            // Implementation
            HashTableSave0(true, ("HHD_VectorState" + lv_str + "_" + lv_tag), lp_stats);
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector状态。使用"互动V_设定Vector状态"后可使用本函数，将本函数参数"类型"设为空时返回固有值。类型参数用以记录多个不同状态，仅当"类型"参数为Vector组ID转的字符串时，返回的状态值"true"和"false"是Vector的Vector组专用状态值，用于内部函数筛选Vector状态（相当于单位组单位索引是否有效）
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <returns></returns>
        public static string HHD_ReturnVectorState(Vector2F lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            lv_tag = HHD_ReturnVectorTag(lp_vector);
            lv_stats = HashTableLoad0(true, ("HHD_VectorState" + lv_str + "_" + lv_tag)).ToString();
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动V_设置Vector自定义值。必须先"注册"获得功能库内部句柄，再使用本函数设定Vector的自定义值，之后可使用"互动V_返回Vector自定义值"，类型参数用以记录多个不同自定义值。注：固有自定义值是注册函数赋予的系统内部变量，只能通过"互动V_注册Vector（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <param name="lp_customValue">自定义值</param>
        public static void HHD_SetVectorCV(Vector2F lp_vector, string lp_key, string lp_customValue)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            lv_tag = HHD_RegVectorTagAndReturn(lp_vector);
            // Implementation
            HashTableSave0(true, ("HHD_VectorCV" + lv_str + "_" + lv_tag), lp_customValue);
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector自定义值。使用"互动V_设定Vector自定义值"后可使用本函数，将本函数参数"类型"设为空时返回固有值，该参数用以记录多个不同自定义值
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <returns></returns>
        public static string HHD_ReturnVectorCV(Vector2F lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            lv_tag = HHD_ReturnVectorTag(lp_vector);
            lv_customValue = HashTableLoad0(true, ("HHD_VectorCV" + lv_str + "_" + lv_tag)).ToString();
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector固有状态。必须先使用"互动V_注册Vector"才能返回到该值，固有状态是独一无二的标记（相当于单位组单位是否活体）
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns></returns>
        public static string HHD_ReturnVectorState_Only(Vector2F lp_vector)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_tag = HHD_ReturnVectorTag(lp_vector);
            lv_stats = HashTableLoad0(true, ("HHD_VectorState" + "" + "_" + lv_tag)).ToString();
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector固有自定义值。必须先使用"互动V_注册Vector"才能返回到该值，固有值是独一无二的标记
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns></returns>
        public static string HHD_ReturnVectorCV_Only(Vector2F lp_vector)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_tag = HHD_ReturnVectorTag(lp_vector);
            lv_customValue = HashTableLoad0(true, ("HHD_VectorCV" + "" + "_" + lv_tag)).ToString();
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动V_设置Vector的实数标记。必须先"注册"获得功能库内部句柄，再使用本函数让Vector携带一个实数值，之后可使用"互动V_返回Vector的实数标记"。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_realNumTag">实数标记</param>
        public static void HHD_SetVectorDouble(Vector2F lp_vector, double lp_realNumTag)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = HHD_RegVectorTagAndReturn(lp_vector);
            // Implementation
            HashTableSave0(true, ("HHD_CDDouble_T_" + lv_tag), lp_realNumTag);
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector的实数标记。使用"互动V_设定Vector的实数标记"后可使用本函数。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns></returns>
        public static double HHD_ReturnVectorDouble(Vector2F lp_vector)
        {
            // Variable Declarations
            string lv_tag = "";
            double lv_f;
            // Variable Initialization
            lv_tag = HHD_ReturnVectorTag(lp_vector);
            lv_f = (double)HashTableLoad0(true, ("HHD_CDDouble_T_" + lv_tag));
            // Implementation
            return lv_f;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector标签句柄有效状态。将Vector视作独一无二的个体，标签是它本身，有效状态则类似"单位是否有效"，当使用"互动V_注册Vector"或"互动VG_添加Vector到Vector组"后激活Vector有效状态（值为"true"），除非使用"互动V_注册Vector（高级）"改写，否则直到注销才会摧毁
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns></returns>
        public static bool HHD_ReturnIfVectorTag(Vector2F lp_vector)
        {
            // Variable Declarations
            string lv_tag = "";
            bool lv_torf;
            // Variable Initialization
            lv_tag = HHD_ReturnVectorTag(lp_vector);
            lv_torf = (bool)HashTableLoad0(true, ("HHD_IfVectorTag" + "" + "_" + lv_tag));
            // Implementation
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector注册状态。使用"互动V_注册Vector"或"互动VG_添加Vector到Vector组"后可使用本函数获取注册Vector在Key中的注册状态，该状态只能注销或从Vector组中移除时清空。Vector组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        /// <returns></returns>
        public static bool HHD_ReturnIfVectorTagKey(Vector2F lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            bool lv_torf;
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            lv_tag = HHD_ReturnVectorTag(lp_vector);
            lv_torf = (bool)HashTableLoad0(true, ("HHD_IfVectorTag" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动VG_根据自定义值类型将Vector组排序。根据Vector携带的自定义值类型，对指定的Vector组元素进行冒泡排序。Vector组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Vector组名称</param>
        /// <param name="lp_cVStr">自定义值类型</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void HHD_VectorGSortCV(string lp_key, string lp_cVStr, bool lp_big)
        {
            // Automatic Variable Declarations
            // Implementation
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            string lv_tagValuestr;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            ThreadWait(lv_str);
            HashTableSave0(true, "Key_VectorGroup" + lv_str, 1);
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = HHD_ReturnVectorTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValuestr = HHD_ReturnVectorCV(HHD_ReturnVectorFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    HashTableSave1(false, "IntStackOutTag", 1, lv_tag);
                    HashTableSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    HashTableSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < (int)HashTableLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    HashTableSave1(false, "IntStackOutTag", lv_c, HashTableLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    HashTableSave1(false, "IntStackOutTagValue", lv_c, HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    HashTableSave1(false, "IntStackOutTagIteraOrig", lv_c, HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                HashTableSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                HashTableSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                HashTableSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > (int)HashTableLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(HHD_ReturnVectorTagFromRegNum(lv_b, lp_key))+"值"+IntToString(HashTableLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    HashTableSave1(false, "IntStackOutTag", lv_c, HashTableLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(HashTableLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    HashTableSave1(false, "IntStackOutTagValue", lv_c, HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    HashTableSave1(false, "IntStackOutTagIteraOrig", lv_c, HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                HashTableSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                HashTableSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                HashTableSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        HashTableSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        HashTableSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        HashTableSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = HashTableLoad1(true, (lp_key + "VectorTag"), lv_a).ToString(); //原始序号元素
                lv_tag = (int)HashTableLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValuestr = HHD_ReturnVectorCV(HHD_ReturnVectorFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = (int)HashTableLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    HashTableSave1(true, (lp_key + "VectorTag"), lv_a, lv_tag); //lv_tag放入新序号
                    //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            HashTableSave0(true, "Key_VectorGroup" + lv_str, 0);
        }

        /// <summary>
        /// 【MM_函数库】互动VG_Vector组排序。对指定的Vector组元素进行冒泡排序（根据元素句柄）。Vector组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Vector组名称</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void HHD_VectorGSort(string lp_key, bool lp_big)
        {
            // Automatic Variable Declarations
            // Implementation
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            ThreadWait(lv_str);
            HashTableSave0(true, "Key_VectorGroup" + lv_str, 1);
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = HHD_ReturnVectorTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValue = lv_tag;
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    HashTableSave1(false, "IntStackOutTag", 1, lv_tag);
                    HashTableSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    HashTableSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < (int)HashTableLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    HashTableSave1(false, "IntStackOutTag", lv_c, HashTableLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    HashTableSave1(false, "IntStackOutTagValue", lv_c, HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    HashTableSave1(false, "IntStackOutTagIteraOrig", lv_c, HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                HashTableSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                HashTableSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                HashTableSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > (int)HashTableLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(HHD_ReturnVectorTagFromRegNum(lv_b, lp_key))+"值"+IntToString(HashTableLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    HashTableSave1(false, "IntStackOutTag", lv_c, HashTableLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(HashTableLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    HashTableSave1(false, "IntStackOutTagValue", lv_c, HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    HashTableSave1(false, "IntStackOutTagIteraOrig", lv_c, HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                HashTableSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                HashTableSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                HashTableSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        HashTableSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        HashTableSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        HashTableSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = HashTableLoad1(true, (lp_key + "VectorTag"), lv_a).ToString(); //原始序号元素
                lv_tag = (int)HashTableLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValue = lv_tag;
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = (int)HashTableLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                                                                                    //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    HashTableSave1(true, (lp_key + "VectorTag"), lv_a, lv_tag); //lv_tag放入新序号
                                                                                //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            HashTableSave0(true, "Key_VectorGroup" + lv_str, 0);
        }

        /// <summary>
        /// 【MM_函数库】互动VG_设定Vector的Vector组专用状态。给Vector组的Vector设定一个状态值（字符串），之后可用"互动V_返回Vector、互动VG_返回Vector组的Vector状态"。状态值"true"和"false"是Vector的Vector组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效），而本函数可以重设干预，影响函数"互动VG_返回Vector组元素数量（仅检索XX状态）"。与"互动V_设定Vector状态"功能相同，只是状态参数在Vector组中被固定为"Vector组变量的内部ID"。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_vectorGroup"></param>
        /// <param name="lp_groupState"></param>
        public static void HHD_SetVectorGState(Vector2F lp_vector, string lp_vectorGroup, string lp_groupState)
        {
            HHD_SetVectorState(lp_vector, lp_vectorGroup, lp_groupState);
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector的Vector组专用状态。使用"互动V_设定Vector、互动VG_设定Vector组的Vector状态"后可使用本函数。与"互动V_返回Vector状态"功能相同，只是状态参数在Vector组中被固定为"Vector组变量的内部ID"。状态值"true"和"false"是Vector的Vector组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效）。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_vectorGroup"></param>
        public static void HHD_ReturnVectorGState(Vector2F lp_vector, string lp_vectorGroup)
        {
            HHD_ReturnVectorState(lp_vector, lp_vectorGroup);
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector组元素序号对应元素。返回Vector组元素序号指定Vector。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static Vector2F HHD_ReturnVectorFromVectorGFunc(int lp_regNum, string lp_gs)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            Vector2F lv_vector;
            // Variable Initialization
            lv_str = (lp_gs + "Vector2F");
            lv_tag = HashTableLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            lv_vector = (Vector2F)HashTableLoad0(true, ("HHD_Vector_" + lv_tag));
            // Implementation
            return lv_vector;
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector组元素总数。返回指定Vector组的元素数量。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HHD_ReturnVectorGNumMax(string lp_gs)
        {
            return (int)HashTableLoad0(true, lp_gs + "VectorNum");
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector组元素总数（仅检测Vector组专用状态="true"）。返回指定Vector组的元素数量。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HHD_ReturnVectorGNumMax_StateTrueFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Vector2F lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HHD_ReturnVectorNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HHD_ReturnVectorFromRegNum(lv_a, lp_gs);
                lv_b = HHD_ReturnVectorState(lv_c, lp_gs);
                if ((lv_b == "true"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector组元素总数（仅检测Vector组专用状态="false"）。返回指定Vector组的元素数量。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HHD_ReturnVectorGNumMax_StateFalseFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Vector2F lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HHD_ReturnVectorNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HHD_ReturnVectorFromRegNum(lv_a, lp_gs);
                lv_b = HHD_ReturnVectorState(lv_c, lp_gs);
                if ((lv_b == "false"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector组元素总数（仅检测Vector组无效专用状态："false"或""）。返回指定Vector组的元素数量（false、""、null）。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HHD_ReturnVectorGNumMax_StateUselessFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Vector2F lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HHD_ReturnVectorNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HHD_ReturnVectorFromRegNum(lv_a, lp_gs);
                lv_b = HHD_ReturnVectorState(lv_c, lp_gs);
                if (((lv_b == "false") || (lv_b == "") || (lv_b == null)))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector组元素总数（仅检测Vector组指定专用状态）。返回指定Vector组的元素数量。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_State">Vector组专用状态</param>
        /// <returns></returns>
        public static int HHD_ReturnVectorGNumMax_StateFunc_Specify(string lp_gs, string lp_State)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Vector2F lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HHD_ReturnVectorNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HHD_ReturnVectorFromRegNum(lv_a, lp_gs);
                lv_b = HHD_ReturnVectorState(lv_c, lp_gs);
                if ((lv_b == lp_State))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动VG_添加Vector到Vector组。相同Vector被认为是同一个，非高级功能不提供专用状态检查，如果Vector没有设置过Vector组专用状态，那么首次添加到Vector组不会赋予"true"（之后可通过"互动V_设定Vector状态"、"互动VG_设定Vector组的Vector状态"修改）。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HHD_AddVectorToGroup_Simple(Vector2F lp_vector, string lp_gs)
        {
            HHD_RegVector_Simple(lp_vector, lp_gs);
        }

        /// <summary>
        /// 【MM_函数库】互动VG_添加Vector到Vector组（高级）。相同Vector被认为是同一个，高级功能提供专用状态检查，如果Vector没有设置过Vector组专用状态，那么首次添加到Vector组会赋予"true"（之后可通过"互动V_设定Vector状态"、"互动VG_设定Vector组的Vector状态"修改）。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HHD_AddVectorToGroup(Vector2F lp_vector, string lp_gs)
        {
            HHD_RegVector_Simple(lp_vector, lp_gs);
            if (HashTableKeyExists(true, ("HHD_VectorState" + lp_gs + "Vector_" + HHD_RegVectorTagAndReturn(lp_vector))) == false)
            {
                HashTableSave0(true, ("HHD_VectorState" + lp_gs + "Vector_" + HHD_RegVectorTagAndReturn(lp_vector)), "true");
                //Console.WriteLine(lp_gs + "=>" + HHD_RegVectorTagAndReturn(lp_vector));
            }
        }

        /// <summary>
        /// 【MM_函数库】互动VG_移除Vector组中的元素。使用"互动VG_添加Vector到Vector组"后可使用本函数进行移除元素。移除使用了"互动V_移除Vector"，同一个存储区（Vector组ID）序号重排，移除时该存储区如有其他操作会排队等待。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HHD_ClearVectorFromGroup(Vector2F lp_vector, string lp_gs)
        {
            HHD_RemoveVector(lp_vector, lp_gs);
        }

        //互动VG_为Vector组中的每个序号
        //GE（星际2的Galaxy Editor）的宏让编辑器保存时自动生成脚本并整合进脚本进行格式调整，C#仅参考需自行编写
        // #AUTOVAR(vs, string) = "#PARAM(group)";//"#PARAM(group)"是与字段、变量名一致的元素组名称，宏去声明string类型名为“Auto随机编号_vs”的自动变量，然后=右侧字符
        // #AUTOVAR(ae) = HHD_ReturnVectorNumMax(#AUTOVAR(vs));//宏去声明默认int类型名为“Auto随机编号_ae”的自动变量，然后=右侧字符
        // #INITAUTOVAR(ai,increment)//宏去声明int类型名为“Auto随机编号_ai”的自动变量，用于下面for循环增量（increment是传入参数）
        // #PARAM(var) = #PARAM(s);//#PARAM(var)是传进来的参数，用作“当前被挑选到的元素”（任意变量-整数 lp_var）， #PARAM(s)是传进来的参数用作"开始"（int lp_s）
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #PARAM(var) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #PARAM(var) >= #AUTOVAR(ae)) ) ; #PARAM(var) += #AUTOVAR(ai) ) {
        //     #SUBFUNCS(actions)//代表用户GUI填写的所有动作
        // }

        /// <summary>
        /// 【MM_函数库】互动VG_为Vector组中的每个序号。每次挑选的元素序号会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素序号，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void HHD_ForEachVectorNumFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            int lv_ae = HHD_ReturnVectorNumMax(lp_gs);
            int lv_var = lp_start;
            int lv_ai = lp_increment;
            for (; (lv_ai >= 0 && lv_var <= lv_ae) || (lv_ai < 0 && lv_var >= lv_ae); lv_var += lv_ai)
            {
                lp_funcref(lv_var);//用户填写的所有动作
            }
        }

        //互动VG_为Vector组中的每个元素
        // #AUTOVAR(vs, string) = "#PARAM(group)";
        // #AUTOVAR(ae) = HHD_ReturnVectorNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= #PARAM(s);
        // #INITAUTOVAR(ai,increment)
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     HashTableSave(false, "VectorGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)), HHD_ReturnVectorFromRegNum(#AUTOVAR(va),#AUTOVAR(vs)));
        // }
        // #AUTOVAR(va)= #PARAM(s);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #PARAM(var) = HashTableLoad(false, "VectorGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)));
        //     #SUBFUNCS(actions)
        // }

        /// <summary>
        /// 【MM_函数库】互动VG_为Vector组中的每个元素。每次挑选的元素会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void HHD_ForEachVectorFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            string lv_vs = lp_gs;
            int lv_ae = HHD_ReturnVectorNumMax(lv_vs);
            int lv_va = lp_start;
            int lv_ai = lp_increment;
            Vector2F lv_vector;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                HashTableSave0(false, "VectorGFor" + lv_vs + lv_va.ToString(), HHD_ReturnVectorFromRegNum(lv_va, lv_vs));
            }
            lv_va = lp_start;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                lv_vector = (Vector2F)HashTableLoad0(false, "VectorGFor" + lv_vs + lv_va.ToString());
                lp_funcref(lv_vector);//用户填写的所有动作
            }
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector组中随机元素。返回指定Vector组中的随机Vector。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static Vector2F HHD_ReturnRandomVectorFromVectorGFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_num;
            int lv_a;
            Vector2F lv_c = new Vector2F(0, 0);
            // Variable Initialization
            lv_num = HHD_ReturnVectorNumMax(lp_gs);
            // Implementation
            if ((lv_num >= 1))
            {
                lv_a = RandomInt(1, lv_num);
                lv_c = HHD_ReturnVectorFromRegNum(lv_a, lp_gs);
            }
            return lv_c;
        }

        //互动VG_添加Vector组到Vector组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = HHD_ReturnVectorNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = HHD_ReturnVectorFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     HHD_AddVectorToGroup(#AUTOVAR(var), #AUTOVAR(vsb));
        // }


        /// <summary>
        /// 【MM_函数库】互动VG_添加Vector组到Vector组。添加一个Vector组A的元素到另一个Vector组B，相同Vector被认为是同一个。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void HHD_AddVectorGToVectorG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = HHD_ReturnVectorNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            Vector2F lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = HHD_ReturnVectorFromRegNum(lv_va, lv_vsa);
                HHD_AddVectorToGroup(lv_var, lv_vsb);
            }
        }

        //互动VG_从Vector组移除Vector组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = HHD_ReturnVectorNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = HHD_ReturnVectorFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     HHD_RemoveVector(#AUTOVAR(var), #AUTOVAR(vsb));
        // }

        /// <summary>
        /// 【MM_函数库】互动VG_从Vector组移除Vector组。将Vector组A的元素从Vector组B中移除，相同Vector被认为是同一个。移除使用了"互动V_移除Vector"，同一个存储区（Vector组ID）序号重排，移除时该存储区如有其他操作会排队等待。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void HHD_ClearVectorGFromVectorG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = HHD_ReturnVectorNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            Vector2F lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = HHD_ReturnVectorFromRegNum(lv_va, lv_vsa);
                HHD_RemoveVector(lv_var, lv_vsb);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动VG_移除Vector组全部元素。将Vector组（Key区）存储的元素全部移除，相同Vector被认为是同一个。移除时同一个存储区（Vector组ID）序号不进行重排，但该存储区如有其他操作会排队等待。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Vector组名称</param>
        public static void HHD_RemoveVectorGAll(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag = "";
            int lv_a;
            // Variable Initialization
            lv_str = (lp_key + "Vector2F");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            // Implementation
            ThreadWait(lv_str);
            HashTableSave0(true, "Key_VectorGroup" + lv_str, 1);
            for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
            {
                lv_tag = HashTableLoad1(true, (lp_key + "VectorTag"), lv_a).ToString();
                lv_num -= 1;
                HashTableClear0(true, "HHD_IfVectorTag" + lv_str + "_" + lv_tag);
                HashTableClear0(true, "HHD_VectorCV" + lv_str + "_" + lv_tag);
                HashTableClear0(true, "HHD_VectorState" + lv_str + "_" + lv_tag);
                HashTableSave0(true, (lp_key + "VectorNum"), lv_num);
            }
            HashTableSave0(true, "Key_VectorGroup" + lv_str, 0);
        }

        //--------------------------------------------------------------------------------------------------
        // 二维向量组End
        //--------------------------------------------------------------------------------------------------

        #endregion

        #region 计时器

        //提示：尽可能使用对口类型，以防值类型与引用类型发生转换时拆装箱降低性能

        //--------------------------------------------------------------------------------------------------
        // 计时器组Start
        //--------------------------------------------------------------------------------------------------

        /// <summary>
        /// 【MM_函数库】互动T_注册Timer标签句柄并返回。为Timer自动设置新的标签句柄，重复时会返回已注册的Timer标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns>返回一个Timer的已注册标签</returns>
        private static int HHD_RegTimerTagAndReturn_Int(Timer lp_timer)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)HashTableLoad0(true, "HHD_TimerJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                HashTableSave0(true, "HHD_TimerJBNum", lv_j);
                HashTableSave0(true, ("HHD_Timer_" + lv_j.ToString()), lp_timer);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if ((Timer)HashTableLoad0(true, ("HHD_Timer_" + lv_j.ToString())) == lp_timer)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            HashTableSave0(true, "HHD_TimerJBNum", lv_j);
                            HashTableSave0(true, ("HHD_Timer_" + lv_j.ToString()), lp_timer);
                        }
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer已注册标签句柄
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns>返回一个Timer的已注册标签，错误返回0</returns>
        public static int HHD_ReturnTimerTag_Int(Timer lp_timer)
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)HashTableLoad0(true, "HHD_TimerJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if ((Timer)HashTableLoad0(true, "HHD_Timer_" + lv_j.ToString()) == lp_timer)
                {
                    break;
                }
                else
                {
                    if ((lv_j == lv_jBNum))
                    {
                        lv_j = 0;
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动T_注册Timer标签句柄并返回。为Timer自动设置新的标签句柄，重复时会返回已注册的Timer标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns>返回一个Timer的已注册标签</returns>
        private static string HHD_RegTimerTagAndReturn(Timer lp_timer)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag = "";
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)HashTableLoad0(true, "HHD_TimerJBNum");
            lv_tag = "";
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                HashTableSave0(true, "HHD_TimerJBNum", lv_j);
                HashTableSave0(true, ("HHD_Timer_" + lv_j.ToString()), lp_timer);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if ((Timer)HashTableLoad0(true, "HHD_Timer_" + lv_j.ToString()) == lp_timer)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            HashTableSave0(true, "HHD_TimerJBNum", lv_j);
                            HashTableSave0(true, ("HHD_Timer_" + lv_j.ToString()), lp_timer);
                        }
                    }
                }
            }
            lv_tag = lv_j.ToString();
            //Console.WriteLine(("Tag：" + lv_tag));
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer已注册标签句柄
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns>返回一个Timer的已注册标签，错误返回""</returns>
        public static string HHD_ReturnTimerTag(Timer lp_timer)
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag = "";
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)HashTableLoad0(true, "HHD_TimerJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if ((Timer)HashTableLoad0(true, "HHD_Timer_" + lv_j.ToString()) == lp_timer)
                {
                    lv_tag = lv_j.ToString();
                    break;
                }
            }
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动T_注册Timer(高级)。在指定Key存入Timer，固有状态、自定义值是Timer独一无二的标志（本函数重复注册会刷新），之后可用互动T_"返回Timer注册总数"、"返回Timer序号"、"返回序号对应Timer"、"返回序号对应Timer标签"、"返回Timer自定义值"。Timer组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Timer组转为Key。首次注册时固有状态为true（相当于单位组单位活体），如需另外设置多个标记可使用"互动T_设定Timer状态/自定义值"
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        /// <param name="lp_inherentStats">固有状态</param>
        /// <param name="lp_inherentCustomValue">固有自定义值</param>
        public static void HHD_RegTimer(Timer lp_timer, string lp_key, string lp_inherentStats, string lp_inherentCustomValue)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_jBNum = (int)HashTableLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = HHD_RegTimerTagAndReturn(lp_timer);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                HashTableSave0(true, (lv_str + "Num"), lv_i);
                HashTableSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                HashTableSave0(true, (("HHD_IfTimerTag" + "") + "_" + lv_tagStr), true);
                HashTableSave1(true, ("HHD_IfTimerTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if ((HashTableLoad1(true, (lv_str + "Tag"), lv_i).ToString() == lv_tagStr))
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                HashTableSave0(true, (lv_str + "Num"), lv_i);
                                HashTableSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                HashTableSave0(true, (("HHD_IfTimerTag" + "") + "_" + lv_tagStr), true);
                                HashTableSave1(true, ("HHD_IfTimerTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            HashTableSave0(true, ("HHD_TimerState" + "" + "_" + lv_tagStr), lp_inherentStats);
            HashTableSave0(true, ("HHD_TimerCV" + "" + "_" + lv_tagStr), lp_inherentCustomValue);
        }

        /// <summary>
        /// 【MM_函数库】互动T_注册Timer。在指定Key存入Timer，固有状态、自定义值是Timer独一无二的标志（本函数重复注册不会刷新），之后可用互动T_"返回Timer注册总数"、"返回Timer序号"、"返回序号对应Timer"、"返回Timer自定义值"。Timer组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Timer组转为Key。首次注册时固有状态为true（相当于单位组单位活体），之后只能通过"互动T_注册Timer（高级）"改写，如需另外设置多个标记可使用"互动T_设定Timer状态/自定义值"
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        public static void HHD_RegTimer_Simple(Timer lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_jBNum = (int)HashTableLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = HHD_RegTimerTagAndReturn(lp_timer);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                HashTableSave0(true, (lv_str + "Num"), lv_i);
                HashTableSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                HashTableSave0(true, (("HHD_IfTimerTag" + "") + "_" + lv_tagStr), true);
                HashTableSave1(true, ("HHD_IfTimerTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if ((HashTableLoad1(true, (lv_str + "Tag"), lv_i).ToString() == lv_tagStr))
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                HashTableSave0(true, (lv_str + "Num"), lv_i);
                                HashTableSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                HashTableSave0(true, (("HHD_IfTimerTag" + "") + "_" + lv_tagStr), true);
                                HashTableSave1(true, ("HHD_IfTimerTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            if ((HashTableKeyExists(true, ("HHD_Timer" + "State" + "_" + lv_tag.ToString())) == false))
            {
                HashTableSave1(true, (("HHD_Timer" + "State")), lv_tag, "true");
            }
        }

        /// <summary>
        /// 【MM_函数库】互动T_注销Timer。用"互动T_注册Timer"到Key，之后可用本函数彻底摧毁注册信息并将序号重排（包括Timer标签有效状态、固有状态及自定义值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动T_设定Timer状态"让Timer状态失效（类似单位组的单位活体状态）。Timer组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Timer组转为Key。本函数无法摧毁用"互动T_设定Timer状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Timer组变量ID时会清空Timer组专用状态
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        public static void HHD_DestroyTimer(Timer lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag = "";
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_tag = HHD_ReturnTimerTag(lp_timer);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                HashTableSave0(true, "Key_TimerGroup" + lv_str, 1);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((HashTableLoad1(true, (lp_key + "TimerTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        HashTableClear0(true, "HHD_IfTimerTag_" + lv_tag);
                        HashTableClear0(true, "HHD_IfTimerTag" + lv_str + "_" + lv_tag);
                        HashTableClear0(true, "HHD_Timer_" + lv_tag);
                        HashTableClear0(true, "HHD_TimerCV_" + lv_tag);
                        HashTableClear0(true, "HHD_TimerState_" + lv_tag);
                        HashTableClear0(true, "HHD_TimerCV" + lv_str + "_" + lv_tag);
                        HashTableClear0(true, "HHD_TimerState" + lv_str + "_" + lv_tag);
                        HashTableSave0(true, (lp_key + "TimerNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = HashTableLoad1(true, (lp_key + "TimerTag"), lv_b + 1).ToString();
                            HashTableSave1(true, (lp_key + "TimerTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                HashTableSave0(true, "Key_TimerGroup" + lv_str, 0);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动T_移除Timer。用"互动T_注册Timer"到Key，之后可用本函数仅摧毁Key区注册的信息并将序号重排，用于Timer组或多个键区仅移除Timer（保留Timer标签有效状态、固有值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动T_设定Timer状态"让Timer状态失效（类似单位组的单位活体状态）。Timer组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Timer组转为Key。本函数无法摧毁用"互动T_设定Timer状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Timer组变量ID时会清空Timer组专用状态
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        public static void HHD_RemoveTimer(Timer lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag = "";
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_tag = HHD_ReturnTimerTag(lp_timer);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                HashTableSave0(true, "Key_TimerGroup" + lv_str, 1);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((HashTableLoad1(true, (lp_key + "TimerTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        HashTableClear0(true, "HHD_IfTimerTag" + lv_str + "_" + lv_tag);
                        HashTableClear0(true, "HHD_TimerCV" + lv_str + "_" + lv_tag);
                        HashTableClear0(true, "HHD_TimerState" + lv_str + "_" + lv_tag);
                        HashTableSave0(true, (lp_key + "TimerNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = HashTableLoad1(true, (lp_key + "TimerTag"), lv_b + 1).ToString();
                            HashTableSave1(true, (lp_key + "TimerTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                HashTableSave0(true, "Key_TimerGroup" + lv_str, 0);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer注册总数。必须先使用"互动T_注册Timer"才能返回指定Key里的注册总数。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key。
        /// </summary>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        /// <returns></returns>
        public static int HHD_ReturnTimerNumMax(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            // Implementation
            return lv_num;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer序号。使用"互动T_注册Timer"后使用本函数可返回Key里的注册序号，Key无元素返回0，Key有元素但对象不在里面则返回-1，Timer标签尚未注册则返回-2。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        /// <returns></returns>
        public static int HHD_ReturnTimerNum(Timer lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_i;
            string lv_tag = "";
            int lv_torf;
            // Automatic Variable Declarations
            const int auto_n = 1;
            int auto_i;
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_tag = HHD_ReturnTimerTag(lp_timer);
            lv_torf = -1;
            // Implementation
            for (auto_i = 1; auto_i <= auto_n; auto_i += 1)
            {
                if ((lv_tag != null))
                {
                    lv_torf = -2;
                    break;
                }
                if ((lv_num == 0))
                {
                    lv_torf = 0;
                }
                else
                {
                    if ((lv_num >= 1))
                    {
                        auto_ae = lv_num;
                        auto_var = 1;
                        for (; auto_var <= auto_ae; auto_var += 1)
                        {
                            lv_i = auto_var;
                            if ((HashTableLoad1(true, (lv_str + "Tag"), lv_i).ToString() == lv_tag))
                            {
                                lv_torf = lv_i;
                                break;
                            }
                        }
                    }
                }
            }
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回序号对应Timer。使用"互动T_注册Timer"后，在参数填入注册序号可返回Timer。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_regNum"></param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        /// <returns></returns>
        public static Timer HHD_ReturnTimerFromRegNum(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            Timer lv_timer;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = HashTableLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            lv_timer = (Timer)HashTableLoad0(true, ("HHD_Timer_" + lv_tag));
            // Implementation
            return lv_timer;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回句柄标签对应Timer。使用"互动T_注册Timer"后，在参数填入句柄标签（整数）可返回Timer，标签是Timer的句柄。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_tag">句柄标签</param>
        /// <returns></returns>
        public static Timer HHD_ReturnTimerFromTag(int lp_tag)
        {
            // Variable Declarations
            string lv_tag = "";
            Timer lv_timer;
            // Variable Initialization
            lv_tag = lp_tag.ToString();
            lv_timer = (Timer)HashTableLoad0(true, ("HHD_Timer_" + lv_tag));
            // Implementation
            return lv_timer;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回序号对应Timer标签句柄。使用"互动T_注册Timer"后，在参数填入注册序号可返回Timer标签（字符串）。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        /// <returns></returns>
        public static string HHD_ReturnTimerTagFromRegNum_String(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = HashTableLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回序号对应Timer标签句柄。使用"互动T_注册Timer"后，在参数填入注册序号可返回Timer标签（整数）。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        /// <returns></returns>
        public static int HHD_ReturnTimerTagFromRegNum_Int(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = HashTableLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return Convert.ToInt32(lv_tag);
        }

        /// <summary>
        /// 【MM_函数库】互动T_设置Timer状态。必须先"注册"获得功能库内部句柄，再使用本函数给Timer设定一个状态值，之后可用"互动T_返回Timer状态"。类型参数用以记录多个不同状态，仅当"类型"参数填Timer组ID转的Timer串时，状态值"true"和"false"是Timer的Timer组专用状态值，用于内部函数筛选Timer状态（相当于单位组单位索引是否有效），其他类型不会干扰系统内部，可随意填写。虽然注销时反向清空注册信息，但用"互动T_设定Timer状态/自定义值"创建的值需要手工填入""来排泄（非大量注销则提升内存量极小，可不管）。注：固有状态值是注册函数赋予的系统内部变量（相当于单位组单位是否活体），只能通过"互动T_注册Timer（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <param name="lp_stats">状态</param>
        public static void HHD_SetTimerState(Timer lp_timer, string lp_key, string lp_stats)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = HHD_RegTimerTagAndReturn(lp_timer);
            // Implementation
            HashTableSave0(true, ("HHD_TimerState" + lv_str + "_" + lv_tag), lp_stats);
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer状态。使用"互动T_设定Timer状态"后可使用本函数，将本函数参数"类型"设为空时返回固有值。类型参数用以记录多个不同状态，仅当"类型"参数为Timer组ID转的字符串时，返回的状态值"true"和"false"是Timer的Timer组专用状态值，用于内部函数筛选Timer状态（相当于单位组单位索引是否有效）
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <returns></returns>
        public static string HHD_ReturnTimerState(Timer lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = HHD_ReturnTimerTag(lp_timer);
            lv_stats = HashTableLoad0(true, ("HHD_TimerState" + lv_str + "_" + lv_tag)).ToString();
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动T_设置Timer自定义值。必须先"注册"获得功能库内部句柄，再使用本函数设定Timer的自定义值，之后可使用"互动T_返回Timer自定义值"，类型参数用以记录多个不同自定义值。注：固有自定义值是注册函数赋予的系统内部变量，只能通过"互动T_注册Timer（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <param name="lp_customValue">自定义值</param>
        public static void HHD_SetTimerCV(Timer lp_timer, string lp_key, string lp_customValue)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = HHD_RegTimerTagAndReturn(lp_timer);
            // Implementation
            HashTableSave0(true, ("HHD_TimerCV" + lv_str + "_" + lv_tag), lp_customValue);
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer自定义值。使用"互动T_设定Timer自定义值"后可使用本函数，将本函数参数"类型"设为空时返回固有值，该参数用以记录多个不同自定义值
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <returns></returns>
        public static string HHD_ReturnTimerCV(Timer lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = HHD_ReturnTimerTag(lp_timer);
            lv_customValue = HashTableLoad0(true, ("HHD_TimerCV" + lv_str + "_" + lv_tag)).ToString();
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer固有状态。必须先使用"互动T_注册Timer"才能返回到该值，固有状态是独一无二的标记（相当于单位组单位是否活体）
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns></returns>
        public static string HHD_ReturnTimerState_Only(Timer lp_timer)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_tag = HHD_ReturnTimerTag(lp_timer);
            lv_stats = HashTableLoad0(true, ("HHD_TimerState" + "" + "_" + lv_tag)).ToString();
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer固有自定义值。必须先使用"互动T_注册Timer"才能返回到该值，固有值是独一无二的标记
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns></returns>
        public static string HHD_ReturnTimerCV_Only(Timer lp_timer)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_tag = HHD_ReturnTimerTag(lp_timer);
            lv_customValue = HashTableLoad0(true, ("HHD_TimerCV" + "" + "_" + lv_tag)).ToString();
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动T_设置Timer的实数标记。必须先"注册"获得功能库内部句柄，再使用本函数让Timer携带一个实数值，之后可使用"互动T_返回Timer的实数标记"。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_realNumTag">实数标记</param>
        public static void HHD_SetTimerDouble(Timer lp_timer, double lp_realNumTag)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = HHD_RegTimerTagAndReturn(lp_timer);
            // Implementation
            HashTableSave0(true, ("HHD_CDDouble_T_" + lv_tag), lp_realNumTag);
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer的实数标记。使用"互动T_设定Timer的实数标记"后可使用本函数。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns></returns>
        public static double HHD_ReturnTimerDouble(Timer lp_timer)
        {
            // Variable Declarations
            string lv_tag = "";
            double lv_f;
            // Variable Initialization
            lv_tag = HHD_ReturnTimerTag(lp_timer);
            lv_f = (double)HashTableLoad0(true, ("HHD_CDDouble_T_" + lv_tag));
            // Implementation
            return lv_f;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer标签句柄有效状态。将Timer视作独一无二的个体，标签是它本身，有效状态则类似"单位是否有效"，当使用"互动T_注册Timer"或"互动TG_添加Timer到Timer组"后激活Timer有效状态（值为"true"），除非使用"互动T_注册Timer（高级）"改写，否则直到注销才会摧毁
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns></returns>
        public static bool HHD_ReturnIfTimerTag(Timer lp_timer)
        {
            // Variable Declarations
            string lv_tag = "";
            bool lv_torf;
            // Variable Initialization
            lv_tag = HHD_ReturnTimerTag(lp_timer);
            lv_torf = (bool)HashTableLoad0(true, ("HHD_IfTimerTag" + "" + "_" + lv_tag));
            // Implementation
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer注册状态。使用"互动T_注册Timer"或"互动TG_添加Timer到Timer组"后可使用本函数获取注册Timer在Key中的注册状态，该状态只能注销或从Timer组中移除时清空。Timer组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        /// <returns></returns>
        public static bool HHD_ReturnIfTimerTagKey(Timer lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            bool lv_torf;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = HHD_ReturnTimerTag(lp_timer);
            lv_torf = (bool)HashTableLoad0(true, ("HHD_IfTimerTag" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动TG_根据自定义值类型将Timer组排序。根据Timer携带的自定义值类型，对指定的Timer组元素进行冒泡排序。Timer组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Timer组名称</param>
        /// <param name="lp_cVStr">自定义值类型</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void HHD_TimerGSortCV(string lp_key, string lp_cVStr, bool lp_big)
        {
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            string lv_tagValuestr;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            ThreadWait(lv_str);
            HashTableSave0(true, "Key_TimerGroup" + lv_str, 1);
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = HHD_ReturnTimerTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValuestr = HHD_ReturnTimerCV(HHD_ReturnTimerFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    HashTableSave1(false, "IntStackOutTag", 1, lv_tag);
                    HashTableSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    HashTableSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < (int)HashTableLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    HashTableSave1(false, "IntStackOutTag", lv_c, HashTableLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    HashTableSave1(false, "IntStackOutTagValue", lv_c, HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    HashTableSave1(false, "IntStackOutTagIteraOrig", lv_c, HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                HashTableSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                HashTableSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                HashTableSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > (int)HashTableLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(HHD_ReturnTimerTagFromRegNum(lv_b, lp_key))+"值"+IntToString(HashTableLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    HashTableSave1(false, "IntStackOutTag", lv_c, HashTableLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(HashTableLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    HashTableSave1(false, "IntStackOutTagValue", lv_c, HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    HashTableSave1(false, "IntStackOutTagIteraOrig", lv_c, HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                HashTableSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                HashTableSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                HashTableSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        HashTableSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        HashTableSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        HashTableSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = HashTableLoad1(true, (lp_key + "TimerTag"), lv_a).ToString(); //原始序号元素
                lv_tag = (int)HashTableLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValuestr = HHD_ReturnTimerCV(HHD_ReturnTimerFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = (int)HashTableLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    HashTableSave1(true, (lp_key + "TimerTag"), lv_a, lv_tag); //lv_tag放入新序号
                    //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            HashTableSave0(true, "Key_TimerGroup" + lv_str, 0);
        }

        /// <summary>
        /// 【MM_函数库】互动TG_Timer组排序。对指定的Timer组元素进行冒泡排序（根据元素句柄）。Timer组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Timer组名称</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void HHD_TimerGSort(string lp_key, bool lp_big)
        {
            // Automatic Variable Declarations
            // Implementation
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            ThreadWait(lv_str);
            HashTableSave0(true, "Key_TimerGroup" + lv_str, 1);
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = HHD_ReturnTimerTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValue = lv_tag;
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    HashTableSave1(false, "IntStackOutTag", 1, lv_tag);
                    HashTableSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    HashTableSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < (int)HashTableLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    HashTableSave1(false, "IntStackOutTag", lv_c, HashTableLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    HashTableSave1(false, "IntStackOutTagValue", lv_c, HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    HashTableSave1(false, "IntStackOutTagIteraOrig", lv_c, HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                HashTableSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                HashTableSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                HashTableSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > (int)HashTableLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(HHD_ReturnTimerTagFromRegNum(lv_b, lp_key))+"值"+IntToString(HashTableLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    HashTableSave1(false, "IntStackOutTag", lv_c, HashTableLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(HashTableLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    HashTableSave1(false, "IntStackOutTagValue", lv_c, HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    HashTableSave1(false, "IntStackOutTagIteraOrig", lv_c, HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                HashTableSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                HashTableSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                HashTableSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        HashTableSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        HashTableSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        HashTableSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = HashTableLoad1(true, (lp_key + "TimerTag"), lv_a).ToString(); //原始序号元素
                lv_tag = (int)HashTableLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValue = lv_tag;
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = (int)HashTableLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                                                                                    //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    HashTableSave1(true, (lp_key + "TimerTag"), lv_a, lv_tag); //lv_tag放入新序号
                                                                               //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            HashTableSave0(true, "Key_TimerGroup" + lv_str, 0);
        }

        /// <summary>
        /// 【MM_函数库】互动TG_设定Timer的Timer组专用状态。给Timer组的Timer设定一个状态值（字符串），之后可用"互动T_返回Timer、互动TG_返回Timer组的Timer状态"。状态值"true"和"false"是Timer的Timer组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效），而本函数可以重设干预，影响函数"互动TG_返回Timer组元素数量（仅检索XX状态）"。与"互动T_设定Timer状态"功能相同，只是状态参数在Timer组中被固定为"Timer组变量的内部ID"。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_timerGroup"></param>
        /// <param name="lp_groupState"></param>
        public static void HHD_SetTimerGState(Timer lp_timer, string lp_timerGroup, string lp_groupState)
        {
            HHD_SetTimerState(lp_timer, lp_timerGroup, lp_groupState);
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer的Timer组专用状态。使用"互动T_设定Timer、互动TG_设定Timer组的Timer状态"后可使用本函数。与"互动T_返回Timer状态"功能相同，只是状态参数在Timer组中被固定为"Timer组变量的内部ID"。状态值"true"和"false"是Timer的Timer组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效）。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_timerGroup"></param>
        public static void HHD_ReturnTimerGState(Timer lp_timer, string lp_timerGroup)
        {
            HHD_ReturnTimerState(lp_timer, lp_timerGroup);
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer组元素序号对应元素。返回Timer组元素序号指定Timer。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static Timer HHD_ReturnTimerFromTimerGFunc(int lp_regNum, string lp_gs)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            Timer lv_timer;
            // Variable Initialization
            lv_str = (lp_gs + "Timer");
            lv_tag = HashTableLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            lv_timer = (Timer)HashTableLoad0(true, ("HHD_Timer_" + lv_tag));
            // Implementation
            return lv_timer;
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer组元素总数。返回指定Timer组的元素数量。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HHD_ReturnTimerGNumMax(string lp_gs)
        {
            return (int)HashTableLoad0(true, lp_gs + "TimerNum");
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer组元素总数（仅检测Timer组专用状态="true"）。返回指定Timer组的元素数量。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HHD_ReturnTimerGNumMax_StateTrueFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Timer lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HHD_ReturnTimerNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HHD_ReturnTimerFromRegNum(lv_a, lp_gs);
                lv_b = HHD_ReturnTimerState(lv_c, lp_gs);
                if ((lv_b == "true"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer组元素总数（仅检测Timer组专用状态="false"）。返回指定Timer组的元素数量。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HHD_ReturnTimerGNumMax_StateFalseFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Timer lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HHD_ReturnTimerNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HHD_ReturnTimerFromRegNum(lv_a, lp_gs);
                lv_b = HHD_ReturnTimerState(lv_c, lp_gs);
                if ((lv_b == "false"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer组元素总数（仅检测Timer组无效专用状态："false"或""）。返回指定Timer组的元素数量（false、""、null）。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HHD_ReturnTimerGNumMax_StateUselessFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Timer lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HHD_ReturnTimerNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HHD_ReturnTimerFromRegNum(lv_a, lp_gs);
                lv_b = HHD_ReturnTimerState(lv_c, lp_gs);
                if (((lv_b == "false") || (lv_b == "") || (lv_b == null)))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer组元素总数（仅检测Timer组指定专用状态）。返回指定Timer组的元素数量。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_State">Timer组专用状态</param>
        /// <returns></returns>
        public static int HHD_ReturnTimerGNumMax_StateFunc_Specify(string lp_gs, string lp_State)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Timer lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HHD_ReturnTimerNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HHD_ReturnTimerFromRegNum(lv_a, lp_gs);
                lv_b = HHD_ReturnTimerState(lv_c, lp_gs);
                if ((lv_b == lp_State))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动TG_添加Timer到Timer组。相同Timer被认为是同一个，非高级功能不提供专用状态检查，如果Timer没有设置过Timer组专用状态，那么首次添加到Timer组不会赋予"true"（之后可通过"互动T_设定Timer状态"、"互动TG_设定Timer组的Timer状态"修改）。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HHD_AddTimerToGroup_Simple(Timer lp_timer, string lp_gs)
        {
            HHD_RegTimer_Simple(lp_timer, lp_gs);
        }

        /// <summary>
        /// 【MM_函数库】互动TG_添加Timer到Timer组（高级）。相同Timer被认为是同一个，高级功能提供专用状态检查，如果Timer没有设置过Timer组专用状态，那么首次添加到Timer组会赋予"true"（之后可通过"互动T_设定Timer状态"、"互动TG_设定Timer组的Timer状态"修改）。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HHD_AddTimerToGroup(Timer lp_timer, string lp_gs)
        {
            HHD_RegTimer_Simple(lp_timer, lp_gs);
            if (HashTableKeyExists(true, ("HHD_TimerState" + lp_gs + "Timer_" + HHD_RegTimerTagAndReturn(lp_timer))) == false)
            {
                HashTableSave0(true, ("HHD_TimerState" + lp_gs + "Timer_" + HHD_RegTimerTagAndReturn(lp_timer)), "true");
                //Console.WriteLine(lp_gs + "=>" + HHD_RegTimerTagAndReturn(lp_timer));
            }
        }

        /// <summary>
        /// 【MM_函数库】互动TG_移除Timer组中的元素。使用"互动TG_添加Timer到Timer组"后可使用本函数进行移除元素。移除使用了"互动T_移除Timer"，同一个存储区（Timer组ID）序号重排，移除时该存储区如有其他操作会排队等待。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HHD_ClearTimerFromGroup(Timer lp_timer, string lp_gs)
        {
            HHD_RemoveTimer(lp_timer, lp_gs);
        }

        //互动TG_为Timer组中的每个序号
        //GE（星际2的Galaxy Editor）的宏让编辑器保存时自动生成脚本并整合进脚本进行格式调整，C#仅参考需自行编写
        // #AUTOVAR(vs, string) = "#PARAM(group)";//"#PARAM(group)"是与字段、变量名一致的元素组名称，宏去声明string类型名为“Auto随机编号_vs”的自动变量，然后=右侧字符
        // #AUTOVAR(ae) = HHD_ReturnTimerNumMax(#AUTOVAR(vs));//宏去声明默认int类型名为“Auto随机编号_ae”的自动变量，然后=右侧字符
        // #INITAUTOVAR(ai,increment)//宏去声明int类型名为“Auto随机编号_ai”的自动变量，用于下面for循环增量（increment是传入参数）
        // #PARAM(var) = #PARAM(s);//#PARAM(var)是传进来的参数，用作“当前被挑选到的元素”（任意变量-整数 lp_var）， #PARAM(s)是传进来的参数用作"开始"（int lp_s）
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #PARAM(var) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #PARAM(var) >= #AUTOVAR(ae)) ) ; #PARAM(var) += #AUTOVAR(ai) ) {
        //     #SUBFUNCS(actions)//代表用户GUI填写的所有动作
        // }

        /// <summary>
        /// 【MM_函数库】互动TG_为Timer组中的每个序号。每次挑选的元素序号会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素序号，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void HHD_ForEachTimerNumFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            int lv_ae = HHD_ReturnTimerNumMax(lp_gs);
            int lv_var = lp_start;
            int lv_ai = lp_increment;
            for (; (lv_ai >= 0 && lv_var <= lv_ae) || (lv_ai < 0 && lv_var >= lv_ae); lv_var += lv_ai)
            {
                lp_funcref(lv_var);//用户填写的所有动作
            }
        }

        //互动TG_为Timer组中的每个元素
        // #AUTOVAR(vs, string) = "#PARAM(group)";
        // #AUTOVAR(ae) = HHD_ReturnTimerNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= #PARAM(s);
        // #INITAUTOVAR(ai,increment)
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     HashTableSave(false, "TimerGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)), HHD_ReturnTimerFromRegNum(#AUTOVAR(va),#AUTOVAR(vs)));
        // }
        // #AUTOVAR(va)= #PARAM(s);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #PARAM(var) = HashTableLoad(false, "TimerGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)));
        //     #SUBFUNCS(actions)
        // }

        /// <summary>
        /// 【MM_函数库】互动TG_为Timer组中的每个元素。每次挑选的元素会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void HHD_ForEachTimerFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            string lv_vs = lp_gs;
            int lv_ae = HHD_ReturnTimerNumMax(lv_vs);
            int lv_va = lp_start;
            int lv_ai = lp_increment;
            Timer lv_timer;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                HashTableSave0(false, "TimerGFor" + lv_vs + lv_va.ToString(), HHD_ReturnTimerFromRegNum(lv_va, lv_vs));
            }
            lv_va = lp_start;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                lv_timer = (Timer)HashTableLoad0(false, "TimerGFor" + lv_vs + lv_va.ToString());
                lp_funcref(lv_timer);//用户填写的所有动作
            }
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer组中随机元素。返回指定Timer组中的随机Timer。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static Timer HHD_ReturnRandomTimerFromTimerGFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_num;
            int lv_a;
            Timer lv_c = null;
            // Variable Initialization
            lv_num = HHD_ReturnTimerNumMax(lp_gs);
            // Implementation
            if ((lv_num >= 1))
            {
                lv_a = RandomInt(1, lv_num);
                lv_c = HHD_ReturnTimerFromRegNum(lv_a, lp_gs);
            }
            return lv_c;
        }

        //互动TG_添加Timer组到Timer组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = HHD_ReturnTimerNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = HHD_ReturnTimerFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     HHD_AddTimerToGroup(#AUTOVAR(var), #AUTOVAR(vsb));
        // }


        /// <summary>
        /// 【MM_函数库】互动TG_添加Timer组到Timer组。添加一个Timer组A的元素到另一个Timer组B，相同Timer被认为是同一个。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void HHD_AddTimerGToTimerG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = HHD_ReturnTimerNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            Timer lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = HHD_ReturnTimerFromRegNum(lv_va, lv_vsa);
                HHD_AddTimerToGroup(lv_var, lv_vsb);
            }
        }

        //互动TG_从Timer组移除Timer组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = HHD_ReturnTimerNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = HHD_ReturnTimerFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     HHD_RemoveTimer(#AUTOVAR(var), #AUTOVAR(vsb));
        // }

        /// <summary>
        /// 【MM_函数库】互动TG_从Timer组移除Timer组。将Timer组A的元素从Timer组B中移除，相同Timer被认为是同一个。移除使用了"互动T_移除Timer"，同一个存储区（Timer组ID）序号重排，移除时该存储区如有其他操作会排队等待。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void HHD_ClearTimerGFromTimerG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = HHD_ReturnTimerNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            Timer lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = HHD_ReturnTimerFromRegNum(lv_va, lv_vsa);
                HHD_RemoveTimer(lv_var, lv_vsb);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动TG_移除Timer组全部元素。将Timer组（Key区）存储的元素全部移除，相同Timer被认为是同一个。移除时同一个存储区（Timer组ID）序号不进行重排，但该存储区如有其他操作会排队等待。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Timer组名称</param>
        public static void HHD_RemoveTimerGAll(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag = "";
            int lv_a;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            // Implementation
            ThreadWait(lv_str);
            HashTableSave0(true, "Key_TimerGroup" + lv_str, 1);
            for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
            {
                lv_tag = HashTableLoad1(true, (lp_key + "TimerTag"), lv_a).ToString();
                lv_num -= 1;
                HashTableClear0(true, "HHD_IfTimerTag" + lv_str + "_" + lv_tag);
                HashTableClear0(true, "HHD_TimerCV" + lv_str + "_" + lv_tag);
                HashTableClear0(true, "HHD_TimerState" + lv_str + "_" + lv_tag);
                HashTableSave0(true, (lp_key + "TimerNum"), lv_num);
            }
            HashTableSave0(true, "Key_TimerGroup" + lv_str, 0);
        }

        //--------------------------------------------------------------------------------------------------
        // 计时器组End
        //--------------------------------------------------------------------------------------------------

        #endregion

        #region 字符串

        //提示：可以将字符串作为模板修改后产生其他类型
        //提示：尽可能使用对口类型，以防值类型与引用类型发生转换时拆装箱降低性能

        //--------------------------------------------------------------------------------------------------
        // 字符串组Start
        //--------------------------------------------------------------------------------------------------

        /// <summary>
        /// 【MM_函数库】互动S_注册String标签句柄并返回。为String自动设置新的标签句柄，重复时会返回已注册的String标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_string"></param>
        /// <returns>返回一个String的已注册标签</returns>
        private static int HHD_RegStringTagAndReturn_Int(string lp_string)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)HashTableLoad0(true, "HHD_StringJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                HashTableSave0(true, "HHD_StringJBNum", lv_j);
                HashTableSave0(true, ("HHD_String_" + lv_j.ToString()), lp_string);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if ((string)HashTableLoad0(true, ("HHD_String_" + lv_j.ToString())) == lp_string)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            HashTableSave0(true, "HHD_StringJBNum", lv_j);
                            HashTableSave0(true, ("HHD_String_" + lv_j.ToString()), lp_string);
                        }
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String已注册标签句柄
        /// </summary>
        /// <param name="lp_string"></param>
        /// <returns>返回一个String的已注册标签，错误返回0</returns>
        public static int HHD_ReturnStringTag_Int(string lp_string)
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)HashTableLoad0(true, "HHD_StringJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if ((string)HashTableLoad0(true, "HHD_String_" + lv_j.ToString()) == lp_string)
                {
                    break;
                }
                else
                {
                    if ((lv_j == lv_jBNum))
                    {
                        lv_j = 0;
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动S_注册String标签句柄并返回。为String自动设置新的标签句柄，重复时会返回已注册的String标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_string"></param>
        /// <returns>返回一个String的已注册标签</returns>
        private static string HHD_RegStringTagAndReturn(string lp_string)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag = "";
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)HashTableLoad0(true, "HHD_StringJBNum");
            lv_tag = "";
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                HashTableSave0(true, "HHD_StringJBNum", lv_j);
                HashTableSave0(true, ("HHD_String_" + lv_j.ToString()), lp_string);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if ((string)HashTableLoad0(true, "HHD_String_" + lv_j.ToString()) == lp_string)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            HashTableSave0(true, "HHD_StringJBNum", lv_j);
                            HashTableSave0(true, ("HHD_String_" + lv_j.ToString()), lp_string);
                        }
                    }
                }
            }
            lv_tag = lv_j.ToString();
            //Console.WriteLine(("Tag：" + lv_tag));
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String已注册标签句柄
        /// </summary>
        /// <param name="lp_string"></param>
        /// <returns>返回一个String的已注册标签，错误返回""</returns>
        public static string HHD_ReturnStringTag(string lp_string)
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag = "";
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)HashTableLoad0(true, "HHD_StringJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if ((string)HashTableLoad0(true, "HHD_String_" + lv_j.ToString()) == lp_string)
                {
                    lv_tag = lv_j.ToString();
                    break;
                }
            }
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动S_注册String(高级)。在指定Key存入String，固有状态、自定义值是String独一无二的标志（本函数重复注册会刷新），之后可用互动S_"返回String注册总数"、"返回String序号"、"返回序号对应String"、"返回序号对应String标签"、"返回String自定义值"。String组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将String组转为Key。首次注册时固有状态为true（相当于单位组单位活体），如需另外设置多个标记可使用"互动S_设定String状态/自定义值"
        /// </summary>
        /// <param name="lp_string"></param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        /// <param name="lp_inherentStats">固有状态</param>
        /// <param name="lp_inherentCustomValue">固有自定义值</param>
        public static void HHD_RegString(string lp_string, string lp_key, string lp_inherentStats, string lp_inherentCustomValue)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_jBNum = (int)HashTableLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = HHD_RegStringTagAndReturn(lp_string);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                HashTableSave0(true, (lv_str + "Num"), lv_i);
                HashTableSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                HashTableSave0(true, (("HHD_IfStringTag" + "") + "_" + lv_tagStr), true);
                HashTableSave1(true, ("HHD_IfStringTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if ((HashTableLoad1(true, (lv_str + "Tag"), lv_i).ToString() == lv_tagStr))
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                HashTableSave0(true, (lv_str + "Num"), lv_i);
                                HashTableSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                HashTableSave0(true, (("HHD_IfStringTag" + "") + "_" + lv_tagStr), true);
                                HashTableSave1(true, ("HHD_IfStringTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            HashTableSave0(true, ("HHD_StringState" + "" + "_" + lv_tagStr), lp_inherentStats);
            HashTableSave0(true, ("HHD_StringCV" + "" + "_" + lv_tagStr), lp_inherentCustomValue);
        }

        /// <summary>
        /// 【MM_函数库】互动S_注册String。在指定Key存入String，固有状态、自定义值是String独一无二的标志（本函数重复注册不会刷新），之后可用互动S_"返回String注册总数"、"返回String序号"、"返回序号对应String"、"返回String自定义值"。String组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将String组转为Key。首次注册时固有状态为true（相当于单位组单位活体），之后只能通过"互动S_注册String（高级）"改写，如需另外设置多个标记可使用"互动S_设定String状态/自定义值"
        /// </summary>
        /// <param name="lp_string"></param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        public static void HHD_RegString_Simple(string lp_string, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_jBNum = (int)HashTableLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = HHD_RegStringTagAndReturn(lp_string);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                HashTableSave0(true, (lv_str + "Num"), lv_i);
                HashTableSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                HashTableSave0(true, (("HHD_IfStringTag" + "") + "_" + lv_tagStr), true);
                HashTableSave1(true, ("HHD_IfStringTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if ((HashTableLoad1(true, (lv_str + "Tag"), lv_i).ToString() == lv_tagStr))
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                HashTableSave0(true, (lv_str + "Num"), lv_i);
                                HashTableSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                HashTableSave0(true, (("HHD_IfStringTag" + "") + "_" + lv_tagStr), true);
                                HashTableSave1(true, ("HHD_IfStringTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            if ((HashTableKeyExists(true, ("HHD_String" + "State" + "_" + lv_tag.ToString())) == false))
            {
                HashTableSave1(true, (("HHD_String" + "State")), lv_tag, "true");
            }
        }

        /// <summary>
        /// 【MM_函数库】互动S_注销String。用"互动S_注册String"到Key，之后可用本函数彻底摧毁注册信息并将序号重排（包括String标签有效状态、固有状态及自定义值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动S_设定String状态"让String状态失效（类似单位组的单位活体状态）。String组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将String组转为Key。本函数无法摧毁用"互动S_设定String状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填String组变量ID时会清空String组专用状态
        /// </summary>
        /// <param name="lp_string"></param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        public static void HHD_DestroyString(string lp_string, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag = "";
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_tag = HHD_ReturnStringTag(lp_string);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                HashTableSave0(true, "Key_StringGroup" + lv_str, 1);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((HashTableLoad1(true, (lp_key + "StringTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        HashTableClear0(true, "HHD_IfStringTag_" + lv_tag);
                        HashTableClear0(true, "HHD_IfStringTag" + lv_str + "_" + lv_tag);
                        HashTableClear0(true, "HHD_String_" + lv_tag);
                        HashTableClear0(true, "HHD_StringCV_" + lv_tag);
                        HashTableClear0(true, "HHD_StringState_" + lv_tag);
                        HashTableClear0(true, "HHD_StringCV" + lv_str + "_" + lv_tag);
                        HashTableClear0(true, "HHD_StringState" + lv_str + "_" + lv_tag);
                        HashTableSave0(true, (lp_key + "StringNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = HashTableLoad1(true, (lp_key + "StringTag"), lv_b + 1).ToString();
                            HashTableSave1(true, (lp_key + "StringTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                HashTableSave0(true, "Key_StringGroup" + lv_str, 0);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动S_移除String。用"互动S_注册String"到Key，之后可用本函数仅摧毁Key区注册的信息并将序号重排，用于String组或多个键区仅移除String（保留String标签有效状态、固有值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动S_设定String状态"让String状态失效（类似单位组的单位活体状态）。String组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将String组转为Key。本函数无法摧毁用"互动S_设定String状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填String组变量ID时会清空String组专用状态
        /// </summary>
        /// <param name="lp_string"></param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        public static void HHD_RemoveString(string lp_string, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag = "";
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_tag = HHD_ReturnStringTag(lp_string);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                HashTableSave0(true, "Key_StringGroup" + lv_str, 1);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((HashTableLoad1(true, (lp_key + "StringTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        HashTableClear0(true, "HHD_IfStringTag" + lv_str + "_" + lv_tag);
                        HashTableClear0(true, "HHD_StringCV" + lv_str + "_" + lv_tag);
                        HashTableClear0(true, "HHD_StringState" + lv_str + "_" + lv_tag);
                        HashTableSave0(true, (lp_key + "StringNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = HashTableLoad1(true, (lp_key + "StringTag"), lv_b + 1).ToString();
                            HashTableSave1(true, (lp_key + "StringTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                HashTableSave0(true, "Key_StringGroup" + lv_str, 0);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String注册总数。必须先使用"互动S_注册String"才能返回指定Key里的注册总数。String组使用时，可用"获取变量的内部名称"将String组转为Key。
        /// </summary>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        /// <returns></returns>
        public static int HHD_ReturnStringNumMax(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            // Implementation
            return lv_num;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String序号。使用"互动S_注册String"后使用本函数可返回Key里的注册序号，Key无元素返回0，Key有元素但对象不在里面则返回-1，String标签尚未注册则返回-2。String组使用时，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_string"></param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        /// <returns></returns>
        public static int HHD_ReturnStringNum(string lp_string, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_i;
            string lv_tag = "";
            int lv_torf;
            // Automatic Variable Declarations
            const int auto_n = 1;
            int auto_i;
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_tag = HHD_ReturnStringTag(lp_string);
            lv_torf = -1;
            // Implementation
            for (auto_i = 1; auto_i <= auto_n; auto_i += 1)
            {
                if ((lv_tag != null))
                {
                    lv_torf = -2;
                    break;
                }
                if ((lv_num == 0))
                {
                    lv_torf = 0;
                }
                else
                {
                    if ((lv_num >= 1))
                    {
                        auto_ae = lv_num;
                        auto_var = 1;
                        for (; auto_var <= auto_ae; auto_var += 1)
                        {
                            lv_i = auto_var;
                            if ((HashTableLoad1(true, (lv_str + "Tag"), lv_i).ToString() == lv_tag))
                            {
                                lv_torf = lv_i;
                                break;
                            }
                        }
                    }
                }
            }
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回序号对应String。使用"互动S_注册String"后，在参数填入注册序号可返回String。String组使用时，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_regNum"></param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        /// <returns></returns>
        public static string HHD_ReturnStringFromRegNum(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_string;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = HashTableLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            lv_string = (string)HashTableLoad0(true, ("HHD_String_" + lv_tag));
            // Implementation
            return lv_string;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回句柄标签对应String。使用"互动S_注册String"后，在参数填入句柄标签（整数）可返回String，标签是String的句柄。String组使用时，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_tag">句柄标签</param>
        /// <returns></returns>
        public static string HHD_ReturnStringFromTag(int lp_tag)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_string;
            // Variable Initialization
            lv_tag = lp_tag.ToString();
            lv_string = (string)HashTableLoad0(true, ("HHD_String_" + lv_tag));
            // Implementation
            return lv_string;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回序号对应String标签句柄。使用"互动S_注册String"后，在参数填入注册序号可返回String标签（字符串串）。String组使用时，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        /// <returns></returns>
        public static string HHD_ReturnStringTagFromRegNum_String(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = HashTableLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回序号对应String标签句柄。使用"互动S_注册String"后，在参数填入注册序号可返回String标签（整数）。String组使用时，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        /// <returns></returns>
        public static int HHD_ReturnStringTagFromRegNum_Int(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = HashTableLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return Convert.ToInt32(lv_tag);
        }

        /// <summary>
        /// 【MM_函数库】互动S_设置String状态。必须先"注册"获得功能库内部句柄，再使用本函数给String设定一个状态值，之后可用"互动S_返回String状态"。类型参数用以记录多个不同状态，仅当"类型"参数填String组ID转的String串时，状态值"true"和"false"是String的String组专用状态值，用于内部函数筛选String状态（相当于单位组单位索引是否有效），其他类型不会干扰系统内部，可随意填写。虽然注销时反向清空注册信息，但用"互动S_设定String状态/自定义值"创建的值需要手工填入""来排泄（非大量注销则提升内存量极小，可不管）。注：固有状态值是注册函数赋予的系统内部变量（相当于单位组单位是否活体），只能通过"互动S_注册String（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_string"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <param name="lp_stats">状态</param>
        public static void HHD_SetStringState(string lp_string, string lp_key, string lp_stats)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = HHD_RegStringTagAndReturn(lp_string);
            // Implementation
            HashTableSave0(true, ("HHD_StringState" + lv_str + "_" + lv_tag), lp_stats);
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String状态。使用"互动S_设定String状态"后可使用本函数，将本函数参数"类型"设为空时返回固有值。类型参数用以记录多个不同状态，仅当"类型"参数为String组ID转的字符串串时，返回的状态值"true"和"false"是String的String组专用状态值，用于内部函数筛选String状态（相当于单位组单位索引是否有效）
        /// </summary>
        /// <param name="lp_string"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <returns></returns>
        public static string HHD_ReturnStringState(string lp_string, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = HHD_ReturnStringTag(lp_string);
            lv_stats = HashTableLoad0(true, ("HHD_StringState" + lv_str + "_" + lv_tag)).ToString();
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动S_设置String自定义值。必须先"注册"获得功能库内部句柄，再使用本函数设定String的自定义值，之后可使用"互动S_返回String自定义值"，类型参数用以记录多个不同自定义值。注：固有自定义值是注册函数赋予的系统内部变量，只能通过"互动S_注册String（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_string"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <param name="lp_customValue">自定义值</param>
        public static void HHD_SetStringCV(string lp_string, string lp_key, string lp_customValue)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = HHD_RegStringTagAndReturn(lp_string);
            // Implementation
            HashTableSave0(true, ("HHD_StringCV" + lv_str + "_" + lv_tag), lp_customValue);
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String自定义值。使用"互动S_设定String自定义值"后可使用本函数，将本函数参数"类型"设为空时返回固有值，该参数用以记录多个不同自定义值
        /// </summary>
        /// <param name="lp_string"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <returns></returns>
        public static string HHD_ReturnStringCV(string lp_string, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = HHD_ReturnStringTag(lp_string);
            lv_customValue = HashTableLoad0(true, ("HHD_StringCV" + lv_str + "_" + lv_tag)).ToString();
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String固有状态。必须先使用"互动S_注册String"才能返回到该值，固有状态是独一无二的标记（相当于单位组单位是否活体）
        /// </summary>
        /// <param name="lp_string"></param>
        /// <returns></returns>
        public static string HHD_ReturnStringState_Only(string lp_string)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_tag = HHD_ReturnStringTag(lp_string);
            lv_stats = HashTableLoad0(true, ("HHD_StringState" + "" + "_" + lv_tag)).ToString();
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String固有自定义值。必须先使用"互动S_注册String"才能返回到该值，固有值是独一无二的标记
        /// </summary>
        /// <param name="lp_string"></param>
        /// <returns></returns>
        public static string HHD_ReturnStringCV_Only(string lp_string)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_tag = HHD_ReturnStringTag(lp_string);
            lv_customValue = HashTableLoad0(true, ("HHD_StringCV" + "" + "_" + lv_tag)).ToString();
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动S_设置String的实数标记。必须先"注册"获得功能库内部句柄，再使用本函数让String携带一个实数值，之后可使用"互动S_返回String的实数标记"。String组使用时，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_string"></param>
        /// <param name="lp_realNumTag">实数标记</param>
        public static void HHD_SetStringDouble(string lp_string, double lp_realNumTag)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = HHD_RegStringTagAndReturn(lp_string);
            // Implementation
            HashTableSave0(true, ("HHD_CDDouble_T_" + lv_tag), lp_realNumTag);
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String的实数标记。使用"互动S_设定String的实数标记"后可使用本函数。String组使用时，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_string"></param>
        /// <returns></returns>
        public static double HHD_ReturnStringDouble(string lp_string)
        {
            // Variable Declarations
            string lv_tag = "";
            double lv_f;
            // Variable Initialization
            lv_tag = HHD_ReturnStringTag(lp_string);
            lv_f = (double)HashTableLoad0(true, ("HHD_CDDouble_T_" + lv_tag));
            // Implementation
            return lv_f;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String标签句柄有效状态。将String视作独一无二的个体，标签是它本身，有效状态则类似"单位是否有效"，当使用"互动S_注册String"或"互动SG_添加String到String组"后激活String有效状态（值为"true"），除非使用"互动S_注册String（高级）"改写，否则直到注销才会摧毁
        /// </summary>
        /// <param name="lp_string"></param>
        /// <returns></returns>
        public static bool HHD_ReturnIfStringTag(string lp_string)
        {
            // Variable Declarations
            string lv_tag = "";
            bool lv_torf;
            // Variable Initialization
            lv_tag = HHD_ReturnStringTag(lp_string);
            lv_torf = (bool)HashTableLoad0(true, ("HHD_IfStringTag" + "" + "_" + lv_tag));
            // Implementation
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String注册状态。使用"互动S_注册String"或"互动SG_添加String到String组"后可使用本函数获取注册String在Key中的注册状态，该状态只能注销或从String组中移除时清空。String组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_string"></param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        /// <returns></returns>
        public static bool HHD_ReturnIfStringTagKey(string lp_string, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            bool lv_torf;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = HHD_ReturnStringTag(lp_string);
            lv_torf = (bool)HashTableLoad0(true, ("HHD_IfStringTag" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动SG_根据自定义值类型将String组排序。根据String携带的自定义值类型，对指定的String组元素进行冒泡排序。String组变量字符串可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填String组名称</param>
        /// <param name="lp_cVStr">自定义值类型</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void HHD_StringGSortCV(string lp_key, string lp_cVStr, bool lp_big)
        {
            // Automatic Variable Declarations
            // Implementation
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            string lv_tagValuestr;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "String");
            ThreadWait(lv_str);
            HashTableSave0(true, "Key_StringGroup" + lv_str, 1);
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = HHD_ReturnStringTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValuestr = HHD_ReturnStringCV(HHD_ReturnStringFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    HashTableSave1(false, "IntStackOutTag", 1, lv_tag);
                    HashTableSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    HashTableSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < (int)HashTableLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    HashTableSave1(false, "IntStackOutTag", lv_c, HashTableLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    HashTableSave1(false, "IntStackOutTagValue", lv_c, HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    HashTableSave1(false, "IntStackOutTagIteraOrig", lv_c, HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                HashTableSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                HashTableSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                HashTableSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > (int)HashTableLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(HHD_ReturnStringTagFromRegNum(lv_b, lp_key))+"值"+IntToString(HashTableLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    HashTableSave1(false, "IntStackOutTag", lv_c, HashTableLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(HashTableLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    HashTableSave1(false, "IntStackOutTagValue", lv_c, HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    HashTableSave1(false, "IntStackOutTagIteraOrig", lv_c, HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                HashTableSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                HashTableSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                HashTableSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        HashTableSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        HashTableSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        HashTableSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = HashTableLoad1(true, (lp_key + "StringTag"), lv_a).ToString(); //原始序号元素
                lv_tag = (int)HashTableLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValuestr = HHD_ReturnStringCV(HHD_ReturnStringFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = (int)HashTableLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    HashTableSave1(true, (lp_key + "StringTag"), lv_a, lv_tag); //lv_tag放入新序号
                    //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            HashTableSave0(true, "Key_StringGroup" + lv_str, 0);
        }

        /// <summary>
        /// 【MM_函数库】互动SG_String组排序。对指定的String组元素进行冒泡排序（根据元素句柄）。String组变量字符串可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填String组名称</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void HHD_StringGSort(string lp_key, bool lp_big)
        {
            // Automatic Variable Declarations
            // Implementation
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "String");
            ThreadWait(lv_str);
            HashTableSave0(true, "Key_StringGroup" + lv_str, 1);
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = HHD_ReturnStringTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValue = lv_tag;
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    HashTableSave1(false, "IntStackOutTag", 1, lv_tag);
                    HashTableSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    HashTableSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < (int)HashTableLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    HashTableSave1(false, "IntStackOutTag", lv_c, HashTableLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    HashTableSave1(false, "IntStackOutTagValue", lv_c, HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    HashTableSave1(false, "IntStackOutTagIteraOrig", lv_c, HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                HashTableSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                HashTableSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                HashTableSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > (int)HashTableLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(HHD_ReturnStringTagFromRegNum(lv_b, lp_key))+"值"+IntToString(HashTableLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    HashTableSave1(false, "IntStackOutTag", lv_c, HashTableLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(HashTableLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    HashTableSave1(false, "IntStackOutTagValue", lv_c, HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    HashTableSave1(false, "IntStackOutTagIteraOrig", lv_c, HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                HashTableSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                HashTableSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                HashTableSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        HashTableSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        HashTableSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        HashTableSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = HashTableLoad1(true, (lp_key + "StringTag"), lv_a).ToString(); //原始序号元素
                lv_tag = (int)HashTableLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValue = lv_tag;
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = (int)HashTableLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                                                                                    //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    HashTableSave1(true, (lp_key + "StringTag"), lv_a, lv_tag); //lv_tag放入新序号
                                                                                //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            HashTableSave0(true, "Key_StringGroup" + lv_str, 0);
        }

        /// <summary>
        /// 【MM_函数库】互动SG_设定String的String组专用状态。给String组的String设定一个状态值（字符串串），之后可用"互动S_返回String、互动SG_返回String组的String状态"。状态值"true"和"false"是String的String组专用状态值，用于内部函数筛选字符串状态（相当于单位组单位索引是否有效），而本函数可以重设干预，影响函数"互动SG_返回String组元素数量（仅检索XX状态）"。与"互动S_设定String状态"功能相同，只是状态参数在String组中被固定为"String组变量的内部ID"。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_string"></param>
        /// <param name="lp_stringGroup"></param>
        /// <param name="lp_groupState"></param>
        public static void HHD_SetStringGState(string lp_string, string lp_stringGroup, string lp_groupState)
        {
            HHD_SetStringState(lp_string, lp_stringGroup, lp_groupState);
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String的String组专用状态。使用"互动S_设定String、互动SG_设定String组的String状态"后可使用本函数。与"互动S_返回String状态"功能相同，只是状态参数在String组中被固定为"String组变量的内部ID"。状态值"true"和"false"是String的String组专用状态值，用于内部函数筛选字符串状态（相当于单位组单位索引是否有效）。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_string"></param>
        /// <param name="lp_stringGroup"></param>
        public static void HHD_ReturnStringGState(string lp_string, string lp_stringGroup)
        {
            HHD_ReturnStringState(lp_string, lp_stringGroup);
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String组元素序号对应元素。返回String组元素序号指定String。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符串应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static string HHD_ReturnStringFromStringGFunc(int lp_regNum, string lp_gs)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_string;
            // Variable Initialization
            lv_str = (lp_gs + "String");
            lv_tag = HashTableLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            lv_string = (string)HashTableLoad0(true, ("HHD_String_" + lv_tag));
            // Implementation
            return lv_string;
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String组元素总数。返回指定String组的元素数量。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符串应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HHD_ReturnStringGNumMax(string lp_gs)
        {
            return (int)HashTableLoad0(true, lp_gs + "StringNum");
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String组元素总数（仅检测String组专用状态="true"）。返回指定String组的元素数量。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符串应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HHD_ReturnStringGNumMax_StateTrueFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            string lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HHD_ReturnStringNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HHD_ReturnStringFromRegNum(lv_a, lp_gs);
                lv_b = HHD_ReturnStringState(lv_c, lp_gs);
                if ((lv_b == "true"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String组元素总数（仅检测String组专用状态="false"）。返回指定String组的元素数量。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符串应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HHD_ReturnStringGNumMax_StateFalseFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            string lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HHD_ReturnStringNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HHD_ReturnStringFromRegNum(lv_a, lp_gs);
                lv_b = HHD_ReturnStringState(lv_c, lp_gs);
                if ((lv_b == "false"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String组元素总数（仅检测String组无效专用状态："false"或""）。返回指定String组的元素数量（false、""、null）。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符串应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HHD_ReturnStringGNumMax_StateUselessFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            string lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HHD_ReturnStringNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HHD_ReturnStringFromRegNum(lv_a, lp_gs);
                lv_b = HHD_ReturnStringState(lv_c, lp_gs);
                if (((lv_b == "false") || (lv_b == "") || (lv_b == null)))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String组元素总数（仅检测String组指定专用状态）。返回指定String组的元素数量。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符串应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_State">String组专用状态</param>
        /// <returns></returns>
        public static int HHD_ReturnStringGNumMax_StateFunc_Specify(string lp_gs, string lp_State)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            string lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HHD_ReturnStringNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HHD_ReturnStringFromRegNum(lv_a, lp_gs);
                lv_b = HHD_ReturnStringState(lv_c, lp_gs);
                if ((lv_b == lp_State))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动SG_添加String到String组。相同String被认为是同一个，非高级功能不提供专用状态检查，如果String没有设置过String组专用状态，那么首次添加到String组不会赋予"true"（之后可通过"互动S_设定String状态"、"互动SG_设定String组的String状态"修改）。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_string"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符串应写成：组[一维][二维]...以此类推</param>
        public static void HHD_AddStringToGroup_Simple(string lp_string, string lp_gs)
        {
            HHD_RegString_Simple(lp_string, lp_gs);
        }

        /// <summary>
        /// 【MM_函数库】互动SG_添加String到String组（高级）。相同String被认为是同一个，高级功能提供专用状态检查，如果String没有设置过String组专用状态，那么首次添加到String组会赋予"true"（之后可通过"互动S_设定String状态"、"互动SG_设定String组的String状态"修改）。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_string"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符串应写成：组[一维][二维]...以此类推</param>
        public static void HHD_AddStringToGroup(string lp_string, string lp_gs)
        {
            HHD_RegString_Simple(lp_string, lp_gs);
            if (HashTableKeyExists(true, ("HHD_StringState" + lp_gs + "String_" + HHD_RegStringTagAndReturn(lp_string))) == false)
            {
                HashTableSave0(true, ("HHD_StringState" + lp_gs + "String_" + HHD_RegStringTagAndReturn(lp_string)), "true");
                //Console.WriteLine(lp_gs + "=>" + HHD_RegStringTagAndReturn(lp_string));
            }
        }

        /// <summary>
        /// 【MM_函数库】互动SG_移除String组中的元素。使用"互动SG_添加String到String组"后可使用本函数进行移除元素。移除使用了"互动S_移除String"，同一个存储区（String组ID）序号重排，移除时该存储区如有其他操作会排队等待。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_string"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符串应写成：组[一维][二维]...以此类推</param>
        public static void HHD_ClearStringFromGroup(string lp_string, string lp_gs)
        {
            HHD_RemoveString(lp_string, lp_gs);
        }

        //互动SG_为String组中的每个序号
        //GE（星际2的Galaxy Editor）的宏让编辑器保存时自动生成脚本并整合进脚本进行格式调整，C#仅参考需自行编写
        // #AUTOVAR(vs, string) = "#PARAM(group)";//"#PARAM(group)"是与字段、变量名一致的元素组名称，宏去声明string类型名为“Auto随机编号_vs”的自动变量，然后=右侧字符串
        // #AUTOVAR(ae) = HHD_ReturnStringNumMax(#AUTOVAR(vs));//宏去声明默认int类型名为“Auto随机编号_ae”的自动变量，然后=右侧字符串
        // #INITAUTOVAR(ai,increment)//宏去声明int类型名为“Auto随机编号_ai”的自动变量，用于下面for循环增量（increment是传入参数）
        // #PARAM(var) = #PARAM(s);//#PARAM(var)是传进来的参数，用作“当前被挑选到的元素”（任意变量-整数 lp_var）， #PARAM(s)是传进来的参数用作"开始"（int lp_s）
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #PARAM(var) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #PARAM(var) >= #AUTOVAR(ae)) ) ; #PARAM(var) += #AUTOVAR(ai) ) {
        //     #SUBFUNCS(actions)//代表用户GUI填写的所有动作
        // }

        /// <summary>
        /// 【MM_函数库】互动SG_为String组中的每个序号。每次挑选的元素序号会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素序号，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符串应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void HHD_ForEachStringNumFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            int lv_ae = HHD_ReturnStringNumMax(lp_gs);
            int lv_var = lp_start;
            int lv_ai = lp_increment;
            for (; (lv_ai >= 0 && lv_var <= lv_ae) || (lv_ai < 0 && lv_var >= lv_ae); lv_var += lv_ai)
            {
                lp_funcref(lv_var);//用户填写的所有动作
            }
        }

        //互动SG_为String组中的每个元素
        // #AUTOVAR(vs, string) = "#PARAM(group)";
        // #AUTOVAR(ae) = HHD_ReturnStringNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= #PARAM(s);
        // #INITAUTOVAR(ai,increment)
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     HashTableSave(false, "StringGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)), HHD_ReturnStringFromRegNum(#AUTOVAR(va),#AUTOVAR(vs)));
        // }
        // #AUTOVAR(va)= #PARAM(s);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #PARAM(var) = HashTableLoad(false, "StringGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)));
        //     #SUBFUNCS(actions)
        // }

        /// <summary>
        /// 【MM_函数库】互动SG_为String组中的每个元素。每次挑选的元素会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符串应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void HHD_ForEachStringFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            string lv_vs = lp_gs;
            int lv_ae = HHD_ReturnStringNumMax(lv_vs);
            int lv_va = lp_start;
            int lv_ai = lp_increment;
            string lv_string;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                HashTableSave0(false, "StringGFor" + lv_vs + lv_va.ToString(), HHD_ReturnStringFromRegNum(lv_va, lv_vs));
            }
            lv_va = lp_start;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                lv_string = (string)HashTableLoad0(false, "StringGFor" + lv_vs + lv_va.ToString());
                lp_funcref(lv_string);//用户填写的所有动作
            }
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String组中随机元素。返回指定String组中的随机String。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符串应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static string HHD_ReturnRandomStringFromStringGFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_num;
            int lv_a;
            string lv_c = null;
            // Variable Initialization
            lv_num = HHD_ReturnStringNumMax(lp_gs);
            // Implementation
            if ((lv_num >= 1))
            {
                lv_a = RandomInt(1, lv_num);
                lv_c = HHD_ReturnStringFromRegNum(lv_a, lp_gs);
            }
            return lv_c;
        }

        //互动SG_添加String组到String组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = HHD_ReturnStringNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = HHD_ReturnStringFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     HHD_AddStringToGroup(#AUTOVAR(var), #AUTOVAR(vsb));
        // }


        /// <summary>
        /// 【MM_函数库】互动SG_添加String组到String组。添加一个String组A的元素到另一个String组B，相同String被认为是同一个。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void HHD_AddStringGToStringG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = HHD_ReturnStringNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            string lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = HHD_ReturnStringFromRegNum(lv_va, lv_vsa);
                HHD_AddStringToGroup(lv_var, lv_vsb);
            }
        }

        //互动SG_从String组移除String组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = HHD_ReturnStringNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = HHD_ReturnStringFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     HHD_RemoveString(#AUTOVAR(var), #AUTOVAR(vsb));
        // }

        /// <summary>
        /// 【MM_函数库】互动SG_从String组移除String组。将String组A的元素从String组B中移除，相同String被认为是同一个。移除使用了"互动S_移除String"，同一个存储区（String组ID）序号重排，移除时该存储区如有其他操作会排队等待。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void HHD_ClearStringGFromStringG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = HHD_ReturnStringNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            string lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = HHD_ReturnStringFromRegNum(lv_va, lv_vsa);
                HHD_RemoveString(lv_var, lv_vsb);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动SG_移除String组全部元素。将String组（Key区）存储的元素全部移除，相同String被认为是同一个。移除时同一个存储区（String组ID）序号不进行重排，但该存储区如有其他操作会排队等待。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_key">存储键区，默认填String组名称</param>
        public static void HHD_RemoveStringGAll(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag = "";
            int lv_a;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            // Implementation
            ThreadWait(lv_str);
            HashTableSave0(true, "Key_StringGroup" + lv_str, 1);
            for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
            {
                lv_tag = HashTableLoad1(true, (lp_key + "StringTag"), lv_a).ToString();
                lv_num -= 1;
                HashTableClear0(true, "HHD_IfStringTag" + lv_str + "_" + lv_tag);
                HashTableClear0(true, "HHD_StringCV" + lv_str + "_" + lv_tag);
                HashTableClear0(true, "HHD_StringState" + lv_str + "_" + lv_tag);
                HashTableSave0(true, (lp_key + "StringNum"), lv_num);
            }
            HashTableSave0(true, "Key_StringGroup" + lv_str, 0);
        }

        //--------------------------------------------------------------------------------------------------
        // 字符串组End
        //--------------------------------------------------------------------------------------------------

        #endregion

        #region 数字

        //提示：尽可能使用对口类型，以防值类型与引用类型发生转换时拆装箱降低性能

        //--------------------------------------------------------------------------------------------------
        // 数字组Start
        //--------------------------------------------------------------------------------------------------

        /// <summary>
        /// 【MM_函数库】互动I_注册Integer标签句柄并返回。为Integer自动设置新的标签句柄，重复时会返回已注册的Integer标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <returns>返回一个Integer的已注册标签</returns>
        private static int HHD_RegIntegerTagAndReturn_Int(int lp_integer)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)HashTableLoad0(true, "HHD_IntegerJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                HashTableSave0(true, "HHD_IntegerJBNum", lv_j);
                HashTableSave0(true, ("HHD_Integer_" + lv_j.ToString()), lp_integer);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if ((int)HashTableLoad0(true, ("HHD_Integer_" + lv_j.ToString())) == lp_integer)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            HashTableSave0(true, "HHD_IntegerJBNum", lv_j);
                            HashTableSave0(true, ("HHD_Integer_" + lv_j.ToString()), lp_integer);
                        }
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Integer已注册标签句柄
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <returns>返回一个Integer的已注册标签，错误返回0</returns>
        public static int HHD_ReturnIntegerTag_Int(int lp_integer)
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)HashTableLoad0(true, "HHD_IntegerJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if ((int)HashTableLoad0(true, "HHD_Integer_" + lv_j.ToString()) == lp_integer)
                {
                    break;
                }
                else
                {
                    if ((lv_j == lv_jBNum))
                    {
                        lv_j = 0;
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动I_注册Integer标签句柄并返回。为Integer自动设置新的标签句柄，重复时会返回已注册的Integer标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <returns>返回一个Integer的已注册标签</returns>
        private static string HHD_RegIntegerTagAndReturn(int lp_integer)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag = "";
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)HashTableLoad0(true, "HHD_IntegerJBNum");
            lv_tag = "";
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                HashTableSave0(true, "HHD_IntegerJBNum", lv_j);
                HashTableSave0(true, ("HHD_Integer_" + lv_j.ToString()), lp_integer);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if ((int)HashTableLoad0(true, "HHD_Integer_" + lv_j.ToString()) == lp_integer)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            HashTableSave0(true, "HHD_IntegerJBNum", lv_j);
                            HashTableSave0(true, ("HHD_Integer_" + lv_j.ToString()), lp_integer);
                        }
                    }
                }
            }
            lv_tag = lv_j.ToString();
            //Console.WriteLine(("Tag：" + lv_tag));
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Integer已注册标签句柄
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <returns>返回一个Integer的已注册标签，错误返回""</returns>
        public static string HHD_ReturnIntegerTag(int lp_integer)
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag = "";
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)HashTableLoad0(true, "HHD_IntegerJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if ((int)HashTableLoad0(true, "HHD_Integer_" + lv_j.ToString()) == lp_integer)
                {
                    lv_tag = lv_j.ToString();
                    break;
                }
            }
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动I_注册Integer(高级)。在指定Key存入Integer，固有状态、自定义值是Integer独一无二的标志（本函数重复注册会刷新），之后可用互动I_"返回Integer注册总数"、"返回Integer序号"、"返回序号对应Integer"、"返回序号对应Integer标签"、"返回Integer自定义值"。Integer组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Integer组转为Key。首次注册时固有状态为true（相当于单位组单位活体），如需另外设置多个标记可使用"互动I_设定Integer状态/自定义值"
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <param name="lp_key">存储键区，默认值"_Integer"</param>
        /// <param name="lp_inherentStats">固有状态</param>
        /// <param name="lp_inherentCustomValue">固有自定义值</param>
        public static void HHD_RegInteger(int lp_integer, string lp_key, string lp_inherentStats, string lp_inherentCustomValue)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Integer");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_jBNum = (int)HashTableLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = HHD_RegIntegerTagAndReturn(lp_integer);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                HashTableSave0(true, (lv_str + "Num"), lv_i);
                HashTableSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                HashTableSave0(true, (("HHD_IfIntegerTag" + "") + "_" + lv_tagStr), true);
                HashTableSave1(true, ("HHD_IfIntegerTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if ((HashTableLoad1(true, (lv_str + "Tag"), lv_i).ToString() == lv_tagStr))
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                HashTableSave0(true, (lv_str + "Num"), lv_i);
                                HashTableSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                HashTableSave0(true, (("HHD_IfIntegerTag" + "") + "_" + lv_tagStr), true);
                                HashTableSave1(true, ("HHD_IfIntegerTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            HashTableSave0(true, ("HHD_IntegerState" + "" + "_" + lv_tagStr), lp_inherentStats);
            HashTableSave0(true, ("HHD_IntegerCV" + "" + "_" + lv_tagStr), lp_inherentCustomValue);
        }

        /// <summary>
        /// 【MM_函数库】互动I_注册Integer。在指定Key存入Integer，固有状态、自定义值是Integer独一无二的标志（本函数重复注册不会刷新），之后可用互动I_"返回Integer注册总数"、"返回Integer序号"、"返回序号对应Integer"、"返回Integer自定义值"。Integer组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Integer组转为Key。首次注册时固有状态为true（相当于单位组单位活体），之后只能通过"互动I_注册Integer（高级）"改写，如需另外设置多个标记可使用"互动I_设定Integer状态/自定义值"
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <param name="lp_key">存储键区，默认值"_Integer"</param>
        public static void HHD_RegInteger_Simple(int lp_integer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Integer");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_jBNum = (int)HashTableLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = HHD_RegIntegerTagAndReturn(lp_integer);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                HashTableSave0(true, (lv_str + "Num"), lv_i);
                HashTableSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                HashTableSave0(true, (("HHD_IfIntegerTag" + "") + "_" + lv_tagStr), true);
                HashTableSave1(true, ("HHD_IfIntegerTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if ((HashTableLoad1(true, (lv_str + "Tag"), lv_i).ToString() == lv_tagStr))
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                HashTableSave0(true, (lv_str + "Num"), lv_i);
                                HashTableSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                HashTableSave0(true, (("HHD_IfIntegerTag" + "") + "_" + lv_tagStr), true);
                                HashTableSave1(true, ("HHD_IfIntegerTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            if ((HashTableKeyExists(true, ("HHD_Integer" + "State" + "_" + lv_tag.ToString())) == false))
            {
                HashTableSave1(true, (("HHD_Integer" + "State")), lv_tag, "true");
            }
        }

        /// <summary>
        /// 【MM_函数库】互动I_注销Integer。用"互动I_注册Integer"到Key，之后可用本函数彻底摧毁注册信息并将序号重排（包括Integer标签有效状态、固有状态及自定义值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动I_设定Integer状态"让Integer状态失效（类似单位组的单位活体状态）。Integer组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Integer组转为Key。本函数无法摧毁用"互动I_设定Integer状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Integer组变量ID时会清空Integer组专用状态
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <param name="lp_key">存储键区，默认值"_Integer"</param>
        public static void HHD_DestroyInteger(int lp_integer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag = "";
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Integer");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_tag = HHD_ReturnIntegerTag(lp_integer);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                ThreadWaitSet(true, "Key_IntegerGroup" + lv_str, true);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((HashTableLoad1(true, (lp_key + "IntegerTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        HashTableClear0(true, "HHD_IfIntegerTag_" + lv_tag);
                        HashTableClear0(true, "HHD_IfIntegerTag" + lv_str + "_" + lv_tag);
                        HashTableClear0(true, "HHD_Integer_" + lv_tag);
                        HashTableClear0(true, "HHD_IntegerCV_" + lv_tag);
                        HashTableClear0(true, "HHD_IntegerState_" + lv_tag);
                        HashTableClear0(true, "HHD_IntegerCV" + lv_str + "_" + lv_tag);
                        HashTableClear0(true, "HHD_IntegerState" + lv_str + "_" + lv_tag);
                        HashTableSave0(true, (lp_key + "IntegerNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = HashTableLoad1(true, (lp_key + "IntegerTag"), lv_b + 1).ToString();
                            HashTableSave1(true, (lp_key + "IntegerTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                ThreadWaitSet(true, "Key_IntegerGroup" + lv_str, false);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动I_移除Integer。用"互动I_注册Integer"到Key，之后可用本函数仅摧毁Key区注册的信息并将序号重排，用于Integer组或多个键区仅移除Integer（保留Integer标签有效状态、固有值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动I_设定Integer状态"让Integer状态失效（类似单位组的单位活体状态）。Integer组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Integer组转为Key。本函数无法摧毁用"互动I_设定Integer状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Integer组变量ID时会清空Integer组专用状态
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <param name="lp_key">存储键区，默认值"_Integer"</param>
        public static void HHD_RemoveInteger(int lp_integer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag = "";
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Integer");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_tag = HHD_ReturnIntegerTag(lp_integer);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                ThreadWaitSet(true, "Key_IntegerGroup" + lv_str, true);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((HashTableLoad1(true, (lp_key + "IntegerTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        HashTableClear0(true, "HHD_IfIntegerTag" + lv_str + "_" + lv_tag);
                        HashTableClear0(true, "HHD_IntegerCV" + lv_str + "_" + lv_tag);
                        HashTableClear0(true, "HHD_IntegerState" + lv_str + "_" + lv_tag);
                        HashTableSave0(true, (lp_key + "IntegerNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = HashTableLoad1(true, (lp_key + "IntegerTag"), lv_b + 1).ToString();
                            HashTableSave1(true, (lp_key + "IntegerTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                ThreadWaitSet(true, "Key_IntegerGroup" + lv_str, false);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Integer注册总数。必须先使用"互动I_注册Integer"才能返回指定Key里的注册总数。Integer组使用时，可用"获取变量的内部名称"将Integer组转为Key。
        /// </summary>
        /// <param name="lp_key">存储键区，默认值"_Integer"</param>
        /// <returns></returns>
        public static int HHD_ReturnIntegerNumMax(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            // Variable Initialization
            lv_str = (lp_key + "Integer");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            // Implementation
            return lv_num;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Integer序号。使用"互动I_注册Integer"后使用本函数可返回Key里的注册序号，Key无元素返回0，Key有元素但对象不在里面则返回-1，Integer标签尚未注册则返回-2。Integer组使用时，可用"获取变量的内部名称"将Integer组转为Key
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <param name="lp_key">存储键区，默认值"_Integer"</param>
        /// <returns></returns>
        public static int HHD_ReturnIntegerNum(int lp_integer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_i;
            string lv_tag = "";
            int lv_torf;
            // Automatic Variable Declarations
            const int auto_n = 1;
            int auto_i;
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Integer");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_tag = HHD_ReturnIntegerTag(lp_integer);
            lv_torf = -1;
            // Implementation
            for (auto_i = 1; auto_i <= auto_n; auto_i += 1)
            {
                if ((lv_tag != null))
                {
                    lv_torf = -2;
                    break;
                }
                if ((lv_num == 0))
                {
                    lv_torf = 0;
                }
                else
                {
                    if ((lv_num >= 1))
                    {
                        auto_ae = lv_num;
                        auto_var = 1;
                        for (; auto_var <= auto_ae; auto_var += 1)
                        {
                            lv_i = auto_var;
                            if ((HashTableLoad1(true, (lv_str + "Tag"), lv_i).ToString() == lv_tag))
                            {
                                lv_torf = lv_i;
                                break;
                            }
                        }
                    }
                }
            }
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回序号对应Integer。使用"互动I_注册Integer"后，在参数填入注册序号可返回Integer。Integer组使用时，可用"获取变量的内部名称"将Integer组转为Key
        /// </summary>
        /// <param name="lp_regNum"></param>
        /// <param name="lp_key">存储键区，默认值"_Integer"</param>
        /// <returns></returns>
        public static int HHD_ReturnIntegerFromRegNum(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            int lv_integer;
            // Variable Initialization
            lv_str = (lp_key + "Integer");
            lv_tag = HashTableLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            lv_integer = (int)HashTableLoad0(true, ("HHD_Integer_" + lv_tag));
            // Implementation
            return lv_integer;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回句柄标签对应Integer。使用"互动I_注册Integer"后，在参数填入句柄标签（整数）可返回Integer，标签是Integer的句柄。Integer组使用时，可用"获取变量的内部名称"将Integer组转为Key
        /// </summary>
        /// <param name="lp_tag">句柄标签</param>
        /// <returns></returns>
        public static int HHD_ReturnIntegerFromTag(int lp_tag)
        {
            // Variable Declarations
            string lv_tag = "";
            int lv_integer;
            // Variable Initialization
            lv_tag = lp_tag.ToString();
            lv_integer = (int)HashTableLoad0(true, ("HHD_Integer_" + lv_tag));
            // Implementation
            return lv_integer;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回序号对应Integer标签句柄。使用"互动I_注册Integer"后，在参数填入注册序号可返回Integer标签（字符串）。Integer组使用时，可用"获取变量的内部名称"将Integer组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Integer"</param>
        /// <returns></returns>
        public static string HHD_ReturnIntegerTagFromRegNum_String(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Integer");
            lv_tag = HashTableLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回序号对应Integer标签句柄。使用"互动I_注册Integer"后，在参数填入注册序号可返回Integer标签（整数）。Integer组使用时，可用"获取变量的内部名称"将Integer组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Integer"</param>
        /// <returns></returns>
        public static int HHD_ReturnIntegerTagFromRegNum_Int(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Integer");
            lv_tag = HashTableLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return Convert.ToInt32(lv_tag);
        }

        /// <summary>
        /// 【MM_函数库】互动I_设置Integer状态。必须先"注册"获得功能库内部句柄，再使用本函数给Integer设定一个状态值，之后可用"互动I_返回Integer状态"。类型参数用以记录多个不同状态，仅当"类型"参数填Integer组ID转的Integer串时，状态值"true"和"false"是Integer的Integer组专用状态值，用于内部函数筛选Integer状态（相当于单位组单位索引是否有效），其他类型不会干扰系统内部，可随意填写。虽然注销时反向清空注册信息，但用"互动I_设定Integer状态/自定义值"创建的值需要手工填入""来排泄（非大量注销则提升内存量极小，可不管）。注：固有状态值是注册函数赋予的系统内部变量（相当于单位组单位是否活体），只能通过"互动I_注册Integer（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <param name="lp_stats">状态</param>
        public static void HHD_SetIntegerState(int lp_integer, string lp_key, string lp_stats)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Integer");
            lv_tag = HHD_RegIntegerTagAndReturn(lp_integer);
            // Implementation
            HashTableSave0(true, ("HHD_IntegerState" + lv_str + "_" + lv_tag), lp_stats);
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Integer状态。使用"互动I_设定Integer状态"后可使用本函数，将本函数参数"类型"设为空时返回固有值。类型参数用以记录多个不同状态，仅当"类型"参数为Integer组ID转的字符串时，返回的状态值"true"和"false"是Integer的Integer组专用状态值，用于内部函数筛选Integer状态（相当于单位组单位索引是否有效）
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <returns></returns>
        public static string HHD_ReturnIntegerState(int lp_integer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_str = (lp_key + "Integer");
            lv_tag = HHD_ReturnIntegerTag(lp_integer);
            lv_stats = HashTableLoad0(true, ("HHD_IntegerState" + lv_str + "_" + lv_tag)).ToString();
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动I_设置Integer自定义值。必须先"注册"获得功能库内部句柄，再使用本函数设定Integer的自定义值，之后可使用"互动I_返回Integer自定义值"，类型参数用以记录多个不同自定义值。注：固有自定义值是注册函数赋予的系统内部变量，只能通过"互动I_注册Integer（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <param name="lp_customValue">自定义值</param>
        public static void HHD_SetIntegerCV(int lp_integer, string lp_key, string lp_customValue)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Integer");
            lv_tag = HHD_RegIntegerTagAndReturn(lp_integer);
            // Implementation
            HashTableSave0(true, ("HHD_IntegerCV" + lv_str + "_" + lv_tag), lp_customValue);
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Integer自定义值。使用"互动I_设定Integer自定义值"后可使用本函数，将本函数参数"类型"设为空时返回固有值，该参数用以记录多个不同自定义值
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <returns></returns>
        public static string HHD_ReturnIntegerCV(int lp_integer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_str = (lp_key + "Integer");
            lv_tag = HHD_ReturnIntegerTag(lp_integer);
            lv_customValue = HashTableLoad0(true, ("HHD_IntegerCV" + lv_str + "_" + lv_tag)).ToString();
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Integer固有状态。必须先使用"互动I_注册Integer"才能返回到该值，固有状态是独一无二的标记（相当于单位组单位是否活体）
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <returns></returns>
        public static string HHD_ReturnIntegerState_Only(int lp_integer)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_tag = HHD_ReturnIntegerTag(lp_integer);
            lv_stats = HashTableLoad0(true, ("HHD_IntegerState" + "" + "_" + lv_tag)).ToString();
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Integer固有自定义值。必须先使用"互动I_注册Integer"才能返回到该值，固有值是独一无二的标记
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <returns></returns>
        public static string HHD_ReturnIntegerCV_Only(int lp_integer)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_tag = HHD_ReturnIntegerTag(lp_integer);
            lv_customValue = HashTableLoad0(true, ("HHD_IntegerCV" + "" + "_" + lv_tag)).ToString();
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动I_设置Integer的实数标记。必须先"注册"获得功能库内部句柄，再使用本函数让Integer携带一个实数值，之后可使用"互动I_返回Integer的实数标记"。Integer组使用时，可用"获取变量的内部名称"将Integer组转为Key
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <param name="lp_realNumTag">实数标记</param>
        public static void HHD_SetIntegerDouble(int lp_integer, double lp_realNumTag)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = HHD_RegIntegerTagAndReturn(lp_integer);
            // Implementation
            HashTableSave0(true, ("HHD_CDDouble_T_" + lv_tag), lp_realNumTag);
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Integer的实数标记。使用"互动I_设定Integer的实数标记"后可使用本函数。Integer组使用时，可用"获取变量的内部名称"将Integer组转为Key
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <returns></returns>
        public static double HHD_ReturnIntegerDouble(int lp_integer)
        {
            // Variable Declarations
            string lv_tag = "";
            double lv_f;
            // Variable Initialization
            lv_tag = HHD_ReturnIntegerTag(lp_integer);
            lv_f = (double)HashTableLoad0(true, ("HHD_CDDouble_T_" + lv_tag));
            // Implementation
            return lv_f;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Integer标签句柄有效状态。将Integer视作独一无二的个体，标签是它本身，有效状态则类似"单位是否有效"，当使用"互动I_注册Integer"或"互动IG_添加Integer到Integer组"后激活Integer有效状态（值为"true"），除非使用"互动I_注册Integer（高级）"改写，否则直到注销才会摧毁
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <returns></returns>
        public static bool HHD_ReturnIfIntegerTag(int lp_integer)
        {
            // Variable Declarations
            string lv_tag = "";
            bool lv_torf;
            // Variable Initialization
            lv_tag = HHD_ReturnIntegerTag(lp_integer);
            lv_torf = (bool)HashTableLoad0(true, ("HHD_IfIntegerTag" + "" + "_" + lv_tag));
            // Implementation
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Integer注册状态。使用"互动I_注册Integer"或"互动IG_添加Integer到Integer组"后可使用本函数获取注册Integer在Key中的注册状态，该状态只能注销或从Integer组中移除时清空。Integer组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Integer组转为Key
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <param name="lp_key">存储键区，默认值"_Integer"</param>
        /// <returns></returns>
        public static bool HHD_ReturnIfIntegerTagKey(int lp_integer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            bool lv_torf;
            // Variable Initialization
            lv_str = (lp_key + "Integer");
            lv_tag = HHD_ReturnIntegerTag(lp_integer);
            lv_torf = (bool)HashTableLoad0(true, ("HHD_IfIntegerTag" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动IG_根据自定义值类型将Integer组排序。根据Integer携带的自定义值类型，对指定的Integer组元素进行冒泡排序。Integer组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Integer组名称</param>
        /// <param name="lp_cVStr">自定义值类型</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void HHD_IntegerGSortCV(string lp_key, string lp_cVStr, bool lp_big)
        {
            // Automatic Variable Declarations
            // Implementation
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            string lv_tagValuestr;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Integer");
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_IntegerGroup" + lv_str, true);
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = HHD_ReturnIntegerTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValuestr = HHD_ReturnIntegerCV(HHD_ReturnIntegerFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    HashTableSave1(false, "IntStackOutTag", 1, lv_tag);
                    HashTableSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    HashTableSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < (int)HashTableLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    HashTableSave1(false, "IntStackOutTag", lv_c, HashTableLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    HashTableSave1(false, "IntStackOutTagValue", lv_c, HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    HashTableSave1(false, "IntStackOutTagIteraOrig", lv_c, HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                HashTableSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                HashTableSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                HashTableSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > (int)HashTableLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(HHD_ReturnIntegerTagFromRegNum(lv_b, lp_key))+"值"+IntToString(HashTableLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    HashTableSave1(false, "IntStackOutTag", lv_c, HashTableLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(HashTableLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    HashTableSave1(false, "IntStackOutTagValue", lv_c, HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    HashTableSave1(false, "IntStackOutTagIteraOrig", lv_c, HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                HashTableSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                HashTableSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                HashTableSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        HashTableSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        HashTableSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        HashTableSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = HashTableLoad1(true, (lp_key + "IntegerTag"), lv_a).ToString(); //原始序号元素
                lv_tag = (int)HashTableLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValuestr = HHD_ReturnIntegerCV(HHD_ReturnIntegerFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = (int)HashTableLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    HashTableSave1(true, (lp_key + "IntegerTag"), lv_a, lv_tag); //lv_tag放入新序号
                    //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            ThreadWaitSet(true, "Key_IntegerGroup" + lv_str, false);
        }

        /// <summary>
        /// 【MM_函数库】互动IG_Integer组排序。对指定的Integer组元素进行冒泡排序（根据元素句柄）。Integer组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Integer组名称</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void HHD_IntegerGSort(string lp_key, bool lp_big)
        {
            // Automatic Variable Declarations
            // Implementation
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Integer");
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_IntegerGroup" + lv_str, true);
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = HHD_ReturnIntegerTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValue = lv_tag;
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    HashTableSave1(false, "IntStackOutTag", 1, lv_tag);
                    HashTableSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    HashTableSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < (int)HashTableLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    HashTableSave1(false, "IntStackOutTag", lv_c, HashTableLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    HashTableSave1(false, "IntStackOutTagValue", lv_c, HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    HashTableSave1(false, "IntStackOutTagIteraOrig", lv_c, HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                HashTableSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                HashTableSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                HashTableSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > (int)HashTableLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(HHD_ReturnIntegerTagFromRegNum(lv_b, lp_key))+"值"+IntToString(HashTableLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    HashTableSave1(false, "IntStackOutTag", lv_c, HashTableLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(HashTableLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    HashTableSave1(false, "IntStackOutTagValue", lv_c, HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    HashTableSave1(false, "IntStackOutTagIteraOrig", lv_c, HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                HashTableSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                HashTableSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                HashTableSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        HashTableSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        HashTableSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        HashTableSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = HashTableLoad1(true, (lp_key + "IntegerTag"), lv_a).ToString(); //原始序号元素
                lv_tag = (int)HashTableLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValue = lv_tag;
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = (int)HashTableLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                                                                                    //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    HashTableSave1(true, (lp_key + "IntegerTag"), lv_a, lv_tag); //lv_tag放入新序号
                                                                                 //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            ThreadWaitSet(true, "Key_IntegerGroup" + lv_str, false);
        }

        /// <summary>
        /// 【MM_函数库】互动IG_设定Integer的Integer组专用状态。给Integer组的Integer设定一个状态值（字符串），之后可用"互动I_返回Integer、互动IG_返回Integer组的Integer状态"。状态值"true"和"false"是Integer的Integer组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效），而本函数可以重设干预，影响函数"互动IG_返回Integer组元素数量（仅检索XX状态）"。与"互动I_设定Integer状态"功能相同，只是状态参数在Integer组中被固定为"Integer组变量的内部ID"。Integer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Integer组到Integer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <param name="lp_integerGroup"></param>
        /// <param name="lp_groupState"></param>
        public static void HHD_SetIntegerGState(int lp_integer, string lp_integerGroup, string lp_groupState)
        {
            HHD_SetIntegerState(lp_integer, lp_integerGroup, lp_groupState);
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Integer的Integer组专用状态。使用"互动I_设定Integer、互动IG_设定Integer组的Integer状态"后可使用本函数。与"互动I_返回Integer状态"功能相同，只是状态参数在Integer组中被固定为"Integer组变量的内部ID"。状态值"true"和"false"是Integer的Integer组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效）。Integer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Integer组到Integer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <param name="lp_integerGroup"></param>
        public static void HHD_ReturnIntegerGState(int lp_integer, string lp_integerGroup)
        {
            HHD_ReturnIntegerState(lp_integer, lp_integerGroup);
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Integer组元素序号对应元素。返回Integer组元素序号指定Integer。Integer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Integer组到Integer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HHD_ReturnIntegerFromIntegerGFunc(int lp_regNum, string lp_gs)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            int lv_integer;
            // Variable Initialization
            lv_str = (lp_gs + "Integer");
            lv_tag = HashTableLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            lv_integer = (int)HashTableLoad0(true, ("HHD_Integer_" + lv_tag));
            // Implementation
            return lv_integer;
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Integer组元素总数。返回指定Integer组的元素数量。Integer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Integer组到Integer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HHD_ReturnIntegerGNumMax(string lp_gs)
        {
            return (int)HashTableLoad0(true, lp_gs + "IntegerNum");
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Integer组元素总数（仅检测Integer组专用状态="true"）。返回指定Integer组的元素数量。Integer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Integer组到Integer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HHD_ReturnIntegerGNumMax_StateTrueFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            int lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HHD_ReturnIntegerNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HHD_ReturnIntegerFromRegNum(lv_a, lp_gs);
                lv_b = HHD_ReturnIntegerState(lv_c, lp_gs);
                if ((lv_b == "true"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Integer组元素总数（仅检测Integer组专用状态="false"）。返回指定Integer组的元素数量。Integer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Integer组到Integer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HHD_ReturnIntegerGNumMax_StateFalseFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            int lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HHD_ReturnIntegerNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HHD_ReturnIntegerFromRegNum(lv_a, lp_gs);
                lv_b = HHD_ReturnIntegerState(lv_c, lp_gs);
                if ((lv_b == "false"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Integer组元素总数（仅检测Integer组无效专用状态："false"或""）。返回指定Integer组的元素数量（false、""、null）。Integer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Integer组到Integer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HHD_ReturnIntegerGNumMax_StateUselessFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            int lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HHD_ReturnIntegerNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HHD_ReturnIntegerFromRegNum(lv_a, lp_gs);
                lv_b = HHD_ReturnIntegerState(lv_c, lp_gs);
                if (((lv_b == "false") || (lv_b == "") || (lv_b == null)))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Integer组元素总数（仅检测Integer组指定专用状态）。返回指定Integer组的元素数量。Integer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Integer组到Integer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_State">Integer组专用状态</param>
        /// <returns></returns>
        public static int HHD_ReturnIntegerGNumMax_StateFunc_Specify(string lp_gs, string lp_State)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            int lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HHD_ReturnIntegerNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HHD_ReturnIntegerFromRegNum(lv_a, lp_gs);
                lv_b = HHD_ReturnIntegerState(lv_c, lp_gs);
                if ((lv_b == lp_State))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动IG_添加Integer到Integer组。相同Integer被认为是同一个，非高级功能不提供专用状态检查，如果Integer没有设置过Integer组专用状态，那么首次添加到Integer组不会赋予"true"（之后可通过"互动I_设定Integer状态"、"互动IG_设定Integer组的Integer状态"修改）。Integer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Integer组到Integer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HHD_AddIntegerToGroup_Simple(int lp_integer, string lp_gs)
        {
            HHD_RegInteger_Simple(lp_integer, lp_gs);
        }

        /// <summary>
        /// 【MM_函数库】互动IG_添加Integer到Integer组（高级）。相同Integer被认为是同一个，高级功能提供专用状态检查，如果Integer没有设置过Integer组专用状态，那么首次添加到Integer组会赋予"true"（之后可通过"互动I_设定Integer状态"、"互动IG_设定Integer组的Integer状态"修改）。Integer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Integer组到Integer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HHD_AddIntegerToGroup(int lp_integer, string lp_gs)
        {
            HHD_RegInteger_Simple(lp_integer, lp_gs);
            if (HashTableKeyExists(true, ("HHD_IntegerState" + lp_gs + "Integer_" + HHD_RegIntegerTagAndReturn(lp_integer))) == false)
            {
                HashTableSave0(true, ("HHD_IntegerState" + lp_gs + "Integer_" + HHD_RegIntegerTagAndReturn(lp_integer)), "true");
                //Console.WriteLine(lp_gs + "=>" + HHD_RegIntegerTagAndReturn(lp_integer));
            }
        }

        /// <summary>
        /// 【MM_函数库】互动IG_移除Integer组中的元素。使用"互动IG_添加Integer到Integer组"后可使用本函数进行移除元素。移除使用了"互动I_移除Integer"，同一个存储区（Integer组ID）序号重排，移除时该存储区如有其他操作会排队等待。Integer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Integer组到Integer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HHD_ClearIntegerFromGroup(int lp_integer, string lp_gs)
        {
            HHD_RemoveInteger(lp_integer, lp_gs);
        }

        //互动IG_为Integer组中的每个序号
        //GE（星际2的Galaxy Editor）的宏让编辑器保存时自动生成脚本并整合进脚本进行格式调整，C#仅参考需自行编写
        // #AUTOVAR(vs, string) = "#PARAM(group)";//"#PARAM(group)"是与字段、变量名一致的元素组名称，宏去声明string类型名为“Auto随机编号_vs”的自动变量，然后=右侧字符
        // #AUTOVAR(ae) = HHD_ReturnIntegerNumMax(#AUTOVAR(vs));//宏去声明默认int类型名为“Auto随机编号_ae”的自动变量，然后=右侧字符
        // #INITAUTOVAR(ai,increment)//宏去声明int类型名为“Auto随机编号_ai”的自动变量，用于下面for循环增量（increment是传入参数）
        // #PARAM(var) = #PARAM(s);//#PARAM(var)是传进来的参数，用作“当前被挑选到的元素”（任意变量-整数 lp_var）， #PARAM(s)是传进来的参数用作"开始"（int lp_s）
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #PARAM(var) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #PARAM(var) >= #AUTOVAR(ae)) ) ; #PARAM(var) += #AUTOVAR(ai) ) {
        //     #SUBFUNCS(actions)//代表用户GUI填写的所有动作
        // }

        /// <summary>
        /// 【MM_函数库】互动IG_为Integer组中的每个序号。每次挑选的元素序号会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素序号，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Integer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Integer组到Integer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void HHD_ForEachIntegerNumFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            int lv_ae = HHD_ReturnIntegerNumMax(lp_gs);
            int lv_var = lp_start;
            int lv_ai = lp_increment;
            for (; (lv_ai >= 0 && lv_var <= lv_ae) || (lv_ai < 0 && lv_var >= lv_ae); lv_var += lv_ai)
            {
                lp_funcref(lv_var);//用户填写的所有动作
            }
        }

        //互动IG_为Integer组中的每个元素
        // #AUTOVAR(vs, string) = "#PARAM(group)";
        // #AUTOVAR(ae) = HHD_ReturnIntegerNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= #PARAM(s);
        // #INITAUTOVAR(ai,increment)
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     HashTableSave(false, "IntegerGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)), HHD_ReturnIntegerFromRegNum(#AUTOVAR(va),#AUTOVAR(vs)));
        // }
        // #AUTOVAR(va)= #PARAM(s);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #PARAM(var) = HashTableLoad(false, "IntegerGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)));
        //     #SUBFUNCS(actions)
        // }

        /// <summary>
        /// 【MM_函数库】互动IG_为Integer组中的每个元素。每次挑选的元素会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Integer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Integer组到Integer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void HHD_ForEachIntegerFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            string lv_vs = lp_gs;
            int lv_ae = HHD_ReturnIntegerNumMax(lv_vs);
            int lv_va = lp_start;
            int lv_ai = lp_increment;
            int lv_integer;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                HashTableSave0(false, "IntegerGFor" + lv_vs + lv_va.ToString(), HHD_ReturnIntegerFromRegNum(lv_va, lv_vs));
            }
            lv_va = lp_start;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                lv_integer = (int)HashTableLoad0(false, "IntegerGFor" + lv_vs + lv_va.ToString());
                lp_funcref(lv_integer);//用户填写的所有动作
            }
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Integer组中随机元素。返回指定Integer组中的随机Integer。Integer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Integer组到Integer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HHD_ReturnRandomIntegerFromIntegerGFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_num;
            int lv_a;
            int lv_c = 0;
            // Variable Initialization
            lv_num = HHD_ReturnIntegerNumMax(lp_gs);
            // Implementation
            if ((lv_num >= 1))
            {
                lv_a = RandomInt(1, lv_num);
                lv_c = HHD_ReturnIntegerFromRegNum(lv_a, lp_gs);
            }
            return lv_c;
        }

        //互动IG_添加Integer组到Integer组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = HHD_ReturnIntegerNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = HHD_ReturnIntegerFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     HHD_AddIntegerToGroup(#AUTOVAR(var), #AUTOVAR(vsb));
        // }


        /// <summary>
        /// 【MM_函数库】互动IG_添加Integer组到Integer组。添加一个Integer组A的元素到另一个Integer组B，相同Integer被认为是同一个。Integer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Integer组到Integer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void HHD_AddIntegerGToIntegerG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = HHD_ReturnIntegerNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            int lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = HHD_ReturnIntegerFromRegNum(lv_va, lv_vsa);
                HHD_AddIntegerToGroup(lv_var, lv_vsb);
            }
        }

        //互动IG_从Integer组移除Integer组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = HHD_ReturnIntegerNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = HHD_ReturnIntegerFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     HHD_RemoveInteger(#AUTOVAR(var), #AUTOVAR(vsb));
        // }

        /// <summary>
        /// 【MM_函数库】互动IG_从Integer组移除Integer组。将Integer组A的元素从Integer组B中移除，相同Integer被认为是同一个。移除使用了"互动I_移除Integer"，同一个存储区（Integer组ID）序号重排，移除时该存储区如有其他操作会排队等待。Integer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Integer组到Integer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void HHD_ClearIntegerGFromIntegerG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = HHD_ReturnIntegerNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            int lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = HHD_ReturnIntegerFromRegNum(lv_va, lv_vsa);
                HHD_RemoveInteger(lv_var, lv_vsb);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动IG_移除Integer组全部元素。将Integer组（Key区）存储的元素全部移除，相同Integer被认为是同一个。移除时同一个存储区（Integer组ID）序号不进行重排，但该存储区如有其他操作会排队等待。Integer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Integer组到Integer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Integer组名称</param>
        public static void HHD_RemoveIntegerGAll(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag = "";
            int lv_a;
            // Variable Initialization
            lv_str = (lp_key + "Integer");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            // Implementation
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_IntegerGroup" + lv_str, true);
            for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
            {
                lv_tag = HashTableLoad1(true, (lp_key + "IntegerTag"), lv_a).ToString();
                lv_num -= 1;
                HashTableClear0(true, "HHD_IfIntegerTag" + lv_str + "_" + lv_tag);
                HashTableClear0(true, "HHD_IntegerCV" + lv_str + "_" + lv_tag);
                HashTableClear0(true, "HHD_IntegerState" + lv_str + "_" + lv_tag);
                HashTableSave0(true, (lp_key + "IntegerNum"), lv_num);
            }
            ThreadWaitSet(true, "Key_IntegerGroup" + lv_str, false);
        }

        //--------------------------------------------------------------------------------------------------
        // 数字组End
        //--------------------------------------------------------------------------------------------------

        #endregion

        #endregion

        #endregion

        #endregion

        #region Functions 键鼠事件动作主体

        //加入按键监听并传参执行

        /// <summary>
        /// 【MM_函数库】注册键鼠总控预制事件。通过本函数可快捷将RecordService类实例中5个预制事件KeyDown、KeyUp、MouseMove、MouseDown、MouseUp注册给库内预制函数引用，从而使用按键总控管理衍生的所有功能（比如将“移动”、“发射火箭”等函数动作注册给Q键）
        /// </summary>
        /// <param name="cover">true：覆盖注册，false：追加注册</param>
        public static void AddKeyMouseEvent(RecordService keyMouseRecordService, bool cover)
        {
            if (cover)
            {
                //执行事件覆盖
                keyMouseRecordService.KeyDownEvent = KeyDown;
                keyMouseRecordService.KeyUpEvent = KeyUp;
                keyMouseRecordService.MouseMoveEvent = MouseMove;
                keyMouseRecordService.MouseDownEvent = MouseDown;
                keyMouseRecordService.MouseUpEvent = MouseUp;
            }
            else if (!keyMouseRecordService.DefaultEvent)
            {
                //执行事件追加
                keyMouseRecordService.KeyDownEvent += KeyDown;
                keyMouseRecordService.KeyUpEvent += KeyUp;
                keyMouseRecordService.MouseMoveEvent += MouseMove;
                keyMouseRecordService.MouseDownEvent += MouseDown;
                keyMouseRecordService.MouseUpEvent += MouseUp;
            }
            keyMouseRecordService.DefaultEvent = true;
        }

        /// <summary>
        /// 【MM_函数库】注销键鼠总控预制事件
        /// </summary>
        /// <param name="lp_null">true注销全部，否则仅注销预制事件</param>
        public static void DelKeyMouseEvent(RecordService keyMouseRecordService, bool lp_null)
        {
            if (lp_null)
            {
                //全事件清除
                keyMouseRecordService.KeyDownEvent = null;
                keyMouseRecordService.KeyUpEvent = null;
                keyMouseRecordService.MouseMoveEvent = null;
                keyMouseRecordService.MouseDownEvent = null;
                keyMouseRecordService.MouseUpEvent = null;
            }
            else if (keyMouseRecordService.DefaultEvent)
            {
                //仅移除预制事件
                keyMouseRecordService.KeyDownEvent -= KeyDown;
                keyMouseRecordService.KeyUpEvent -= KeyUp;
                keyMouseRecordService.MouseMoveEvent -= MouseMove;
                keyMouseRecordService.MouseDownEvent -= MouseDown;
                keyMouseRecordService.MouseUpEvent -= MouseUp;
            }
            keyMouseRecordService.DefaultEvent = false;
        }

        /// <summary>
        /// 【MM_函数库】键盘按下事件主要动作（加入按键监听并传参执行）
        /// </summary>
        /// <param name="player"></param>
        /// <param name="key"></param>
        internal static bool KeyDown(int player, int key)
        {
            bool torf = !StopKeyMouseEvent[player];
            Player.KeyDownState[player, key] = torf;  //当前按键状态值
            Player.KeyDown[player, key] = true;  //当前按键值

            if (StopKeyMouseEvent[player] == false)
            {
                Player.KeyDownLoopOneBitNum[player] += 1; //玩家当前注册的按键队列数量
                HashTableSave2(true, "KeyDownLoopOneBit", player, Player.KeyDownLoopOneBitNum[player], key);
                //↑存储玩家注册序号对应按键队列键位
                HashTableSave2(true, "KeyDownLoopOneBitKey", player, key, true); //玩家按键队列键位状态
                //---------------------------------------------------------------------蓄力管理
                // if (XuLiGuanLi == true){
                // libBC0D3AAD_gf_HD_RegKXL(key, "IntGroup_XuLi" + IntToString(player)); //HD_注册蓄力按键
                // libBC0D3AAD_gf_HD_SetKeyFixedXL(player, key, 1.0);
                // }
                //---------------------------------------------------------------------双击管理
                // if (ShuangJiGuanLi == true){
                //     lv_a = libBC0D3AAD_gf_HD_ReturnKeyFixedSJ(player, key);
                //     if ((0.0 < lv_a) && (lv_a <= ShuangJiShiXian)){
                //         //符合双击标准，发送事件
                //         libBC0D3AAD_gf_Send_KeyDoubleClicked(player, key, ShuangJiShiXian - lv_a);
                //     } 
                //     else {   
                //         libBC0D3AAD_gf_HD_RegKSJ(key, "IntGroup_DoubleClicked" + IntToString(player)); //HD_注册按键
                //         libBC0D3AAD_gf_HD_SetKeyFixedSJ(player, key, ShuangJiShiXian);
                //     }
                // }
                //---------------------------------------------------------------------
                KeyDownGlobalEvent(key, true, player);
            }
            return torf;
        }

        /// <summary>
        /// 【MM_函数库】键盘弹起事件主要动作（加入按键监听并传参执行）
        /// </summary>
        /// <param name="player"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        internal static bool KeyUp(int player, int key)
        {
            bool torf = !StopKeyMouseEvent[player];
            Player.KeyDownState[player, key] = false;  //当前按键状态值，本事件始终为false
            Player.KeyDown[player, key] = false;  //当前按键值

            if (StopKeyMouseEvent[player] == false)
            {
                //直接执行动作或通知延迟弹起函数去执行动作
                if ((bool)HashTableLoad2(true, "KeyDownLoopOneBitKey", player, key) == false)
                {
                    //弹起时无该键动作队列（由延迟弹起执行完），则直接执行本次事件动作
                    KeyUpFunc(player, key);
                }
                else
                {
                    //弹起时有该键动作队列，通知延迟弹起函数运行（按键队列>0时，清空一次队列并执行它们的动作）
                    HashTableSave2(true, "KeyDownLoopOneBitEnd", player, key, true);
                }
            }
            return torf;
        }

        /// <summary>
        /// 【MM_函数库】键盘弹起事件处理函数
        /// </summary>
        /// <param name="player"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        internal static bool KeyUpFunc(int player, int key)
        {
            bool torf = true;
            if (StopKeyMouseEvent[player] == true)
            {
                torf = false;
            }
            else
            {
                KeyDownGlobalEvent(key, false, player);
            }
            return torf;
        }

        /// <summary>
        /// 【MM_函数库】鼠标移动事件主要动作（加入按键监听并传参执行）
        /// </summary>
        /// <param name="player"></param>
        /// <param name="lp_mouseVector3F"></param>
        /// <param name="uiX"></param>
        /// <param name="uiY"></param>
        internal static void MouseMove(int player, Vector3F lp_mouseVector3F, int uiX, int uiY)
        {
            if (StopKeyMouseEvent[player] == false)
            {
                Player.MouseVector2F[player] = new Vector2F(lp_mouseVector3F.X, lp_mouseVector3F.Y);

                //↓注意取出来的是该点最高位Unit
                float unitTerrainHeight = float.Parse(HD_ReturnVectorCV(Player.MouseVector2F[player], "Unit.TerrainHeight"));
                float unitHeight = float.Parse(HD_ReturnVectorCV(Player.MouseVector2F[player], "Unit.Height"));

                Player.MouseVectorX[player] = lp_mouseVector3F.X;
                Player.MouseVectorY[player] = lp_mouseVector3F.Y;
                Player.MouseVectorZ[player] = lp_mouseVector3F.Z;
                Player.MouseVectorZFixed[player] = lp_mouseVector3F.Z - Game.MapHeight;

                Player.MouseUIX[player] = uiX;
                Player.MouseUIY[player] = uiY;

                Player.MouseVector3FFixed[player] = new Vector3F(lp_mouseVector3F.X, lp_mouseVector3F.Y, Player.MouseVectorZFixed[player]);
                Player.MouseVector3F[player] = lp_mouseVector3F;
                //下面2个动作应该要从二维点读取单位（可多个），将最高的单位的头顶坐标填入以修正鼠标Z点
                Player.MouseVector3FUnitTerrain[player] = new Vector3F(lp_mouseVector3F.X, lp_mouseVector3F.Y, lp_mouseVector3F.Z - unitTerrainHeight);
                Player.MouseVector3FTerrain[player] = new Vector3F(lp_mouseVector3F.X, lp_mouseVector3F.Y, lp_mouseVector3F.Z - unitTerrainHeight - unitHeight);

                //玩家控制单位存在时，计算鼠标距离控制单位的2D角度和3D距离
                if (Player.UnitControl[player] != null)
                {
                    //计算鼠标与控制单位的2D角度，用于调整角色在二维坐标系四象限内的的朝向
                    Player.MouseToUnitControlAngle[player] = AngleBetween(Player.UnitControl[player].Vector2F, Player.MouseVector2F[player]);
                    //计算鼠标与控制单位的2D距离（由于点击的位置是单位头顶位置，2个单位重叠则返回最高位的，所以玩家会点到最高位单位）
                    Player.MouseToUnitControlRange[player] = Distance(Player.UnitControl[player].Vector2F, Player.MouseVector2F[player]);
                    //计算鼠标与控制单位的3D距离（由于点击的位置是单位头顶位置，2个单位重叠则返回最高位的，所以玩家会点到最高位单位）
                    Player.MouseToUnitControlRange3F[player] = Distance(Player.UnitControl[player].Vector3F, lp_mouseVector3F);
                }
            }
        }

        /// <summary>
        /// 【MM_函数库】鼠标按下事件主要动作（加入按键监听并传参执行）
        /// </summary>
        /// <param name="player"></param>
        /// <param name="key"></param>
        /// <param name="lp_mouseVector3F"></param>
        /// <param name="uiX"></param>
        /// <param name="uiY"></param>
        /// <returns></returns>
        internal static bool MouseDown(int player, int key, Vector3F lp_mouseVector3F, int uiX, int uiY)
        {
            bool torf = !StopKeyMouseEvent[player];
            Player.MouseDownState[player, key] = torf;  //当前按键状态值
            Player.MouseDown[player, key] = true;  //当前按键值
            if (key == c_mouseButtonLeft)
            {
                Player.MouseDownLeft[player] = true;
            }
            if (key == c_mouseButtonRight)
            {
                Player.MouseDownRight[player] = true;
            }
            if (key == c_mouseButtonMiddle)
            {
                Player.MouseDownMiddle[player] = true;
            }

            if (StopKeyMouseEvent[player] == false)
            {
                Player.MouseVector2F[player] = new Vector2F(lp_mouseVector3F.X, lp_mouseVector3F.Y);

                //↓注意取出来的是该点最高位Unit
                float unitTerrainHeight = float.Parse(HD_ReturnVectorCV(Player.MouseVector2F[player], "Unit.TerrainHeight"));
                float unitHeight = float.Parse(HD_ReturnVectorCV(Player.MouseVector2F[player], "Unit.Height"));

                Player.MouseVectorX[player] = lp_mouseVector3F.X;
                Player.MouseVectorY[player] = lp_mouseVector3F.Y;
                Player.MouseVectorZ[player] = lp_mouseVector3F.Z;
                Player.MouseVectorZFixed[player] = lp_mouseVector3F.Z - Game.MapHeight;

                Player.MouseUIX[player] = uiX;
                Player.MouseUIY[player] = uiY;

                Player.MouseVector3FFixed[player] = new Vector3F(lp_mouseVector3F.X, lp_mouseVector3F.Y, Player.MouseVectorZFixed[player]);
                Player.MouseVector3F[player] = lp_mouseVector3F;
                //下面2个动作应该要从二维点读取单位（可多个），将最高的单位的头顶坐标填入以修正鼠标Z点
                Player.MouseVector3FUnitTerrain[player] = new Vector3F(lp_mouseVector3F.X, lp_mouseVector3F.Y, lp_mouseVector3F.Z - unitTerrainHeight);
                Player.MouseVector3FTerrain[player] = new Vector3F(lp_mouseVector3F.X, lp_mouseVector3F.Y, lp_mouseVector3F.Z - unitTerrainHeight - unitHeight);

                //玩家控制单位存在时，计算鼠标距离控制单位的2D角度和3D距离
                if (Player.UnitControl[player] != null)
                {
                    //计算鼠标与控制单位的2D角度，用于调整角色在二维坐标系四象限内的的朝向
                    Player.MouseToUnitControlAngle[player] = AngleBetween(Player.UnitControl[player].Vector2F, Player.MouseVector2F[player]);
                    //计算鼠标与控制单位的2D距离（由于点击的位置是单位头顶位置，2个单位重叠则返回最高位的，所以玩家会点到最高位单位）
                    Player.MouseToUnitControlRange[player] = Distance(Player.UnitControl[player].Vector2F, Player.MouseVector2F[player]);
                    //计算鼠标与控制单位的3D距离（由于点击的位置是单位头顶位置，2个单位重叠则返回最高位的，所以玩家会点到最高位单位）
                    Player.MouseToUnitControlRange3F[player] = Distance(Player.UnitControl[player].Vector3F, lp_mouseVector3F);
                }

                //---------------------------------------------------------------------
                Player.MouseDownLoopOneBitNum[player] += 1;
                HashTableSave2(true, "MouseDownLoopOneBit", player, Player.MouseDownLoopOneBitNum[player], key);
                HashTableSave2(true, "MouseDownLoopOneBitKey", player, key, true);
                //---------------------------------------------------------------------
                //if (libBC0D3AAD_gv_XuLiGuanLi == true)
                //{
                //    libBC0D3AAD_gf_HD_RegKXL(lv_mouseButton, "libBC0D3AAD_gv_IntGroup_XuLi" + IntToString(lv_player)); //HD_注册按键
                //    libBC0D3AAD_gf_HD_SetKeyFixedXL(lv_player, lv_mouseButton, 1.0);
                //}
                ////---------------------------------------------------------------------
                //if (libBC0D3AAD_gv_ShuangJiGuanLi == true)
                //{
                //    libBC0D3AAD_gf_HD_RegPTwo(lv_point1, "DoubleClicked_PTwo_" + IntToString(lv_player));
                //    lv_a = libBC0D3AAD_gf_HD_ReturnKeyFixedSJ(lv_player, lv_mouseButton);
                //    if ((0.0 < lv_a) && (lv_a <= libBC0D3AAD_gv_ShuangJiShiXian) && libBC0D3AAD_gf_HD_PTwoRangeTrue("DoubleClicked_PTwo_" + IntToString(lv_player)))
                //    {
                //        //符合双击标准（鼠标双击多个2点验证），发送事件
                //        libBC0D3AAD_gf_Send_MouseDoubleClicked(lv_player, lv_mouseButton, libBC0D3AAD_gv_ShuangJiShiXian - lv_a, lv_point0, lv_uiX, lv_uiY);
                //    }
                //    else
                //    {
                //        libBC0D3AAD_gf_HD_RegKSJ(lv_mouseButton, "libBC0D3AAD_gv_IntGroup_DoubleClicked" + IntToString(lv_player)); //HD_注册按键
                //        libBC0D3AAD_gf_HD_SetKeyFixedSJ(lv_player, lv_mouseButton, libBC0D3AAD_gv_ShuangJiShiXian);
                //    }
                //}
                ////---------------------------------------------------------------------
                MouseDownFunc(player, key, lp_mouseVector3F, uiX, uiY);
            }
            return torf;
        }

        /// <summary>
        /// 【MM_函数库】鼠标按下事件处理函数
        /// </summary>
        /// <param name="player"></param>
        /// <param name="key"></param>
        /// <param name="lp_mouseVector3F"></param>
        /// <param name="uiX"></param>
        /// <param name="uiY"></param>
        /// <returns></returns>
        internal static bool MouseDownFunc(int player, int key, Vector3F lp_mouseVector3F, int uiX, int uiY)
        {
            // Variable Declarations
            bool torf = true;

            // Implementation
            if (StopKeyMouseEvent[player] == true)
            {
                //阻止按键事件时强制取消按键状态
                Player.MouseDownState[player, key] = false;
                if (key == c_mouseButtonLeft)
                {
                    Player.MouseDownLeft[player] = false;
                }
                if (key == c_mouseButtonRight)
                {
                    Player.MouseDownRight[player] = false;
                }
                if (key == c_mouseButtonMiddle)
                {
                    Player.MouseDownMiddle[player] = false;
                }
                torf = false;
            }
            else
            {
                MouseDownGlobalEvent(key, true, player);
            }
            return torf;
        }

        /// <summary>
        /// 【MM_函数库】鼠标弹起事件主要动作（加入按键监听并传参执行）
        /// </summary>
        /// <param name="player"></param>
        /// <param name="key"></param>
        /// <param name="lp_mouseVector3F"></param>
        /// <param name="uiX"></param>
        /// <param name="uiY"></param>
        internal static bool MouseUp(int player, int key, Vector3F lp_mouseVector3F, int uiX, int uiY)
        {
            bool torf = !StopKeyMouseEvent[player];
            Player.MouseDownState[player, key] = false;  //当前按键状态值，本事件始终为false
            Player.MouseDown[player, key] = false;  //当前按键值
            if (key == c_mouseButtonLeft)
            {
                Player.MouseDownLeft[player] = false;
            }
            if (key == c_mouseButtonRight)
            {
                Player.MouseDownRight[player] = false;
            }
            if (key == c_mouseButtonMiddle)
            {
                Player.MouseDownMiddle[player] = false;
            }

            if (StopKeyMouseEvent[player] == false)
            {
                //直接执行动作或通知延迟弹起函数去执行动作
                if ((bool)HashTableLoad2(true, "MouseDownLoopOneBitKey", player, key) == false)
                {
                    //弹起时无该键动作队列（由延迟弹起执行完），则直接执行本次事件动作
                    MouseUpFunc(player, key);
                }
                else
                {
                    //弹起时有该键动作队列，通知延迟弹起函数运行（按键队列>0时，清空一次队列并执行它们的动作）
                    HashTableSave2(true, "MouseDownLoopOneBitEnd", player, key, true);
                }
            }
            return torf;
        }

        /// <summary>
        /// 【MM_函数库】鼠标弹起事件处理函数
        /// </summary>
        /// <param name="player"></param>
        /// <param name="key"></param>
        internal static bool MouseUpFunc(int player, int key)
        {
            bool torf = true;
            if (StopKeyMouseEvent[player] == true)
            {
                torf = false;
            }
            else
            {
                MouseDownGlobalEvent(key, false, player);
            }
            return torf;
        }

        /// <summary>
        /// 【MM_函数库】键鼠弹起事件延迟执行函数，会按序执行键鼠事件动作队列，需加入到每帧执行
        /// </summary>
        /// <param name="player"></param>
        /// <param name="key"></param>
        /// <param name="lp_mouseVector3F"></param>
        /// <param name="uiX"></param>
        /// <param name="uiY"></param>
        internal static void MouseKeyUpWait(int player, int key)
        {
            int ae, be, a, ai = 1, bi = 1;
            //玩家有鼠标按键事件动作队列时
            if (Player.MouseDownLoopOneBitNum[player] > 0)
            {
                ae = Player.MouseDownLoopOneBitNum[player];//获取动作队列数量
                a = 1;
                for (; ((ai >= 0 && a <= ae) || (ai < 0 && a >= ae)); a += ai)
                {
                    key = (int)HashTableLoad2(true, "MouseDownLoopOneBit", player, a);//读取玩家指定动作队列按键
                    if ((bool)HashTableLoad2(true, "MouseDownLoopOneBitEnd", player, key) == true)//判断玩家指定按键的动作队列是否结束
                    {
                        //如果该键的动作队列结束，重置按键状态
                        if (key == c_mouseButtonLeft)
                        {
                            Player.MouseDown[player, c_mouseButtonLeft] = false;
                        }
                        if (key == c_mouseButtonRight)
                        {
                            Player.MouseDown[player, c_mouseButtonRight] = false;
                        }
                        if (key == c_mouseButtonMiddle)
                        {
                            Player.MouseDown[player, c_mouseButtonMiddle] = false;
                        }
                        //
                        MouseDownFunc(player, key, Player.MouseVector3F[player], Player.MouseUIX[player], Player.MouseUIY[player]);
                    }
                    HashTableClear2(true, "MouseDownLoopOneBit", player, a);
                    HashTableClear2(true, "MouseDownLoopOneBitKey", player, key);
                    HashTableClear2(true, "MouseDownLoopOneBitEnd", player, key);
                }
                Player.MouseDownLoopOneBitNum[player] = 0; //动作全部执行，全队列清空
            }
            //玩家有键盘按键事件动作队列时
            if (Player.KeyDownLoopOneBitNum[player] > 0)//获取动作队列数量
            {
                be = Player.KeyDownLoopOneBitNum[player];
                a = 1;
                for (; ((bi >= 0 && a <= be) || (bi < 0 && a >= be)); a += bi)
                {
                    key = (int)HashTableLoad2(true, "KeyDownLoopOneBit", player, a);//读取玩家指定动作队列按键
                    if ((bool)HashTableLoad2(true, "KeyDownLoopOneBitEnd", player, key) == true)//判断玩家指定按键的动作队列是否结束
                    {
                        //如果该键的动作队列结束，重置按键状态
                        Player.KeyDown[player, key] = false;
                        KeyUpFunc(player, key);
                    }
                    HashTableClear2(true, "KeyDownLoopOneBit", player, a);
                    HashTableClear2(true, "KeyDownLoopOneBitKey", player, key);
                    HashTableClear2(true, "KeyDownLoopOneBitEnd", player, key);
                }
                Player.KeyDownLoopOneBitNum[player] = 0; //全键盘队列清空
            }
        }

        #endregion

        #region Functions 键鼠事件函数引用管理

        //可进行注册注销查询更换归并执行委托

        //------------------------------------↓KeyDownEventStart↓-----------------------------------------

        /// <summary>
        /// 【MM_函数库】将（1个或多个）委托函数注册到键盘按键事件（或者说给委托函数添加指定事件，完成事件注册）。
        /// 注册指定键盘按键的委托函数，每个键盘按键最大注册数量限制（8），超过则什么也不做
        /// </summary>
        /// <param name="key"></param>
        /// <param name="funcref"></param>
        public static void RegistKeyEventFuncref(int key, KeyMouseEventFuncref funcref)
        {
            ThreadWait("MMCore_KeyEventFuncref_");//注册注销时进行等待
            ThreadWaitSet("MMCore_KeyEventFuncref_", true);
            if (keyEventFuncrefGroupNum[key] >= c_regKeyMax)
            {
                return;
            }
            keyEventFuncrefGroupNum[key] += 1;//注册成功记录+1
            keyEventFuncrefGroup[key, keyEventFuncrefGroupNum[key]] = funcref;//这里采用等于，设计为覆盖
            ThreadWaitSet("MMCore_KeyEventFuncref_", false);
        }
        /// <summary>
        /// 【MM_函数库】注册指定键盘按键的委托函数（登录在指定注册序号num位置）
        /// </summary>
        /// <param name="key"></param>
        /// <param name="num">不能超过最大注册数量限制（8）</param>
        /// <param name="funcref"></param>
        public static void RegistKeyEventFuncref(int key, int num, KeyMouseEventFuncref funcref)
        {
            ThreadWait("MMCore_KeyEventFuncref_");//注册注销时进行等待
            ThreadWaitSet("MMCore_KeyEventFuncref_", true);
            keyEventFuncrefGroup[key, num] = funcref;
            ThreadWaitSet("MMCore_KeyEventFuncref_", false);
        }

        /// <summary>
        /// 【MM_函数库】注销指定键盘按键的委托函数（发生序号重排）
        /// </summary>
        /// <param name="key"></param>
        /// <param name="funcref"></param>
        public static void RemoveKeyEventFuncref(int key, KeyMouseEventFuncref funcref)
        {
            ThreadWait("MMCore_KeyEventFuncref_");
            ThreadWaitSet("MMCore_KeyEventFuncref_", true);
            for (int a = 1; a <= keyEventFuncrefGroupNum[key]; a += 1)
            {
                //遍历检查所填函数注册序号
                if (keyEventFuncrefGroup[key, a] == funcref)
                {
                    //该键位注册总数减一
                    keyEventFuncrefGroupNum[key] -= 1;
                    for (int b = a; b <= keyEventFuncrefGroupNum[key]; b += 1)
                    {
                        //将后序有效函数（如有）按序重排
                        keyEventFuncrefGroup[key, b] = keyEventFuncrefGroup[key, b];
                    }
                    //新的序号下从可疑序号重新开始检查，确保该函数在键位中彻底消失
                    a -= 1;
                }
            }
            ThreadWaitSet("MMCore_KeyEventFuncref_", false);
        }

        /// <summary>
        /// 【MM_函数库】返回指定键盘按键注册函数的序号
        /// </summary>
        /// <param name="key"></param>
        /// <param name="funcref"></param>
        /// <returns>错误时返回-1</returns>
        public static int GetKeyEventFuncrefNearestNum(int key, KeyMouseEventFuncref funcref)
        {
            int num = -1;
            for (int a = 1; a <= keyEventFuncrefGroupNum[key]; a += 1)
            {
                //遍历检查所填函数注册序号
                if (keyEventFuncrefGroup[key, a] == funcref)
                {
                    //返回最近的函数序号
                    num = a;
                    break;
                }
            }
            return num;
        }

        /// <summary>
        /// 【MM_函数库】返回指定键盘按键指定函数的注册数量（>1则注册了多个同样的函数）
        /// </summary>
        /// <param name="key"></param>
        /// <param name="funcref"></param>
        /// <returns></returns>
        public static int GetKeyEventFuncrefCount(int key, KeyMouseEventFuncref funcref)
        {
            int count = 0;
            for (int a = 1; a <= keyEventFuncrefGroupNum[key]; a += 1)
            {
                //遍历检查所填函数注册序号
                if (keyEventFuncrefGroup[key, a] == funcref)
                {
                    count += 1;
                }
            }

            return count;
        }

        /// <summary>
        /// 【MM_函数库】归并键盘按键指定函数（如存在则移除该函数注册并序号重排，之后重新注册1次）
        /// </summary>
        /// <param name="key"></param>
        /// <param name="funcref"></param>
        /// <returns></returns>
        public static bool RedoKeyEventFuncref(int key, KeyMouseEventFuncref funcref)
        {
            ThreadWait("MMCore_KeyEventFuncref_");//注册注销时进行等待
            ThreadWaitSet("MMCore_KeyEventFuncref_", true);
            bool result = false;
            int num = GetKeyEventFuncrefCount(key, funcref);
            if (num > 1)
            {
                result = true;
                //发现重复函数，移除后重新注册
                RemoveKeyEventFuncref(key, funcref);
                RegistKeyEventFuncref(key, funcref);
            }
            ThreadWaitSet("MMCore_KeyEventFuncref_", false);
            return result;
        }

        /// <summary>
        /// 【MM_函数库】全局键盘按键事件，对指定键盘按键执行委托函数动作集合
        /// </summary>
        /// <param name="key"></param>
        /// <param name="keydown"></param>
        /// <param name="player"></param>
        public static void KeyDownGlobalEvent(int key, bool keydown, int player)
        {
            for (int a = 1; a <= keyEventFuncrefGroupNum[key]; a += 1)
            {
                //这里不开新线程，是否另开线程运行宜由委托函数去写
                keyEventFuncrefGroup[key, a](keydown, player);//执行键盘按键委托
            }
        }

        //--------------------------------------↑KeyDownEventEnd↑-----------------------------------------

        //------------------------------------↓MouseDownEventStart↓---------------------------------------

        /// <summary>
        /// 【MM_函数库】将（1个或多个）委托函数注册到鼠标按键事件（或者说给委托函数添加指定事件，完成事件注册）。
        /// 注册指定鼠标键位的委托函数，每个鼠标按键最大注册数量限制（24），超过则什么也不做
        /// </summary>
        /// <param name="key"></param>
        /// <param name="funcref"></param>
        public static void RegistMouseEventFuncref(int key, KeyMouseEventFuncref funcref)
        {
            ThreadWait("MouseEventFuncref");//注册注销时进行等待
            ThreadWaitSet("MouseEventFuncref", true);
            if (mouseEventFuncrefGroupNum[key] >= c_regMouseMax)
            {
                return;
            }
            mouseEventFuncrefGroupNum[key] += 1;//注册成功记录+1
            mouseEventFuncrefGroup[key, mouseEventFuncrefGroupNum[key]] = funcref;//这里采用等于，设计为覆盖
            ThreadWaitSet("MouseEventFuncref", false);
        }

        /// <summary>
        /// 【MM_函数库】注册指定鼠标键位的委托函数（登录在指定注册序号num位置）
        /// </summary>
        /// <param name="key"></param>
        /// <param name="num">不能超过最大注册数量限制（24）</param>
        /// <param name="funcref"></param>
        public static void RegistMouseEventFuncref(int key, int num, KeyMouseEventFuncref funcref)
        {
            ThreadWait("MouseEventFuncref");//注册注销时进行等待
            ThreadWaitSet("MouseEventFuncref", true);
            mouseEventFuncrefGroup[key, num] = funcref;
            ThreadWaitSet("MouseEventFuncref", false);
        }

        /// <summary>
        /// 【MM_函数库】注销指定鼠标键位的委托函数（发生序号重排）
        /// </summary>
        /// <param name="key"></param>
        /// <param name="funcref"></param>
        public static void RemoveMouseEventFuncref(int key, KeyMouseEventFuncref funcref)
        {
            ThreadWait("MouseEventFuncref");
            ThreadWaitSet("MouseEventFuncref", true);
            for (int a = 1; a <= mouseEventFuncrefGroupNum[key]; a += 1)
            {
                if (mouseEventFuncrefGroup[key, a] == funcref)
                {
                    mouseEventFuncrefGroupNum[key] -= 1;
                    for (int b = a; b <= mouseEventFuncrefGroupNum[key]; b += 1)
                    {
                        mouseEventFuncrefGroup[key, b] = mouseEventFuncrefGroup[key, b];
                    }
                    a -= 1;
                }
            }
            ThreadWaitSet("MouseEventFuncref", false);
        }

        /// <summary>
        /// 【MM_函数库】返回指定鼠标键位注册函数的序号
        /// </summary>
        /// <param name="key"></param>
        /// <param name="funcref"></param>
        /// <returns>错误时返回-1</returns>
        public static int GetMouseEventFuncrefNearestNum(int key, KeyMouseEventFuncref funcref)
        {
            int num = -1;
            for (int a = 1; a <= mouseEventFuncrefGroupNum[key]; a += 1)
            {
                //遍历检查所填函数注册序号
                if (mouseEventFuncrefGroup[key, a] == funcref)
                {
                    //返回最近的函数序号
                    num = a;
                    break;
                }
            }
            return num;
        }

        /// <summary>
        /// 【MM_函数库】返回指定鼠标键位指定注册函数的数量（>1则注册了多个同样的函数）
        /// </summary>
        /// <param name="key"></param>
        /// <param name="funcref"></param>
        /// <returns></returns>
        public static int GetMouseEventFuncrefCount(int key, KeyMouseEventFuncref funcref)
        {
            int count = 0;
            for (int a = 1; a <= mouseEventFuncrefGroupNum[key]; a += 1)
            {
                //遍历检查所填函数注册序号
                if (mouseEventFuncrefGroup[key, a] == funcref)
                {
                    count += 1;
                }
            }
            return count;
        }

        /// <summary>
        /// 【MM_函数库】归并鼠标按键指定函数（如存在则移除该函数注册并序号重排，之后重新注册1次）
        /// </summary>
        /// <param name="key"></param>
        /// <param name="funcref"></param>
        /// <returns></returns>
        public static bool RedoMouseEventFuncref(int key, KeyMouseEventFuncref funcref)
        {
            bool torf = false;
            int num = GetMouseEventFuncrefCount(key, funcref);
            if (num > 1)
            {
                torf = true;
                //发现重复函数，移除后重新注册
                RemoveMouseEventFuncref(key, funcref);
                RegistMouseEventFuncref(key, funcref);
            }
            return torf;
        }

        /// <summary>
        /// 【MM_函数库】全局鼠标按键事件，对指定鼠标按键执行委托函数动作集合
        /// </summary>
        /// <param name="key"></param>
        /// <param name="keydown"></param>
        /// <param name="player"></param>
        public static void MouseDownGlobalEvent(int key, bool keydown, int player)
        {
            int a = 1;
            for (; a <= mouseEventFuncrefGroupNum[key]; a += 1)
            {
                //这里不开新线程，是否另开线程运行宜由委托函数去写
                mouseEventFuncrefGroup[key, a](keydown, player);//执行鼠标按键委托
            }
        }

        //------------------------------------↑MouseDownEventEnd↑-----------------------------------------

        #endregion

        #region Functions 主副循环入口事件函数管理

        //可进行注册注销查询更换归并执行委托

        //------------------------------------↓EntryFuncStart↓-----------------------------------------

        /// <summary>
        /// 【MM_函数库】将（1个或多个）委托函数注册到主副循环入口事件（或者说给委托函数添加指定事件，完成事件注册）。
        /// 注册指定主副循环入口的委托函数，每个入口最大注册数量限制（1），超过则什么也不做
        /// </summary>
        /// <param name="entry"></param>
        /// <param name="funcref"></param>
        public static void RegistEntryEventFuncref(Entry entry, EntryEventFuncref funcref)
        {
            ThreadWait("EntryEventFuncref");//注册注销时进行等待
            ThreadWaitSet("EntryEventFuncref", true);
            if (entryEventFuncrefGroupNum[(int)entry] >= c_regEntryMax)
            {
                return;
            }
            entryEventFuncrefGroupNum[(int)entry] += 1;//注册成功记录+1
            entryEventFuncrefGroup[(int)entry, entryEventFuncrefGroupNum[(int)entry]] = funcref;//这里采用等于，设计为覆盖
            ThreadWaitSet("EntryEventFuncref", false);
        }

        /// <summary>
        /// 【MM_函数库】注册指定主副循环入口的委托函数（登录在指定注册序号num位置）
        /// </summary>
        /// <param name="entry"></param>
        /// <param name="num">不能超过最大注册数量限制（8）</param>
        /// <param name="funcref"></param>
        public static void RegistEntryEventFuncref(Entry entry, int num, EntryEventFuncref funcref)
        {
            ThreadWait("EntryEventFuncref");//注册注销时进行等待
            ThreadWaitSet("EntryEventFuncref", true);
            entryEventFuncrefGroup[(int)entry, num] = funcref;
            ThreadWaitSet("EntryEventFuncref", false);
        }

        /// <summary>
        /// 【MM_函数库】注销指定主副循环入口的委托函数（发生序号重排）
        /// </summary>
        /// <param name="entry"></param>
        /// <param name="funcref"></param>
        public static void RemoveEntryEventFuncref(Entry entry, EntryEventFuncref funcref)
        {
            ThreadWait("EntryEventFuncref");
            ThreadWaitSet("EntryEventFuncref", true);
            for (int a = 1; a <= entryEventFuncrefGroupNum[(int)entry]; a += 1)
            {
                //遍历检查所填函数注册序号
                if (entryEventFuncrefGroup[(int)entry, a] == funcref)
                {
                    //该键位注册总数减一
                    entryEventFuncrefGroupNum[(int)entry] -= 1;
                    for (int b = a; b <= entryEventFuncrefGroupNum[(int)entry]; b += 1)
                    {
                        //将后序有效函数（如有）按序重排
                        entryEventFuncrefGroup[(int)entry, b] = entryEventFuncrefGroup[(int)entry, b];
                    }
                    //新的序号下从可疑序号重新开始检查，确保该函数在键位中彻底消失
                    a -= 1;
                }
            }
            ThreadWaitSet("EntryEventFuncref", false);
        }

        /// <summary>
        /// 【MM_函数库】返回指定主副循环入口注册函数的序号
        /// </summary>
        /// <param name="entry"></param>
        /// <param name="funcref"></param>
        /// <returns>错误时返回-1</returns>
        public static int GetEntryEventFuncrefNearestNum(Entry entry, EntryEventFuncref funcref)
        {
            int num = -1;
            for (int a = 1; a <= entryEventFuncrefGroupNum[(int)entry]; a += 1)
            {
                //遍历检查所填函数注册序号
                if (entryEventFuncrefGroup[(int)entry, a] == funcref)
                {
                    //返回最近的函数序号
                    num = a;
                    break;
                }
            }
            return num;
        }

        /// <summary>
        /// 【MM_函数库】返回指定主副循环入口指定函数的注册数量（>1则注册了多个同样的函数）
        /// </summary>
        /// <param name="entry"></param>
        /// <param name="funcref"></param>
        /// <returns></returns>
        public static int GetEntryEventFuncrefCount(Entry entry, EntryEventFuncref funcref)
        {
            int count = 0;
            for (int a = 1; a <= entryEventFuncrefGroupNum[(int)entry]; a += 1)
            {
                //遍历检查所填函数注册序号
                if (entryEventFuncrefGroup[(int)entry, a] == funcref)
                {
                    count += 1;
                }
            }

            return count;
        }

        /// <summary>
        /// 【MM_函数库】归并主副循环入口指定函数（如存在则移除该函数注册并序号重排，之后重新注册1次）
        /// </summary>
        /// <param name="entry"></param>
        /// <param name="funcref"></param>
        /// <returns></returns>
        public static bool RedoEntryEventFuncref(Entry entry, EntryEventFuncref funcref)
        {
            bool result = false;
            int num = GetEntryEventFuncrefCount(entry, funcref);
            if (num > 1)
            {
                result = true;
                //发现重复函数，移除后重新注册
                RemoveEntryEventFuncref(entry, funcref);
                RegistEntryEventFuncref(entry, funcref);
            }
            return result;
        }

        /// <summary>
        /// 【MM_函数库】全局主副循环入口事件，对指定入口执行委托函数动作集合
        /// </summary>
        /// <param name="entry"></param>
        public static void EntryGlobalEvent(Entry entry)
        {
            for (int a = 1; a <= entryEventFuncrefGroupNum[(int)entry]; a += 1)
            {
                entryEventFuncrefGroup[(int)entry, a]();//执行主副循环入口委托
            }
        }

        //------------------------------------↑EntryFuncEnd↑-----------------------------------------

        #endregion

    }
}
