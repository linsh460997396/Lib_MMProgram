#region 序言

//--------------------------------------------------------------------------------------------------
//MetalMaxSystem.FuncLib（MM_函数库）
//Code By Prinny（蔚蓝星海）
//Github：https://github.com/linsh460997396/Lib_MMProgram.git
//--------------------------------------------------------------------------------------------------
//功能及使用说明：
//
//函数参数中int player范围是0~16，单机默认分配1为用户本人，16=触发器（程序自身调用），其余均为玩家
//
//关于静态（Static）
//声明为静态的，内存数据副本只从模板创建1份，放在静态内存区（区别于实例数据动态增删的活动内存区，它是为了效率从逻辑上分类的而非物理分类），且创建后只在程序结束才会清理
//静态数据包括静态局部变量（C#不支持，C++支持），创建唯一副本时只赋初值一次，后每次调用函数不再重新赋初值只保留上次调用结束时的值
//静态数据内存地址不变化（并非声明静态就一定给全局通用要考虑作用域，全局使用其他命名空间类成员需加前缀globol::）
//
//其余另详README.md
//--------------------------------------------------------------------------------------------------

#endregion

#region 引用空间

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Management;
using System.Net;
using System.Text.RegularExpressions;
using System.Runtime.InteropServices;
using Microsoft.Win32;
using System.Collections;
using System.Threading;
using System.ComponentModel;
using System.Windows;
using System.Windows.Media.Media3D;
using Point = System.Windows.Point;
using MessageBox = System.Windows.MessageBox;
using Timer = System.Threading.Timer;
using static MetalMaxSystem.MouseHook;
using static MetalMaxSystem.KeyboardHook;
using System.Linq;
using Microsoft.CodeAnalysis;

#endregion

/// <summary>
/// MetalMax系统 引用空间
/// </summary>
namespace MetalMaxSystem
{
    #region 公用枚举

    //枚举是值类型

    /// <summary>
    /// 【MM_函数库】主副循环的入口枚举
    /// </summary>
    public enum Entry
    {
        /// <summary>
        /// 【MM_函数库】主循环唤醒阶段
        /// </summary>
        MainAwake,
        /// <summary>
        /// 【MM_函数库】主循环开始阶段
        /// </summary>
        MainStart,
        /// <summary>
        /// 【MM_函数库】主循环周期循环阶段
        /// </summary>
        MainUpdate,
        /// <summary>
        /// 【MM_函数库】主循环结束阶段
        /// </summary>
        MainEnd,
        /// <summary>
        /// 【MM_函数库】主循环摧毁阶段
        /// </summary>
        MainDestroy,
        /// <summary>
        /// 【MM_函数库】副循环唤醒阶段
        /// </summary>
        SubAwake,
        /// <summary>
        /// 【MM_函数库】副循环开始阶段
        /// </summary>
        SubStart,
        /// <summary>
        /// 【MM_函数库】副循环周期循环阶段
        /// </summary>
        SubUpdate,
        /// <summary>
        /// 【MM_函数库】副循环结束阶段
        /// </summary>
        SubEnd,
        /// <summary>
        /// 【MM_函数库】副循环摧毁阶段
        /// </summary>
        SubDestroy
    }

    /// <summary>
    /// 【MM_函数库】单位创建标旗枚举
    /// </summary>
    public enum UnitCreateTag
    {
        /// <summary>
        /// 【MM_函数库】诞生
        /// </summary>
        Birth,
        /// <summary>
        /// 【MM_函数库】忽略占位
        /// </summary>
        IgnorePlacement,
        /// <summary>
        /// 【MM_函数库】成长中
        /// </summary>
        Growing
    }

    /// <summary>
    /// 【MM_函数库】指令目标枚举
    /// </summary>
    public enum OrderTarget
    {
        None,
        Point,
        Unit,
        Item
    }

    /// <summary>
    /// 【MM_函数库】单位计数枚举
    /// </summary>
    public enum UnitCount
    {
        All,
        Alive,
        Dead
    }

    /// <summary>
    /// 【MM_函数库】指令队列枚举
    /// </summary>
    public enum OrderQueue
    {
        Replace,
        AddToEnd,
        AddToFront
    }

    /// <summary>
    /// 【MM_函数库】单位属性
    /// </summary>
    public enum UnitProp
    {
        Life = 0,
        LifePercent = 1,
        LifeMax = 2,
        LifeRegen = 3,
        Energy = 4,
        EnergyPercent = 5,
        EnergyMax = 6,
        EnergyRegen = 7,
        Shields = 8,
        ShieldsPercent = 9,
        ShieldsMax = 10,
        ShieldsRegen = 11,
        SuppliesUsed = 12,
        SuppliesMade = 13,
        Kills = 14,
        Vitality = 15,
        VitalityPercent = 16,
        VitalityMax = 17,
        Acceleration = 18,
        Height = 19,
        MovementSpeed = 20,
        TurnRate = 21,
        Resources = 22,
        Radius = 23,
        XP = 24,
        Level = 25,
        BountyMinerals = 26,
        BountyVespene = 27,
        BountyTerrazine = 28,
        BountyCustom = 29,
        KillXP = 30,
        CarriedMinerals = 31,
        CarriedVespene = 32,
        CarriedTerrazine = 33,
        CarriedCustom = 34,
        LifeArmor = 35,
        ShieldArmor = 36,
        EnergyArmor = 37,
        LifeExpected = 38,
        EnergyExpected = 39,
        ShieldsExpected = 40,
        BaseMovementSpeed = 41,
        MovementSpeedCurrent = 42,
        LifeExpectedPercent = 43,
        EnergyExpectedPercent = 44,
        ShieldsExpectedPercent = 45,
        AIEvaluationFactor = 46
    }

    /// <summary>
    /// 【MM_函数库】玩家属性
    /// </summary>
    public enum PlayerProp
    {
        Minerals = 0,
        Vespene = 1,
        Terrazine = 2,
        Custom = 3,
        SuppliesUsed = 4,
        SuppliesMade = 5,
        SuppliesLimit = 6,
        Credits = 7,
        CreditsSpent = 8,
        ResearchPoints = 9,
        ResearchPointsSpent = 10,
        Handicap = 11,
        MineralsCollected = 12,
        VespeneCollected = 13,
        TerrazineCollected = 14,
        CustomCollected = 15,
        DamageDealtPercent = 16,
        DamageTakenPercent = 17,
        DamageDealtTime = 18,
        DamageTakenTime = 19,
        CurriculumScore = 20
    }

    /// <summary>
    /// 【MM_函数库】玩家属性操作
    /// </summary>
    public enum PlayerPropOp
    {
        SetTo = 0,
        Add = 1,
        Subtract = 2
    }

    #endregion

    #region 公用结构

    //结构是值类型

    //暂无

    #endregion

    #region 公用委托类型

    //委托是引用类型

    //个人书写习惯↓
    //声明的委托类型首字母大写
    //结尾Funcref 表示无事件event记号的常规委托类型（不安全使用）
    //结尾Handler 表示有事件event记号的事件委托类型（可安全使用）

    /// <summary>
    /// 【MM_函数库】键鼠常规函数引用（委托类型），特征：void KeyMouseEventFuncref(bool ifKeyDown, int player)
    /// </summary>
    /// <param name="ifKeyDown"></param>
    /// <param name="player"></param>
    public delegate void KeyMouseEventFuncref(bool ifKeyDown, int player);

    /// <summary>
    /// 【MM_函数库】主副循环入口常规函数引用（委托类型），特征：void EntryEventFuncref()
    /// </summary>
    public delegate void EntryEventFuncref();

    /// <summary>
    /// 【MM_函数库】计时器事件函数引用（委托类型），特征：void TimerEventHandler(object sender, EventArgs e)
    /// </summary>
    /// <param name="sender"></param>
    /// <param name="e"></param>
    public delegate void TimerEventHandler(object sender, EventArgs e);

    /// <summary>
    /// 【MM_函数库】子函数动作集合常规函数引用（委托类型），特征：void SubActionEventFuncref(int lp_var)
    /// </summary>
    public delegate void SubActionEventFuncref(object sender);

    #region 监听服务预制委托

    /// <summary>
    /// 【MM_函数库】监听服务键盘按键常规函数引用（委托类型），特征：bool KeyDownEventFuncref(int player, int key)
    /// </summary>
    /// <param name="player"></param>
    /// <param name="key"></param>
    /// <returns></returns>
    public delegate bool KeyDownEventFuncref(int player, int key);
    /// <summary>
    /// 【MM_函数库】监听服务键盘双击常规函数引用（委托类型），特征：bool KeyDoubleClickEventFuncref(int player, int key)
    /// </summary>
    /// <param name="player"></param>
    /// <param name="key"></param>
    /// <returns></returns>
    public delegate bool KeyDoubleClickEventFuncref(int player, int key);
    /// <summary>
    /// 【MM_函数库】监听服务键盘弹起常规函数引用（委托类型），特征：bool KeyUpEventFuncref(int player, int key)
    /// </summary>
    /// <param name="player"></param>
    /// <param name="key"></param>
    /// <returns></returns>
    public delegate bool KeyUpEventFuncref(int player, int key);
    /// <summary>
    /// 【MM_函数库】监听服务鼠标移动常规函数引用（委托类型），特征：void MouseMoveEventFuncref(int player, Vector3D lp_mouseVector3D, int uiX, int uiY)
    /// </summary>
    /// <param name="player"></param>
    /// <param name="lp_mouseVector3D"></param>
    /// <param name="uiX"></param>
    /// <param name="uiY"></param>
    public delegate void MouseMoveEventFuncref(int player, Vector3D lp_mouseVector3D, int uiX, int uiY);
    /// <summary>
    /// 【MM_函数库】监听服务鼠标按下常规函数引用（委托类型），特征：bool MouseDownEventFuncref(int player, int key, Vector3D lp_mouseVector3D, int uiX, int uiY)
    /// </summary>
    /// <param name="player"></param>
    /// <param name="key"></param>
    /// <param name="lp_mouseVector3D"></param>
    /// <param name="uiX"></param>
    /// <param name="uiY"></param>
    /// <returns></returns>
    public delegate bool MouseDownEventFuncref(int player, int key, Vector3D lp_mouseVector3D, int uiX, int uiY);
    /// <summary>
    /// 【MM_函数库】监听服务鼠标左键双击常规函数引用（委托类型），特征：bool MouseLDoubleClickEventFuncref(int player, Vector3D lp_mouseVector3D, int uiX, int uiY)
    /// </summary>
    /// <param name="player"></param>
    /// <param name="lp_mouseVector3D"></param>
    /// <param name="uiX"></param>
    /// <param name="uiY"></param>
    /// <returns></returns>
    public delegate bool MouseLDoubleClickEventFuncref(int player, Vector3D lp_mouseVector3D, int uiX, int uiY);
    /// <summary>
    /// 【MM_函数库】监听服务鼠标右键双击常规函数引用（委托类型），特征：bool MouseRDoubleClickEventFuncref(int player, Vector3D lp_mouseVector3D, int uiX, int uiY)
    /// </summary>
    /// <param name="player"></param>
    /// <param name="lp_mouseVector3D"></param>
    /// <param name="uiX"></param>
    /// <param name="uiY"></param>
    /// <returns></returns>
    public delegate bool MouseRDoubleClickEventFuncref(int player, Vector3D lp_mouseVector3D, int uiX, int uiY);
    /// <summary>
    /// 【MM_函数库】监听服务鼠标弹起常规函数引用（委托类型），特征：bool MouseUpEventFuncref(int player, int key, Vector3D lp_mouseVector3D, int uiX, int uiY)
    /// </summary>
    /// <param name="player"></param>
    /// <param name="key"></param>
    /// <param name="lp_mouseVector3D"></param>
    /// <param name="uiX"></param>
    /// <param name="uiY"></param>
    /// <returns></returns>
    public delegate bool MouseUpEventFuncref(int player, int key, Vector3D lp_mouseVector3D, int uiX, int uiY);

    #endregion

    #endregion

    #region 类

    //自定义类是引用类型

    //静态类数据在内存中唯一（从模板也只产生一个可修改副本），公开的静态类可供其他程序集调用
    //类的访问修饰符只有public和internal，其中internal修饰后只能在自身程序集（dll或exe）使用，类中创建类默认为internal（内部类）
    //前缀加partial（分部类型）用来定义要拆分到多个文件中的类，亦称"部分类"
    //提供给程序集外或用户无限制使用的类及成员（字段、方法）标public，不让外部操作或需隐藏则不标
    //若需额外让派生类（子类）使用则标protected，会限制在基类&派生类（父子类）中，要注意其结合privite（修饰成员）、internal（修饰类）时反而是扩大使用范围
    //静态数据的副本创建后只有在程序结束才会清理



    /// <summary>
    /// 【MM_函数库】核心类
    /// </summary>
    public static class MMCore
    {
        #region 常量

        //键盘按键映射

        public const int c_keyNone = -1;
        public const int c_keyShift = 0;
        public const int c_keyControl = 1;
        public const int c_keyAlt = 2;
        public const int c_key0 = 3;
        public const int c_key1 = 4;
        public const int c_key2 = 5;
        public const int c_key3 = 6;
        public const int c_key4 = 7;
        public const int c_key5 = 8;
        public const int c_key6 = 9;
        public const int c_key7 = 10;
        public const int c_key8 = 11;
        public const int c_key9 = 12;
        public const int c_keyA = 13;
        public const int c_keyB = 14;
        public const int c_keyC = 15;
        public const int c_keyD = 16;
        public const int c_keyE = 17;
        public const int c_keyF = 18;
        public const int c_keyG = 19;
        public const int c_keyH = 20;
        public const int c_keyI = 21;
        public const int c_keyJ = 22;
        public const int c_keyK = 23;
        public const int c_keyL = 24;
        public const int c_keyM = 25;
        public const int c_keyN = 26;
        public const int c_keyO = 27;
        public const int c_keyP = 28;
        public const int c_keyQ = 29;
        public const int c_keyR = 30;
        public const int c_keyS = 31;
        public const int c_keyT = 32;
        public const int c_keyU = 33;
        public const int c_keyV = 34;
        public const int c_keyW = 35;
        public const int c_keyX = 36;
        public const int c_keyY = 37;
        public const int c_keyZ = 38;
        public const int c_keySpace = 39;
        public const int c_keyGrave = 40;
        public const int c_keyNumPad0 = 41;
        public const int c_keyNumPad1 = 42;
        public const int c_keyNumPad2 = 43;
        public const int c_keyNumPad3 = 44;
        public const int c_keyNumPad4 = 45;
        public const int c_keyNumPad5 = 46;
        public const int c_keyNumPad6 = 47;
        public const int c_keyNumPad7 = 48;
        public const int c_keyNumPad8 = 49;
        public const int c_keyNumPad9 = 50;
        public const int c_keyNumPadPlus = 51;
        public const int c_keyNumPadMinus = 52;
        public const int c_keyNumPadMultiply = 53;
        public const int c_keyNumPadDivide = 54;
        public const int c_keyNumPadDecimal = 55;
        public const int c_keyEquals = 56;
        public const int c_keyMinus = 57;
        public const int c_keyBracketOpen = 58;
        public const int c_keyBracketClose = 59;
        public const int c_keyBackSlash = 60;
        public const int c_keySemiColon = 61;
        public const int c_keyApostrophe = 62;
        public const int c_keyComma = 63;
        public const int c_keyPeriod = 64;
        public const int c_keySlash = 65;
        public const int c_keyEscape = 66;
        public const int c_keyEnter = 67;
        public const int c_keyBackSpace = 68;
        public const int c_keyTab = 69;
        public const int c_keyLeft = 70;
        public const int c_keyUp = 71;
        public const int c_keyRight = 72;
        public const int c_keyDown = 73;
        public const int c_keyInsert = 74;
        public const int c_keyDelete = 75;
        public const int c_keyHome = 76;
        public const int c_keyEnd = 77;
        public const int c_keyPageUp = 78;
        public const int c_keyPageDown = 79;
        public const int c_keyCapsLock = 80;
        public const int c_keyNumLock = 81;
        public const int c_keyScrollLock = 82;
        public const int c_keyPause = 83;
        public const int c_keyPrintScreen = 84;
        public const int c_keyNextTrack = 85;
        public const int c_keyPrevTrack = 86;
        public const int c_keyF1 = 87;
        public const int c_keyF2 = 88;
        public const int c_keyF3 = 89;
        public const int c_keyF4 = 90;
        public const int c_keyF5 = 91;
        public const int c_keyF6 = 92;
        public const int c_keyF7 = 93;
        public const int c_keyF8 = 94;
        public const int c_keyF9 = 95;
        public const int c_keyF10 = 96;
        public const int c_keyF11 = 97;
        public const int c_keyF12 = 98;

        //鼠标按键映射

        public const int c_mouseButtonNone = 0;
        public const int c_mouseButtonLeft = 1;
        public const int c_mouseButtonMiddle = 2;
        public const int c_mouseButtonRight = 3;
        public const int c_mouseButtonXButton1 = 4;
        public const int c_mouseButtonXButton2 = 5;

        //其他常量

        //暂无

        //键鼠函数引用上限及单键注册上限

        /// <summary>
        /// 【MM_函数库】键盘按键句柄上限（句柄范围0~98，无按键-1）
        /// </summary>
        public const int c_keyMax = 98;
        /// <summary>
        /// 【MM_函数库】每个键盘按键可注册函数上限
        /// </summary>
        public const int c_regKeyMax = 8;
        /// <summary>
        /// 【MM_函数库】鼠标按键句柄上限（句柄范围1~5，无按键0）
        /// </summary>
        public const int c_mouseMax = 5;
        /// <summary>
        /// 【MM_函数库】每个鼠标按键可注册函数上限
        /// </summary>
        public const int c_regMouseMax = 24;

        //主副循环入口函数引用上限及单入口注册上限

        /// <summary>
        /// 【MM_函数库】主副循环入口句柄上限（句柄范围0~9）
        /// </summary>
        private const int c_entryMax = 9;//内部使用，无需给用户使用
        /// <summary>
        /// 【MM_函数库】每个主副循环入口可注册函数上限
        /// </summary>
        private const int c_regEntryMax = 1;//内部使用，无需给用户使用

        #endregion

        #region "全局和局部变量"（不同作用域下的无属性字段）

        //类只有字段没变量说法，但理论上公有静态字段是该程序在内存中唯一的全局变量，无论类实例化多次或多线程从模板调用，它只生成一次副本直到程序结束才清理
        //而非静态（实例）类每次实例化都复制一份模板去形成多个副本，私有实例字段相当于类的局部变量
        //不标Static则类及其成员在结束时垃圾回收，标Static则副本唯一且程序结束才从内存消失
        //静态局部变量在函数结束时不参与垃圾回收，以便相同函数重复访问
        //静态数据是从模板形成的内存中唯一的可修改副本（不同类同名也不一样，要考虑命名空间和类名路径，无需担心重复）
        //数组元素数量上限均+1是习惯问题，防止某些循环以数组判断时最后退出还+1导致超限

        /// <summary>
        /// 【MM_函数库】键盘按键已注册数量（每个数组元素算1个，即使它们+=多个委托函数）
        /// </summary>
        private static int[] keyEventFuncrefGroupNum = new int[c_keyMax + 1];//内部使用

        /// <summary>
        /// 【MM_函数库】鼠标按键的已注册数量（每个数组元素算1个，即使它们+=多个委托函数）
        /// </summary>
        private static int[] mouseEventFuncrefGroupNum = new int[c_mouseMax + 1];//内部使用

        private static bool[] _stopKeyMouseEvent = new bool[Game.c_maxPlayers + 1];
        /// <summary>
        /// 【MM_函数库】用户按键事件禁用状态（用于过场、剧情对话、特殊技能如禁锢时强制停用用户的按键事件）
        /// </summary>
        public static bool[] StopKeyMouseEvent { get => _stopKeyMouseEvent; set => _stopKeyMouseEvent = value; }

        /// <summary>
        /// 【MM_函数库】主副循环每个入口的已注册数量（每个数组元素算1个，即使它们+=多个委托函数）
        /// </summary>
        private static int[] entryEventFuncrefGroupNum = new int[c_entryMax + 1];//内部使用

        private static bool[] _stopEntryEvent = new bool[Game.c_maxPlayers + 1];
        /// <summary>
        /// 【MM_函数库】主副循环事件禁用状态（用于特殊情况如个人处理队列过多、玩家间未同步时间过长情况下停用用户主副循环事件）
        /// </summary>
        public static bool[] StopEntryEvent { get => _stopEntryEvent; set => _stopEntryEvent = value; }

        #region 字典

        #region 值类型

        /// <summary>
        /// 【MM_函数库】全局字典<string,int> （不排泄，直到程序结束）
        /// </summary>
        private static Dictionary<string, int> systemDictionaryInt = new Dictionary<string, int>();//内部使用
        /// <summary>
        /// 【MM_函数库】临时字典<string,int> （函数或动作集结束时应手动排泄）
        /// </summary>
        private static Dictionary<string, int> tempDictionaryInt = new Dictionary<string, int>();//内部使用

        /// <summary>
        /// 【MM_函数库】全局字典<string,long> （不排泄，直到程序结束）
        /// </summary>
        private static Dictionary<string, long> systemDictionaryLong = new Dictionary<string, long>();//内部使用
        /// <summary>
        /// 【MM_函数库】临时字典<string,long> （函数或动作集结束时应手动排泄）
        /// </summary>
        private static Dictionary<string, long> tempDictionaryLong = new Dictionary<string, long>();//内部使用

        /// <summary>
        /// 【MM_函数库】全局字典<string,char> （不排泄，直到程序结束）
        /// </summary>
        private static Dictionary<string, char> systemDictionaryChar = new Dictionary<string, char>();//内部使用
        /// <summary>
        /// 【MM_函数库】临时字典<string,char> （函数或动作集结束时应手动排泄）
        /// </summary>
        private static Dictionary<string, char> tempDictionaryChar = new Dictionary<string, char>();//内部使用

        /// <summary>
        /// 【MM_函数库】全局字典<string,float> （不排泄，直到程序结束）
        /// </summary>
        private static Dictionary<string, float> systemDictionaryFloat = new Dictionary<string, float>();//内部使用
        /// <summary>
        /// 【MM_函数库】临时字典<string,float> （函数或动作集结束时应手动排泄）
        /// </summary>
        private static Dictionary<string, float> tempDictionaryFloat = new Dictionary<string, float>();//内部使用

        /// <summary>
        /// 【MM_函数库】全局字典<string,double> （不排泄，直到程序结束）
        /// </summary>
        private static Dictionary<string, double> systemDictionaryDouble = new Dictionary<string, double>();//内部使用
        /// <summary>
        /// 【MM_函数库】临时字典<string,double> （函数或动作集结束时应手动排泄）
        /// </summary>
        private static Dictionary<string, double> tempDictionaryDouble = new Dictionary<string, double>();//内部使用

        /// <summary>
        /// 【MM_函数库】全局字典<string,bool> （不排泄，直到程序结束）
        /// </summary>
        private static Dictionary<string, bool> systemDictionaryBool = new Dictionary<string, bool>();//内部使用
        /// <summary>
        /// 【MM_函数库】临时字典<string,bool> （函数或动作集结束时应手动排泄）
        /// </summary>
        private static Dictionary<string, bool> tempDictionaryBool = new Dictionary<string, bool>();//内部使用

        /// <summary>
        /// 【MM_函数库】全局字典<string,byte> （不排泄，直到程序结束）
        /// </summary>
        private static Dictionary<string, byte> systemDictionaryByte = new Dictionary<string, byte>();//内部使用
        /// <summary>
        /// 【MM_函数库】临时字典<string,byte> （函数或动作集结束时应手动排泄）
        /// </summary>
        private static Dictionary<string, byte> tempDictionaryByte = new Dictionary<string, byte>();//内部使用

        #endregion

        #region 引用类型

        /// <summary>
        /// 【MM_函数库】全局字典<string,Object> （不排泄，直到程序结束）
        /// </summary>
        private static Dictionary<string, object> systemDictionaryObject = new Dictionary<string, object>();//内部使用
        /// <summary>
        /// 【MM_函数库】临时字典<string,Object> （函数或动作集结束时应手动排泄）
        /// </summary>
        private static Dictionary<string, object> tempDictionaryObject = new Dictionary<string, object>();//内部使用

        /// <summary>
        /// 【MM_函数库】全局字典<string,Vector> （不排泄，直到程序结束）
        /// </summary>
        private static Dictionary<string, Vector> systemDictionaryVector = new Dictionary<string, Vector>();//内部使用
        /// <summary>
        /// 【MM_函数库】临时字典<string,Vector> （函数或动作集结束时应手动排泄）
        /// </summary>
        private static Dictionary<string, Vector> tempDictionaryVector = new Dictionary<string, Vector>();//内部使用

        /// <summary>
        /// 【MM_函数库】全局字典<string,Timer> （不排泄，直到程序结束）
        /// </summary>
        private static Dictionary<string, Timer> systemDictionaryTimer = new Dictionary<string, Timer>();//内部使用
        /// <summary>
        /// 【MM_函数库】临时字典<string,Timer> （函数或动作集结束时应手动排泄）
        /// </summary>
        private static Dictionary<string, Timer> tempDictionaryTimer = new Dictionary<string, Timer>();//内部使用

        /// <summary>
        /// 【MM_函数库】全局字典<string,string> （不排泄，直到程序结束）
        /// </summary>
        private static Dictionary<string, string> systemDictionaryString = new Dictionary<string, string>();//内部使用
        /// <summary>
        /// 【MM_函数库】临时字典<string,string> （函数或动作集结束时应手动排泄）
        /// </summary>
        private static Dictionary<string, string> tempDictionaryString = new Dictionary<string, string>();//内部使用

        #endregion

        #endregion

        /// <summary>
        /// 【MM_函数库】全局哈希表（不排泄，直到程序结束）
        /// </summary>
        private static Hashtable systemHashTable = new Hashtable();//内部使用
        /// <summary>
        /// 【MM_函数库】临时哈希表（函数或动作集结束时应手动排泄）
        /// </summary>
        private static Hashtable tempHashTable = new Hashtable();//内部使用

        //声明用于存放键盘、鼠标"按键事件引用类型"委托变量的二维数组集合（单元素也是集合能+=多个委托函数），C#自带委托列表类型能继续存储这些委托类型变量

        /// <summary>
        /// 【MM_函数库】键盘按键事件引用委托类型变量数组[c_keyMax + 1, c_regKeyMax + 1]，用于自定义委托函数注册
        /// </summary>
        private static KeyMouseEventFuncref[,] keyEventFuncrefGroup = new KeyMouseEventFuncref[c_keyMax + 1, c_regKeyMax + 1];//内部使用
        /// <summary>
        /// 【MM_函数库】鼠标按键事件引用委托类型变量数组[c_mouseMax + 1, c_regMouseMax + 1]，用于自定义委托函数注册
        /// </summary>
        private static KeyMouseEventFuncref[,] mouseEventFuncrefGroup = new KeyMouseEventFuncref[c_mouseMax + 1, c_regMouseMax + 1];//内部使用

        //声明用于存放"主副循环入口事件引用类型"委托变量二维数组集合

        /// <summary>
        /// 【MM_函数库】主副循环入口事件引用委托类型变量数组[c_entryMax + 1, c_regEntryMax + 1]，用于自定义委托函数注册
        /// </summary>
        private static EntryEventFuncref[,] entryEventFuncrefGroup = new EntryEventFuncref[c_entryMax + 1, c_regEntryMax + 1];//内部使用

        #endregion

        #region 构造函数

        /// <summary>
        /// 【MM_函数库】核心类
        /// </summary>
        static MMCore()
        {
            //这里可给字段进行第二次赋值或安排其他动作（字段的首次赋值是在声明时，同一次初始化执行顺序受动作所在上下文影响）
        }

        #endregion

        #region 字段及其属性方法

        //字段及其属性方法（避免不安全读写，private保护和隐藏字段，设计成只允许通过public修饰的属性方法间接去安全读写）

        public static string _dataTableType;
        /// <summary>
        /// 【MM_函数库】数据表类型，填入"HashTable"时切换为哈希表，其他情况默认采用字典
        /// </summary>
        public static string DataTableType
        {
            get => _dataTableType;
            set
            {
                switch (value)
                {
                    case "HashTable":
                        _dataTableType = value;
                        break;
                    default:
                        _dataTableType = "Dictionary";
                        break;
                }
            }
        }

        private static int _localID;
        /// <summary>
        /// 【MM_函数库】本地主机编号
        /// </summary>
        public static int LocalID { get => _localID; set => _localID = value; }

        private static int _directoryEmptyUserDefIndex = 0;
        /// <summary>
        /// 【MM_函数库】用户定义的空文件夹形式，以供内部判断：0是子文件（夹）数量为0，1是文件夹大小为0，2是前两者必须都符合，如果用户输入错误，本属性方法将纠正为默认值0
        /// </summary>
        public static int DirectoryEmptyUserDefIndex
        {
            get => _directoryEmptyUserDefIndex;
            //如果用户输入错误，纠正为默认值0
            set
            {
                if (value >= 0 && value <= 2)
                {
                    _directoryEmptyUserDefIndex = value;
                }
                else
                {
                    _directoryEmptyUserDefIndex = 0;
                }
            }
        }

        #endregion

        #region Functions 数学公式

        /// <summary>
        /// 【MM_函数库】随机角度
        /// </summary>
        /// <param name="min"></param>
        /// <param name="max"></param>
        /// <returns>返回[0,360)之间的随机角度</returns>
        public static double RandomAngle()
        {
            Random r = new Random(Guid.NewGuid().GetHashCode());
            return 360 * r.NextDouble();
        }

        /// <summary>
        /// 【MM_函数库】随机实数（不含最大值）
        /// </summary>
        /// <param name="min"></param>
        /// <param name="max"></param>
        /// <returns>返回[min,max)之间的随机实数</returns>
        public static double RandomDouble(double min, double max)
        {
            Random r = new Random(Guid.NewGuid().GetHashCode());
            if (min <= max)
            {
                return min + (max - min) * r.NextDouble();
            }
            else
            {
                return max + (min - max) * r.NextDouble();
            }
        }

        /// <summary>
        /// 【MM_函数库】随机整数（不含最大值）
        /// </summary>
        /// <param name="min"></param>
        /// <param name="max"></param>
        /// <returns>返回[min,max)之间的随机整数</returns>
        public static int RandomInt(int min, int max)
        {
            Random r = new Random(Guid.NewGuid().GetHashCode());
            if (min <= max)
            {
                return r.Next(min, max);
            }
            else
            {
                return r.Next(max, min);
            }
        }

        /// <summary>
        /// 【MM_函数库】将Vector3D转Vector（去掉Z轴）
        /// </summary>
        /// <param name="vector"></param>
        /// <returns></returns>
        public static Vector ToVector(Vector3D vector)
        {
            return new Vector(vector.X, vector.Y);
        }

        /// <summary>
        ///  【MM_函数库】以实数返回二维坐标（x,y）与（a,b）形成的角度（单位：度）
        /// </summary>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static double AngleBetween(double x, double y, double a, double b)
        {
            return Vector.AngleBetween(new Vector(x, y), new Vector(a, b));
        }

        /// <summary>
        /// 【MM_函数库】以实数返回三维坐标（x,y,z）与（a,b,c）形成的角度（单位：度）
        /// </summary>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <param name="z"></param>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <param name="c"></param>
        /// <returns></returns>
        public static double AngleBetween(double x, double y, double z, double a, double b, double c)
        {
            return Vector3D.AngleBetween(new Vector3D(x, y, z), new Vector3D(a, b, z));
        }

        /// <summary>
        /// 【MM_函数库】以实数返回二维点1点2形成的角度（单位：度）
        /// Returns the angle from point 1 to point 2 as a real value, in degrees
        /// </summary>
        /// <param name="point1">二维点</param>
        /// <param name="point2">二维点</param>
        /// <returns></returns>
        public static double AngleBetween(Point point1, Point point2)
        {
            //double X1 = point1.X, Y1 = point1.Y, X2 = point2.Y, Y2 = point2.Y;
            //double angleOfLine = Math.Atan2((Y2 - Y1), (X2 - X2)) * 180 / Math.PI;

            return Vector.AngleBetween(new Vector(point1.X, point1.Y), new Vector(point2.X, point2.Y));
        }

        /// <summary>
        /// 【MM_函数库】以实数返回三维点1点2形成的角度（单位：度）
        /// </summary>
        /// <param name="point1">三维点</param>
        /// <param name="point2">三维点</param>
        /// <returns></returns>
        public static double AngleBetween(Point3D point1, Point3D point2)
        {
            return Vector3D.AngleBetween(new Vector3D(point1.X, point1.Y, point1.Z), new Vector3D(point2.X, point2.Y, point2.Z));
        }

        /// <summary>
        /// 【MM_函数库】以实数返回二维向量之间形成的角度（单位：度）
        /// </summary>
        /// <param name="vector1"></param>
        /// <param name="vector2"></param>
        /// <returns></returns>
        public static double AngleBetween(Vector vector1, Vector vector2)
        {
            return Vector.AngleBetween(vector1, vector2);
        }

        /// <summary>
        /// 【MM_函数库】以实数返回三维向量之间形成的角度（单位：度）
        /// </summary>
        /// <param name="vector1"></param>
        /// <param name="vector2"></param>
        /// <returns></returns>
        public static double AngleBetween(Vector3D vector1, Vector3D vector2)
        {
            return Vector3D.AngleBetween(vector1, vector2);
        }

        /// <summary>
        /// 【MM_函数库】以实数返回二维坐标（x,y）与（a,b）形成的距离（单位：m）
        /// </summary>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static double Distance(double x, double y, double a, double b)
        {
            double x1 = x;
            double y1 = y;

            double x2 = a;
            double y2 = b;

            double result = Math.Sqrt(Math.Pow((x1 - x2), 2) + Math.Pow((y1 - y2), 2));
            return result;
        }

        /// <summary>
        /// 【MM_函数库】以实数返回二维点之间形成的距离（单位：m）
        /// </summary>
        /// <param name="point1"></param>
        /// <param name="point2"></param>
        /// <returns></returns>
        public static double Distance(Point point1, Point point2)
        {
            double x1 = point1.X;
            double y1 = point1.Y;

            double x2 = point2.X;
            double y2 = point2.Y;

            double result = Math.Sqrt(Math.Pow((x1 - x2), 2) + Math.Pow((y1 - y2), 2));
            return result;
        }

        /// <summary>
        /// 【MM_函数库】以实数返回二维向量之间形成的距离（单位：m）
        /// </summary>
        /// <param name="vector1"></param>
        /// <param name="vector2"></param>
        /// <returns></returns>
        public static double Distance(Vector vector1, Vector vector2)
        {
            double x1 = vector1.X;
            double y1 = vector1.Y;

            double x2 = vector2.X;
            double y2 = vector2.Y;

            double result = Math.Sqrt(Math.Pow((x1 - x2), 2) + Math.Pow((y1 - y2), 2));
            return result;
        }

        /// <summary>
        /// 【MM_函数库】以实数返回三维坐标（x,y,z）与（a,b,c）形成的距离（单位：度）
        /// </summary>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <param name="z"></param>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <param name="c"></param>
        /// <returns></returns>
        public static double Distance(double x, double y, double z, double a, double b, double c)
        {
            double x1 = x;
            double y1 = y;
            double z1 = z;

            double x2 = a;
            double y2 = b;
            double z2 = c;

            double result = Math.Sqrt(Math.Pow((x1 - x2), 2) + Math.Pow((y1 - y2), 2) + Math.Pow((z1 - z2), 2));
            return result;
        }

        /// <summary>
        /// 【MM_函数库】以实数返回三维点之间形成的距离（单位：m）
        /// </summary>
        /// <param name="point1"></param>
        /// <param name="point2"></param>
        /// <returns></returns>
        public static double Distance(Point3D point1, Point3D point2)
        {
            double x1 = point1.X;
            double y1 = point1.Y;
            double z1 = point1.Z;

            double x2 = point2.X;
            double y2 = point2.Y;
            double z2 = point2.Z;

            double result = Math.Sqrt(Math.Pow((x1 - x2), 2) + Math.Pow((y1 - y2), 2) + Math.Pow((z1 - z2), 2));
            return result;
        }

        /// <summary>
        /// 【MM_函数库】以实数返回三维向量之间形成的距离（单位：m）
        /// </summary>
        /// <param name="vector1"></param>
        /// <param name="vector2"></param>
        /// <returns></returns>
        public static double Distance(Vector3D vector1, Vector3D vector2)
        {
            double x1 = vector1.X;
            double y1 = vector1.Y;
            double z1 = vector1.Z;

            double x2 = vector2.X;
            double y2 = vector2.Y;
            double z2 = vector2.Z;

            double result = Math.Sqrt(Math.Pow((x1 - x2), 2) + Math.Pow((y1 - y2), 2) + Math.Pow((z1 - z2), 2));
            return result;
        }

        #endregion

        #region Functions 通用功能

        /// <summary>
        /// 将字符串转换为字节数组，再转成2位16进制字符串格式或转成10进制数字再转为3位8进制字符串格式，以供在Galaxy代码中混肴使用
        /// Galaxy代码会自动转转义8和16位格式字符串（\0及\x）为ASCII值（数字）,再转为控制字符使用
        /// </summary>
        /// <param name="input"></param>
        /// <param name="r">向16进制转换的概率，否则向8进制转换</param>
        /// <returns></returns>
        public static string ConvertStringToHOMixed(string input, double r)
        {
            string result = "";
            // 创建一个Random对象
            Random random = new Random(Guid.NewGuid().GetHashCode());
            foreach (byte b in Encoding.UTF8.GetBytes(input))
            {
                // 根据随机数和触发概率决定是否执行动作
                if (random.NextDouble() < r)
                {
                    result += $"\\x{b:X2}";
                }
                else
                {
                    result += $"\\0{Convert.ToString(b, 8)}";
                }
            }
            return result;
        }

        /// <summary>
        /// 将字符串转换为字节数组，再转成10进制数字，再转为3位8进制字符串格式，以供在Galaxy代码中混肴使用
        /// Galaxy代码会自动转转义8和16位格式字符串（\0及\x）为ASCII值（数字）,再转为控制字符使用
        /// 如八进制"\0124"、"\0114"表示十进制的84和76，Galaxy脚本中识别为"T"和"L"
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        public static string ConvertStringToOctal(string input)
        {
            string result = "";
            foreach (byte b in Encoding.UTF8.GetBytes(input))
            {
                result += $"\\0{Convert.ToString(b, 8)}";
            }
            return result;
        }

        /// <summary>
        /// 将字符串转换为字节数组，再转成2位16进制字符串格式，以供在Galaxy代码中混肴使用
        /// Galaxy代码会自动转转义8和16位格式字符串（\0及\x）为ASCII值（数字）,再转为控制字符使用
        /// 如十六进制"\x4C"表示十进制的84，Galaxy脚本中识别为"T"
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        public static string ConvertStringToHex(string input) 
        {
            string result = "";
            foreach (byte b in Encoding.UTF8.GetBytes(input))
            {
                result += $"\\x{b:X2}";
            }
            return result;
        }

        /// <summary>
        /// 去掉代码里的注释
        /// </summary>
        /// <param name="code"></param>
        /// <returns></returns>
        public static string RemoveComments(string code)
        {
            string pattern = @"//.*?$|/\*.*?\*/";
            //使用 RegexOptions.Multiline 选项来指定模式应在多个行上进行匹配，并使用 RegexOptions.Singleline 选项来指定模式应在单个连续字符串上进行匹配
            RegexOptions options = RegexOptions.Multiline | RegexOptions.Singleline;
            string result = Regex.Replace(code, pattern, string.Empty, options);
            return result;
        }

        /// <summary>
        /// 去掉代码里的空行
        /// </summary>
        /// <param name="code"></param>
        /// <returns></returns>
        public static string RemoveEmptyLines(string code)
        {
            string pattern = @"^\s*$";
            RegexOptions options = RegexOptions.Multiline;
            string result = Regex.Replace(code, pattern, string.Empty, options);
            return result;
        }

        #region 判断文件是否被占用

        [DllImport("kernel32.dll")]
        public static extern IntPtr _lopen(string lpPathName, int iReadWrite);

        [DllImport("kernel32.dll")]
        public static extern bool CloseHandle(IntPtr hObject);

        public const int OF_READWRITE = 2;
        public const int OF_SHARE_DENY_NONE = 0x40;
        public static readonly IntPtr HFILE_ERROR = new IntPtr(-1);

        /// <summary>
        /// 【MM_函数库】文件是否被占用（WIN32 API调用）
        /// </summary>
        /// <param name="fileFullNmae"></param>
        /// <returns></returns>
        public static bool IsOccupied(string fileFullNmae)
        {
            if (!File.Exists(fileFullNmae)) return false;
            IntPtr vHandle = _lopen(fileFullNmae, OF_READWRITE | OF_SHARE_DENY_NONE);
            var flag = vHandle == HFILE_ERROR;
            CloseHandle(vHandle);
            return flag;
        }

        /// <summary>
        /// 【MM_函数库】文件是否被占用（文件流判断法）
        /// </summary>
        /// <param name="fileName"></param>
        /// <returns>true表示正在使用,false没有使用 </returns>
        public static bool IsFileInUse(string fileName)
        {
            bool inUse = true;
            FileStream fs = null;
            try
            {
                fs = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.None);
                inUse = false;
            }
            catch { }
            finally
            {
                if (fs != null) fs.Dispose();
            }
            return inUse;
        }

        #endregion

        /// <summary>
        /// 【MM_函数库】递归方式强制删除文件夹（进最里层删除文件使文件夹为空后删除这个空文件夹，层层递出时重复动作），删除前会去掉文件（夹）的Archive、ReadOnly、Hidden属性以确保删除
        /// </summary>
        /// <param name="dirInfo"></param>
        public static void DelDirectoryRecursively(DirectoryInfo dirInfo)
        {
            foreach (DirectoryInfo newInfo in dirInfo.GetDirectories())
            {
                DelDirectoryRecursively(newInfo);//递归遍历子文件夹
            }
            foreach (FileInfo newInfo in dirInfo.GetFiles())
            {
                //处理每个文件夹内部的文件（从里层开始删除）
                newInfo.Attributes &= ~(FileAttributes.Archive | FileAttributes.ReadOnly | FileAttributes.Hidden);
                newInfo.Delete();
            }
            //对每个文件夹处理（从里层开始删除）
            dirInfo.Attributes &= ~(FileAttributes.Archive | FileAttributes.ReadOnly | FileAttributes.Hidden);
            dirInfo.Delete(true);
        }

        /// <summary>
        /// 【MM_函数库】递归方式强制删除文件夹（进最里层删除文件使文件夹为空后删除这个空文件夹，层层递出时重复动作），删除前会去掉文件（夹）的Archive、ReadOnly、Hidden属性以确保删除
        /// </summary>
        /// <param name="dirPath"></param>
        public static void DelDirectoryRecursively(string dirPath)
        {
            DirectoryInfo dirInfo = new DirectoryInfo(dirPath);
            foreach (DirectoryInfo newInfo in dirInfo.GetDirectories())
            {
                DelDirectoryRecursively(newInfo);
            }
            foreach (FileInfo newInfo in dirInfo.GetFiles())
            {
                newInfo.Attributes &= ~(FileAttributes.Archive | FileAttributes.ReadOnly | FileAttributes.Hidden);
                newInfo.Delete();
            }
            dirInfo.Attributes &= ~(FileAttributes.Archive | FileAttributes.ReadOnly | FileAttributes.Hidden);
            dirInfo.Delete(true);

        }

        /// <summary>
        /// 【MM_函数库】删除文件夹
        /// </summary>
        /// <param name="dirInfo"></param>
        /// <returns>删除成功返回真，否则返回假</returns>
        public static bool DelDirectory(DirectoryInfo dirInfo)
        {
            bool torf = false;
            if (dirInfo.Exists)
            {
                dirInfo.Delete(true);
                if (!dirInfo.Exists) { torf = true; }
            }
            return torf;
        }

        /// <summary>
        /// 【MM_函数库】删除文件夹
        /// </summary>
        /// <param name="dirPath"></param>
        /// <returns>删除返回真，否则返回假</returns>
        public static bool DelDirectory(string dirPath)
        {
            bool torf = false;
            if (Directory.Exists(dirPath))
            {
                DirectoryInfo dirInfo = new DirectoryInfo(dirPath);
                dirInfo.Delete(true);
                if (!dirInfo.Exists) { torf = true; }
            }
            return torf;
        }

        /// <summary>
        /// 【MM_函数库】删除文件到回收站功能专用属性，已添加Shell API特性[DllImport("shell32.dll", CharSet = CharSet.Unicode)]
        /// </summary>
        /// <param name="lpFileOp"></param>
        /// <returns></returns>
        [DllImport("shell32.dll", CharSet = CharSet.Unicode)]
        public static extern int SHFileOperation(ref SHFILEOPSTRUCT lpFileOp);

        /// <summary>
        /// 【MM_函数库】删除文件到回收站功能专用结构体，已添加特性[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        public struct SHFILEOPSTRUCT
        {
            public IntPtr hwnd;
            public uint wFunc;
            public string pFrom;
            public string pTo;
            public ushort fFlags;
            public bool fAnyOperationsAborted;
            public IntPtr hNameMappings;
            public string lpszProgressTitle;
        }

        /// <summary>
        /// 【MM_函数库】删除文件到回收站功能专用枚举，已添加特性[Flags]
        /// </summary>
        [Flags]
        public enum SHFileOperationFlags : ushort
        {
            /// <summary>
            /// 不出现错误确认或询问用户的对话框
            /// </summary>
            FOF_SILENT = 0x0004,
            /// <summary>
            /// 不出现任何对话框
            /// </summary>
            FOF_NOCONFIRMATION = 0x0010,
            /// <summary>
            /// 文件删除后可以放到回收站
            /// </summary>
            FOF_ALLOWUNDO = 0x0040,
            /// <summary>
            /// 不出现错误对话框
            /// </summary>
            FOF_NOERRORUI = 0x0400,
        }

        /// <summary>
        /// 【MM_函数库】删除文件到回收站
        /// </summary>
        /// <param name="filePath"></param>
        /// <param name="torf"></param>
        public static void DelFileToRecycleBin(string filePath, bool torf)
        {
            if (!File.Exists(filePath))
            {
                return;
            }
            SHFILEOPSTRUCT fileop = new SHFILEOPSTRUCT
            {
                wFunc = 0x003,//删除文件到回收站
                pFrom = filePath + '\0'//多个文件以 \0 分隔
            };
            if (!torf)
            {
                //不确认直接删除（通过或运算符集成准许撤销+不出现任何对话框）
                fileop.fFlags = (ushort)(SHFileOperationFlags.FOF_ALLOWUNDO | SHFileOperationFlags.FOF_NOCONFIRMATION);
            }
            else
            {
                //需要用户确认删除，文件操作属性清空
                fileop.fFlags = 0;
            }
            SHFileOperation(ref fileop);
        }

        /// <summary>
        /// 【MM_函数库】删除文件夹到回收站
        /// </summary>
        /// <param name="dirPath"></param>
        /// <param name="torf">回收站删除提示</param>
        public static void DelDirectoryToRecycleBin(string dirPath, bool torf)
        {
            if (!Directory.Exists(dirPath))
            {
                return;
            }
            SHFILEOPSTRUCT fileop = new SHFILEOPSTRUCT
            {
                wFunc = 0x003,//删除文件到回收站
                pFrom = dirPath + '\0'//多个文件以 \0 分隔
            };
            if (!torf)
            {
                //不确认直接删除（通过或运算符集成准许撤销+不出现任何对话框）
                fileop.fFlags = (ushort)(SHFileOperationFlags.FOF_ALLOWUNDO | SHFileOperationFlags.FOF_NOCONFIRMATION);
            }
            else
            {
                //需要用户确认删除，文件操作属性清空
                fileop.fFlags = 0;
            }
            SHFileOperation(ref fileop);
        }

        /// <summary>
        /// 【MM_函数库】将字节大小转字符串Byte、KB、MB、GB、TB、PB、EB、ZB、YB、NB形式
        /// </summary>
        /// <param name="Size">字节大小</param>
        /// <param name="Byte">true=强制输出字节单位</param>
        /// <returns></returns>
        public static string CountSize(long Size, bool Byte)
        {
            string strSize = "";
            if (Byte)
            {
                strSize = StrAddSymbol(Size.ToString(), 3, ",") + " Byte";
            }
            else
            {
                if (Size < 1024.00)
                    strSize = Size.ToString() + " Byte";
                else if (Size >= 1024.00 && Size < Math.Pow(1024, 2))
                    strSize = (Size / 1024.00).ToString("F2") + " KB";
                else if (Size >= Math.Pow(1024, 2) && Size < Math.Pow(1024, 3))
                    strSize = (Size / Math.Pow(1024, 2)).ToString("F2") + " MB";
                else if (Size >= Math.Pow(1024, 3) && Size < Math.Pow(1024, 4))
                    strSize = (Size / Math.Pow(1024, 3)).ToString("F2") + " GB";
                else if (Size >= Math.Pow(1024, 4) && Size < Math.Pow(1024, 5))
                    strSize = (Size / Math.Pow(1024, 4)).ToString("F2") + " TB";
                else if (Size >= Math.Pow(1024, 5) && Size < Math.Pow(1024, 6))
                    strSize = (Size / Math.Pow(1024, 5)).ToString("F2") + " PB";
                else if (Size >= Math.Pow(1024, 6) && Size < Math.Pow(1024, 7))
                    strSize = (Size / Math.Pow(1024, 6)).ToString("F2") + " EB";
                else if (Size >= Math.Pow(1024, 7) && Size < Math.Pow(1024, 8))
                    strSize = (Size / Math.Pow(1024, 7)).ToString("F2") + " ZB";
                else if (Size >= Math.Pow(1024, 8) && Size < Math.Pow(1024, 9))
                    strSize = (Size / Math.Pow(1024, 8)).ToString("F2") + " YB";
                else if (Size >= Math.Pow(1024, 9) && Size < Math.Pow(1024, 10))
                    strSize = (Size / Math.Pow(1024, 9)).ToString("F2") + " NB";
                else if (Size >= Math.Pow(1024, 10))
                    strSize = (Size / Math.Pow(1024, 10)).ToString("F2") + " DB";
            }
            return strSize;
        }

        /// <summary>
        /// 【MM_函数库】将字节大小转字符串Byte、KB、MB、GB、TB、PB、EB、ZB、YB、NB形式
        /// </summary>
        /// <param name="Size">字节大小</param>
        /// <param name="Byte">true=强制输出字节单位</param>
        /// <returns></returns>
        public static string CountSize(double Size, bool Byte)
        {
            string strSize = "";
            if (Byte)
            {
                strSize = StrAddSymbol(Size.ToString(), 3, ",") + " Byte";
            }
            else
            {
                if (Size < 1024.00)
                    strSize = Size.ToString() + " Byte";
                else if (Size >= 1024.00 && Size < Math.Pow(1024, 2))
                    strSize = (Size / 1024.00).ToString("F2") + " KB";
                else if (Size >= Math.Pow(1024, 2) && Size < Math.Pow(1024, 3))
                    strSize = (Size / Math.Pow(1024, 2)).ToString("F2") + " MB";
                else if (Size >= Math.Pow(1024, 3) && Size < Math.Pow(1024, 4))
                    strSize = (Size / Math.Pow(1024, 3)).ToString("F2") + " GB";
                else if (Size >= Math.Pow(1024, 4) && Size < Math.Pow(1024, 5))
                    strSize = (Size / Math.Pow(1024, 4)).ToString("F2") + " TB";
                else if (Size >= Math.Pow(1024, 5) && Size < Math.Pow(1024, 6))
                    strSize = (Size / Math.Pow(1024, 5)).ToString("F2") + " PB";
                else if (Size >= Math.Pow(1024, 6) && Size < Math.Pow(1024, 7))
                    strSize = (Size / Math.Pow(1024, 6)).ToString("F2") + " EB";
                else if (Size >= Math.Pow(1024, 7) && Size < Math.Pow(1024, 8))
                    strSize = (Size / Math.Pow(1024, 7)).ToString("F2") + " ZB";
                else if (Size >= Math.Pow(1024, 8) && Size < Math.Pow(1024, 9))
                    strSize = (Size / Math.Pow(1024, 8)).ToString("F2") + " YB";
                else if (Size >= Math.Pow(1024, 9) && Size < Math.Pow(1024, 10))
                    strSize = (Size / Math.Pow(1024, 9)).ToString("F2") + " NB";
                else if (Size >= Math.Pow(1024, 10))
                    strSize = (Size / Math.Pow(1024, 10)).ToString("F2") + " DB";
            }
            return strSize;
        }

        /// <summary>
        /// 【MM_函数库】为字符串str每隔every位添加symbol
        /// </summary>
        /// <param name="str"></param>
        /// <param name="every"></param>
        /// <param name="symbol"></param>
        /// <returns></returns>
        public static string StrAddSymbol(string str, int every, string symbol)
        {
            string n = "";
            for (int i = str.Length - 1, j = 1; i >= 0; i--)
            {
                n = str[i].ToString() + n;
                if (j > 0 && i > 0 && (j % every == 0))
                {
                    n = symbol + n;
                    j = 0;
                }
                j++;
            }
            return n;
        }

        /// <summary>
        /// 【MM_函数库】获取文件大小
        /// </summary>
        /// <param name="fileInfo"></param>
        /// <returns></returns>
        public static long GetFileLength(FileInfo fileInfo)
        {
            long len = 0;
            if (fileInfo.Exists)
            {
                len = fileInfo.Length;
            }
            return len;
        }

        /// <summary>
        /// 【MM_函数库】获取文件大小
        /// </summary>
        /// <param name="filePath">文件名完整路径</param>
        /// <returns></returns>
        public static long GetFileLength(string filePath)
        {
            long len = 0;
            if (File.Exists(filePath))
            {
                len = new FileInfo(filePath).Length;
            }
            return len;
        }

        /// <summary>
        /// 【MM_函数库】递归方法获取文件夹大小
        /// </summary>
        /// <param name="dirPath">文件夹完整路径</param>
        /// <returns></returns>
        public static long GetDirectoryLength(string dirPath)
        {
            //判断给定的路径是否存在,如果不存在则退出
            if (!Directory.Exists(dirPath))
            {
                return 0;
            }
            long len = 0;
            //定义一个DirectoryInfo对象
            DirectoryInfo di = new DirectoryInfo(dirPath);
            //通过GetFiles方法,获取di目录中的所有文件的大小，量越大越慢
            foreach (FileInfo fi in di.GetFiles())
            {
                len += fi.Length;
            }
            //获取di中所有的文件夹,并存到一个新的对象数组中,以进行递归
            DirectoryInfo[] dis = di.GetDirectories();
            if (dis.Length > 0)
            {
                for (int i = 0; i < dis.Length; i++)
                {
                    len += GetDirectoryLength(dis[i].FullName);
                }
            }
            return len;
        }

        /// <summary>
        /// 【MM_函数库】取得设备硬盘的卷序列号
        /// </summary>
        /// <param name="diskSymbol">盘符</param>
        /// <returns>成功返回卷序列号，失败返回"uHnIk"</returns>
        public static string GetHardDiskID(string diskSymbol)
        {
            try
            {
                string hdInfo = "";
                ManagementObject disk = new ManagementObject(
                    "win32_logicaldisk.deviceid=\"" + diskSymbol + ":\""
                );
                hdInfo = disk.Properties["VolumeSerialNumber"].Value.ToString();
                disk = null;
                return hdInfo.Trim();
            }
            catch
            {
                return "uHnIk";
            }
        }

        /// <summary>
        /// 【MM_函数库】验证字符串是否为整数
        /// </summary>
        /// <param name="str"></param>
        /// <returns></returns>
        public static bool IsNumeric(string str)
        {
            Regex reg1 = new Regex(@"^[0-9]\d*$");
            return reg1.IsMatch(str);
        }

        /// <summary>
        /// 【MM_函数库】验证字符串是否为合法文件（夹）名称，可以是虚拟路径（本函数不验证其真实存在）
        /// </summary>
        /// <param name="path">文件（夹）路径全名</param>
        /// <returns></returns>
        public static bool IsDFPath(string path)
        {
            //发现带中文符号会识别不出，为中文符号继续追加（）【】：
            Regex regex = new Regex(
                @"^([a-zA-Z]:\\)([-\u4e00-\u9fa5\w\s.（）【】：~!@#$%^&()\[\]{}+=]+\\?)*$"
            );
            Match result = regex.Match(path);
            return result.Success;
        }

        /// <summary>
        /// 【MM_函数库】验证字符串路径的文件（夹）是否真实存在
        /// </summary>
        /// <param name="path">文件（夹）路径全名</param>
        /// <returns></returns>
        public static bool IsDF(string path)
        {
            bool torf = false;
            if (Directory.Exists(path) || File.Exists(path))
            {
                torf = true;
            }
            return torf;
        }

        /// <summary>
        /// 【MM_函数库】判断目标属性是否为真实文件夹
        /// </summary>
        /// <param name="path">文件夹路径全名</param>
        /// <returns></returns>
        public static bool IsDirAttributes(string path)
        {
            FileInfo fi = new FileInfo(path);
            if ((fi.Attributes & FileAttributes.Directory) != 0)
            {
                //ReadOnly = 1,
                //Hidden = 2,
                //System = 4,
                //Directory = 16,
                //Archive = 32,
                //Device = 64,
                //如果设置了ReadOnly和Directory，则FileAttributes等于16+1=17，二进制为00001001
                //如果没有设置目录位，则会得到零：
                //File.GetAttributes(source) = 00000001
                //  FileAttributes.Directory = 00001000 &
                //-------------------------------------
                //                             00000000
                return true;
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        /// 【MM_函数库】验证字符串路径的文件夹是否真实存在
        /// </summary>
        /// <param name="path">文件夹路径全名</param>
        /// <returns></returns>
        public static bool IsDir(string path)
        {
            bool torf = false;
            if (Directory.Exists(path))
            {
                torf = true;
            }
            return torf;
        }

        /// <summary>
        /// 【MM_函数库】验证字符串路径的文件是否真实存在
        /// </summary>
        /// <param name="path">文件路径全名</param>
        /// <returns></returns>
        public static bool IsFile(string path)
        {
            bool torf = false;
            if (File.Exists(path))
            {
                torf = true;
            }
            return torf;
        }

        /// <summary>
        /// 【MM_函数库】验证目录是否为空
        /// </summary>
        /// <param name="path"></param>
        /// <returns></returns>
        public static bool IsDirectoryEmpty(string path)
        {
            bool torf = false;
            DirectoryInfo dir = new DirectoryInfo(path);
            //为了效率，只要验证当前层就可以了
            if (dir.GetFiles().Length + dir.GetDirectories().Length == 0)
            {
                torf = true;
            }
            return torf;
        }

        /// <summary>
        /// 【MM_函数库】验证路径是否为用户定义的空文件夹，通过MMCore.DirectoryEmptyUserDefIndex属性可定义空文件夹形式
        /// </summary>
        /// <param name="path"></param>
        /// <returns></returns>
        public static bool IsDirectoryEmptyUserDef(string path)
        {
            bool torf = false;
            switch (DirectoryEmptyUserDefIndex) //定义空文件夹形式
            {
                case 0:
                    if (IsDirectoryEmpty(path))
                    {
                        torf = true;
                    } //里面的子文件夹和文件数量均为0
                    break;
                case 1:
                    if (GetDirectoryLength(path) == 0)
                    {
                        torf = true;
                    } //文件夹大小为0
                    break;
                case 2:
                    if (IsDirectoryEmpty(path) && GetDirectoryLength(path) == 0)
                    {
                        torf = true;
                    } //以上两者
                    break;
                default:
                    if (IsDirectoryEmpty(path))
                    {
                        torf = true;
                    } //里面的子文件夹和文件数量均为0
                    break;
            }
            return torf;
        }

        /// <summary>
        /// 【MM_函数库】写文本每行，文件若不存在则自动新建
        /// </summary>
        /// <param name="path"></param>
        /// <param name="value"></param>
        /// <param name="torf">false是覆盖，true是追加文本</param>
        public static void WriteLine(string path, string value, bool torf)
        {
            using (StreamWriter sw = new StreamWriter(path, torf, Encoding.Unicode))
            {
                sw.WriteLine(value);
                //sw.Flush(); 不等待sw.Close()即刻写入，对于遍历大量写入来说并不效率，故此时不写
            }

        }

        /// <summary>
        /// 【MM_函数库】写文本，文件若不存在则自动新建
        /// </summary>
        /// <param name="path"></param>
        /// <param name="value"></param>
        /// <param name="torf">false是覆盖，true是追加文本</param>
        public static void Write(string path, string value, bool torf)
        {
            using (StreamWriter sw = new StreamWriter(path, torf, Encoding.Unicode))
            {
                sw.Write(value);
                //sw.Flush(); 不等待sw.Close()即刻写入，对于遍历大量写入来说并不效率，故此时不写
            }

        }

        /// <summary>
        /// 【MM_函数库】验证文件大小是否在用户定义的[a,b]范围
        /// </summary>
        /// <param name="path"></param>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool IsDFSizeInRange(string path, long a, long b)
        {
            bool torf = false;
            long x;
            for (int i = 0; i < 1; i++)
            {
                if (IsDir(path))
                {
                    x = GetDirectoryLength(path);
                }
                else if (IsFile(path))
                {
                    x = GetFileLength(path);
                }
                else { break; }
                if (x >= a && x <= b)
                {
                    torf = true;
                }
            }
            return torf;
        }

        /// <summary>
        /// 【MM_函数库】创建GET请求
        /// </summary>
        /// <param name="url"></param>
        /// <returns></returns>
        public static string CreateGetHttpResponse(string url)
        {
            HttpWebRequest request = WebRequest.Create(url) as HttpWebRequest;
            request.Method = "GET";
            request.UserAgent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36 Edg/113.0.1774.50";
            try
            {
                HttpWebResponse webresponse = request.GetResponse() as HttpWebResponse;
                using (Stream s = webresponse.GetResponseStream())
                {
                    StreamReader reader = new StreamReader(s, Encoding.UTF8);
                    return reader.ReadToEnd();
                }
            }
            catch (Exception)
            {
                return "requestFalse";
            }

        }

        /// <summary>
        /// 【MM_函数库】创建POST请求
        /// </summary>
        /// <param name="url"></param>
        /// <param name="parameters"></param>
        /// <param name="ContentType"></param>
        /// <returns></returns>
        public static string CreatePostHttpResponse(string url, IDictionary<string, string> parameters, string ContentType = "application/x-www-form-urlencoded")
        {
            HttpWebRequest request;
            //如果是发送HTTPS请求  
            if (url.StartsWith("https", StringComparison.OrdinalIgnoreCase))
            {
                request = WebRequest.Create(url) as HttpWebRequest;
            }
            else
            {
                request = WebRequest.Create(url) as HttpWebRequest;
            }
            request.Method = "POST";
            request.UserAgent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36 Edg/113.0.1774.50";
            request.ContentType = ContentType;
            //发送POST数据  
            if (!(parameters == null || parameters.Count == 0))
            {
                StringBuilder buffer = new StringBuilder();
                int i = 0;
                foreach (string key in parameters.Keys)
                {
                    if (i > 0)
                    {
                        buffer.AppendFormat("&{0}={1}", key, parameters[key]);
                    }
                    else
                    {
                        buffer.AppendFormat("{0}={1}", key, parameters[key]);
                        i++;
                    }
                }
                byte[] data = Encoding.ASCII.GetBytes(buffer.ToString());
                using (Stream stream = request.GetRequestStream())
                {
                    stream.Write(data, 0, data.Length);
                }
            }
            try
            {
                HttpWebResponse webresponse = request.GetResponse() as HttpWebResponse;
                using (Stream s = webresponse.GetResponseStream())
                {
                    StreamReader reader = new StreamReader(s, Encoding.UTF8);
                    return reader.ReadToEnd();
                }
            }
            catch (Exception)
            {
                return "requestFalse";
            }
        }

        /// <summary>
        /// 【MM_函数库】下载指定网站的指定节点内容到指定文件夹并保存为自定义文件名
        /// 使用范例：
        /// HtmlDocument doc = new();
        /// doc.LoadHtml(MMCore.CreateGetHttpResponse("https://ac.qq.com/Comic/ComicInfo/id/542330"));
        /// HtmlNode img = doc.DocumentNode.SelectSingleNode("/html/body/div[3]/div[3]/div[1]/div[1]/div[1]/a/img");
        /// string imgUal = img.Attributes["src"].Value;
        /// MMCore.Download(imgUal, "123.jpg", @"C:\Users\Admin\Desktop\Download\", true);
        ///// Debug.WriteLine("下载完成！");
        /// </summary>
        /// <param name="url">浏览器网址</param>
        /// <param name="filename">自定义文件名</param>
        /// <param name="path">下载路径，如 @"C:\Users\Admin\Desktop\Download\"</param>
        /// <param name="cover">发生文件重复时覆盖</param>
        /// <returns></returns>
        public static bool Download(string url, string filename, string path, bool cover)
        {
            string tempPath = Path.Combine(Path.GetDirectoryName(path), "temp");//确定临时文件夹全名路径
            string filepath = Path.Combine(path, filename);//确定最终下载文件全名路径
            Directory.CreateDirectory(tempPath);  //创建临时文件夹
            string tempFile = tempPath + "\\" + filename + ".temp"; //确定临时下载文件全名路径
            if (File.Exists(tempFile))
            {
                File.Delete(tempFile);    //临时下载文件存在则删除
            }
            FileStream fs = new FileStream(tempFile, FileMode.Append, FileAccess.Write, FileShare.ReadWrite);
            try
            {
                // 设置参数
                HttpWebRequest request = WebRequest.Create(url) as HttpWebRequest;
                //发送请求并获取相应回应数据
                HttpWebResponse response = request.GetResponse() as HttpWebResponse;
                //直到request.GetResponse()程序才开始向目标网页发送Post请求
                Stream responseStream = response.GetResponseStream();
                byte[] bArr = new byte[1024];
                int size = responseStream.Read(bArr, 0, (int)bArr.Length);
                while (size > 0)
                {
                    fs.Write(bArr, 0, size);
                    size = responseStream.Read(bArr, 0, (int)bArr.Length);
                }
                responseStream.Close();
                responseStream.Dispose();
            }
            catch (Exception ex)
            {
                //Debug.WriteLine("错误:{0}", ex.Message);
                return false;
            }
            finally
            {
                fs.Close();
                fs.Dispose();
            }
            try
            {
                File.Move(tempFile, filepath);
            }
            catch
            {
                if (cover) { File.Delete(filepath); File.Move(tempFile, filepath); }
            }
            try
            {
                DelDirectory(tempPath);
            }
            catch
            {
                DelDirectoryRecursively(tempPath);
            }
            return true;
        }

        ///<summary>
        ///【MM_函数库】生成随机字符串 
        ///</summary>
        ///<param name="length">目标字符串的长度</param>
        ///<param name="useNum">是否包含数字，1=包含，默认为包含</param>
        ///<param name="useLow">是否包含小写字母，1=包含，默认为包含</param>
        ///<param name="useUpp">是否包含大写字母，1=包含，默认为包含</param>
        ///<param name="useSpe">是否包含特殊字符，1=包含，默认为不包含</param>
        ///<param name="custom">要包含的自定义字符，直接输入要包含的字符列表</param>
        ///<returns>指定长度的随机字符串</returns>
        public static string GetRandomString(int length, bool useNum = true, bool useLow = true, bool useUpp = true, bool useSpe = false, string custom = null)
        {
            byte[] b = new byte[4];
            new System.Security.Cryptography.RNGCryptoServiceProvider().GetBytes(b);
            Random r = new Random(BitConverter.ToInt32(b, 0));
            string s = null, str = custom;
            if (useNum == true) { str += "0123456789"; }
            if (useLow == true) { str += "abcdefghijklmnopqrstuvwxyz"; }
            if (useUpp == true) { str += "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; }
            if (useSpe == true) { str += "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~"; }
            for (int i = 0; i < length; i++)
            {
                s += str.Substring(r.Next(0, str.Length - 1), 1);
            }
            return s;
        }

        /// <summary>
        /// 【MM_函数库】创建文件夹，若已存在则什么也不干
        /// </summary>
        /// <param name="path"></param>
        public static void CreatDirectory(string path)
        {
            if (!Directory.Exists(path))
            {
                DirectoryInfo directory = new DirectoryInfo(path);
                directory.Create();
            }
        }

        /// <summary>
        /// 【MM_函数库】创建文件，若已存在则什么也不干
        /// </summary>
        /// <param name="filepath"></param>
        public static void CreatFile(string filepath)
        {
            if (!File.Exists(filepath))
            {
                File.Create(filepath);
            }
        }

        /// <summary>
        /// 【MM_函数库】用WinRAR解压带密码的压缩包
        /// </summary>
        /// <param name="zipFilePath">压缩包路径</param>
        /// <param name="unZipPath">解压后文件夹的路径</param>
        /// <param name="password">压缩包密码</param>
        /// <returns></returns>
        public static bool UnZip(string zipFilePath, string unZipPath, string password)
        {
            if (!IsOwnWinRAR())
            {
                MessageBox.Show("本机并未安装WinRAR,请安装该压缩软件!", "温馨提示");
                return false;
            }

            Process Process1 = new Process();
            Process1.StartInfo.FileName = "WinRAR.exe";
            Process1.StartInfo.CreateNoWindow = true;
            Process1.StartInfo.Arguments = " x -p" + password + " " + zipFilePath + " " + unZipPath;
            Process1.Start();
            if (Process1.HasExited)
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        /// 【MM_函数库】判断系统上是否安装WinRAR
        /// </summary>
        /// <returns></returns>
        public static bool IsOwnWinRAR()
        {
            RegistryKey the_Reg =
                Registry.LocalMachine.OpenSubKey(
                    @"SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\WinRAR.exe");
            return !string.IsNullOrEmpty(the_Reg.GetValue("").ToString());

        }

        #region 弹幕爬取

        //功能出处：https://blog.csdn.net/qq_15505341/article/details/79212070/

        /// <summary>
        /// 【MM_函数库】获取弹幕信息（本函数待改中请勿使用）
        /// </summary>
        /// <param name="room"></param>
        /// <returns></returns>
        public static string Post(string room)
        {
            string postString = "roomid=" + room + "&token=&csrf_token=我是图中的马赛克";//要发送的数据
            byte[] postData = Encoding.UTF8.GetBytes(postString);//编码，尤其是汉字，事先要看下抓取网页的编码方式  
            string url = @"http://api.live.bilibili.com/ajax/msg";//地址  

            WebClient webClient = new WebClient();
            webClient.Headers.Add("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36");
            webClient.Headers.Add("Content-Type", "application/x-www-form-urlencoded");//采取POST方式必须加的header，如果改为GET方式的话就去掉这句话即可  
            webClient.Headers.Add("Cookie",
                "可耻的马赛克"
                );
            byte[] responseData = webClient.UploadData(url, "POST", postData);//得到返回字符流  
            string srcString = Encoding.UTF8.GetString(responseData);//解码  
            return srcString;
        }

        /// <summary>
        /// 【MM_函数库】处理弹幕信息为中文（本函数待改中请勿使用）
        /// </summary>
        /// <param name="room"></param>
        /// <returns></returns>
        public static List<string> GetDanMu(string room)
        {
            string danmu = Post(room);
            List<string> list = new List<string>();
            //正则匹配
            foreach (Match item in Regex.Matches(danmu, "text\":\".*?\""))
            {
                //截取字符串，将unicode码转换为中文
                list.Add(Regex.Unescape(item.Value.Substring(7, item.Value.Length - 8)));
            }
            return list;
        }


        #endregion

        #endregion

        #region Functions 数据表功能

        //注：用户与基础数据表通用键名，用户数据表的键名默认添加前缀"HD_"进行区分，用数据表设计其他功能时应再次添加不重复前缀以免与用户数据表键区重叠（参互动管理功能）

        #region 用户数据表

        //建议使用泛型字典，值与引用类型不混用

        #region 引用类型

        #region Object

        /// <summary>
        /// 【MM_函数库】判断数据表键是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DataTableObjectKeyExists(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableKeyExists(place, "HD_" + key);
                default:
                    return DictionaryObjectKeyExists(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】判断数据表值是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool DataTableObjectValueExists(bool place, object value)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableValueExists(place, value);
                default:
                    return DictionaryObjectValueExists(place, value);
            }

        }

        /// <summary>
        /// 【MM_函数库】获取数据表键对应的值
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static object DataTableObjectGetValue(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableGetValue(place, "HD_" + key);
                default:
                    return DictionaryObjectGetValue(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        public static void DataTableObjectClear0(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    DictionaryObjectClear0(place, "HD_" + key);
                    break;
                default:
                    HashTableClear0(place, "HD_" + key);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[]，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        public static void DataTableObjectClear1(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear1(place, "HD_" + key, lp_1);
                    break;
                default:
                    DictionaryObjectClear1(place, "HD_" + key, lp_1);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,]，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        public static void DataTableObjectClear2(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear2(place, "HD_" + key, lp_1, lp_2);
                    break;
                default:
                    DictionaryObjectClear2(place, "HD_" + key, lp_1, lp_2);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,,]，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        public static void DataTableObjectClear3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear3(place, "HD_" + key, lp_1, lp_2, lp_3);
                    break;
                default:
                    DictionaryObjectClear3(place, "HD_" + key, lp_1, lp_2, lp_3);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,,,]，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        public static void DataTableObjectClear4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                    break;
                default:
                    DictionaryObjectClear4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】移除数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        private static void DataTableObjectRemove(bool place, string key)//内部函数
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableRemove(place, "HD_" + key);
                    break;
                default:
                    DictionaryObjectRemove(place, "HD_" + key);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        public static void DataTableObjectSave0(bool place, string key, object val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave0(place, "HD_" + key, val);
                    break;
                default:
                    DictionaryObjectSave0(place, "HD_" + key, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="val"></param>
        public static void DataTableObjectSave1(bool place, string key, int lp_1, object val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave1(place, "HD_" + key, lp_1, val);
                    break;
                default:
                    DictionaryObjectSave1(place, "HD_" + key, lp_1, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="val"></param>
        public static void DataTableObjectSave2(bool place, string key, int lp_1, int lp_2, object val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave2(place, "HD_" + key, lp_1, lp_2, val);
                    break;
                default:
                    DictionaryObjectSave2(place, "HD_" + key, lp_1, lp_2, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="val"></param>
        public static void DataTableObjectSave3(bool place, string key, int lp_1, int lp_2, int lp_3, object val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave3(place, "HD_" + key, lp_1, lp_2, lp_3, val);
                    break;
                default:
                    DictionaryObjectSave3(place, "HD_" + key, lp_1, lp_2, lp_3, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <param name="val"></param>
        public static void DataTableObjectSave4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4, object val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4, val);
                    break;
                default:
                    DictionaryObjectSave4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static object DataTableObjectLoad0(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableLoad0(place, "HD_" + key);
                default:
                    return DictionaryObjectLoad0(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns></returns>
        public static object DataTableObjectLoad1(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableLoad1(place, "HD_" + key, lp_1);
                default:
                    return DictionaryObjectLoad1(place, "HD_" + key, lp_1);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns></returns>
        public static object DataTableObjectLoad2(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableLoad2(place, "HD_" + key, lp_1, lp_2);
                default:
                    return DictionaryObjectLoad2(place, "HD_" + key, lp_1, lp_2);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns></returns>
        public static object DataTableObjectLoad3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
                default:
                    return DictionaryObjectLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns></returns>
        public static object DataTableObjectLoad4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                default:
                    return DictionaryObjectLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
            }
        }

        #endregion

        #region Vector

        /// <summary>
        /// 【MM_函数库】判断数据表键是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DataTableVectorKeyExists(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableKeyExists(place, "HD_" + key);
                default:
                    return DictionaryVectorKeyExists(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】判断数据表值是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool DataTableVectorValueExists(bool place, Vector value)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableValueExists(place, value);
                default:
                    return DictionaryVectorValueExists(place, value);
            }
        }

        /// <summary>
        /// 【MM_函数库】获取数据表键对应的值
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static Vector DataTableVectorGetValue(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (Vector)HashTableGetValue(place, "HD_" + key);
                default:
                    return DictionaryVectorGetValue(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        public static void DataTableVectorClear0(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear0(place, "HD_" + key);
                    break;
                default:
                    DictionaryVectorClear0(place, "HD_" + key);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[]，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        public static void DataTableVectorClear1(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear1(place, "HD_" + key, lp_1);
                    break;
                default:
                    DictionaryVectorClear1(place, "HD_" + key, lp_1);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,]，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        public static void DataTableVectorClear2(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear2(place, "HD_" + key, lp_1, lp_2);
                    break;
                default:
                    DictionaryVectorClear2(place, "HD_" + key, lp_1, lp_2);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,,]，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        public static void DataTableVectorClear3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear3(place, "HD_" + key, lp_1, lp_2, lp_3);
                    break;
                default:
                    DictionaryVectorClear3(place, "HD_" + key, lp_1, lp_2, lp_3);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,,,]，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        public static void DataTableVectorClear4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                    break;
                default:
                    DictionaryVectorClear4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】移除数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        private static void DataTableVectorRemove(bool place, string key)//内部函数
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableRemove(place, "HD_" + key);
                    break;
                default:
                    DictionaryVectorRemove(place, "HD_" + key);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        public static void DataTableVectorSave0(bool place, string key, Vector val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave0(place, "HD_" + key, val);
                    break;
                default:
                    DictionaryVectorSave0(place, "HD_" + key, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="val"></param>
        public static void DataTableVectorSave1(bool place, string key, int lp_1, Vector val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave1(place, "HD_" + key, lp_1, val);
                    break;
                default:
                    DictionaryVectorSave1(place, "HD_" + key, lp_1, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="val"></param>
        public static void DataTableVectorSave2(bool place, string key, int lp_1, int lp_2, Vector val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave2(place, "HD_" + key, lp_1, lp_2, val);
                    break;
                default:
                    DictionaryVectorSave2(place, "HD_" + key, lp_1, lp_2, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="val"></param>
        public static void DataTableVectorSave3(bool place, string key, int lp_1, int lp_2, int lp_3, Vector val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave3(place, "HD_" + key, lp_1, lp_2, lp_3, val);
                    break;
                default:
                    DictionaryVectorSave3(place, "HD_" + key, lp_1, lp_2, lp_3, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <param name="val"></param>
        public static void DataTableVectorSave4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4, Vector val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4, val);
                    break;
                default:
                    DictionaryVectorSave4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static Vector? DataTableVectorLoad0_N(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (Vector?)HashTableLoad0(place, "HD_" + key);
                default:
                    return DictionaryVectorLoad0_N(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns></returns>
        public static Vector? DataTableVectorLoad1_N(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (Vector?)HashTableLoad1(place, "HD_" + key, lp_1);
                default:
                    return DictionaryVectorLoad1_N(place, "HD_" + key, lp_1);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns></returns>
        public static Vector? DataTableVectorLoad2_N(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (Vector?)HashTableLoad2(place, "HD_" + key, lp_1, lp_2);
                default:
                    return DictionaryVectorLoad2_N(place, "HD_" + key, lp_1, lp_2);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns></returns>
        public static Vector? DataTableVectorLoad3_N(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (Vector?)HashTableLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
                default:
                    return DictionaryVectorLoad3_N(place, "HD_" + key, lp_1, lp_2, lp_3);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns></returns>
        public static Vector? DataTableVectorLoad4_N(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (Vector?)HashTableLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                default:
                    return DictionaryVectorLoad4_N(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns>错误时返回new Vector(0,0)</returns>
        public static Vector DataTableVectorLoad0(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (Vector)HashTableLoad0(place, "HD_" + key);
                default:
                    return DictionaryVectorLoad0(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns></returns>
        public static Vector DataTableVectorLoad1(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (Vector)HashTableLoad1(place, "HD_" + key, lp_1);
                default:
                    return DictionaryVectorLoad1(place, "HD_" + key, lp_1);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns></returns>
        public static Vector DataTableVectorLoad2(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (Vector)HashTableLoad2(place, "HD_" + key, lp_1, lp_2);
                default:
                    return DictionaryVectorLoad2(place, "HD_" + key, lp_1, lp_2);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns></returns>
        public static Vector DataTableVectorLoad3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (Vector)HashTableLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
                default:
                    return DictionaryVectorLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns></returns>
        public static Vector DataTableVectorLoad4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (Vector)HashTableLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                default:
                    return DictionaryVectorLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
            }
        }

        #endregion

        #region Timer

        /// <summary>
        /// 【MM_函数库】判断数据表键是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DataTableTimerKeyExists(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableKeyExists(place, "HD_" + key);
                default:
                    return DictionaryTimerKeyExists(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】判断数据表值是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool DataTableTimerValueExists(bool place, Timer value)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableValueExists(place, value);
                default:
                    return DictionaryTimerValueExists(place, value);
            }
        }

        /// <summary>
        /// 【MM_函数库】获取数据表键对应的值
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static Timer DataTableTimerGetValue(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (Timer)HashTableGetValue(place, "HD_" + key);
                default:
                    return DictionaryTimerGetValue(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        public static void DataTableTimerClear0(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear0(place, "HD_" + key);
                    break;
                default:
                    DictionaryTimerClear0(place, "HD_" + key);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[]，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        public static void DataTableTimerClear1(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear1(place, "HD_" + key, lp_1);
                    break;
                default:
                    DictionaryTimerClear1(place, "HD_" + key, lp_1);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,]，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        public static void DataTableTimerClear2(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear2(place, "HD_" + key, lp_1, lp_2);
                    break;
                default:
                    DictionaryTimerClear2(place, "HD_" + key, lp_1, lp_2);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,,]，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        public static void DataTableTimerClear3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear3(place, "HD_" + key, lp_1, lp_2, lp_3);
                    break;
                default:
                    DictionaryTimerClear3(place, "HD_" + key, lp_1, lp_2, lp_3);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,,,]，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        public static void DataTableTimerClear4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                    break;
                default:
                    DictionaryTimerClear4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】移除数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        private static void DataTableTimerRemove(bool place, string key)//内部函数
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableRemove(place, "HD_" + key);
                    break;
                default:
                    DictionaryTimerRemove(place, "HD_" + key);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        public static void DataTableTimerSave0(bool place, string key, Timer val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave0(place, "HD_" + key, val);
                    break;
                default:
                    DictionaryTimerSave0(place, "HD_" + key, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="val"></param>
        public static void DataTableTimerSave1(bool place, string key, int lp_1, Timer val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave1(place, "HD_" + key, lp_1, val);
                    break;
                default:
                    DictionaryTimerSave1(place, "HD_" + key, lp_1, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="val"></param>
        public static void DataTableTimerSave2(bool place, string key, int lp_1, int lp_2, Timer val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave2(place, "HD_" + key, lp_1, lp_2, val);
                    break;
                default:
                    DictionaryTimerSave2(place, "HD_" + key, lp_1, lp_2, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="val"></param>
        public static void DataTableTimerSave3(bool place, string key, int lp_1, int lp_2, int lp_3, Timer val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave3(place, "HD_" + key, lp_1, lp_2, lp_3, val);
                    break;
                default:
                    DictionaryTimerSave3(place, "HD_" + key, lp_1, lp_2, lp_3, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <param name="val"></param>
        public static void DataTableTimerSave4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4, Timer val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4, val);
                    break;
                default:
                    DictionaryTimerSave4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static Timer DataTableTimerLoad0(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (Timer)HashTableLoad0(place, "HD_" + key);
                default:
                    return DictionaryTimerLoad0(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns></returns>
        public static Timer DataTableTimerLoad1(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (Timer)HashTableLoad1(place, "HD_" + key, lp_1);
                default:
                    return DictionaryTimerLoad1(place, "HD_" + key, lp_1);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns></returns>
        public static Timer DataTableTimerLoad2(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (Timer)HashTableLoad2(place, "HD_" + key, lp_1, lp_2);
                default:
                    return DictionaryTimerLoad2(place, "HD_" + key, lp_1, lp_2);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns></returns>
        public static Timer DataTableTimerLoad3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (Timer)HashTableLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
                default:
                    return DictionaryTimerLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns></returns>
        public static Timer DataTableTimerLoad4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (Timer)HashTableLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                default:
                    return DictionaryTimerLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
            }
        }

        #endregion

        #region String

        /// <summary>
        /// 【MM_函数库】判断数据表键是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DataTableStringKeyExists(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableKeyExists(place, "HD_" + key);
                default:
                    return DictionaryStringKeyExists(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】判断数据表值是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool DataTableStringValueExists(bool place, string value)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableValueExists(place, value);
                default:
                    return DictionaryStringValueExists(place, value);
            }
        }

        /// <summary>
        /// 【MM_函数库】获取数据表键对应的值
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static string DataTableStringGetValue(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (string)HashTableGetValue(place, "HD_" + key);
                default:
                    return DictionaryStringGetValue(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        public static void DataTableStringClear0(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear0(place, "HD_" + key);
                    break;
                default:
                    DictionaryStringClear0(place, "HD_" + key);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[]，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        public static void DataTableStringClear1(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear1(place, "HD_" + key, lp_1);
                    break;
                default:
                    DictionaryStringClear1(place, "HD_" + key, lp_1);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,]，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        public static void DataTableStringClear2(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear2(place, "HD_" + key, lp_1, lp_2);
                    break;
                default:
                    DictionaryStringClear2(place, "HD_" + key, lp_1, lp_2);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,,]，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        public static void DataTableStringClear3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear3(place, "HD_" + key, lp_1, lp_2, lp_3);
                    break;
                default:
                    DictionaryStringClear3(place, "HD_" + key, lp_1, lp_2, lp_3);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,,,]，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        public static void DataTableStringClear4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                    break;
                default:
                    DictionaryStringClear4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】移除数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        private static void DataTableStringRemove(bool place, string key)//内部函数
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableRemove(place, "HD_" + key);
                    break;
                default:
                    DictionaryStringRemove(place, "HD_" + key);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        public static void DataTableStringSave0(bool place, string key, string val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave0(place, "HD_" + key, val);
                    break;
                default:
                    DictionaryStringSave0(place, "HD_" + key, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="val"></param>
        public static void DataTableStringSave1(bool place, string key, int lp_1, string val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave1(place, "HD_" + key, lp_1, val);
                    break;
                default:
                    DictionaryStringSave1(place, "HD_" + key, lp_1, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="val"></param>
        public static void DataTableStringSave2(bool place, string key, int lp_1, int lp_2, string val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave2(place, "HD_" + key, lp_1, lp_2, val);
                    break;
                default:
                    DictionaryStringSave2(place, "HD_" + key, lp_1, lp_2, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="val"></param>
        public static void DataTableStringSave3(bool place, string key, int lp_1, int lp_2, int lp_3, string val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave3(place, "HD_" + key, lp_1, lp_2, lp_3, val);
                    break;
                default:
                    DictionaryStringSave3(place, "HD_" + key, lp_1, lp_2, lp_3, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <param name="val"></param>
        public static void DataTableStringSave4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4, string val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4, val);
                    break;
                default:
                    DictionaryStringSave4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static string DataTableStringLoad0(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (string)HashTableLoad0(place, "HD_" + key);
                default:
                    return DictionaryStringLoad0(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns></returns>
        public static string DataTableStringLoad1(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (string)HashTableLoad1(place, "HD_" + key, lp_1);
                default:
                    return DictionaryStringLoad1(place, "HD_" + key, lp_1);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns></returns>
        public static string DataTableStringLoad2(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (string)HashTableLoad2(place, "HD_" + key, lp_1, lp_2);
                default:
                    return DictionaryStringLoad2(place, "HD_" + key, lp_1, lp_2);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns></returns>
        public static string DataTableStringLoad3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (string)HashTableLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
                default:
                    return DictionaryStringLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns></returns>
        public static string DataTableStringLoad4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (string)HashTableLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                default:
                    return DictionaryStringLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
            }
        }

        #endregion

        #endregion

        #region 值类型

        #region Int

        /// <summary>
        /// 【MM_函数库】判断数据表键是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DataTableIntKeyExists(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableKeyExists(place, "HD_" + key);
                default:
                    return DictionaryIntKeyExists(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】判断数据表值是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool DataTableIntValueExists(bool place, int value)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableValueExists(place, value);
                default:
                    return DictionaryIntValueExists(place, value);
            }
        }

        /// <summary>
        /// 【MM_函数库】获取数据表键对应的值
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static int DataTableIntGetValue(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (int)HashTableGetValue(place, "HD_" + key);
                default:
                    return DictionaryIntGetValue(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        public static void DataTableIntClear0(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear0(place, "HD_" + key);
                    break;
                default:
                    DictionaryIntClear0(place, "HD_" + key);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[]，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        public static void DataTableIntClear1(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear1(place, "HD_" + key, lp_1);
                    break;
                default:
                    DictionaryIntClear1(place, "HD_" + key, lp_1);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,]，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        public static void DataTableIntClear2(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear2(place, "HD_" + key, lp_1, lp_2);
                    break;
                default:
                    DictionaryIntClear2(place, "HD_" + key, lp_1, lp_2);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,,]，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        public static void DataTableIntClear3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear3(place, "HD_" + key, lp_1, lp_2, lp_3);
                    break;
                default:
                    DictionaryIntClear3(place, "HD_" + key, lp_1, lp_2, lp_3);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,,,]，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        public static void DataTableIntClear4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                    break;
                default:
                    DictionaryIntClear4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】移除数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        private static void DataTableIntRemove(bool place, string key)//内部函数
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableRemove(place, "HD_" + key);
                    break;
                default:
                    DictionaryIntRemove(place, "HD_" + key);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        public static void DataTableIntSave0(bool place, string key, int val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave0(place, "HD_" + key, val);
                    break;
                default:
                    DictionaryIntSave0(place, "HD_" + key, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="val"></param>
        public static void DataTableIntSave1(bool place, string key, int lp_1, int val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave1(place, "HD_" + key, lp_1, val);
                    break;
                default:
                    DictionaryIntSave1(place, "HD_" + key, lp_1, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="val"></param>
        public static void DataTableIntSave2(bool place, string key, int lp_1, int lp_2, int val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave2(place, "HD_" + key, lp_1, lp_2, val);
                    break;
                default:
                    DictionaryIntSave2(place, "HD_" + key, lp_1, lp_2, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="val"></param>
        public static void DataTableIntSave3(bool place, string key, int lp_1, int lp_2, int lp_3, int val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave3(place, "HD_" + key, lp_1, lp_2, lp_3, val);
                    break;
                default:
                    DictionaryIntSave3(place, "HD_" + key, lp_1, lp_2, lp_3, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <param name="val"></param>
        public static void DataTableIntSave4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4, int val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4, val);
                    break;
                default:
                    DictionaryIntSave4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static int? DataTableIntLoad0_N(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (int?)HashTableLoad0(place, "HD_" + key);
                default:
                    return DictionaryIntLoad0_N(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns></returns>
        public static int? DataTableIntLoad1_N(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (int?)HashTableLoad1(place, "HD_" + key, lp_1);
                default:
                    return DictionaryIntLoad1_N(place, "HD_" + key, lp_1);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns></returns>
        public static int? DataTableIntLoad2_N(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (int?)HashTableLoad2(place, "HD_" + key, lp_1, lp_2);
                default:
                    return DictionaryIntLoad2_N(place, "HD_" + key, lp_1, lp_2);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns></returns>
        public static int? DataTableIntLoad3_N(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (int?)HashTableLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
                default:
                    return DictionaryIntLoad3_N(place, "HD_" + key, lp_1, lp_2, lp_3);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns></returns>
        public static int? DataTableIntLoad4_N(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (int?)HashTableLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                default:
                    return DictionaryIntLoad4_N(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static int DataTableIntLoad0(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (int)HashTableLoad0(place, "HD_" + key);
                default:
                    return DictionaryIntLoad0(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns></returns>
        public static int DataTableIntLoad1(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (int)HashTableLoad1(place, "HD_" + key, lp_1);
                default:
                    return DictionaryIntLoad1(place, "HD_" + key, lp_1);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns></returns>
        public static int DataTableIntLoad2(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (int)HashTableLoad2(place, "HD_" + key, lp_1, lp_2);
                default:
                    return DictionaryIntLoad2(place, "HD_" + key, lp_1, lp_2);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns></returns>
        public static int DataTableIntLoad3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (int)HashTableLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
                default:
                    return DictionaryIntLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns></returns>
        public static int DataTableIntLoad4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (int)HashTableLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                default:
                    return DictionaryIntLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
            }
        }

        #endregion

        #region Long

        /// <summary>
        /// 【MM_函数库】判断数据表键是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DataTableLongKeyExists(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableKeyExists(place, "HD_" + key);
                default:
                    return DictionaryLongKeyExists(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】判断数据表值是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool DataTableLongValueExists(bool place, long value)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableValueExists(place, value);
                default:
                    return DictionaryLongValueExists(place, value);
            }
        }

        /// <summary>
        /// 【MM_函数库】获取数据表键对应的值
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static long DataTableLongGetValue(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (long)HashTableGetValue(place, "HD_" + key);
                default:
                    return DictionaryLongGetValue(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        public static void DataTableLongClear0(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear0(place, "HD_" + key);
                    break;
                default:
                    DictionaryLongClear0(place, "HD_" + key);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[]，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        public static void DataTableLongClear1(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear1(place, "HD_" + key, lp_1);
                    break;
                default:
                    DictionaryLongClear1(place, "HD_" + key, lp_1);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,]，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        public static void DataTableLongClear2(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear2(place, "HD_" + key, lp_1, lp_2);
                    break;
                default:
                    DictionaryLongClear2(place, "HD_" + key, lp_1, lp_2);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,,]，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        public static void DataTableLongClear3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear3(place, "HD_" + key, lp_1, lp_2, lp_3);
                    break;
                default:
                    DictionaryLongClear3(place, "HD_" + key, lp_1, lp_2, lp_3);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,,,]，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        public static void DataTableLongClear4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                    break;
                default:
                    DictionaryLongClear4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】移除数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        private static void DataTableLongRemove(bool place, string key)//内部函数
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableRemove(place, "HD_" + key);
                    break;
                default:
                    DictionaryLongRemove(place, "HD_" + key);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        public static void DataTableLongSave0(bool place, string key, long val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave0(place, "HD_" + key, val);
                    break;
                default:
                    DictionaryLongSave0(place, "HD_" + key, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="val"></param>
        public static void DataTableLongSave1(bool place, string key, int lp_1, long val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave1(place, "HD_" + key, lp_1, val);
                    break;
                default:
                    DictionaryLongSave1(place, "HD_" + key, lp_1, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="val"></param>
        public static void DataTableLongSave2(bool place, string key, int lp_1, int lp_2, long val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave2(place, "HD_" + key, lp_1, lp_2, val);
                    break;
                default:
                    DictionaryLongSave2(place, "HD_" + key, lp_1, lp_2, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="val"></param>
        public static void DataTableLongSave3(bool place, string key, int lp_1, int lp_2, int lp_3, long val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave3(place, "HD_" + key, lp_1, lp_2, lp_3, val);
                    break;
                default:
                    DictionaryLongSave3(place, "HD_" + key, lp_1, lp_2, lp_3, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <param name="val"></param>
        public static void DataTableLongSave4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4, long val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4, val);
                    break;
                default:
                    DictionaryLongSave4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static long? DataTableLongLoad0_N(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (long?)HashTableLoad0(place, "HD_" + key);
                default:
                    return DictionaryLongLoad0_N(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns></returns>
        public static long? DataTableLongLoad1_N(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (long?)HashTableLoad1(place, "HD_" + key, lp_1);
                default:
                    return DictionaryLongLoad1_N(place, "HD_" + key, lp_1);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns></returns>
        public static long? DataTableLongLoad2_N(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (long?)HashTableLoad2(place, "HD_" + key, lp_1, lp_2);
                default:
                    return DictionaryLongLoad2_N(place, "HD_" + key, lp_1, lp_2);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns></returns>
        public static long? DataTableLongLoad3_N(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (long?)HashTableLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
                default:
                    return DictionaryLongLoad3_N(place, "HD_" + key, lp_1, lp_2, lp_3);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns></returns>
        public static long? DataTableLongLoad4_N(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (long?)HashTableLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                default:
                    return DictionaryLongLoad4_N(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static long DataTableLongLoad0(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (long)HashTableLoad0(place, "HD_" + key);
                default:
                    return DictionaryLongLoad0(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns></returns>
        public static long DataTableLongLoad1(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (long)HashTableLoad1(place, "HD_" + key, lp_1);
                default:
                    return DictionaryLongLoad1(place, "HD_" + key, lp_1);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns></returns>
        public static long DataTableLongLoad2(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (long)HashTableLoad2(place, "HD_" + key, lp_1, lp_2);
                default:
                    return DictionaryLongLoad2(place, "HD_" + key, lp_1, lp_2);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns></returns>
        public static long DataTableLongLoad3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (long)HashTableLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
                default:
                    return DictionaryLongLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns></returns>
        public static long DataTableLongLoad4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (long)HashTableLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                default:
                    return DictionaryLongLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
            }
        }

        #endregion

        #region Char

        /// <summary>
        /// 【MM_函数库】判断数据表键是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DataTableCharKeyExists(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableKeyExists(place, "HD_" + key);
                default:
                    return DictionaryCharKeyExists(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】判断数据表值是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool DataTableCharValueExists(bool place, char value)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableValueExists(place, value);
                default:
                    return DictionaryCharValueExists(place, value);
            }
        }

        /// <summary>
        /// 【MM_函数库】获取数据表键对应的值
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static char DataTableCharGetValue(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (char)HashTableGetValue(place, "HD_" + key);
                default:
                    return DictionaryCharGetValue(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        public static void DataTableCharClear0(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear0(place, "HD_" + key);
                    break;
                default:
                    DictionaryCharClear0(place, "HD_" + key);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[]，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        public static void DataTableCharClear1(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear1(place, "HD_" + key, lp_1);
                    break;
                default:
                    DictionaryCharClear1(place, "HD_" + key, lp_1);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,]，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        public static void DataTableCharClear2(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear2(place, "HD_" + key, lp_1, lp_2);
                    break;
                default:
                    DictionaryCharClear2(place, "HD_" + key, lp_1, lp_2);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,,]，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        public static void DataTableCharClear3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear3(place, "HD_" + key, lp_1, lp_2, lp_3);
                    break;
                default:
                    DictionaryCharClear3(place, "HD_" + key, lp_1, lp_2, lp_3);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,,,]，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        public static void DataTableCharClear4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                    break;
                default:
                    DictionaryCharClear4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】移除数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        private static void DataTableCharRemove(bool place, string key)//内部函数
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableRemove(place, "HD_" + key);
                    break;
                default:
                    DictionaryCharRemove(place, "HD_" + key);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        public static void DataTableCharSave0(bool place, string key, char val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave0(place, "HD_" + key, val);
                    break;
                default:
                    DictionaryCharSave0(place, "HD_" + key, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="val"></param>
        public static void DataTableCharSave1(bool place, string key, int lp_1, char val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave1(place, "HD_" + key, lp_1, val);
                    break;
                default:
                    DictionaryCharSave1(place, "HD_" + key, lp_1, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="val"></param>
        public static void DataTableCharSave2(bool place, string key, int lp_1, int lp_2, char val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave2(place, "HD_" + key, lp_1, lp_2, val);
                    break;
                default:
                    DictionaryCharSave2(place, "HD_" + key, lp_1, lp_2, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="val"></param>
        public static void DataTableCharSave3(bool place, string key, int lp_1, int lp_2, int lp_3, char val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave3(place, "HD_" + key, lp_1, lp_2, lp_3, val);
                    break;
                default:
                    DictionaryCharSave3(place, "HD_" + key, lp_1, lp_2, lp_3, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <param name="val"></param>
        public static void DataTableCharSave4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4, char val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4, val);
                    break;
                default:
                    DictionaryCharSave4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static char? DataTableCharLoad0_N(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (char?)HashTableLoad0(place, "HD_" + key);
                default:
                    return DictionaryCharLoad0_N(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns></returns>
        public static char? DataTableCharLoad1_N(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (char?)HashTableLoad1(place, "HD_" + key, lp_1);
                default:
                    return DictionaryCharLoad1_N(place, "HD_" + key, lp_1);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns></returns>
        public static char? DataTableCharLoad2_N(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (char?)HashTableLoad2(place, "HD_" + key, lp_1, lp_2);
                default:
                    return DictionaryCharLoad2_N(place, "HD_" + key, lp_1, lp_2);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns></returns>
        public static char? DataTableCharLoad3_N(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (char?)HashTableLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
                default:
                    return DictionaryCharLoad3_N(place, "HD_" + key, lp_1, lp_2, lp_3);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns></returns>
        public static char? DataTableCharLoad4_N(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (char?)HashTableLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                default:
                    return DictionaryCharLoad4_N(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static char DataTableCharLoad0(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (char)HashTableLoad0(place, "HD_" + key);
                default:
                    return DictionaryCharLoad0(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns></returns>
        public static char DataTableCharLoad1(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (char)HashTableLoad1(place, "HD_" + key, lp_1);
                default:
                    return DictionaryCharLoad1(place, "HD_" + key, lp_1);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns></returns>
        public static char DataTableCharLoad2(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (char)HashTableLoad2(place, "HD_" + key, lp_1, lp_2);
                default:
                    return DictionaryCharLoad2(place, "HD_" + key, lp_1, lp_2);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns></returns>
        public static char DataTableCharLoad3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (char)HashTableLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
                default:
                    return DictionaryCharLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns></returns>
        public static char DataTableCharLoad4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (char)HashTableLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                default:
                    return DictionaryCharLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
            }
        }

        #endregion

        #region Float

        /// <summary>
        /// 【MM_函数库】判断数据表键是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DataTableFloatKeyExists(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableKeyExists(place, "HD_" + key);
                default:
                    return DictionaryFloatKeyExists(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】判断数据表值是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool DataTableFloatValueExists(bool place, float value)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableValueExists(place, value);
                default:
                    return DictionaryFloatValueExists(place, value);
            }
        }

        /// <summary>
        /// 【MM_函数库】获取数据表键对应的值
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static float DataTableFloatGetValue(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (float)HashTableGetValue(place, "HD_" + key);
                default:
                    return DictionaryFloatGetValue(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        public static void DataTableFloatClear0(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear0(place, "HD_" + key);
                    break;
                default:
                    DictionaryFloatClear0(place, "HD_" + key);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[]，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        public static void DataTableFloatClear1(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear1(place, "HD_" + key, lp_1);
                    break;
                default:
                    DictionaryFloatClear1(place, "HD_" + key, lp_1);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,]，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        public static void DataTableFloatClear2(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear2(place, "HD_" + key, lp_1, lp_2);
                    break;
                default:
                    DictionaryFloatClear2(place, "HD_" + key, lp_1, lp_2);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,,]，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        public static void DataTableFloatClear3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear3(place, "HD_" + key, lp_1, lp_2, lp_3);
                    break;
                default:
                    DictionaryFloatClear3(place, "HD_" + key, lp_1, lp_2, lp_3);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,,,]，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        public static void DataTableFloatClear4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                    break;
                default:
                    DictionaryFloatClear4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】移除数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        private static void DataTableFloatRemove(bool place, string key)//内部函数
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableRemove(place, "HD_" + key);
                    break;
                default:
                    DictionaryFloatRemove(place, "HD_" + key);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        public static void DataTableFloatSave0(bool place, string key, float val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave0(place, "HD_" + key, val);
                    break;
                default:
                    DictionaryFloatSave0(place, "HD_" + key, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="val"></param>
        public static void DataTableFloatSave1(bool place, string key, int lp_1, float val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave1(place, "HD_" + key, lp_1, val);
                    break;
                default:
                    DictionaryFloatSave1(place, "HD_" + key, lp_1, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="val"></param>
        public static void DataTableFloatSave2(bool place, string key, int lp_1, int lp_2, float val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave2(place, "HD_" + key, lp_1, lp_2, val);
                    break;
                default:
                    DictionaryFloatSave2(place, "HD_" + key, lp_1, lp_2, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="val"></param>
        public static void DataTableFloatSave3(bool place, string key, int lp_1, int lp_2, int lp_3, float val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave3(place, "HD_" + key, lp_1, lp_2, lp_3, val);
                    break;
                default:
                    DictionaryFloatSave3(place, "HD_" + key, lp_1, lp_2, lp_3, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <param name="val"></param>
        public static void DataTableFloatSave4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4, float val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4, val);
                    break;
                default:
                    DictionaryFloatSave4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static float? DataTableFloatLoad0_N(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (float?)HashTableLoad0(place, "HD_" + key);
                default:
                    return DictionaryFloatLoad0_N(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns></returns>
        public static float? DataTableFloatLoad1_N(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (float?)HashTableLoad1(place, "HD_" + key, lp_1);
                default:
                    return DictionaryFloatLoad1_N(place, "HD_" + key, lp_1);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns></returns>
        public static float? DataTableFloatLoad2_N(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (float?)HashTableLoad2(place, "HD_" + key, lp_1, lp_2);
                default:
                    return DictionaryFloatLoad2_N(place, "HD_" + key, lp_1, lp_2);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns></returns>
        public static float? DataTableFloatLoad3_N(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (float?)HashTableLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
                default:
                    return DictionaryFloatLoad3_N(place, "HD_" + key, lp_1, lp_2, lp_3);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns></returns>
        public static float? DataTableFloatLoad4_N(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (float?)HashTableLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                default:
                    return DictionaryFloatLoad4_N(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static float DataTableFloatLoad0(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (float)HashTableLoad0(place, "HD_" + key);
                default:
                    return DictionaryFloatLoad0(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns></returns>
        public static float DataTableFloatLoad1(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (float)HashTableLoad1(place, "HD_" + key, lp_1);
                default:
                    return DictionaryFloatLoad1(place, "HD_" + key, lp_1);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns></returns>
        public static float DataTableFloatLoad2(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (float)HashTableLoad2(place, "HD_" + key, lp_1, lp_2);
                default:
                    return DictionaryFloatLoad2(place, "HD_" + key, lp_1, lp_2);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns></returns>
        public static float DataTableFloatLoad3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (float)HashTableLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
                default:
                    return DictionaryFloatLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns></returns>
        public static float DataTableFloatLoad4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (float)HashTableLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                default:
                    return DictionaryFloatLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
            }
        }

        #endregion

        #region Double

        /// <summary>
        /// 【MM_函数库】判断数据表键是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DataTableDoubleKeyExists(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableKeyExists(place, "HD_" + key);
                default:
                    return DictionaryDoubleKeyExists(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】判断数据表值是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool DataTableDoubleValueExists(bool place, double value)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableValueExists(place, value);
                default:
                    return DictionaryDoubleValueExists(place, value);
            }
        }

        /// <summary>
        /// 【MM_函数库】获取数据表键对应的值
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static double DataTableDoubleGetValue(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (double)HashTableGetValue(place, "HD_" + key);
                default:
                    return DictionaryDoubleGetValue(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        public static void DataTableDoubleClear0(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear0(place, "HD_" + key);
                    break;
                default:
                    DictionaryDoubleClear0(place, "HD_" + key);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[]，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        public static void DataTableDoubleClear1(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear1(place, "HD_" + key, lp_1);
                    break;
                default:
                    DictionaryDoubleClear1(place, "HD_" + key, lp_1);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,]，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        public static void DataTableDoubleClear2(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear2(place, "HD_" + key, lp_1, lp_2);
                    break;
                default:
                    DictionaryDoubleClear2(place, "HD_" + key, lp_1, lp_2);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,,]，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        public static void DataTableDoubleClear3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear3(place, "HD_" + key, lp_1, lp_2, lp_3);
                    break;
                default:
                    DictionaryDoubleClear3(place, "HD_" + key, lp_1, lp_2, lp_3);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,,,]，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        public static void DataTableDoubleClear4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                    break;
                default:
                    DictionaryDoubleClear4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】移除数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        private static void DataTableDoubleRemove(bool place, string key)//内部函数
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableRemove(place, "HD_" + key);
                    break;
                default:
                    DictionaryDoubleRemove(place, "HD_" + key);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        public static void DataTableDoubleSave0(bool place, string key, double val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave0(place, "HD_" + key, val);
                    break;
                default:
                    DictionaryDoubleSave0(place, "HD_" + key, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="val"></param>
        public static void DataTableDoubleSave1(bool place, string key, int lp_1, double val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave1(place, "HD_" + key, lp_1, val);
                    break;
                default:
                    DictionaryDoubleSave1(place, "HD_" + key, lp_1, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="val"></param>
        public static void DataTableDoubleSave2(bool place, string key, int lp_1, int lp_2, double val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave2(place, "HD_" + key, lp_1, lp_2, val);
                    break;
                default:
                    DictionaryDoubleSave2(place, "HD_" + key, lp_1, lp_2, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="val"></param>
        public static void DataTableDoubleSave3(bool place, string key, int lp_1, int lp_2, int lp_3, double val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave3(place, "HD_" + key, lp_1, lp_2, lp_3, val);
                    break;
                default:
                    DictionaryDoubleSave3(place, "HD_" + key, lp_1, lp_2, lp_3, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <param name="val"></param>
        public static void DataTableDoubleSave4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4, double val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4, val);
                    break;
                default:
                    DictionaryDoubleSave4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static double? DataTableDoubleLoad0_N(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (double?)HashTableLoad0(place, "HD_" + key);
                default:
                    return DictionaryDoubleLoad0_N(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns></returns>
        public static double? DataTableDoubleLoad1_N(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (double?)HashTableLoad1(place, "HD_" + key, lp_1);
                default:
                    return DictionaryDoubleLoad1_N(place, "HD_" + key, lp_1);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns></returns>
        public static double? DataTableDoubleLoad2_N(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (double?)HashTableLoad2(place, "HD_" + key, lp_1, lp_2);
                default:
                    return DictionaryDoubleLoad2_N(place, "HD_" + key, lp_1, lp_2);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns></returns>
        public static double? DataTableDoubleLoad3_N(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (double?)HashTableLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
                default:
                    return DictionaryDoubleLoad3_N(place, "HD_" + key, lp_1, lp_2, lp_3);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns></returns>
        public static double? DataTableDoubleLoad4_N(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (double?)HashTableLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                default:
                    return DictionaryDoubleLoad4_N(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static double DataTableDoubleLoad0(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (double)HashTableLoad0(place, "HD_" + key);
                default:
                    return DictionaryDoubleLoad0(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns></returns>
        public static double DataTableDoubleLoad1(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (double)HashTableLoad1(place, "HD_" + key, lp_1);
                default:
                    return DictionaryDoubleLoad1(place, "HD_" + key, lp_1);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns></returns>
        public static double DataTableDoubleLoad2(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (double)HashTableLoad2(place, "HD_" + key, lp_1, lp_2);
                default:
                    return DictionaryDoubleLoad2(place, "HD_" + key, lp_1, lp_2);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns></returns>
        public static double DataTableDoubleLoad3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (double)HashTableLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
                default:
                    return DictionaryDoubleLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns></returns>
        public static double DataTableDoubleLoad4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (double)HashTableLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                default:
                    return DictionaryDoubleLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
            }
        }

        #endregion

        #region Bool

        /// <summary>
        /// 【MM_函数库】判断数据表键是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DataTableBoolKeyExists(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableKeyExists(place, "HD_" + key);
                default:
                    return DictionaryBoolKeyExists(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】判断数据表值是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool DataTableBoolValueExists(bool place, bool value)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableValueExists(place, value);
                default:
                    return DictionaryBoolValueExists(place, value);
            }
        }

        /// <summary>
        /// 【MM_函数库】获取数据表键对应的值
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DataTableBoolGetValue(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (bool)HashTableGetValue(place, "HD_" + key);
                default:
                    return DictionaryBoolGetValue(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        public static void DataTableBoolClear0(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear0(place, "HD_" + key);
                    break;
                default:
                    DictionaryBoolClear0(place, "HD_" + key);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[]，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        public static void DataTableBoolClear1(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear1(place, "HD_" + key, lp_1);
                    break;
                default:
                    DictionaryBoolClear1(place, "HD_" + key, lp_1);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,]，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        public static void DataTableBoolClear2(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear2(place, "HD_" + key, lp_1, lp_2);
                    break;
                default:
                    DictionaryBoolClear2(place, "HD_" + key, lp_1, lp_2);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,,]，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        public static void DataTableBoolClear3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear3(place, "HD_" + key, lp_1, lp_2, lp_3);
                    break;
                default:
                    DictionaryBoolClear3(place, "HD_" + key, lp_1, lp_2, lp_3);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,,,]，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        public static void DataTableBoolClear4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                    break;
                default:
                    DictionaryBoolClear4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】移除数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        private static void DataTableBoolRemove(bool place, string key)//内部函数
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableRemove(place, "HD_" + key);
                    break;
                default:
                    DictionaryBoolRemove(place, "HD_" + key);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        public static void DataTableBoolSave0(bool place, string key, bool val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave0(place, "HD_" + key, val);
                    break;
                default:
                    DictionaryBoolSave0(place, "HD_" + key, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="val"></param>
        public static void DataTableBoolSave1(bool place, string key, int lp_1, bool val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave1(place, "HD_" + key, lp_1, val);
                    break;
                default:
                    DictionaryBoolSave1(place, "HD_" + key, lp_1, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="val"></param>
        public static void DataTableBoolSave2(bool place, string key, int lp_1, int lp_2, bool val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave2(place, "HD_" + key, lp_1, lp_2, val);
                    break;
                default:
                    DictionaryBoolSave2(place, "HD_" + key, lp_1, lp_2, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="val"></param>
        public static void DataTableBoolSave3(bool place, string key, int lp_1, int lp_2, int lp_3, bool val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave3(place, "HD_" + key, lp_1, lp_2, lp_3, val);
                    break;
                default:
                    DictionaryBoolSave3(place, "HD_" + key, lp_1, lp_2, lp_3, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <param name="val"></param>
        public static void DataTableBoolSave4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4, bool val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4, val);
                    break;
                default:
                    DictionaryBoolSave4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool? DataTableBoolLoad0_N(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (bool?)HashTableLoad0(place, "HD_" + key);
                default:
                    return DictionaryBoolLoad0_N(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns></returns>
        public static bool? DataTableBoolLoad1_N(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (bool?)HashTableLoad1(place, "HD_" + key, lp_1);
                default:
                    return DictionaryBoolLoad1_N(place, "HD_" + key, lp_1);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns></returns>
        public static bool? DataTableBoolLoad2_N(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (bool?)HashTableLoad2(place, "HD_" + key, lp_1, lp_2);
                default:
                    return DictionaryBoolLoad2_N(place, "HD_" + key, lp_1, lp_2);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns></returns>
        public static bool? DataTableBoolLoad3_N(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (bool?)HashTableLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
                default:
                    return DictionaryBoolLoad3_N(place, "HD_" + key, lp_1, lp_2, lp_3);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns></returns>
        public static bool? DataTableBoolLoad4_N(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (bool?)HashTableLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                default:
                    return DictionaryBoolLoad4_N(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DataTableBoolLoad0(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (bool)HashTableLoad0(place, "HD_" + key);
                default:
                    return DictionaryBoolLoad0(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns></returns>
        public static bool DataTableBoolLoad1(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (bool)HashTableLoad1(place, "HD_" + key, lp_1);
                default:
                    return DictionaryBoolLoad1(place, "HD_" + key, lp_1);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns></returns>
        public static bool DataTableBoolLoad2(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (bool)HashTableLoad2(place, "HD_" + key, lp_1, lp_2);
                default:
                    return DictionaryBoolLoad2(place, "HD_" + key, lp_1, lp_2);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns></returns>
        public static bool DataTableBoolLoad3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (bool)HashTableLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
                default:
                    return DictionaryBoolLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns></returns>
        public static bool DataTableBoolLoad4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (bool)HashTableLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                default:
                    return DictionaryBoolLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
            }
        }

        #endregion

        #region Byte

        /// <summary>
        /// 【MM_函数库】判断数据表键是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DataTableByteKeyExists(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableKeyExists(place, "HD_" + key);
                default:
                    return DictionaryByteKeyExists(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】判断数据表值是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool DataTableByteValueExists(bool place, byte value)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return HashTableValueExists(place, value);
                default:
                    return DictionaryByteValueExists(place, value);
            }
        }

        /// <summary>
        /// 【MM_函数库】获取数据表键对应的值
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static byte DataTableByteGetValue(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (byte)HashTableGetValue(place, "HD_" + key);
                default:
                    return DictionaryByteGetValue(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        public static void DataTableByteClear0(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear0(place, "HD_" + key);
                    break;
                default:
                    DictionaryByteClear0(place, "HD_" + key);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[]，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        public static void DataTableByteClear1(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear1(place, "HD_" + key, lp_1);
                    break;
                default:
                    DictionaryByteClear1(place, "HD_" + key, lp_1);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,]，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        public static void DataTableByteClear2(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear2(place, "HD_" + key, lp_1, lp_2);
                    break;
                default:
                    DictionaryByteClear2(place, "HD_" + key, lp_1, lp_2);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,,]，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        public static void DataTableByteClear3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear3(place, "HD_" + key, lp_1, lp_2, lp_3);
                    break;
                default:
                    DictionaryByteClear3(place, "HD_" + key, lp_1, lp_2, lp_3);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】从数据表中清除Key[,,,]，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        public static void DataTableByteClear4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableClear4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                    break;
                default:
                    DictionaryByteClear4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】移除数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        private static void DataTableByteRemove(bool place, string key)//内部函数
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableRemove(place, "HD_" + key);
                    break;
                default:
                    DictionaryByteRemove(place, "HD_" + key);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        public static void DataTableByteSave0(bool place, string key, byte val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave0(place, "HD_" + key, val);
                    break;
                default:
                    DictionaryByteSave0(place, "HD_" + key, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="val"></param>
        public static void DataTableByteSave1(bool place, string key, int lp_1, byte val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave1(place, "HD_" + key, lp_1, val);
                    break;
                default:
                    DictionaryByteSave1(place, "HD_" + key, lp_1, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="val"></param>
        public static void DataTableByteSave2(bool place, string key, int lp_1, int lp_2, byte val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave2(place, "HD_" + key, lp_1, lp_2, val);
                    break;
                default:
                    DictionaryByteSave2(place, "HD_" + key, lp_1, lp_2, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="val"></param>
        public static void DataTableByteSave3(bool place, string key, int lp_1, int lp_2, int lp_3, byte val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave3(place, "HD_" + key, lp_1, lp_2, lp_3, val);
                    break;
                default:
                    DictionaryByteSave3(place, "HD_" + key, lp_1, lp_2, lp_3, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】保存数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <param name="val"></param>
        public static void DataTableByteSave4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4, byte val)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    HashTableSave4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4, val);
                    break;
                default:
                    DictionaryByteSave4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4, val);
                    break;
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static byte? DataTableByteLoad0_N(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (byte?)HashTableLoad0(place, "HD_" + key);
                default:
                    return DictionaryByteLoad0_N(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns></returns>
        public static byte? DataTableByteLoad1_N(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (byte?)HashTableLoad1(place, "HD_" + key, lp_1);
                default:
                    return DictionaryByteLoad1_N(place, "HD_" + key, lp_1);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns></returns>
        public static byte? DataTableByteLoad2_N(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (byte?)HashTableLoad2(place, "HD_" + key, lp_1, lp_2);
                default:
                    return DictionaryByteLoad2_N(place, "HD_" + key, lp_1, lp_2);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns></returns>
        public static byte? DataTableByteLoad3_N(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (byte?)HashTableLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
                default:
                    return DictionaryByteLoad3_N(place, "HD_" + key, lp_1, lp_2, lp_3);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns></returns>
        public static byte? DataTableByteLoad4_N(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (byte?)HashTableLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                default:
                    return DictionaryByteLoad4_N(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static byte DataTableByteLoad0(bool place, string key)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (byte)HashTableLoad0(place, "HD_" + key);
                default:
                    return DictionaryByteLoad0(place, "HD_" + key);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns></returns>
        public static byte DataTableByteLoad1(bool place, string key, int lp_1)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (byte)HashTableLoad1(place, "HD_" + key, lp_1);
                default:
                    return DictionaryByteLoad1(place, "HD_" + key, lp_1);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns></returns>
        public static byte DataTableByteLoad2(bool place, string key, int lp_1, int lp_2)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (byte)HashTableLoad2(place, "HD_" + key, lp_1, lp_2);
                default:
                    return DictionaryByteLoad2(place, "HD_" + key, lp_1, lp_2);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns></returns>
        public static byte DataTableByteLoad3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (byte)HashTableLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
                default:
                    return DictionaryByteLoad3(place, "HD_" + key, lp_1, lp_2, lp_3);
            }
        }

        /// <summary>
        /// 【MM_函数库】读取数据表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns></returns>
        public static byte DataTableByteLoad4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            switch (DataTableType)
            {
                case "HashTable":
                    return (byte)HashTableLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
                default:
                    return DictionaryByteLoad4(place, "HD_" + key, lp_1, lp_2, lp_3, lp_4);
            }
        }

        #endregion

        #endregion

        #endregion

        #region 基础数据表

        #region 哈希表

        //使用哈希表设计存取任意类型

        /// <summary>
        /// 【MM_函数库】添加哈希表键值对（重复添加则覆盖）
        /// </summary>
        /// <param name="place">true=全局，false=临时</param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        private static void HashTableSet(bool place, string key, object val)//内部使用
        {
            if (place)
            {
                //存入全局哈希表
                systemHashTable[key] = val;

                //if (systemHashTable.Contains(key)) 
                //{
                //    systemHashTable.Remove(key);
                //}
                //systemHashTable.Add(key, val);

            }
            else
            {
                //存入局部哈希表
                tempHashTable[key] = val;

                //if (tempHashTable.Contains(key)) { tempHashTable.Remove(key); }
                //tempHashTable.Add(key, val);
            }
        }

        /// <summary>
        /// 【MM_函数库】判断哈希表键是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool HashTableKeyExists(bool place, string key)
        {
            if (place) { return systemHashTable.ContainsKey(key); }
            else { return tempHashTable.ContainsKey(key); }
        }

        /// <summary>
        /// 【MM_函数库】判断哈希表值是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool HashTableValueExists(bool place, object value)
        {
            if (place) { return systemHashTable.ContainsValue(value); }
            else { return tempHashTable.ContainsValue(value); }
        }

        /// <summary>
        /// 【MM_函数库】获取哈希表键对应的值
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static object HashTableGetValue(bool place, string key)
        {
            if (place) { return systemHashTable[key]; }
            else { return tempHashTable[key]; }
        }

        /// <summary>
        /// 【MM_函数库】从哈希表中清除Key
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        public static void HashTableClear0(bool place, string key)
        {
            HashTableRemove(place, key);
        }

        /// <summary>
        /// 【MM_函数库】从哈希表中清除Key[]，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        public static void HashTableClear1(bool place, string key, int lp_1)
        {
            HashTableRemove(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从哈希表中清除Key[,]，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        public static void HashTableClear2(bool place, string key, int lp_1, int lp_2)
        {
            HashTableRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从哈希表中清除Key[,,]，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        public static void HashTableClear3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            HashTableRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从哈希表中清除Key[,,,]，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        public static void HashTableClear4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            HashTableRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】移除哈希表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        private static void HashTableRemove(bool place, string key)//内部函数
        {
            if (place) { systemHashTable.Remove(key); }
            else { tempHashTable.Remove(key); }
        }

        /// <summary>
        /// 【MM_函数库】保存哈希表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        public static void HashTableSave0(bool place, string key, object val)
        {
            HashTableSet(place, key, val);
        }

        /// <summary>
        /// 【MM_函数库】保存哈希表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="val"></param>
        public static void HashTableSave1(bool place, string key, int lp_1, object val)
        {
            HashTableSet(place, (key + "_" + lp_1.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存哈希表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="val"></param>
        public static void HashTableSave2(bool place, string key, int lp_1, int lp_2, object val)
        {
            HashTableSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存哈希表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="val"></param>
        public static void HashTableSave3(bool place, string key, int lp_1, int lp_2, int lp_3, object val)
        {
            HashTableSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存哈希表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <param name="val"></param>
        public static void HashTableSave4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4, object val)
        {
            HashTableSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】读取哈希表键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static object HashTableLoad0(bool place, string key)
        {
            if ((HashTableKeyExists(place, key) == false))
            {
                return null;
            }
            return HashTableGetValue(place, key);
        }

        /// <summary>
        /// 【MM_函数库】读取哈希表键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns></returns>
        public static object HashTableLoad1(bool place, string key, int lp_1)
        {
            if ((HashTableKeyExists(place, (key + "_" + lp_1.ToString())) == false))
            {
                return null;
            }
            return HashTableGetValue(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取哈希表键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns></returns>
        public static object HashTableLoad2(bool place, string key, int lp_1, int lp_2)
        {
            if ((HashTableKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString())) == false))
            {
                return null;
            }
            return HashTableGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取哈希表键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns></returns>
        public static object HashTableLoad3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            if ((HashTableKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString())) == false))
            {
                return null;
            }
            return HashTableGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取哈希表键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns></returns>
        public static object HashTableLoad4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            if ((HashTableKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString())) == false))
            {
                return null;
            }
            return HashTableGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        #endregion

        #region 字典

        //使用字典设计存取指定类型

        #region 值类型

        #region Int字典

        /// <summary>
        /// 【MM_函数库】添加字典键值对（重复添加则覆盖）
        /// </summary>
        /// <param name="place">true=全局，false=局部</param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        private static void DictionaryIntSet(bool place, string key, int val)//内部使用
        {
            if (place)
            {
                //存入全局字典
                systemDictionaryInt[key] = val;

                //if (systemDictionaryInt.Contains(key)) 
                //{
                //    systemDictionaryInt.Remove(key);
                //}
                //systemDictionaryInt.Add(key, val);

            }
            else
            {
                //存入局部字典
                tempDictionaryInt[key] = val;

                //if (tempDictionaryInt.Contains(key)) { tempDictionaryInt.Remove(key); }
                //tempDictionaryInt.Add(key, val);
            }
        }

        /// <summary>
        /// 【MM_函数库】判断字典键是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DictionaryIntKeyExists(bool place, string key)
        {
            if (place) { return systemDictionaryInt.ContainsKey(key); }
            else { return tempDictionaryInt.ContainsKey(key); }
        }

        /// <summary>
        /// 【MM_函数库】判断字典值是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool DictionaryIntValueExists(bool place, int value)
        {
            if (place) { return systemDictionaryInt.ContainsValue(value); }
            else { return tempDictionaryInt.ContainsValue(value); }
        }

        /// <summary>
        /// 【MM_函数库】获取字典键对应的值
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static int DictionaryIntGetValue(bool place, string key)
        {
            if (place) { return systemDictionaryInt[key]; }
            else { return tempDictionaryInt[key]; }
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        public static void DictionaryIntClear0(bool place, string key)
        {
            DictionaryIntRemove(place, key);
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[]，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        public static void DictionaryIntClear1(bool place, string key, int lp_1)
        {
            DictionaryIntRemove(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,]，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        public static void DictionaryIntClear2(bool place, string key, int lp_1, int lp_2)
        {
            DictionaryIntRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,,]，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        public static void DictionaryIntClear3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            DictionaryIntRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,,,]，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        public static void DictionaryIntClear4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            DictionaryIntRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】移除字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        private static void DictionaryIntRemove(bool place, string key)//内部函数
        {
            if (place) { systemDictionaryInt.Remove(key); }
            else { tempDictionaryInt.Remove(key); }
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        public static void DictionaryIntSave0(bool place, string key, int val)
        {
            DictionaryIntSet(place, key, val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="val"></param>
        public static void DictionaryIntSave1(bool place, string key, int lp_1, int val)
        {
            DictionaryIntSet(place, (key + "_" + lp_1.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="val"></param>
        public static void DictionaryIntSave2(bool place, string key, int lp_1, int lp_2, int val)
        {
            DictionaryIntSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="val"></param>
        public static void DictionaryIntSave3(bool place, string key, int lp_1, int lp_2, int lp_3, int val)
        {
            DictionaryIntSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <param name="val"></param>
        public static void DictionaryIntSave4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4, int val)
        {
            DictionaryIntSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns>错误时返回null</returns>
        public static int? DictionaryIntLoad0_N(bool place, string key)
        {
            if ((DictionaryIntKeyExists(place, key) == false))
            {
                return null;
            }
            return DictionaryIntGetValue(place, key);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns>错误时返回null</returns>
        public static int? DictionaryIntLoad1_N(bool place, string key, int lp_1)
        {
            if ((DictionaryIntKeyExists(place, (key + "_" + lp_1.ToString())) == false))
            {
                return null;
            }
            return DictionaryIntGetValue(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns>错误时返回null</returns>
        public static int? DictionaryIntLoad2_N(bool place, string key, int lp_1, int lp_2)
        {
            if ((DictionaryIntKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString())) == false))
            {
                return null;
            }
            return DictionaryIntGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns>错误时返回null</returns>
        public static int? DictionaryIntLoad3_N(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            if ((DictionaryIntKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString())) == false))
            {
                return null;
            }
            return DictionaryIntGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns>错误时返回null</returns>
        public static int? DictionaryIntLoad4_N(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            if ((DictionaryIntKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString())) == false))
            {
                return null;
            }
            return DictionaryIntGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns>错误时返回0</returns>
        public static int DictionaryIntLoad0(bool place, string key)
        {
            if ((DictionaryIntKeyExists(place, key) == false))
            {
                return 0;
            }
            return DictionaryIntGetValue(place, key);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns>错误时返回0</returns>
        public static int DictionaryIntLoad1(bool place, string key, int lp_1)
        {
            if ((DictionaryIntKeyExists(place, (key + "_" + lp_1.ToString())) == false))
            {
                return 0;
            }
            return DictionaryIntGetValue(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns>错误时返回0</returns>
        public static int DictionaryIntLoad2(bool place, string key, int lp_1, int lp_2)
        {
            if ((DictionaryIntKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString())) == false))
            {
                return 0;
            }
            return DictionaryIntGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns>错误时返回0</returns>
        public static int DictionaryIntLoad3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            if ((DictionaryIntKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString())) == false))
            {
                return 0;
            }
            return DictionaryIntGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns>错误时返回0</returns>
        public static int DictionaryIntLoad4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            if ((DictionaryIntKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString())) == false))
            {
                return 0;
            }
            return DictionaryIntGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        #endregion

        #region Long字典

        /// <summary>
        /// 【MM_函数库】添加字典键值对（重复添加则覆盖）
        /// </summary>
        /// <param name="place">true=全局，false=局部</param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        private static void DictionaryLongSet(bool place, string key, long val)//内部使用
        {
            if (place)
            {
                //存入全局字典
                systemDictionaryLong[key] = val;

                //if (systemDictionaryLong.Contains(key)) 
                //{
                //    systemDictionaryLong.Remove(key);
                //}
                //systemDictionaryLong.Add(key, val);

            }
            else
            {
                //存入局部字典
                tempDictionaryLong[key] = val;

                //if (tempDictionaryLong.Contains(key)) { tempDictionaryLong.Remove(key); }
                //tempDictionaryLong.Add(key, val);
            }
        }

        /// <summary>
        /// 【MM_函数库】判断字典键是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DictionaryLongKeyExists(bool place, string key)
        {
            if (place) { return systemDictionaryLong.ContainsKey(key); }
            else { return tempDictionaryLong.ContainsKey(key); }
        }

        /// <summary>
        /// 【MM_函数库】判断字典值是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool DictionaryLongValueExists(bool place, long value)
        {
            if (place) { return systemDictionaryLong.ContainsValue(value); }
            else { return tempDictionaryLong.ContainsValue(value); }
        }

        /// <summary>
        /// 【MM_函数库】获取字典键对应的值
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static long DictionaryLongGetValue(bool place, string key)
        {
            if (place) { return systemDictionaryLong[key]; }
            else { return tempDictionaryLong[key]; }
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        public static void DictionaryLongClear0(bool place, string key)
        {
            DictionaryLongRemove(place, key);
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[]，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        public static void DictionaryLongClear1(bool place, string key, int lp_1)
        {
            DictionaryLongRemove(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,]，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        public static void DictionaryLongClear2(bool place, string key, int lp_1, int lp_2)
        {
            DictionaryLongRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,,]，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        public static void DictionaryLongClear3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            DictionaryLongRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,,,]，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        public static void DictionaryLongClear4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            DictionaryLongRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】移除字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        private static void DictionaryLongRemove(bool place, string key)//内部函数
        {
            if (place) { systemDictionaryLong.Remove(key); }
            else { tempDictionaryLong.Remove(key); }
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        public static void DictionaryLongSave0(bool place, string key, long val)
        {
            DictionaryLongSet(place, key, val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="val"></param>
        public static void DictionaryLongSave1(bool place, string key, int lp_1, long val)
        {
            DictionaryLongSet(place, (key + "_" + lp_1.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="val"></param>
        public static void DictionaryLongSave2(bool place, string key, int lp_1, int lp_2, long val)
        {
            DictionaryLongSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="val"></param>
        public static void DictionaryLongSave3(bool place, string key, int lp_1, int lp_2, int lp_3, long val)
        {
            DictionaryLongSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <param name="val"></param>
        public static void DictionaryLongSave4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4, long val)
        {
            DictionaryLongSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns>错误时返回null</returns>
        public static long? DictionaryLongLoad0_N(bool place, string key)
        {
            if ((DictionaryLongKeyExists(place, key) == false))
            {
                return null;
            }
            return DictionaryLongGetValue(place, key);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns>错误时返回null</returns>
        public static long? DictionaryLongLoad1_N(bool place, string key, int lp_1)
        {
            if ((DictionaryLongKeyExists(place, (key + "_" + lp_1.ToString())) == false))
            {
                return null;
            }
            return DictionaryLongGetValue(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns>错误时返回null</returns>
        public static long? DictionaryLongLoad2_N(bool place, string key, int lp_1, int lp_2)
        {
            if ((DictionaryLongKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString())) == false))
            {
                return null;
            }
            return DictionaryLongGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns>错误时返回null</returns>
        public static long? DictionaryLongLoad3_N(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            if ((DictionaryLongKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString())) == false))
            {
                return null;
            }
            return DictionaryLongGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns>错误时返回null</returns>
        public static long? DictionaryLongLoad4_N(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            if ((DictionaryLongKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString())) == false))
            {
                return null;
            }
            return DictionaryLongGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns>错误时返回0</returns>
        public static long DictionaryLongLoad0(bool place, string key)
        {
            if ((DictionaryLongKeyExists(place, key) == false))
            {
                return 0;
            }
            return DictionaryLongGetValue(place, key);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns>错误时返回0</returns>
        public static long DictionaryLongLoad1(bool place, string key, int lp_1)
        {
            if ((DictionaryLongKeyExists(place, (key + "_" + lp_1.ToString())) == false))
            {
                return 0;
            }
            return DictionaryLongGetValue(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns>错误时返回0</returns>
        public static long DictionaryLongLoad2(bool place, string key, int lp_1, int lp_2)
        {
            if ((DictionaryLongKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString())) == false))
            {
                return 0;
            }
            return DictionaryLongGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns>错误时返回0</returns>
        public static long DictionaryLongLoad3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            if ((DictionaryLongKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString())) == false))
            {
                return 0;
            }
            return DictionaryLongGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns>错误时返回0</returns>
        public static long DictionaryLongLoad4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            if ((DictionaryLongKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString())) == false))
            {
                return 0;
            }
            return DictionaryLongGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        #endregion

        #region Char字典

        /// <summary>
        /// 【MM_函数库】添加字典键值对（重复添加则覆盖）
        /// </summary>
        /// <param name="place">true=全局，false=局部</param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        private static void DictionaryCharSet(bool place, string key, char val)//内部使用
        {
            if (place)
            {
                //存入全局字典
                systemDictionaryChar[key] = val;

                //if (systemDictionaryChar.Contains(key)) 
                //{
                //    systemDictionaryChar.Remove(key);
                //}
                //systemDictionaryChar.Add(key, val);

            }
            else
            {
                //存入局部字典
                tempDictionaryChar[key] = val;

                //if (tempDictionaryChar.Contains(key)) { tempDictionaryChar.Remove(key); }
                //tempDictionaryChar.Add(key, val);
            }
        }

        /// <summary>
        /// 【MM_函数库】判断字典键是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DictionaryCharKeyExists(bool place, string key)
        {
            if (place) { return systemDictionaryChar.ContainsKey(key); }
            else { return tempDictionaryChar.ContainsKey(key); }
        }

        /// <summary>
        /// 【MM_函数库】判断字典值是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool DictionaryCharValueExists(bool place, char value)
        {
            if (place) { return systemDictionaryChar.ContainsValue(value); }
            else { return tempDictionaryChar.ContainsValue(value); }
        }

        /// <summary>
        /// 【MM_函数库】获取字典键对应的值
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static char DictionaryCharGetValue(bool place, string key)
        {
            if (place) { return systemDictionaryChar[key]; }
            else { return tempDictionaryChar[key]; }
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        public static void DictionaryCharClear0(bool place, string key)
        {
            DictionaryCharRemove(place, key);
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[]，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        public static void DictionaryCharClear1(bool place, string key, int lp_1)
        {
            DictionaryCharRemove(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,]，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        public static void DictionaryCharClear2(bool place, string key, int lp_1, int lp_2)
        {
            DictionaryCharRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,,]，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        public static void DictionaryCharClear3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            DictionaryCharRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,,,]，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        public static void DictionaryCharClear4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            DictionaryCharRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】移除字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        private static void DictionaryCharRemove(bool place, string key)//内部函数
        {
            if (place) { systemDictionaryChar.Remove(key); }
            else { tempDictionaryChar.Remove(key); }
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        public static void DictionaryCharSave0(bool place, string key, char val)
        {
            DictionaryCharSet(place, key, val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="val"></param>
        public static void DictionaryCharSave1(bool place, string key, int lp_1, char val)
        {
            DictionaryCharSet(place, (key + "_" + lp_1.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="val"></param>
        public static void DictionaryCharSave2(bool place, string key, int lp_1, int lp_2, char val)
        {
            DictionaryCharSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="val"></param>
        public static void DictionaryCharSave3(bool place, string key, int lp_1, int lp_2, int lp_3, char val)
        {
            DictionaryCharSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <param name="val"></param>
        public static void DictionaryCharSave4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4, char val)
        {
            DictionaryCharSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns>错误时返回null</returns>
        public static char? DictionaryCharLoad0_N(bool place, string key)
        {
            if ((DictionaryCharKeyExists(place, key) == false))
            {
                return null;
            }
            return DictionaryCharGetValue(place, key);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns>错误时返回null</returns>
        public static char? DictionaryCharLoad1_N(bool place, string key, int lp_1)
        {
            if ((DictionaryCharKeyExists(place, (key + "_" + lp_1.ToString())) == false))
            {
                return null;
            }
            return DictionaryCharGetValue(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns>错误时返回null</returns>
        public static char? DictionaryCharLoad2_N(bool place, string key, int lp_1, int lp_2)
        {
            if ((DictionaryCharKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString())) == false))
            {
                return null;
            }
            return DictionaryCharGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns>错误时返回null</returns>
        public static char? DictionaryCharLoad3_N(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            if ((DictionaryCharKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString())) == false))
            {
                return null;
            }
            return DictionaryCharGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns>错误时返回null</returns>
        public static char? DictionaryCharLoad4_N(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            if ((DictionaryCharKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString())) == false))
            {
                return null;
            }
            return DictionaryCharGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns>错误时返回' '</returns>
        public static char DictionaryCharLoad0(bool place, string key)
        {
            if ((DictionaryCharKeyExists(place, key) == false))
            {
                return ' ';
            }
            return DictionaryCharGetValue(place, key);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns>错误时返回' '</returns>
        public static char DictionaryCharLoad1(bool place, string key, int lp_1)
        {
            if ((DictionaryCharKeyExists(place, (key + "_" + lp_1.ToString())) == false))
            {
                return ' ';
            }
            return DictionaryCharGetValue(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns>错误时返回' '</returns>
        public static char DictionaryCharLoad2(bool place, string key, int lp_1, int lp_2)
        {
            if ((DictionaryCharKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString())) == false))
            {
                return ' ';
            }
            return DictionaryCharGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns>错误时返回' '</returns>
        public static char DictionaryCharLoad3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            if ((DictionaryCharKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString())) == false))
            {
                return ' ';
            }
            return DictionaryCharGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns>错误时返回' '</returns>
        public static char DictionaryCharLoad4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            if ((DictionaryCharKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString())) == false))
            {
                return ' ';
            }
            return DictionaryCharGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        #endregion

        #region Float字典

        /// <summary>
        /// 【MM_函数库】添加字典键值对（重复添加则覆盖）
        /// </summary>
        /// <param name="place">true=全局，false=局部</param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        private static void DictionaryFloatSet(bool place, string key, float val)//内部使用
        {
            if (place)
            {
                //存入全局字典
                systemDictionaryFloat[key] = val;

                //if (systemDictionaryFloat.Contains(key)) 
                //{
                //    systemDictionaryFloat.Remove(key);
                //}
                //systemDictionaryFloat.Add(key, val);

            }
            else
            {
                //存入局部字典
                tempDictionaryFloat[key] = val;

                //if (tempDictionaryFloat.Contains(key)) { tempDictionaryFloat.Remove(key); }
                //tempDictionaryFloat.Add(key, val);
            }
        }

        /// <summary>
        /// 【MM_函数库】判断字典键是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DictionaryFloatKeyExists(bool place, string key)
        {
            if (place) { return systemDictionaryFloat.ContainsKey(key); }
            else { return tempDictionaryFloat.ContainsKey(key); }
        }

        /// <summary>
        /// 【MM_函数库】判断字典值是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool DictionaryFloatValueExists(bool place, float value)
        {
            if (place) { return systemDictionaryFloat.ContainsValue(value); }
            else { return tempDictionaryFloat.ContainsValue(value); }
        }

        /// <summary>
        /// 【MM_函数库】获取字典键对应的值
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static float DictionaryFloatGetValue(bool place, string key)
        {
            if (place) { return systemDictionaryFloat[key]; }
            else { return tempDictionaryFloat[key]; }
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        public static void DictionaryFloatClear0(bool place, string key)
        {
            DictionaryFloatRemove(place, key);
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[]，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        public static void DictionaryFloatClear1(bool place, string key, int lp_1)
        {
            DictionaryFloatRemove(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,]，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        public static void DictionaryFloatClear2(bool place, string key, int lp_1, int lp_2)
        {
            DictionaryFloatRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,,]，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        public static void DictionaryFloatClear3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            DictionaryFloatRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,,,]，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        public static void DictionaryFloatClear4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            DictionaryFloatRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】移除字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        private static void DictionaryFloatRemove(bool place, string key)//内部函数
        {
            if (place) { systemDictionaryFloat.Remove(key); }
            else { tempDictionaryFloat.Remove(key); }
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        public static void DictionaryFloatSave0(bool place, string key, float val)
        {
            DictionaryFloatSet(place, key, val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="val"></param>
        public static void DictionaryFloatSave1(bool place, string key, int lp_1, float val)
        {
            DictionaryFloatSet(place, (key + "_" + lp_1.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="val"></param>
        public static void DictionaryFloatSave2(bool place, string key, int lp_1, int lp_2, float val)
        {
            DictionaryFloatSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="val"></param>
        public static void DictionaryFloatSave3(bool place, string key, int lp_1, int lp_2, int lp_3, float val)
        {
            DictionaryFloatSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <param name="val"></param>
        public static void DictionaryFloatSave4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4, float val)
        {
            DictionaryFloatSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns>错误时返回null</returns>
        public static float? DictionaryFloatLoad0_N(bool place, string key)
        {
            if ((DictionaryFloatKeyExists(place, key) == false))
            {
                return null;
            }
            return DictionaryFloatGetValue(place, key);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns>错误时返回null</returns>
        public static float? DictionaryFloatLoad1_N(bool place, string key, int lp_1)
        {
            if ((DictionaryFloatKeyExists(place, (key + "_" + lp_1.ToString())) == false))
            {
                return null;
            }
            return DictionaryFloatGetValue(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns>错误时返回null</returns>
        public static float? DictionaryFloatLoad2_N(bool place, string key, int lp_1, int lp_2)
        {
            if ((DictionaryFloatKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString())) == false))
            {
                return null;
            }
            return DictionaryFloatGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns>错误时返回null</returns>
        public static float? DictionaryFloatLoad3_N(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            if ((DictionaryFloatKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString())) == false))
            {
                return null;
            }
            return DictionaryFloatGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns>错误时返回null</returns>
        public static float? DictionaryFloatLoad4_N(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            if ((DictionaryFloatKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString())) == false))
            {
                return null;
            }
            return DictionaryFloatGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns>错误时返回0.0f</returns>
        public static float DictionaryFloatLoad0(bool place, string key)
        {
            if ((DictionaryFloatKeyExists(place, key) == false))
            {
                return 0.0f;
            }
            return DictionaryFloatGetValue(place, key);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns>错误时返回0.0f</returns>
        public static float DictionaryFloatLoad1(bool place, string key, int lp_1)
        {
            if ((DictionaryFloatKeyExists(place, (key + "_" + lp_1.ToString())) == false))
            {
                return 0.0f;
            }
            return DictionaryFloatGetValue(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns>错误时返回0.0f</returns>
        public static float DictionaryFloatLoad2(bool place, string key, int lp_1, int lp_2)
        {
            if ((DictionaryFloatKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString())) == false))
            {
                return 0.0f;
            }
            return DictionaryFloatGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns>错误时返回0.0f</returns>
        public static float DictionaryFloatLoad3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            if ((DictionaryFloatKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString())) == false))
            {
                return 0.0f;
            }
            return DictionaryFloatGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns>错误时返回0.0f</returns>
        public static float DictionaryFloatLoad4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            if ((DictionaryFloatKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString())) == false))
            {
                return 0.0f;
            }
            return DictionaryFloatGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        #endregion

        #region Double字典

        /// <summary>
        /// 【MM_函数库】添加字典键值对（重复添加则覆盖）
        /// </summary>
        /// <param name="place">true=全局，false=局部</param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        private static void DictionaryDoubleSet(bool place, string key, double val)//内部使用
        {
            if (place)
            {
                //存入全局字典
                systemDictionaryDouble[key] = val;

                //if (systemDictionaryDouble.Contains(key)) 
                //{
                //    systemDictionaryDouble.Remove(key);
                //}
                //systemDictionaryDouble.Add(key, val);

            }
            else
            {
                //存入局部字典
                tempDictionaryDouble[key] = val;

                //if (tempDictionaryDouble.Contains(key)) { tempDictionaryDouble.Remove(key); }
                //tempDictionaryDouble.Add(key, val);
            }
        }

        /// <summary>
        /// 【MM_函数库】判断字典键是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DictionaryDoubleKeyExists(bool place, string key)
        {
            if (place) { return systemDictionaryDouble.ContainsKey(key); }
            else { return tempDictionaryDouble.ContainsKey(key); }
        }

        /// <summary>
        /// 【MM_函数库】判断字典值是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool DictionaryDoubleValueExists(bool place, double value)
        {
            if (place) { return systemDictionaryDouble.ContainsValue(value); }
            else { return tempDictionaryDouble.ContainsValue(value); }
        }

        /// <summary>
        /// 【MM_函数库】获取字典键对应的值
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static double DictionaryDoubleGetValue(bool place, string key)
        {
            if (place) { return systemDictionaryDouble[key]; }
            else { return tempDictionaryDouble[key]; }
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        public static void DictionaryDoubleClear0(bool place, string key)
        {
            DictionaryDoubleRemove(place, key);
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[]，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        public static void DictionaryDoubleClear1(bool place, string key, int lp_1)
        {
            DictionaryDoubleRemove(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,]，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        public static void DictionaryDoubleClear2(bool place, string key, int lp_1, int lp_2)
        {
            DictionaryDoubleRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,,]，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        public static void DictionaryDoubleClear3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            DictionaryDoubleRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,,,]，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        public static void DictionaryDoubleClear4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            DictionaryDoubleRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】移除字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        private static void DictionaryDoubleRemove(bool place, string key)//内部函数
        {
            if (place) { systemDictionaryDouble.Remove(key); }
            else { tempDictionaryDouble.Remove(key); }
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        public static void DictionaryDoubleSave0(bool place, string key, double val)
        {
            DictionaryDoubleSet(place, key, val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="val"></param>
        public static void DictionaryDoubleSave1(bool place, string key, int lp_1, double val)
        {
            DictionaryDoubleSet(place, (key + "_" + lp_1.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="val"></param>
        public static void DictionaryDoubleSave2(bool place, string key, int lp_1, int lp_2, double val)
        {
            DictionaryDoubleSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="val"></param>
        public static void DictionaryDoubleSave3(bool place, string key, int lp_1, int lp_2, int lp_3, double val)
        {
            DictionaryDoubleSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <param name="val"></param>
        public static void DictionaryDoubleSave4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4, double val)
        {
            DictionaryDoubleSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns>错误时返回null</returns>
        public static double? DictionaryDoubleLoad0_N(bool place, string key)
        {
            if (DictionaryDoubleKeyExists(place, key) == false)
            {
                return null;
            }
            return DictionaryDoubleGetValue(place, key);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns>错误时返回null</returns>
        public static double? DictionaryDoubleLoad1_N(bool place, string key, int lp_1)
        {
            if ((DictionaryDoubleKeyExists(place, (key + "_" + lp_1.ToString())) == false))
            {
                return null;
            }
            return DictionaryDoubleGetValue(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns>错误时返回null</returns>
        public static double? DictionaryDoubleLoad2_N(bool place, string key, int lp_1, int lp_2)
        {
            if ((DictionaryDoubleKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString())) == false))
            {
                return null;
            }
            return DictionaryDoubleGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns>错误时返回null</returns>
        public static double? DictionaryDoubleLoad3_N(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            if ((DictionaryDoubleKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString())) == false))
            {
                return null;
            }
            return DictionaryDoubleGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns>错误时返回null</returns>
        public static double? DictionaryDoubleLoad4_N(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            if ((DictionaryDoubleKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString())) == false))
            {
                return null;
            }
            return DictionaryDoubleGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns>错误时返回0.0</returns>
        public static double DictionaryDoubleLoad0(bool place, string key)
        {
            if (DictionaryDoubleKeyExists(place, key) == false)
            {
                return 0.0;
            }
            return DictionaryDoubleGetValue(place, key);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns>错误时返回0.0</returns>
        public static double DictionaryDoubleLoad1(bool place, string key, int lp_1)
        {
            if ((DictionaryDoubleKeyExists(place, (key + "_" + lp_1.ToString())) == false))
            {
                return 0.0;
            }
            return DictionaryDoubleGetValue(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns>错误时返回0.0</returns>
        public static double DictionaryDoubleLoad2(bool place, string key, int lp_1, int lp_2)
        {
            if ((DictionaryDoubleKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString())) == false))
            {
                return 0.0;
            }
            return DictionaryDoubleGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns>错误时返回0.0</returns>
        public static double DictionaryDoubleLoad3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            if ((DictionaryDoubleKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString())) == false))
            {
                return 0.0;
            }
            return DictionaryDoubleGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns>错误时返回0.0</returns>
        public static double DictionaryDoubleLoad4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            if ((DictionaryDoubleKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString())) == false))
            {
                return 0.0;
            }
            return DictionaryDoubleGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        #endregion

        #region Bool字典

        /// <summary>
        /// 【MM_函数库】添加字典键值对（重复添加则覆盖）
        /// </summary>
        /// <param name="place">true=全局，false=局部</param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        private static void DictionaryBoolSet(bool place, string key, bool val)//内部使用
        {
            if (place)
            {
                //存入全局字典
                systemDictionaryBool[key] = val;

                //if (systemDictionaryBool.Contains(key)) 
                //{
                //    systemDictionaryBool.Remove(key);
                //}
                //systemDictionaryBool.Add(key, val);

            }
            else
            {
                //存入局部字典
                tempDictionaryBool[key] = val;

                //if (tempDictionaryBool.Contains(key)) { tempDictionaryBool.Remove(key); }
                //tempDictionaryBool.Add(key, val);
            }
        }

        /// <summary>
        /// 【MM_函数库】判断字典键是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DictionaryBoolKeyExists(bool place, string key)
        {
            if (place)
            {
                return systemDictionaryBool.ContainsKey(key);
            }
            else { return tempDictionaryBool.ContainsKey(key); }
        }

        /// <summary>
        /// 【MM_函数库】判断字典值是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool DictionaryBoolValueExists(bool place, bool value)
        {
            if (place) { return systemDictionaryBool.ContainsValue(value); }
            else { return tempDictionaryBool.ContainsValue(value); }
        }

        /// <summary>
        /// 【MM_函数库】获取字典键对应的值
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DictionaryBoolGetValue(bool place, string key)
        {
            if (place) { return systemDictionaryBool[key]; }
            else { return tempDictionaryBool[key]; }
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        public static void DictionaryBoolClear0(bool place, string key)
        {
            DictionaryBoolRemove(place, key);
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[]，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        public static void DictionaryBoolClear1(bool place, string key, int lp_1)
        {
            DictionaryBoolRemove(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,]，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        public static void DictionaryBoolClear2(bool place, string key, int lp_1, int lp_2)
        {
            DictionaryBoolRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,,]，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        public static void DictionaryBoolClear3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            DictionaryBoolRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,,,]，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        public static void DictionaryBoolClear4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            DictionaryBoolRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】移除字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        private static void DictionaryBoolRemove(bool place, string key)//内部函数
        {
            if (place) { systemDictionaryBool.Remove(key); }
            else { tempDictionaryBool.Remove(key); }
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        public static void DictionaryBoolSave0(bool place, string key, bool val)
        {
            DictionaryBoolSet(place, key, val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="val"></param>
        public static void DictionaryBoolSave1(bool place, string key, int lp_1, bool val)
        {
            DictionaryBoolSet(place, (key + "_" + lp_1.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="val"></param>
        public static void DictionaryBoolSave2(bool place, string key, int lp_1, int lp_2, bool val)
        {
            DictionaryBoolSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="val"></param>
        public static void DictionaryBoolSave3(bool place, string key, int lp_1, int lp_2, int lp_3, bool val)
        {
            DictionaryBoolSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <param name="val"></param>
        public static void DictionaryBoolSave4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4, bool val)
        {
            DictionaryBoolSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns>错误时返回null</returns>
        public static bool? DictionaryBoolLoad0_N(bool place, string key)
        {
            if ((DictionaryBoolKeyExists(place, key) == false))
            {
                return null;
            }
            return DictionaryBoolGetValue(place, key);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns>错误时返回null</returns>
        public static bool? DictionaryBoolLoad1_N(bool place, string key, int lp_1)
        {
            if ((DictionaryBoolKeyExists(place, (key + "_" + lp_1.ToString())) == false))
            {
                return null;
            }
            return DictionaryBoolGetValue(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns>错误时返回null</returns>
        public static bool? DictionaryBoolLoad2_N(bool place, string key, int lp_1, int lp_2)
        {
            if ((DictionaryBoolKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString())) == false))
            {
                return null;
            }
            return DictionaryBoolGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns>错误时返回null</returns>
        public static bool? DictionaryBoolLoad3_N(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            if ((DictionaryBoolKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString())) == false))
            {
                return null;
            }
            return DictionaryBoolGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns>错误时返回null</returns>
        public static bool? DictionaryBoolLoad4_N(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            if ((DictionaryBoolKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString())) == false))
            {
                return null;
            }
            return DictionaryBoolGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns>错误时返回false</returns>
        public static bool DictionaryBoolLoad0(bool place, string key)
        {
            if ((DictionaryBoolKeyExists(place, key) == false))
            {
                return false;
            }
            return DictionaryBoolGetValue(place, key);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns>错误时返回false</returns>
        public static bool DictionaryBoolLoad1(bool place, string key, int lp_1)
        {
            if ((DictionaryBoolKeyExists(place, (key + "_" + lp_1.ToString())) == false))
            {
                return false;
            }
            return DictionaryBoolGetValue(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns>错误时返回false</returns>
        public static bool DictionaryBoolLoad2(bool place, string key, int lp_1, int lp_2)
        {
            if ((DictionaryBoolKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString())) == false))
            {
                return false;
            }
            return DictionaryBoolGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns>错误时返回false</returns>
        public static bool DictionaryBoolLoad3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            if ((DictionaryBoolKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString())) == false))
            {
                return false;
            }
            return DictionaryBoolGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns>错误时返回false</returns>
        public static bool DictionaryBoolLoad4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            if ((DictionaryBoolKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString())) == false))
            {
                return false;
            }
            return DictionaryBoolGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        #endregion

        #region Byte字典

        /// <summary>
        /// 【MM_函数库】添加字典键值对（重复添加则覆盖）
        /// </summary>
        /// <param name="place">true=全局，false=局部</param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        private static void DictionaryByteSet(bool place, string key, byte val)//内部使用
        {
            if (place)
            {
                //存入全局字典
                systemDictionaryByte[key] = val;

                //if (systemDictionaryByte.Contains(key)) 
                //{
                //    systemDictionaryByte.Remove(key);
                //}
                //systemDictionaryByte.Add(key, val);

            }
            else
            {
                //存入局部字典
                tempDictionaryByte[key] = val;

                //if (tempDictionaryByte.Contains(key)) { tempDictionaryByte.Remove(key); }
                //tempDictionaryByte.Add(key, val);
            }
        }

        /// <summary>
        /// 【MM_函数库】判断字典键是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DictionaryByteKeyExists(bool place, string key)
        {
            if (place) { return systemDictionaryByte.ContainsKey(key); }
            else { return tempDictionaryByte.ContainsKey(key); }
        }

        /// <summary>
        /// 【MM_函数库】判断字典值是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool DictionaryByteValueExists(bool place, byte value)
        {
            if (place) { return systemDictionaryByte.ContainsValue(value); }
            else { return tempDictionaryByte.ContainsValue(value); }
        }

        /// <summary>
        /// 【MM_函数库】获取字典键对应的值
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static byte DictionaryByteGetValue(bool place, string key)
        {
            if (place) { return systemDictionaryByte[key]; }
            else { return tempDictionaryByte[key]; }
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        public static void DictionaryByteClear0(bool place, string key)
        {
            DictionaryByteRemove(place, key);
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[]，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        public static void DictionaryByteClear1(bool place, string key, int lp_1)
        {
            DictionaryByteRemove(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,]，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        public static void DictionaryByteClear2(bool place, string key, int lp_1, int lp_2)
        {
            DictionaryByteRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,,]，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        public static void DictionaryByteClear3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            DictionaryByteRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,,,]，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        public static void DictionaryByteClear4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            DictionaryByteRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】移除字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        private static void DictionaryByteRemove(bool place, string key)//内部函数
        {
            if (place) { systemDictionaryByte.Remove(key); }
            else { tempDictionaryByte.Remove(key); }
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        public static void DictionaryByteSave0(bool place, string key, byte val)
        {
            DictionaryByteSet(place, key, val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="val"></param>
        public static void DictionaryByteSave1(bool place, string key, int lp_1, byte val)
        {
            DictionaryByteSet(place, (key + "_" + lp_1.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="val"></param>
        public static void DictionaryByteSave2(bool place, string key, int lp_1, int lp_2, byte val)
        {
            DictionaryByteSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="val"></param>
        public static void DictionaryByteSave3(bool place, string key, int lp_1, int lp_2, int lp_3, byte val)
        {
            DictionaryByteSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <param name="val"></param>
        public static void DictionaryByteSave4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4, byte val)
        {
            DictionaryByteSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns>错误时返回null</returns>
        public static byte? DictionaryByteLoad0_N(bool place, string key)
        {
            if ((DictionaryByteKeyExists(place, key) == false))
            {
                return null;
            }
            return DictionaryByteGetValue(place, key);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns>错误时返回null</returns>
        public static byte? DictionaryByteLoad1_N(bool place, string key, int lp_1)
        {
            if ((DictionaryByteKeyExists(place, (key + "_" + lp_1.ToString())) == false))
            {
                return null;
            }
            return DictionaryByteGetValue(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns>错误时返回null</returns>
        public static byte? DictionaryByteLoad2_N(bool place, string key, int lp_1, int lp_2)
        {
            if ((DictionaryByteKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString())) == false))
            {
                return null;
            }
            return DictionaryByteGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns>错误时返回null</returns>
        public static byte? DictionaryByteLoad3_N(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            if ((DictionaryByteKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString())) == false))
            {
                return null;
            }
            return DictionaryByteGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns>错误时返回null</returns>
        public static byte? DictionaryByteLoad4_N(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            if ((DictionaryByteKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString())) == false))
            {
                return null;
            }
            return DictionaryByteGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns>错误时返回0</returns>
        public static byte DictionaryByteLoad0(bool place, string key)
        {
            if ((DictionaryByteKeyExists(place, key) == false))
            {
                return 0;
            }
            return DictionaryByteGetValue(place, key);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns>错误时返回0</returns>
        public static byte DictionaryByteLoad1(bool place, string key, int lp_1)
        {
            if ((DictionaryByteKeyExists(place, (key + "_" + lp_1.ToString())) == false))
            {
                return 0;
            }
            return DictionaryByteGetValue(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns>错误时返回0</returns>
        public static byte DictionaryByteLoad2(bool place, string key, int lp_1, int lp_2)
        {
            if ((DictionaryByteKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString())) == false))
            {
                return 0;
            }
            return DictionaryByteGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns>错误时返回0</returns>
        public static byte DictionaryByteLoad3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            if ((DictionaryByteKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString())) == false))
            {
                return 0;
            }
            return DictionaryByteGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns>错误时返回0</returns>
        public static byte DictionaryByteLoad4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            if ((DictionaryByteKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString())) == false))
            {
                return 0;
            }
            return DictionaryByteGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        #endregion

        #endregion

        #region 引用类型

        #region Object字典

        /// <summary>
        /// 【MM_函数库】添加字典键值对（重复添加则覆盖）
        /// </summary>
        /// <param name="place">true=全局，false=局部</param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        private static void DictionaryObjectSet(bool place, string key, object val)//内部使用
        {
            if (place)
            {
                //存入全局字典
                systemDictionaryObject[key] = val;

                //if (systemDictionaryObject.Contains(key)) 
                //{
                //    systemDictionaryObject.Remove(key);
                //}
                //systemDictionaryObject.Add(key, val);

            }
            else
            {
                //存入局部字典
                tempDictionaryObject[key] = val;

                //if (tempDictionaryObject.Contains(key)) { tempDictionaryObject.Remove(key); }
                //tempDictionaryObject.Add(key, val);
            }
        }

        /// <summary>
        /// 【MM_函数库】判断字典键是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DictionaryObjectKeyExists(bool place, string key)
        {
            if (place) { return systemDictionaryObject.ContainsKey(key); }
            else { return tempDictionaryObject.ContainsKey(key); }
        }

        /// <summary>
        /// 【MM_函数库】判断字典值是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool DictionaryObjectValueExists(bool place, object value)
        {
            if (place) { return systemDictionaryObject.ContainsValue(value); }
            else { return tempDictionaryObject.ContainsValue(value); }
        }

        /// <summary>
        /// 【MM_函数库】获取字典键对应的值
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static object DictionaryObjectGetValue(bool place, string key)
        {
            if (place) { return systemDictionaryObject[key]; }
            else { return tempDictionaryObject[key]; }
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        public static void DictionaryObjectClear0(bool place, string key)
        {
            DictionaryObjectRemove(place, key);
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[]，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        public static void DictionaryObjectClear1(bool place, string key, int lp_1)
        {
            DictionaryObjectRemove(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,]，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        public static void DictionaryObjectClear2(bool place, string key, int lp_1, int lp_2)
        {
            DictionaryObjectRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,,]，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        public static void DictionaryObjectClear3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            DictionaryObjectRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,,,]，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        public static void DictionaryObjectClear4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            DictionaryObjectRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】移除字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        private static void DictionaryObjectRemove(bool place, string key)//内部函数
        {
            if (place) { systemDictionaryObject.Remove(key); }
            else { tempDictionaryObject.Remove(key); }
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        public static void DictionaryObjectSave0(bool place, string key, object val)
        {
            DictionaryObjectSet(place, key, val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="val"></param>
        public static void DictionaryObjectSave1(bool place, string key, int lp_1, object val)
        {
            DictionaryObjectSet(place, (key + "_" + lp_1.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="val"></param>
        public static void DictionaryObjectSave2(bool place, string key, int lp_1, int lp_2, object val)
        {
            DictionaryObjectSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="val"></param>
        public static void DictionaryObjectSave3(bool place, string key, int lp_1, int lp_2, int lp_3, object val)
        {
            DictionaryObjectSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <param name="val"></param>
        public static void DictionaryObjectSave4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4, object val)
        {
            DictionaryObjectSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns>错误时返回null</returns>
        public static object DictionaryObjectLoad0(bool place, string key)
        {
            if ((DictionaryObjectKeyExists(place, key) == false))
            {
                return null;
            }
            return DictionaryObjectGetValue(place, key);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns>错误时返回null</returns>
        public static object DictionaryObjectLoad1(bool place, string key, int lp_1)
        {
            if ((DictionaryObjectKeyExists(place, (key + "_" + lp_1.ToString())) == false))
            {
                return null;
            }
            return DictionaryObjectGetValue(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns>错误时返回null</returns>
        public static object DictionaryObjectLoad2(bool place, string key, int lp_1, int lp_2)
        {
            if ((DictionaryObjectKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString())) == false))
            {
                return null;
            }
            return DictionaryObjectGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns>错误时返回null</returns>
        public static object DictionaryObjectLoad3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            if ((DictionaryObjectKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString())) == false))
            {
                return null;
            }
            return DictionaryObjectGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns>错误时返回null</returns>
        public static object DictionaryObjectLoad4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            if ((DictionaryObjectKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString())) == false))
            {
                return null;
            }
            return DictionaryObjectGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        #endregion

        #region Vector字典

        /// <summary>
        /// 【MM_函数库】添加字典键值对（重复添加则覆盖）
        /// </summary>
        /// <param name="place">true=全局，false=局部</param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        private static void DictionaryVectorSet(bool place, string key, Vector val)//内部使用
        {
            if (place)
            {
                //存入全局字典
                systemDictionaryVector[key] = val;

                //if (systemDictionaryVector.Contains(key)) 
                //{
                //    systemDictionaryVector.Remove(key);
                //}
                //systemDictionaryVector.Add(key, val);

            }
            else
            {
                //存入局部字典
                tempDictionaryVector[key] = val;

                //if (tempDictionaryVector.Contains(key)) { tempDictionaryVector.Remove(key); }
                //tempDictionaryVector.Add(key, val);
            }
        }

        /// <summary>
        /// 【MM_函数库】判断字典键是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DictionaryVectorKeyExists(bool place, string key)
        {
            if (place) { return systemDictionaryVector.ContainsKey(key); }
            else { return tempDictionaryVector.ContainsKey(key); }
        }

        /// <summary>
        /// 【MM_函数库】判断字典值是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool DictionaryVectorValueExists(bool place, Vector value)
        {
            if (place) { return systemDictionaryVector.ContainsValue(value); }
            else { return tempDictionaryVector.ContainsValue(value); }
        }

        /// <summary>
        /// 【MM_函数库】获取字典键对应的值
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static Vector DictionaryVectorGetValue(bool place, string key)
        {
            if (place) { return systemDictionaryVector[key]; }
            else { return tempDictionaryVector[key]; }
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        public static void DictionaryVectorClear0(bool place, string key)
        {
            DictionaryVectorRemove(place, key);
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[]，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        public static void DictionaryVectorClear1(bool place, string key, int lp_1)
        {
            DictionaryVectorRemove(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,]，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        public static void DictionaryVectorClear2(bool place, string key, int lp_1, int lp_2)
        {
            DictionaryVectorRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,,]，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        public static void DictionaryVectorClear3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            DictionaryVectorRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,,,]，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        public static void DictionaryVectorClear4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            DictionaryVectorRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】移除字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        private static void DictionaryVectorRemove(bool place, string key)//内部函数
        {
            if (place) { systemDictionaryVector.Remove(key); }
            else { tempDictionaryVector.Remove(key); }
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        public static void DictionaryVectorSave0(bool place, string key, Vector val)
        {
            DictionaryVectorSet(place, key, val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="val"></param>
        public static void DictionaryVectorSave1(bool place, string key, int lp_1, Vector val)
        {
            DictionaryVectorSet(place, (key + "_" + lp_1.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="val"></param>
        public static void DictionaryVectorSave2(bool place, string key, int lp_1, int lp_2, Vector val)
        {
            DictionaryVectorSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="val"></param>
        public static void DictionaryVectorSave3(bool place, string key, int lp_1, int lp_2, int lp_3, Vector val)
        {
            DictionaryVectorSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <param name="val"></param>
        public static void DictionaryVectorSave4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4, Vector val)
        {
            DictionaryVectorSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns>错误时返回null</returns>
        public static Vector? DictionaryVectorLoad0_N(bool place, string key)
        {
            if ((DictionaryVectorKeyExists(place, key) == false))
            {
                return null;
            }
            return DictionaryVectorGetValue(place, key);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns>错误时返回null</returns>
        public static Vector? DictionaryVectorLoad1_N(bool place, string key, int lp_1)
        {
            if ((DictionaryVectorKeyExists(place, (key + "_" + lp_1.ToString())) == false))
            {
                return null;
            }
            return DictionaryVectorGetValue(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns>错误时返回null</returns>
        public static Vector? DictionaryVectorLoad2_N(bool place, string key, int lp_1, int lp_2)
        {
            if ((DictionaryVectorKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString())) == false))
            {
                return null;
            }
            return DictionaryVectorGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns>错误时返回null</returns>
        public static Vector? DictionaryVectorLoad3_N(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            if ((DictionaryVectorKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString())) == false))
            {
                return null;
            }
            return DictionaryVectorGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns>错误时返回null</returns>
        public static Vector? DictionaryVectorLoad4_N(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            if ((DictionaryVectorKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString())) == false))
            {
                return null;
            }
            return DictionaryVectorGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns>错误时返回new Vector(0,0)</returns>
        public static Vector DictionaryVectorLoad0(bool place, string key)
        {
            if ((DictionaryVectorKeyExists(place, key) == false))
            {
                return new Vector(0, 0);
            }
            return DictionaryVectorGetValue(place, key);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns>错误时返回new Vector(0,0)</returns>
        public static Vector DictionaryVectorLoad1(bool place, string key, int lp_1)
        {
            if ((DictionaryVectorKeyExists(place, (key + "_" + lp_1.ToString())) == false))
            {
                return new Vector(0, 0);
            }
            return DictionaryVectorGetValue(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns>错误时返回new Vector(0,0)</returns>
        public static Vector DictionaryVectorLoad2(bool place, string key, int lp_1, int lp_2)
        {
            if ((DictionaryVectorKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString())) == false))
            {
                return new Vector(0, 0);
            }
            return DictionaryVectorGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns>错误时返回new Vector(0,0)</returns>
        public static Vector DictionaryVectorLoad3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            if ((DictionaryVectorKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString())) == false))
            {
                return new Vector(0, 0);
            }
            return DictionaryVectorGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns>错误时返回new Vector(0,0)</returns>
        public static Vector DictionaryVectorLoad4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            if ((DictionaryVectorKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString())) == false))
            {
                return new Vector(0, 0);
            }
            return DictionaryVectorGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        #endregion

        #region Timer字典

        /// <summary>
        /// 【MM_函数库】添加字典键值对（重复添加则覆盖）
        /// </summary>
        /// <param name="place">true=全局，false=局部</param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        private static void DictionaryTimerSet(bool place, string key, Timer val)//内部使用
        {
            if (place)
            {
                //存入全局字典
                systemDictionaryTimer[key] = val;

                //if (systemDictionaryTimer.Contains(key)) 
                //{
                //    systemDictionaryTimer.Remove(key);
                //}
                //systemDictionaryTimer.Add(key, val);

            }
            else
            {
                //存入局部字典
                tempDictionaryTimer[key] = val;

                //if (tempDictionaryTimer.Contains(key)) { tempDictionaryTimer.Remove(key); }
                //tempDictionaryTimer.Add(key, val);
            }
        }

        /// <summary>
        /// 【MM_函数库】判断字典键是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DictionaryTimerKeyExists(bool place, string key)
        {
            if (place) { return systemDictionaryTimer.ContainsKey(key); }
            else { return tempDictionaryTimer.ContainsKey(key); }
        }

        /// <summary>
        /// 【MM_函数库】判断字典值是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool DictionaryTimerValueExists(bool place, Timer value)
        {
            if (place) { return systemDictionaryTimer.ContainsValue(value); }
            else { return tempDictionaryTimer.ContainsValue(value); }
        }

        /// <summary>
        /// 【MM_函数库】获取字典键对应的值
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static Timer DictionaryTimerGetValue(bool place, string key)
        {
            if (place) { return systemDictionaryTimer[key]; }
            else { return tempDictionaryTimer[key]; }
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        public static void DictionaryTimerClear0(bool place, string key)
        {
            DictionaryTimerRemove(place, key);
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[]，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        public static void DictionaryTimerClear1(bool place, string key, int lp_1)
        {
            DictionaryTimerRemove(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,]，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        public static void DictionaryTimerClear2(bool place, string key, int lp_1, int lp_2)
        {
            DictionaryTimerRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,,]，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        public static void DictionaryTimerClear3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            DictionaryTimerRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,,,]，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        public static void DictionaryTimerClear4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            DictionaryTimerRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】移除字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        private static void DictionaryTimerRemove(bool place, string key)//内部函数
        {
            if (place) { systemDictionaryTimer.Remove(key); }
            else { tempDictionaryTimer.Remove(key); }
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        public static void DictionaryTimerSave0(bool place, string key, Timer val)
        {
            DictionaryTimerSet(place, key, val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="val"></param>
        public static void DictionaryTimerSave1(bool place, string key, int lp_1, Timer val)
        {
            DictionaryTimerSet(place, (key + "_" + lp_1.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="val"></param>
        public static void DictionaryTimerSave2(bool place, string key, int lp_1, int lp_2, Timer val)
        {
            DictionaryTimerSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="val"></param>
        public static void DictionaryTimerSave3(bool place, string key, int lp_1, int lp_2, int lp_3, Timer val)
        {
            DictionaryTimerSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <param name="val"></param>
        public static void DictionaryTimerSave4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4, Timer val)
        {
            DictionaryTimerSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns>错误时返回null</returns>
        public static Timer DictionaryTimerLoad0(bool place, string key)
        {
            if ((DictionaryTimerKeyExists(place, key) == false))
            {
                return null;
            }
            return DictionaryTimerGetValue(place, key);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns>错误时返回null</returns>
        public static Timer DictionaryTimerLoad1(bool place, string key, int lp_1)
        {
            if ((DictionaryTimerKeyExists(place, (key + "_" + lp_1.ToString())) == false))
            {
                return null;
            }
            return DictionaryTimerGetValue(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns>错误时返回null</returns>
        public static Timer DictionaryTimerLoad2(bool place, string key, int lp_1, int lp_2)
        {
            if ((DictionaryTimerKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString())) == false))
            {
                return null;
            }
            return DictionaryTimerGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns>错误时返回null</returns>
        public static Timer DictionaryTimerLoad3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            if ((DictionaryTimerKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString())) == false))
            {
                return null;
            }
            return DictionaryTimerGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns>错误时返回null</returns>
        public static Timer DictionaryTimerLoad4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            if ((DictionaryTimerKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString())) == false))
            {
                return null;
            }
            return DictionaryTimerGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        #endregion

        #region String字典

        /// <summary>
        /// 【MM_函数库】添加字典键值对（重复添加则覆盖）
        /// </summary>
        /// <param name="place">true=全局，false=局部</param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        private static void DictionaryStringSet(bool place, string key, string val)//内部使用
        {
            if (place)
            {
                //存入全局字典
                systemDictionaryString[key] = val;

                //if (systemDictionaryString.Contains(key)) 
                //{
                //    systemDictionaryString.Remove(key);
                //}
                //systemDictionaryString.Add(key, val);

            }
            else
            {
                //存入局部字典
                tempDictionaryString[key] = val;

                //if (tempDictionaryString.Contains(key)) { tempDictionaryString.Remove(key); }
                //tempDictionaryString.Add(key, val);
            }
        }

        /// <summary>
        /// 【MM_函数库】判断字典键是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static bool DictionaryStringKeyExists(bool place, string key)
        {
            if (place) { return systemDictionaryString.ContainsKey(key); }
            else { return tempDictionaryString.ContainsKey(key); }
        }

        /// <summary>
        /// 【MM_函数库】判断字典值是否存在
        /// </summary>
        /// <param name="place"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool DictionaryStringValueExists(bool place, string value)
        {
            if (place) { return systemDictionaryString.ContainsValue(value); }
            else { return tempDictionaryString.ContainsValue(value); }
        }

        /// <summary>
        /// 【MM_函数库】获取字典键对应的值
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static string DictionaryStringGetValue(bool place, string key)
        {
            if (place) { return systemDictionaryString[key]; }
            else { return tempDictionaryString[key]; }
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        public static void DictionaryStringClear0(bool place, string key)
        {
            DictionaryStringRemove(place, key);
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[]，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        public static void DictionaryStringClear1(bool place, string key, int lp_1)
        {
            DictionaryStringRemove(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,]，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        public static void DictionaryStringClear2(bool place, string key, int lp_1, int lp_2)
        {
            DictionaryStringRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,,]，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        public static void DictionaryStringClear3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            DictionaryStringRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】从字典中清除Key[,,,]，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        public static void DictionaryStringClear4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            DictionaryStringRemove(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】移除字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        private static void DictionaryStringRemove(bool place, string key)//内部函数
        {
            if (place) { systemDictionaryString.Remove(key); }
            else { tempDictionaryString.Remove(key); }
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="val"></param>
        public static void DictionaryStringSave0(bool place, string key, string val)
        {
            DictionaryStringSet(place, key, val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="val"></param>
        public static void DictionaryStringSave1(bool place, string key, int lp_1, string val)
        {
            DictionaryStringSet(place, (key + "_" + lp_1.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="val"></param>
        public static void DictionaryStringSave2(bool place, string key, int lp_1, int lp_2, string val)
        {
            DictionaryStringSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="val"></param>
        public static void DictionaryStringSave3(bool place, string key, int lp_1, int lp_2, int lp_3, string val)
        {
            DictionaryStringSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】保存字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <param name="val"></param>
        public static void DictionaryStringSave4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4, string val)
        {
            DictionaryStringSet(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()), val);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <returns>错误时返回null</returns>
        public static string DictionaryStringLoad0(bool place, string key)
        {
            if ((DictionaryStringKeyExists(place, key) == false))
            {
                return null;
            }
            return DictionaryStringGetValue(place, key);
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟1维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <returns>错误时返回null</returns>
        public static string DictionaryStringLoad1(bool place, string key, int lp_1)
        {
            if ((DictionaryStringKeyExists(place, (key + "_" + lp_1.ToString())) == false))
            {
                return null;
            }
            return DictionaryStringGetValue(place, (key + "_" + lp_1.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟2维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <returns>错误时返回null</returns>
        public static string DictionaryStringLoad2(bool place, string key, int lp_1, int lp_2)
        {
            if ((DictionaryStringKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString())) == false))
            {
                return null;
            }
            return DictionaryStringGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟3维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <returns>错误时返回null</returns>
        public static string DictionaryStringLoad3(bool place, string key, int lp_1, int lp_2, int lp_3)
        {
            if ((DictionaryStringKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString())) == false))
            {
                return null;
            }
            return DictionaryStringGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString()));
        }

        /// <summary>
        /// 【MM_函数库】读取字典键值对，模拟4维数组
        /// </summary>
        /// <param name="place"></param>
        /// <param name="key"></param>
        /// <param name="lp_1"></param>
        /// <param name="lp_2"></param>
        /// <param name="lp_3"></param>
        /// <param name="lp_4"></param>
        /// <returns>错误时返回null</returns>
        public static string DictionaryStringLoad4(bool place, string key, int lp_1, int lp_2, int lp_3, int lp_4)
        {
            if ((DictionaryStringKeyExists(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString())) == false))
            {
                return null;
            }
            return DictionaryStringGetValue(place, (key + "_" + lp_1.ToString() + "_" + lp_2.ToString() + "_" + lp_3.ToString() + "_" + lp_4.ToString()));
        }

        #endregion

        #endregion

        #endregion

        #endregion

        #endregion

        #region Functions 互动管理

        //用数据表实现不同类型数据互动、信息管理

        #region 存储区状态队列管理

        /// <summary>
        /// 【MM_函数库】存储区容错处理函数，当哈希表键值存在时执行线程等待。常用于多线程触发器频繁写值，如大量注册注销动作使存储区数据重排序的，因哈希表正在使用需排队等待完成才给执行下一个。执行原理：将调用该函数的当前线程反复挂起50毫秒，直到动作要写入的存储区闲置
        /// </summary>
        /// <param name="key"></param>
        public static void ThreadWait(string key)
        {
            while (DataTableBoolLoad0(true, "MMCore_ThreadWait_" + key) == true)
            {
                Thread.Sleep(50); //将调用该函数的当前线程挂起
            }
        }

        /// <summary>
        /// 【MM_函数库】存储区容错处理函数，当哈希表键值存在时执行线程等待。常用于多线程触发器频繁写值，如大量注册注销动作使存储区数据重排序的，因哈希表正在使用需排队等待完成才给执行下一个。执行原理：将调用该函数的当前线程反复挂起period毫秒，直到动作要写入的存储区闲置
        /// </summary>
        /// <param name="key"></param>
        /// <param name="period"></param>
        public static void ThreadWait(string key, int period)
        {
            while (DataTableBoolLoad0(true, "MMCore_ThreadWait_" + key) == true)
            {
                Thread.Sleep(period); //将调用该函数的当前线程挂起
            }
        }

        /// <summary>
        /// 【MM_函数库】存储区容错处理函数，引发注册注销等存储区频繁重排序的动作，在函数开始/完成写入存储区时，应设置线程等待（val=1）/闲置（val=0）
        /// </summary>
        /// <param name="key"></param>
        /// <param name="val">函数动作完成，所写入存储区闲置时填false，反之填true</param>
        private static void ThreadWaitSet(string key, bool val)
        {
            DataTableBoolSave0(true, "MMCore_ThreadWait_" + key, val);
        }

        /// <summary>
        /// 【MM_函数库】存储区容错处理函数，当哈希表键值存在时执行线程等待。常用于多线程触发器频繁写值，如大量注册注销动作使存储区数据重排序的，因哈希表正在使用需排队等待完成才给执行下一个。执行原理：将调用该函数的当前线程反复挂起50毫秒，直到动作要写入的存储区闲置
        /// </summary>
        /// <param name="key"></param>
        public static void ThreadWait(bool place, string key)
        {
            while (DataTableBoolLoad0(place, "MMCore_ThreadWait_" + key) == true)
            {
                Thread.Sleep(50); //将调用该函数的当前线程挂起
            }
        }

        /// <summary>
        /// 【MM_函数库】存储区容错处理函数，当哈希表键值存在时执行线程等待。常用于多线程触发器频繁写值，如大量注册注销动作使存储区数据重排序的，因哈希表正在使用需排队等待完成才给执行下一个。执行原理：将调用该函数的当前线程反复挂起period毫秒，直到动作要写入的存储区闲置
        /// </summary>
        /// <param name="key"></param>
        /// <param name="period"></param>
        public static void ThreadWait(bool place, string key, int period)
        {
            while (DataTableBoolLoad0(place, "MMCore_ThreadWait_" + key) == true)
            {
                Thread.Sleep(period); //将调用该函数的当前线程挂起
            }
        }

        /// <summary>
        /// 【MM_函数库】存储区容错处理函数，引发注册注销等存储区频繁重排序的动作，在函数开始/完成写入存储区时，应设置线程等待（val=1）/闲置（val=0）
        /// </summary>
        /// <param name="key"></param>
        /// <param name="val">函数动作完成，所写入存储区闲置时填false，反之填true</param>
        private static void ThreadWaitSet(bool place, string key, bool val)
        {
            DataTableBoolSave0(place, "MMCore_ThreadWait_" + key, val);
        }

        #endregion

        //注：下方分用户和系统共计三种互动，用户互动即便填入与系统互动相同参数键名也会存储在不同键区位置，所以是安全的

        #region 用户互动

        #region 任意类型

        //提示：可以将本类型作为模板修改后产生其他类型
        //提示：尽可能使用对口类型，以防值类型与引用类型发生转换时拆装箱降低性能

        //--------------------------------------------------------------------------------------------------
        // 任意类型组Start
        //--------------------------------------------------------------------------------------------------

        /// <summary>
        /// 【MM_函数库】互动O_注册Object标签句柄并返回。为Object自动设置新的标签句柄，重复时会返回已注册的Object标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns>返回一个Object的已注册标签</returns>
        private static int HD_RegObjectTagAndReturn_Int(object lp_object)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = DataTableIntLoad0(true, "HD_ObjectJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                DataTableIntSave0(true, "HD_ObjectJBNum", lv_j);
                DataTableObjectSave0(true, ("HD_Object_" + lv_j.ToString()), lp_object);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if (DataTableObjectLoad0(true, ("HD_Object_" + lv_j.ToString())) == lp_object)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            DataTableIntSave0(true, "HD_ObjectJBNum", lv_j);
                            DataTableObjectSave0(true, ("HD_Object_" + lv_j.ToString()), lp_object);
                        }
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object已注册标签句柄
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns>返回一个Object的已注册标签，错误返回0</returns>
        public static int HD_ReturnObjectTag_Int(object lp_object)
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = DataTableIntLoad0(true, "HD_ObjectJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if (DataTableObjectLoad0(true, "HD_Object_" + lv_j.ToString()) == lp_object)
                {
                    break;
                }
                else
                {
                    if ((lv_j == lv_jBNum))
                    {
                        lv_j = 0;
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动O_注册Object标签句柄并返回。为Object自动设置新的标签句柄，重复时会返回已注册的Object标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns>返回一个Object的已注册标签""</returns>
        private static string HD_RegObjectTagAndReturn(object lp_object)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = DataTableIntLoad0(true, "HD_ObjectJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                DataTableIntSave0(true, "HD_ObjectJBNum", lv_j);
                DataTableObjectSave0(true, ("HD_Object_" + lv_j.ToString()), lp_object);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if (DataTableObjectLoad0(true, "HD_Object_" + lv_j.ToString()) == lp_object)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            DataTableIntSave0(true, "HD_ObjectJBNum", lv_j);
                            DataTableObjectSave0(true, ("HD_Object_" + lv_j.ToString()), lp_object);
                        }
                    }
                }
            }
            lv_tag = lv_j.ToString();
            //Console.WriteLine(("Tag：" + lv_tag));
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object已注册标签句柄
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns>返回一个Object的已注册标签，错误返回""</returns>
        public static string HD_ReturnObjectTag(object lp_object)
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag = "";
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = DataTableIntLoad0(true, "HD_ObjectJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if (DataTableObjectLoad0(true, "HD_Object_" + lv_j.ToString()) == lp_object)
                {
                    lv_tag = lv_j.ToString();
                    break;
                }
            }
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动O_注册Object(高级)。在指定Key存入Object，固有状态、自定义值是Object独一无二的标志（本函数重复注册会刷新），之后可用互动O_"返回Object注册总数"、"返回Object序号"、"返回序号对应Object"、"返回序号对应Object标签"、"返回Object自定义值"。Object组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Object组转为Key。首次注册时固有状态为true（相当于单位组单位活体），如需另外设置多个标记可使用"互动O_设定Object状态/自定义值"
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        /// <param name="lp_inherentStats">固有状态</param>
        /// <param name="lp_inherentCustomValue">固有自定义值</param>
        public static void HD_RegObject(object lp_object, string lp_key, string lp_inherentStats, string lp_inherentCustomValue)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;

            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_jBNum = DataTableIntLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = HD_RegObjectTagAndReturn(lp_object);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                DataTableIntSave0(true, (lv_str + "Num"), lv_i);
                DataTableStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                DataTableBoolSave0(true, (("HD_IfObjectTag" + "") + "_" + lv_tagStr), true);
                DataTableBoolSave1(true, ("HD_IfObjectTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if (DataTableIntLoad1(true, lv_str + "Tag", lv_i).ToString() == lv_tagStr)
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                DataTableIntSave0(true, (lv_str + "Num"), lv_i);
                                DataTableStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                DataTableBoolSave0(true, (("HD_IfObjectTag" + "") + "_" + lv_tagStr), true);
                                DataTableBoolSave1(true, ("HD_IfObjectTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            DataTableStringSave0(true, ("HD_ObjectState" + "" + "_" + lv_tagStr), lp_inherentStats);
            DataTableStringSave0(true, ("HD_ObjectCV" + "" + "_" + lv_tagStr), lp_inherentCustomValue);
        }

        /// <summary>
        /// 【MM_函数库】互动O_注册Object。在指定Key存入Object，固有状态、自定义值是Object独一无二的标志（本函数重复注册不会刷新），之后可用互动O_"返回Object注册总数"、"返回Object序号"、"返回序号对应Object"、"返回Object自定义值"。Object组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Object组转为Key。首次注册时固有状态为true（相当于单位组单位活体），之后只能通过"互动O_注册Object（高级）"改写，如需另外设置多个标记可使用"互动O_设定Object状态/自定义值"
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        public static void HD_RegObject_Simple(object lp_object, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;

            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_jBNum = DataTableIntLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = HD_RegObjectTagAndReturn(lp_object);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                DataTableIntSave0(true, (lv_str + "Num"), lv_i);
                DataTableStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                DataTableBoolSave0(true, (("HD_IfObjectTag" + "") + "_" + lv_tagStr), true);
                DataTableBoolSave1(true, ("HD_IfObjectTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if (DataTableIntLoad1(true, lv_str + "Tag", lv_i).ToString() == lv_tagStr)
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                DataTableIntSave0(true, (lv_str + "Num"), lv_i);
                                DataTableStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                DataTableBoolSave0(true, (("HD_IfObjectTag" + "") + "_" + lv_tagStr), true);
                                DataTableBoolSave1(true, ("HD_IfObjectTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            if ((DataTableBoolKeyExists(true, ("HD_Object" + "State" + "_" + lv_tag.ToString())) == false))
            {
                DataTableStringSave1(true, (("HD_Object" + "State")), lv_tag, "true");
            }
        }

        /// <summary>
        /// 【MM_函数库】互动O_注销Object。用"互动O_注册Object"到Key，之后可用本函数彻底摧毁注册信息并将序号重排（包括Object标签有效状态、固有状态及自定义值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动O_设定Object状态"让Object状态失效（类似单位组的单位活体状态）。Object组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Object组转为Key。本函数无法摧毁用"互动O_设定Object状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Object组变量ID时会清空Object组专用状态
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        public static void HD_DestroyObject(object lp_object, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag;
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_tag = HD_ReturnObjectTag(lp_object);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                ThreadWaitSet(true, "Key_ObjectGroup" + lv_str, true);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((DataTableIntLoad1(true, (lp_key + "ObjectTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        DataTableBoolClear0(true, "HD_IfObjectTag_" + lv_tag);
                        DataTableBoolClear0(true, "HD_IfObjectTag" + lv_str + "_" + lv_tag);
                        DataTableObjectClear0(true, "HD_Object_" + lv_tag);
                        DataTableStringClear0(true, "HD_ObjectCV_" + lv_tag);
                        DataTableStringClear0(true, "HD_ObjectState_" + lv_tag);
                        DataTableStringClear0(true, "HD_ObjectCV" + lv_str + "_" + lv_tag);
                        DataTableStringClear0(true, "HD_ObjectState" + lv_str + "_" + lv_tag);
                        DataTableIntSave0(true, (lp_key + "ObjectNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = DataTableIntLoad1(true, (lp_key + "ObjectTag"), lv_b + 1).ToString();
                            DataTableStringSave1(true, (lp_key + "ObjectTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                ThreadWaitSet(true, "Key_ObjectGroup" + lv_str, false);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动O_移除Object。用"互动O_注册Object"到Key，之后可用本函数仅摧毁Key区注册的信息并将序号重排，用于Object组或多个键区仅移除Object（保留Object标签有效状态、固有值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动O_设定Object状态"让Object状态失效（类似单位组的单位活体状态）。Object组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Object组转为Key。本函数无法摧毁用"互动O_设定Object状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Object组变量ID时会清空Object组专用状态
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        public static void HD_RemoveObject(object lp_object, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag;
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_tag = HD_ReturnObjectTag(lp_object);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                ThreadWaitSet(true, "Key_ObjectGroup" + lv_str, true);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((DataTableIntLoad1(true, (lp_key + "ObjectTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        DataTableBoolClear0(true, "HD_IfObjectTag" + lv_str + "_" + lv_tag);
                        DataTableStringClear0(true, "HD_ObjectCV" + lv_str + "_" + lv_tag);
                        DataTableStringClear0(true, "HD_ObjectState" + lv_str + "_" + lv_tag);
                        DataTableIntSave0(true, (lp_key + "ObjectNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = DataTableIntLoad1(true, (lp_key + "ObjectTag"), lv_b + 1).ToString();
                            DataTableStringSave1(true, (lp_key + "ObjectTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                ThreadWaitSet(true, "Key_ObjectGroup" + lv_str, false);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object注册总数。必须先使用"互动O_注册Object"才能返回指定Key里的注册总数。Object组使用时，可用"获取变量的内部名称"将Object组转为Key。
        /// </summary>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        /// <returns></returns>
        public static int HD_ReturnObjectNumMax(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            // Implementation
            return lv_num;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object序号。使用"互动O_注册Object"后使用本函数可返回Key里的注册序号，Key无元素返回0，Key有元素但对象不在里面则返回-1，Object标签尚未注册则返回-2。Object组使用时，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        /// <returns></returns>
        public static int HD_ReturnObjectNum(object lp_object, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_i;
            string lv_tag;
            int lv_torf;
            // Automatic Variable Declarations
            const int auto_n = 1;
            int auto_i;
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_tag = HD_ReturnObjectTag(lp_object);
            lv_torf = -1;
            // Implementation
            for (auto_i = 1; auto_i <= auto_n; auto_i += 1)
            {
                if ((lv_tag != null))
                {
                    lv_torf = -2;
                    break;
                }
                if ((lv_num == 0))
                {
                    lv_torf = 0;
                }
                else
                {
                    if ((lv_num >= 1))
                    {
                        auto_ae = lv_num;
                        auto_var = 1;
                        for (; auto_var <= auto_ae; auto_var += 1)
                        {
                            lv_i = auto_var;
                            if ((DataTableIntLoad1(true, (lv_str + "Tag"), lv_i).ToString() == lv_tag))
                            {
                                lv_torf = lv_i;
                                break;
                            }
                        }
                    }
                }
            }
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回序号对应Object。使用"互动O_注册Object"后，在参数填入注册序号可返回Object。Object组使用时，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_regNum"></param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        /// <returns></returns>
        public static object HD_ReturnObjectFromRegNum(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag;
            object lv_object;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = DataTableIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            lv_object = DataTableObjectLoad0(true, ("HD_Object_" + lv_tag));
            // Implementation
            return lv_object;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回句柄标签对应Object。使用"互动O_注册Object"后，在参数填入句柄标签（整数）可返回Object，标签是Object的句柄。Object组使用时，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_tag">句柄标签</param>
        /// <returns></returns>
        public static object HD_ReturnObjectFromTag(int lp_tag)
        {
            // Variable Declarations
            string lv_tag;
            object lv_object;
            // Variable Initialization
            lv_tag = lp_tag.ToString();
            lv_object = DataTableObjectLoad0(true, ("HD_Object_" + lv_tag));
            // Implementation
            return lv_object;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回序号对应Object标签句柄。使用"互动O_注册Object"后，在参数填入注册序号可返回Object标签（字符串）。Object组使用时，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        /// <returns></returns>
        public static string HD_ReturnObjectTagFromRegNum_String(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = DataTableIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回序号对应Object标签句柄。使用"互动O_注册Object"后，在参数填入注册序号可返回Object标签（整数）。Object组使用时，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        /// <returns></returns>
        public static int HD_ReturnObjectTagFromRegNum_Int(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = DataTableIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return Convert.ToInt32(lv_tag);
        }

        /// <summary>
        /// 【MM_函数库】互动O_设置Object状态。必须先"注册"获得功能库内部句柄，再使用本函数给Object设定一个状态值，之后可用"互动O_返回Object状态"。类型参数用以记录多个不同状态，仅当"类型"参数填Object组ID转的Object串时，状态值"true"和"false"是Object的Object组专用状态值，用于内部函数筛选Object状态（相当于单位组单位索引是否有效），其他类型不会干扰系统内部，可随意填写。虽然注销时反向清空注册信息，但用"互动O_设定Object状态/自定义值"创建的值需要手工填入""来排泄（非大量注销则提升内存量极小，可不管）。注：固有状态值是注册函数赋予的系统内部变量（相当于单位组单位是否活体），只能通过"互动O_注册Object（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <param name="lp_stats">状态</param>
        public static void HD_SetObjectState(object lp_object, string lp_key, string lp_stats)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = HD_RegObjectTagAndReturn(lp_object);
            // Implementation
            DataTableStringSave0(true, ("HD_ObjectState" + lv_str + "_" + lv_tag), lp_stats);
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object状态。使用"互动O_设定Object状态"后可使用本函数，将本函数参数"类型"设为空时返回固有值。类型参数用以记录多个不同状态，仅当"类型"参数为Object组ID转的字符串时，返回的状态值"true"和"false"是Object的Object组专用状态值，用于内部函数筛选Object状态（相当于单位组单位索引是否有效）
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <returns></returns>
        public static string HD_ReturnObjectState(object lp_object, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag;
            string lv_stats;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = HD_ReturnObjectTag(lp_object);
            lv_stats = DataTableStringLoad0(true, ("HD_ObjectState" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动O_设置Object自定义值。必须先"注册"获得功能库内部句柄，再使用本函数设定Object的自定义值，之后可使用"互动O_返回Object自定义值"，类型参数用以记录多个不同自定义值。注：固有自定义值是注册函数赋予的系统内部变量，只能通过"互动O_注册Object（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <param name="lp_customValue">自定义值</param>
        public static void HD_SetObjectCV(object lp_object, string lp_key, string lp_customValue)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = HD_RegObjectTagAndReturn(lp_object);
            // Implementation
            DataTableStringSave0(true, ("HD_ObjectCV" + lv_str + "_" + lv_tag), lp_customValue);
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object自定义值。使用"互动O_设定Object自定义值"后可使用本函数，将本函数参数"类型"设为空时返回固有值，该参数用以记录多个不同自定义值
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <returns></returns>
        public static string HD_ReturnObjectCV(object lp_object, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag;
            string lv_customValue;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = HD_ReturnObjectTag(lp_object);
            lv_customValue = DataTableStringLoad0(true, ("HD_ObjectCV" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object固有状态。必须先使用"互动O_注册Object"才能返回到该值，固有状态是独一无二的标记（相当于单位组单位是否活体）
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns></returns>
        public static string HD_ReturnObjectState_Only(object lp_object)
        {
            // Variable Declarations
            string lv_tag;
            string lv_stats;
            // Variable Initialization
            lv_tag = HD_ReturnObjectTag(lp_object);
            lv_stats = DataTableStringLoad0(true, ("HD_ObjectState" + "" + "_" + lv_tag));
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object固有自定义值。必须先使用"互动O_注册Object"才能返回到该值，固有值是独一无二的标记
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns></returns>
        public static string HD_ReturnObjectCV_Only(object lp_object)
        {
            // Variable Declarations
            string lv_tag;
            string lv_customValue;
            // Variable Initialization
            lv_tag = HD_ReturnObjectTag(lp_object);
            lv_customValue = DataTableStringLoad0(true, ("HD_ObjectCV" + "" + "_" + lv_tag));
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动O_设置Object的实数标记。必须先"注册"获得功能库内部句柄，再使用本函数让Object携带一个实数值，之后可使用"互动O_返回Object的实数标记"。Object组使用时，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_realNumTag">实数标记</param>
        public static void HD_SetObjectDouble(object lp_object, double lp_realNumTag)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = HD_RegObjectTagAndReturn(lp_object);
            // Implementation
            DataTableDoubleSave0(true, ("HD_CDDouble_Object_" + lv_tag), lp_realNumTag);
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object的实数标记。使用"互动O_设定Object的实数标记"后可使用本函数。Object组使用时，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns></returns>
        public static double HD_ReturnObjectDouble(object lp_object)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = HD_ReturnObjectTag(lp_object);
            // Implementation
            return DataTableDoubleLoad0(true, ("HD_CDDouble_Object_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object标签句柄有效状态。将Object视作独一无二的个体，标签是它本身，有效状态则类似"单位是否有效"，当使用"互动O_注册Object"或"互动OG_添加Object到Object组"后激活Object有效状态（值为"true"），除非使用"互动O_注册Object（高级）"改写，否则直到注销才会摧毁
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns></returns>
        public static bool HD_ReturnIfObjectTag(object lp_object)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = HD_ReturnObjectTag(lp_object);
            // Implementation
            return DataTableBoolLoad0(true, ("HD_IfObjectTag" + "" + "_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object注册状态。使用"互动O_注册Object"或"互动OG_添加Object到Object组"后可使用本函数获取注册Object在Key中的注册状态，该状态只能注销或从Object组中移除时清空。Object组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        /// <returns></returns>
        public static bool HD_ReturnIfObjectTagKey(object lp_object, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = HD_ReturnObjectTag(lp_object);
            // Implementation
            return DataTableBoolLoad0(true, ("HD_IfObjectTag" + lv_str + "_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动OG_根据自定义值类型将Object组排序。根据Object携带的自定义值类型，对指定的Object组元素进行冒泡排序。Object组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Object组名称</param>
        /// <param name="lp_cVStr">自定义值类型</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void HD_ObjectGSortCV(string lp_key, string lp_cVStr, bool lp_big)
        {
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            string lv_tagValuestr;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_ObjectGroup" + lv_str, true);
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = HD_ReturnObjectTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValuestr = HD_ReturnObjectCV(HD_ReturnObjectFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    DataTableIntSave1(false, "IntStackOutTag", 1, lv_tag);
                    DataTableIntSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < DataTableIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DataTableIntSave1(false, "IntStackOutTag", lv_c, DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    DataTableIntSave1(false, "IntStackOutTagValue", lv_c, DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_c, DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                DataTableIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                DataTableIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > DataTableIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(HD_ReturnObjectTagFromRegNum(lv_b, lp_key))+"值"+IntToString(DataTableIntLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DataTableIntSave1(false, "IntStackOutTag", lv_c, DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DataTableIntSave1(false, "IntStackOutTagValue", lv_c, DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_c, DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                DataTableIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DataTableIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        DataTableIntSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DataTableIntSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = DataTableIntLoad1(true, (lp_key + "ObjectTag"), lv_a).ToString(); //原始序号元素
                lv_tag = DataTableIntLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValuestr = HD_ReturnObjectCV(HD_ReturnObjectFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = DataTableIntLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    DataTableIntSave1(true, (lp_key + "ObjectTag"), lv_a, lv_tag); //lv_tag放入新序号
                    //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            ThreadWaitSet(true, "Key_ObjectGroup" + lv_str, false);
        }

        /// <summary>
        /// 【MM_函数库】互动OG_Object组排序。对指定的Object组元素进行冒泡排序（根据元素句柄）。Object组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Object组名称</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void HD_ObjectGSort(string lp_key, bool lp_big)
        {
            // Automatic Variable Declarations
            // Implementation
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_ObjectGroup" + lv_str, true);
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = HD_ReturnObjectTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValue = lv_tag;
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    DataTableIntSave1(false, "IntStackOutTag", 1, lv_tag);
                    DataTableIntSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < DataTableIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DataTableIntSave1(false, "IntStackOutTag", lv_c, DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    DataTableIntSave1(false, "IntStackOutTagValue", lv_c, DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_c, DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                DataTableIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                DataTableIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > DataTableIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(HD_ReturnObjectTagFromRegNum(lv_b, lp_key))+"值"+IntToString(DataTableIntLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DataTableIntSave1(false, "IntStackOutTag", lv_c, DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DataTableIntSave1(false, "IntStackOutTagValue", lv_c, DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_c, DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                DataTableIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DataTableIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        DataTableIntSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DataTableIntSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = DataTableIntLoad1(true, (lp_key + "ObjectTag"), lv_a).ToString(); //原始序号元素
                lv_tag = DataTableIntLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValue = lv_tag;
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = DataTableIntLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                                                                                  //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    DataTableIntSave1(true, (lp_key + "ObjectTag"), lv_a, lv_tag); //lv_tag放入新序号
                                                                                   //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            ThreadWaitSet(true, "Key_ObjectGroup" + lv_str, false);
        }

        /// <summary>
        /// 【MM_函数库】互动OG_设定Object的Object组专用状态。给Object组的Object设定一个状态值（字符串），之后可用"互动O_返回Object、互动OG_返回Object组的Object状态"。状态值"true"和"false"是Object的Object组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效），而本函数可以重设干预，影响函数"互动OG_返回Object组元素数量（仅检索XX状态）"。与"互动O_设定Object状态"功能相同，只是状态参数在Object组中被固定为"Object组变量的内部ID"。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_objectGroup"></param>
        /// <param name="lp_groupState"></param>
        public static void HD_SetObjectGState(object lp_object, string lp_objectGroup, string lp_groupState)
        {
            HD_SetObjectState(lp_object, lp_objectGroup, lp_groupState);
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object的Object组专用状态。使用"互动O_设定Object、互动OG_设定Object组的Object状态"后可使用本函数。与"互动O_返回Object状态"功能相同，只是状态参数在Object组中被固定为"Object组变量的内部ID"。状态值"true"和"false"是Object的Object组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效）。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_objectGroup"></param>
        public static void HD_ReturnObjectGState(object lp_object, string lp_objectGroup)
        {
            HD_ReturnObjectState(lp_object, lp_objectGroup);
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object组元素序号对应元素。返回Object组元素序号指定Object。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static object HD_ReturnObjectFromObjectGFunc(int lp_regNum, string lp_gs)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag;
            object lv_object;
            // Variable Initialization
            lv_str = (lp_gs + "Object");
            lv_tag = DataTableIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            lv_object = DataTableObjectLoad0(true, ("HD_Object_" + lv_tag));
            // Implementation
            return lv_object;
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object组元素总数。返回指定Object组的元素数量。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns>错误时返回0</returns>
        public static int HD_ReturnObjectGNumMax(string lp_gs)
        {
            return DataTableIntLoad0(true, lp_gs + "ObjectNum");
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object组元素总数（仅检测Object组专用状态="true"）。返回指定Object组的元素数量。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HD_ReturnObjectGNumMax_StateTrueFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            object lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HD_ReturnObjectNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HD_ReturnObjectFromRegNum(lv_a, lp_gs);
                lv_b = HD_ReturnObjectState(lv_c, lp_gs);
                if ((lv_b == "true"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object组元素总数（仅检测Object组专用状态="false"）。返回指定Object组的元素数量。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HD_ReturnObjectGNumMax_StateFalseFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            object lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HD_ReturnObjectNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HD_ReturnObjectFromRegNum(lv_a, lp_gs);
                lv_b = HD_ReturnObjectState(lv_c, lp_gs);
                if ((lv_b == "false"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object组元素总数（仅检测Object组无效专用状态："false"或""）。返回指定Object组的元素数量（false、""、null）。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HD_ReturnObjectGNumMax_StateUselessFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            object lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HD_ReturnObjectNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HD_ReturnObjectFromRegNum(lv_a, lp_gs);
                lv_b = HD_ReturnObjectState(lv_c, lp_gs);
                if (((lv_b == "false") || (lv_b == "") || (lv_b == null)))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object组元素总数（仅检测Object组指定专用状态）。返回指定Object组的元素数量。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_State">Object组专用状态</param>
        /// <returns></returns>
        public static int HD_ReturnObjectGNumMax_StateFunc_Specify(string lp_gs, string lp_State)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            object lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HD_ReturnObjectNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HD_ReturnObjectFromRegNum(lv_a, lp_gs);
                lv_b = HD_ReturnObjectState(lv_c, lp_gs);
                if ((lv_b == lp_State))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动OG_添加Object到Object组。相同Object被认为是同一个，非高级功能不提供专用状态检查，如果Object没有设置过Object组专用状态，那么首次添加到Object组不会赋予"true"（之后可通过"互动O_设定Object状态"、"互动OG_设定Object组的Object状态"修改）。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HD_AddObjectToGroup_Simple(object lp_object, string lp_gs)
        {
            HD_RegObject_Simple(lp_object, lp_gs);
        }

        /// <summary>
        /// 【MM_函数库】互动OG_添加Object到Object组（高级）。相同Object被认为是同一个，高级功能提供专用状态检查，如果Object没有设置过Object组专用状态，那么首次添加到Object组会赋予"true"（之后可通过"互动O_设定Object状态"、"互动OG_设定Object组的Object状态"修改）。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HD_AddObjectToGroup(object lp_object, string lp_gs)
        {
            HD_RegObject_Simple(lp_object, lp_gs);
            if (DataTableStringKeyExists(true, ("HD_ObjectState" + lp_gs + "Object_" + HD_RegObjectTagAndReturn(lp_object))) == false)
            {
                DataTableStringSave0(true, ("HD_ObjectState" + lp_gs + "Object_" + HD_RegObjectTagAndReturn(lp_object)), "true");
                //Console.WriteLine(lp_gs + "=>" + HD_RegObjectTagAndReturn(lp_object));
            }
        }

        /// <summary>
        /// 【MM_函数库】互动OG_移除Object组中的元素。使用"互动OG_添加Object到Object组"后可使用本函数进行移除元素。移除使用了"互动O_移除Object"，同一个存储区（Object组ID）序号重排，移除时该存储区如有其他操作会排队等待。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HD_ClearObjectFromGroup(object lp_object, string lp_gs)
        {
            HD_RemoveObject(lp_object, lp_gs);
        }

        //互动OG_为Object组中的每个序号
        //GE（星际2的Galaxy Editor）的宏让编辑器保存时自动生成脚本并整合进脚本进行格式调整，C#仅参考需自行编写
        // #AUTOVAR(vs, string) = "#PARAM(group)";//"#PARAM(group)"是与字段、变量名一致的元素组名称，宏去声明string类型名为“Auto随机编号_vs”的自动变量，然后=右侧字符
        // #AUTOVAR(ae) = HD_ReturnObjectNumMax(#AUTOVAR(vs));//宏去声明默认int类型名为“Auto随机编号_ae”的自动变量，然后=右侧字符
        // #INITAUTOVAR(ai,increment)//宏去声明int类型名为“Auto随机编号_ai”的自动变量，用于下面for循环增量（increment是传入参数）
        // #PARAM(var) = #PARAM(s);//#PARAM(var)是传进来的参数，用作“当前被挑选到的元素”（任意变量-整数 lp_var）， #PARAM(s)是传进来的参数用作"开始"（int lp_s）
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #PARAM(var) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #PARAM(var) >= #AUTOVAR(ae)) ) ; #PARAM(var) += #AUTOVAR(ai) ) {
        //     #SUBFUNCS(actions)//代表用户GUI填写的所有动作
        // }

        /// <summary>
        /// 【MM_函数库】互动OG_为Object组中的每个序号。每次挑选的元素序号会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素序号，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void HD_ForEachObjectNumFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            int lv_ae = HD_ReturnObjectNumMax(lp_gs);
            int lv_var = lp_start;
            int lv_ai = lp_increment;
            for (; (lv_ai >= 0 && lv_var <= lv_ae) || (lv_ai < 0 && lv_var >= lv_ae); lv_var += lv_ai)
            {
                lp_funcref(lv_var);//用户填写的所有动作
            }
        }

        //互动OG_为Object组中的每个元素
        // #AUTOVAR(vs, string) = "#PARAM(group)";
        // #AUTOVAR(ae) = HD_ReturnObjectNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= #PARAM(s);
        // #INITAUTOVAR(ai,increment)
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     DataTableSave(false, "ObjectGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)), HD_ReturnObjectFromRegNum(#AUTOVAR(va),#AUTOVAR(vs)));
        // }
        // #AUTOVAR(va)= #PARAM(s);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #PARAM(var) = DataTableLoad(false, "ObjectGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)));
        //     #SUBFUNCS(actions)
        // }

        /// <summary>
        /// 【MM_函数库】互动OG_为Object组中的每个元素。每次挑选的元素会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void HD_ForEachObjectFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            string lv_vs = lp_gs;
            int lv_ae = HD_ReturnObjectNumMax(lv_vs);
            int lv_va = lp_start;
            int lv_ai = lp_increment;
            object lv_object;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                DataTableObjectSave0(false, "ObjectGFor" + lv_vs + lv_va.ToString(), HD_ReturnObjectFromRegNum(lv_va, lv_vs));
            }
            lv_va = lp_start;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                lv_object = DataTableObjectLoad0(false, "ObjectGFor" + lv_vs + lv_va.ToString());
                lp_funcref(lv_object);//用户填写的所有动作
            }
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object组中随机元素。返回指定Object组中的随机Object。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static object HD_ReturnRandomObjectFromObjectGFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_num;
            int lv_a;
            object lv_c = null;
            // Variable Initialization
            lv_num = HD_ReturnObjectNumMax(lp_gs);
            // Implementation
            if ((lv_num >= 1))
            {
                lv_a = RandomInt(1, lv_num);
                lv_c = HD_ReturnObjectFromRegNum(lv_a, lp_gs);
            }
            return lv_c;
        }

        //互动OG_添加Object组到Object组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = HD_ReturnObjectNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = HD_ReturnObjectFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     HD_AddObjectToGroup(#AUTOVAR(var), #AUTOVAR(vsb));
        // }

        /// <summary>
        /// 【MM_函数库】互动OG_添加Object组到Object组。添加一个Object组A的元素到另一个Object组B，相同Object被认为是同一个。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void HD_AddObjectGToObjectG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = HD_ReturnObjectNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            object lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = HD_ReturnObjectFromRegNum(lv_va, lv_vsa);
                HD_AddObjectToGroup(lv_var, lv_vsb);
            }
        }

        //互动OG_从Object组移除Object组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = HD_ReturnObjectNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = HD_ReturnObjectFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     HD_RemoveObject(#AUTOVAR(var), #AUTOVAR(vsb));
        // }

        /// <summary>
        /// 【MM_函数库】互动OG_从Object组移除Object组。将Object组A的元素从Object组B中移除，相同Object被认为是同一个。移除使用了"互动O_移除Object"，同一个存储区（Object组ID）序号重排，移除时该存储区如有其他操作会排队等待。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void HD_ClearObjectGFromObjectG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = HD_ReturnObjectNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            object lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = HD_ReturnObjectFromRegNum(lv_va, lv_vsa);
                HD_RemoveObject(lv_var, lv_vsb);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动OG_移除Object组全部元素。将Object组（Key区）存储的元素全部移除，相同Object被认为是同一个。移除时同一个存储区（Object组ID）序号不进行重排，但该存储区如有其他操作会排队等待。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Object组名称</param>
        public static void HD_RemoveObjectGAll(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag = "";
            int lv_a;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            // Implementation
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_ObjectGroup" + lv_str, true);
            for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
            {
                lv_tag = DataTableIntLoad1(true, (lp_key + "ObjectTag"), lv_a).ToString();
                lv_num -= 1;
                DataTableBoolClear0(true, "HD_IfObjectTag" + lv_str + "_" + lv_tag);
                DataTableStringClear0(true, "HD_ObjectCV" + lv_str + "_" + lv_tag);
                DataTableStringClear0(true, "HD_ObjectState" + lv_str + "_" + lv_tag);
                DataTableIntSave0(true, (lp_key + "ObjectNum"), lv_num);
            }
            ThreadWaitSet(true, "Key_ObjectGroup" + lv_str, false);
        }

        //--------------------------------------------------------------------------------------------------
        // 任意类型组End
        //--------------------------------------------------------------------------------------------------

        #endregion

        #region 二维向量

        //提示：尽可能使用对口类型，以防值类型与引用类型发生转换时拆装箱降低性能

        //--------------------------------------------------------------------------------------------------
        // 二维向量组Start
        //--------------------------------------------------------------------------------------------------

        /// <summary>
        /// 【MM_函数库】互动V_注册Vector标签句柄并返回。为Vector自动设置新的标签句柄，重复时会返回已注册的Vector标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns>返回一个Vector的已注册标签</returns>
        private static int HD_RegVectorTagAndReturn_Int(Vector lp_vector)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = DataTableIntLoad0(true, "HD_VectorJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                DataTableIntSave0(true, "HD_VectorJBNum", lv_j);
                DataTableVectorSave0(true, ("HD_Vector_" + lv_j.ToString()), lp_vector);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if (DataTableVectorLoad0(true, ("HD_Vector_" + lv_j.ToString())) == lp_vector)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            DataTableIntSave0(true, "HD_VectorJBNum", lv_j);
                            DataTableVectorSave0(true, ("HD_Vector_" + lv_j.ToString()), lp_vector);
                        }
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector已注册标签句柄
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns>返回一个Vector的已注册标签，错误返回0</returns>
        public static int HD_ReturnVectorTag_Int(Vector lp_vector)
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = DataTableIntLoad0(true, "HD_VectorJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if (DataTableVectorLoad0(true, "HD_Vector_" + lv_j.ToString()) == lp_vector)
                {
                    break;
                }
                else
                {
                    if ((lv_j == lv_jBNum))
                    {
                        lv_j = 0;
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动V_注册Vector标签句柄并返回。为Vector自动设置新的标签句柄，重复时会返回已注册的Vector标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns>返回一个Vector的已注册标签</returns>
        private static string HD_RegVectorTagAndReturn(Vector lp_vector)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = DataTableIntLoad0(true, "HD_VectorJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                DataTableIntSave0(true, "HD_VectorJBNum", lv_j);
                DataTableVectorSave0(true, ("HD_Vector_" + lv_j.ToString()), lp_vector);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if (DataTableVectorLoad0(true, "HD_Vector_" + lv_j.ToString()) == lp_vector)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            DataTableIntSave0(true, "HD_VectorJBNum", lv_j);
                            DataTableVectorSave0(true, ("HD_Vector_" + lv_j.ToString()), lp_vector);
                        }
                    }
                }
            }
            lv_tag = lv_j.ToString();
            //Console.WriteLine(("Tag：" + lv_tag));
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector已注册标签句柄
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns>返回一个Vector的已注册标签，错误返回""</returns>
        public static string HD_ReturnVectorTag(Vector lp_vector)
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag = "";
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = DataTableIntLoad0(true, "HD_VectorJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if (DataTableVectorLoad0(true, "HD_Vector_" + lv_j.ToString()) == lp_vector)
                {
                    lv_tag = lv_j.ToString();
                    break;
                }
            }
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动V_注册Vector(高级)。在指定Key存入Vector，固有状态、自定义值是Vector独一无二的标志（本函数重复注册会刷新），之后可用互动V_"返回Vector注册总数"、"返回Vector序号"、"返回序号对应Vector"、"返回序号对应Vector标签"、"返回Vector自定义值"。Vector组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Vector组转为Key。首次注册时固有状态为true（相当于单位组单位活体），如需另外设置多个标记可使用"互动V_设定Vector状态/自定义值"
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        /// <param name="lp_inherentStats">固有状态</param>
        /// <param name="lp_inherentCustomValue">固有自定义值</param>
        public static void HD_RegVector(Vector lp_vector, string lp_key, string lp_inherentStats, string lp_inherentCustomValue)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;

            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_jBNum = DataTableIntLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = HD_RegVectorTagAndReturn(lp_vector);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                DataTableIntSave0(true, (lv_str + "Num"), lv_i);
                DataTableStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                DataTableBoolSave0(true, (("HD_IfVectorTag" + "") + "_" + lv_tagStr), true);
                DataTableBoolSave1(true, ("HD_IfVectorTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if (DataTableIntLoad1(true, lv_str + "Tag", lv_i).ToString() == lv_tagStr)
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                DataTableIntSave0(true, (lv_str + "Num"), lv_i);
                                DataTableStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                DataTableBoolSave0(true, (("HD_IfVectorTag" + "") + "_" + lv_tagStr), true);
                                DataTableBoolSave1(true, ("HD_IfVectorTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            DataTableStringSave0(true, ("HD_VectorState" + "" + "_" + lv_tagStr), lp_inherentStats);
            DataTableStringSave0(true, ("HD_VectorCV" + "" + "_" + lv_tagStr), lp_inherentCustomValue);
        }

        /// <summary>
        /// 【MM_函数库】互动V_注册Vector。在指定Key存入Vector，固有状态、自定义值是Vector独一无二的标志（本函数重复注册不会刷新），之后可用互动V_"返回Vector注册总数"、"返回Vector序号"、"返回序号对应Vector"、"返回Vector自定义值"。Vector组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Vector组转为Key。首次注册时固有状态为true（相当于单位组单位活体），之后只能通过"互动V_注册Vector（高级）"改写，如需另外设置多个标记可使用"互动V_设定Vector状态/自定义值"
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        public static void HD_RegVector_Simple(Vector lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;

            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_jBNum = DataTableIntLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = HD_RegVectorTagAndReturn(lp_vector);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                DataTableIntSave0(true, (lv_str + "Num"), lv_i);
                DataTableStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                DataTableBoolSave0(true, (("HD_IfVectorTag" + "") + "_" + lv_tagStr), true);
                DataTableBoolSave1(true, ("HD_IfVectorTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if (DataTableIntLoad1(true, lv_str + "Tag", lv_i).ToString() == lv_tagStr)
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                DataTableIntSave0(true, (lv_str + "Num"), lv_i);
                                DataTableStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                DataTableBoolSave0(true, (("HD_IfVectorTag" + "") + "_" + lv_tagStr), true);
                                DataTableBoolSave1(true, ("HD_IfVectorTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            if ((DataTableBoolKeyExists(true, ("HD_Vector" + "State" + "_" + lv_tag.ToString())) == false))
            {
                DataTableStringSave1(true, (("HD_Vector" + "State")), lv_tag, "true");
            }
        }

        /// <summary>
        /// 【MM_函数库】互动V_注销Vector。用"互动V_注册Vector"到Key，之后可用本函数彻底摧毁注册信息并将序号重排（包括Vector标签有效状态、固有状态及自定义值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动V_设定Vector状态"让Vector状态失效（类似单位组的单位活体状态）。Vector组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Vector组转为Key。本函数无法摧毁用"互动V_设定Vector状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Vector组变量ID时会清空Vector组专用状态
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        public static void HD_DestroyVector(Vector lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag;
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_tag = HD_ReturnVectorTag(lp_vector);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                ThreadWaitSet(true, "Key_VectorGroup" + lv_str, true);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((DataTableIntLoad1(true, (lp_key + "VectorTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        DataTableBoolClear0(true, "HD_IfVectorTag_" + lv_tag);
                        DataTableBoolClear0(true, "HD_IfVectorTag" + lv_str + "_" + lv_tag);
                        DataTableVectorClear0(true, "HD_Vector_" + lv_tag);
                        DataTableStringClear0(true, "HD_VectorCV_" + lv_tag);
                        DataTableStringClear0(true, "HD_VectorState_" + lv_tag);
                        DataTableStringClear0(true, "HD_VectorCV" + lv_str + "_" + lv_tag);
                        DataTableStringClear0(true, "HD_VectorState" + lv_str + "_" + lv_tag);
                        DataTableIntSave0(true, (lp_key + "VectorNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = DataTableIntLoad1(true, (lp_key + "VectorTag"), lv_b + 1).ToString();
                            DataTableStringSave1(true, (lp_key + "VectorTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                ThreadWaitSet(true, "Key_VectorGroup" + lv_str, false);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动V_移除Vector。用"互动V_注册Vector"到Key，之后可用本函数仅摧毁Key区注册的信息并将序号重排，用于Vector组或多个键区仅移除Vector（保留Vector标签有效状态、固有值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动V_设定Vector状态"让Vector状态失效（类似单位组的单位活体状态）。Vector组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Vector组转为Key。本函数无法摧毁用"互动V_设定Vector状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Vector组变量ID时会清空Vector组专用状态
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        public static void HD_RemoveVector(Vector lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag;
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_tag = HD_ReturnVectorTag(lp_vector);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                ThreadWaitSet(true, "Key_VectorGroup" + lv_str, true);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((DataTableIntLoad1(true, (lp_key + "VectorTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        DataTableBoolClear0(true, "HD_IfVectorTag" + lv_str + "_" + lv_tag);
                        DataTableStringClear0(true, "HD_VectorCV" + lv_str + "_" + lv_tag);
                        DataTableStringClear0(true, "HD_VectorState" + lv_str + "_" + lv_tag);
                        DataTableIntSave0(true, (lp_key + "VectorNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = DataTableIntLoad1(true, (lp_key + "VectorTag"), lv_b + 1).ToString();
                            DataTableStringSave1(true, (lp_key + "VectorTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                ThreadWaitSet(true, "Key_VectorGroup" + lv_str, false);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector注册总数。必须先使用"互动V_注册Vector"才能返回指定Key里的注册总数。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key。
        /// </summary>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        /// <returns></returns>
        public static int HD_ReturnVectorNumMax(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            // Implementation
            return lv_num;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector序号。使用"互动V_注册Vector"后使用本函数可返回Key里的注册序号，Key无元素返回0，Key有元素但对象不在里面则返回-1，Vector标签尚未注册则返回-2。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        /// <returns></returns>
        public static int HD_ReturnVectorNum(Vector lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_i;
            string lv_tag;
            int lv_torf;
            // Automatic Variable Declarations
            const int auto_n = 1;
            int auto_i;
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_tag = HD_ReturnVectorTag(lp_vector);
            lv_torf = -1;
            // Implementation
            for (auto_i = 1; auto_i <= auto_n; auto_i += 1)
            {
                if ((lv_tag != null))
                {
                    lv_torf = -2;
                    break;
                }
                if ((lv_num == 0))
                {
                    lv_torf = 0;
                }
                else
                {
                    if ((lv_num >= 1))
                    {
                        auto_ae = lv_num;
                        auto_var = 1;
                        for (; auto_var <= auto_ae; auto_var += 1)
                        {
                            lv_i = auto_var;
                            if ((DataTableIntLoad1(true, (lv_str + "Tag"), lv_i).ToString() == lv_tag))
                            {
                                lv_torf = lv_i;
                                break;
                            }
                        }
                    }
                }
            }
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回序号对应Vector。使用"互动V_注册Vector"后，在参数填入注册序号可返回Vector。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_regNum"></param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        /// <returns>错误时返回new Vector(0,0)</returns>
        public static Vector HD_ReturnVectorFromRegNum(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            lv_tag = DataTableIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return DataTableVectorLoad0(true, ("HD_Vector_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回句柄标签对应Vector。使用"互动V_注册Vector"后，在参数填入句柄标签（整数）可返回Vector，标签是Vector的句柄。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_tag">句柄标签</param>
        /// <returns>错误时返回new Vector(0,0)</returns>
        public static Vector HD_ReturnVectorFromTag(int lp_tag)
        {
            // Variable Declarations
            string lv_tag;
            // Variable Initialization
            lv_tag = lp_tag.ToString();
            // Implementation
            return DataTableVectorLoad0(true, ("HD_Vector_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回序号对应Vector标签句柄。使用"互动V_注册Vector"后，在参数填入注册序号可返回Vector标签（字符串）。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        /// <returns></returns>
        public static string HD_ReturnVectorTagFromRegNum_String(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            lv_tag = DataTableIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回序号对应Vector标签句柄。使用"互动V_注册Vector"后，在参数填入注册序号可返回Vector标签（整数）。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        /// <returns></returns>
        public static int HD_ReturnVectorTagFromRegNum_Int(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            lv_tag = DataTableIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return Convert.ToInt32(lv_tag);
        }

        /// <summary>
        /// 【MM_函数库】互动V_设置Vector状态。必须先"注册"获得功能库内部句柄，再使用本函数给Vector设定一个状态值，之后可用"互动V_返回Vector状态"。类型参数用以记录多个不同状态，仅当"类型"参数填Vector组ID转的Vector串时，状态值"true"和"false"是Vector的Vector组专用状态值，用于内部函数筛选Vector状态（相当于单位组单位索引是否有效），其他类型不会干扰系统内部，可随意填写。虽然注销时反向清空注册信息，但用"互动V_设定Vector状态/自定义值"创建的值需要手工填入""来排泄（非大量注销则提升内存量极小，可不管）。注：固有状态值是注册函数赋予的系统内部变量（相当于单位组单位是否活体），只能通过"互动V_注册Vector（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <param name="lp_stats">状态</param>
        public static void HD_SetVectorState(Vector lp_vector, string lp_key, string lp_stats)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            lv_tag = HD_RegVectorTagAndReturn(lp_vector);
            // Implementation
            DataTableStringSave0(true, ("HD_VectorState" + lv_str + "_" + lv_tag), lp_stats);
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector状态。使用"互动V_设定Vector状态"后可使用本函数，将本函数参数"类型"设为空时返回固有值。类型参数用以记录多个不同状态，仅当"类型"参数为Vector组ID转的字符串时，返回的状态值"true"和"false"是Vector的Vector组专用状态值，用于内部函数筛选Vector状态（相当于单位组单位索引是否有效）
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <returns></returns>
        public static string HD_ReturnVectorState(Vector lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            lv_tag = HD_ReturnVectorTag(lp_vector);
            lv_stats = DataTableStringLoad0(true, ("HD_VectorState" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动V_设置Vector自定义值。必须先"注册"获得功能库内部句柄，再使用本函数设定Vector的自定义值，之后可使用"互动V_返回Vector自定义值"，类型参数用以记录多个不同自定义值。注：固有自定义值是注册函数赋予的系统内部变量，只能通过"互动V_注册Vector（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <param name="lp_customValue">自定义值</param>
        public static void HD_SetVectorCV(Vector lp_vector, string lp_key, string lp_customValue)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            lv_tag = HD_RegVectorTagAndReturn(lp_vector);
            // Implementation
            DataTableStringSave0(true, ("HD_VectorCV" + lv_str + "_" + lv_tag), lp_customValue);
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector自定义值。使用"互动V_设定Vector自定义值"后可使用本函数，将本函数参数"类型"设为空时返回固有值，该参数用以记录多个不同自定义值
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <returns></returns>
        public static string HD_ReturnVectorCV(Vector lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            lv_tag = HD_ReturnVectorTag(lp_vector);
            lv_customValue = DataTableStringLoad0(true, ("HD_VectorCV" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector固有状态。必须先使用"互动V_注册Vector"才能返回到该值，固有状态是独一无二的标记（相当于单位组单位是否活体）
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns></returns>
        public static string HD_ReturnVectorState_Only(Vector lp_vector)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_tag = HD_ReturnVectorTag(lp_vector);
            lv_stats = DataTableStringLoad0(true, ("HD_VectorState" + "" + "_" + lv_tag));
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector固有自定义值。必须先使用"互动V_注册Vector"才能返回到该值，固有值是独一无二的标记
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns></returns>
        public static string HD_ReturnVectorCV_Only(Vector lp_vector)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_tag = HD_ReturnVectorTag(lp_vector);
            lv_customValue = DataTableStringLoad0(true, ("HD_VectorCV" + "" + "_" + lv_tag));
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动V_设置Vector的实数标记。必须先"注册"获得功能库内部句柄，再使用本函数让Vector携带一个实数值，之后可使用"互动V_返回Vector的实数标记"。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_realNumTag">实数标记</param>
        public static void HD_SetVectorDouble(Vector lp_vector, double lp_realNumTag)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = HD_RegVectorTagAndReturn(lp_vector);
            // Implementation
            DataTableDoubleSave0(true, ("HD_CDDouble_Vector_" + lv_tag), lp_realNumTag);
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector的实数标记。使用"互动V_设定Vector的实数标记"后可使用本函数。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns></returns>
        public static double HD_ReturnVectorDouble(Vector lp_vector)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = HD_ReturnVectorTag(lp_vector);
            // Implementation
            return DataTableDoubleLoad0(true, ("HD_CDDouble_Vector_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector标签句柄有效状态。将Vector视作独一无二的个体，标签是它本身，有效状态则类似"单位是否有效"，当使用"互动V_注册Vector"或"互动VG_添加Vector到Vector组"后激活Vector有效状态（值为"true"），除非使用"互动V_注册Vector（高级）"改写，否则直到注销才会摧毁
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns></returns>
        public static bool HD_ReturnIfVectorTag(Vector lp_vector)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = HD_ReturnVectorTag(lp_vector);
            // Implementation
            return DataTableBoolLoad0(true, ("HD_IfVectorTag" + "" + "_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector注册状态。使用"互动V_注册Vector"或"互动VG_添加Vector到Vector组"后可使用本函数获取注册Vector在Key中的注册状态，该状态只能注销或从Vector组中移除时清空。Vector组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        /// <returns></returns>
        public static bool HD_ReturnIfVectorTagKey(Vector lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            lv_tag = HD_ReturnVectorTag(lp_vector);
            // Implementation
            return DataTableBoolLoad0(true, ("HD_IfVectorTag" + lv_str + "_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动VG_根据自定义值类型将Vector组排序。根据Vector携带的自定义值类型，对指定的Vector组元素进行冒泡排序。Vector组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Vector组名称</param>
        /// <param name="lp_cVStr">自定义值类型</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void HD_VectorGSortCV(string lp_key, string lp_cVStr, bool lp_big)
        {
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            string lv_tagValuestr;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_VectorGroup" + lv_str, true);
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = HD_ReturnVectorTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValuestr = HD_ReturnVectorCV((Vector)HD_ReturnVectorFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    DataTableIntSave1(false, "IntStackOutTag", 1, lv_tag);
                    DataTableIntSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < DataTableIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DataTableIntSave1(false, "IntStackOutTag", lv_c, DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    DataTableIntSave1(false, "IntStackOutTagValue", lv_c, DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_c, DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                DataTableIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                DataTableIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > DataTableIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(HD_ReturnVectorTagFromRegNum(lv_b, lp_key))+"值"+IntToString(DataTableIntLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DataTableIntSave1(false, "IntStackOutTag", lv_c, DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DataTableIntSave1(false, "IntStackOutTagValue", lv_c, DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_c, DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                DataTableIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DataTableIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        DataTableIntSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DataTableIntSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = DataTableIntLoad1(true, (lp_key + "VectorTag"), lv_a).ToString(); //原始序号元素
                lv_tag = DataTableIntLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValuestr = HD_ReturnVectorCV((Vector)HD_ReturnVectorFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = DataTableIntLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    DataTableIntSave1(true, (lp_key + "VectorTag"), lv_a, lv_tag); //lv_tag放入新序号
                    //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            ThreadWaitSet(true, "Key_VectorGroup" + lv_str, false);
        }

        /// <summary>
        /// 【MM_函数库】互动VG_Vector组排序。对指定的Vector组元素进行冒泡排序（根据元素句柄）。Vector组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Vector组名称</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void HD_VectorGSort(string lp_key, bool lp_big)
        {
            // Automatic Variable Declarations
            // Implementation
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_VectorGroup" + lv_str, true);
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = HD_ReturnVectorTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValue = lv_tag;
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    DataTableIntSave1(false, "IntStackOutTag", 1, lv_tag);
                    DataTableIntSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < DataTableIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DataTableIntSave1(false, "IntStackOutTag", lv_c, DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    DataTableIntSave1(false, "IntStackOutTagValue", lv_c, DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_c, DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                DataTableIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                DataTableIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > DataTableIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(HD_ReturnVectorTagFromRegNum(lv_b, lp_key))+"值"+IntToString(DataTableIntLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DataTableIntSave1(false, "IntStackOutTag", lv_c, DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DataTableIntSave1(false, "IntStackOutTagValue", lv_c, DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_c, DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                DataTableIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DataTableIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        DataTableIntSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DataTableIntSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = DataTableIntLoad1(true, (lp_key + "VectorTag"), lv_a).ToString(); //原始序号元素
                lv_tag = DataTableIntLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValue = lv_tag;
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = DataTableIntLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                                                                                  //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    DataTableIntSave1(true, (lp_key + "VectorTag"), lv_a, lv_tag); //lv_tag放入新序号
                                                                                   //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            ThreadWaitSet(true, "Key_VectorGroup" + lv_str, false);
        }

        /// <summary>
        /// 【MM_函数库】互动VG_设定Vector的Vector组专用状态。给Vector组的Vector设定一个状态值（字符串），之后可用"互动V_返回Vector、互动VG_返回Vector组的Vector状态"。状态值"true"和"false"是Vector的Vector组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效），而本函数可以重设干预，影响函数"互动VG_返回Vector组元素数量（仅检索XX状态）"。与"互动V_设定Vector状态"功能相同，只是状态参数在Vector组中被固定为"Vector组变量的内部ID"。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_vectorGroup"></param>
        /// <param name="lp_groupState"></param>
        public static void HD_SetVectorGState(Vector lp_vector, string lp_vectorGroup, string lp_groupState)
        {
            HD_SetVectorState(lp_vector, lp_vectorGroup, lp_groupState);
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector的Vector组专用状态。使用"互动V_设定Vector、互动VG_设定Vector组的Vector状态"后可使用本函数。与"互动V_返回Vector状态"功能相同，只是状态参数在Vector组中被固定为"Vector组变量的内部ID"。状态值"true"和"false"是Vector的Vector组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效）。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_vectorGroup"></param>
        public static void HD_ReturnVectorGState(Vector lp_vector, string lp_vectorGroup)
        {
            HD_ReturnVectorState(lp_vector, lp_vectorGroup);
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector组元素序号对应元素。返回Vector组元素序号指定Vector。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static Vector HD_ReturnVectorFromVectorGFunc(int lp_regNum, string lp_gs)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_gs + "Vector");
            lv_tag = DataTableIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return DataTableVectorLoad0(true, ("HD_Vector_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector组元素总数。返回指定Vector组的元素数量。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HD_ReturnVectorGNumMax(string lp_gs)
        {
            return DataTableIntLoad0(true, lp_gs + "VectorNum");
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector组元素总数（仅检测Vector组专用状态="true"）。返回指定Vector组的元素数量。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HD_ReturnVectorGNumMax_StateTrueFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Vector lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HD_ReturnVectorNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (Vector)HD_ReturnVectorFromRegNum(lv_a, lp_gs);
                lv_b = HD_ReturnVectorState(lv_c, lp_gs);
                if ((lv_b == "true"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector组元素总数（仅检测Vector组专用状态="false"）。返回指定Vector组的元素数量。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HD_ReturnVectorGNumMax_StateFalseFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Vector lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HD_ReturnVectorNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (Vector)HD_ReturnVectorFromRegNum(lv_a, lp_gs);
                lv_b = HD_ReturnVectorState(lv_c, lp_gs);
                if ((lv_b == "false"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector组元素总数（仅检测Vector组无效专用状态："false"或""）。返回指定Vector组的元素数量（false、""、null）。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HD_ReturnVectorGNumMax_StateUselessFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Vector lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HD_ReturnVectorNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (Vector)HD_ReturnVectorFromRegNum(lv_a, lp_gs);
                lv_b = HD_ReturnVectorState(lv_c, lp_gs);
                if (((lv_b == "false") || (lv_b == "") || (lv_b == null)))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector组元素总数（仅检测Vector组指定专用状态）。返回指定Vector组的元素数量。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_State">Vector组专用状态</param>
        /// <returns></returns>
        public static int HD_ReturnVectorGNumMax_StateFunc_Specify(string lp_gs, string lp_State)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Vector lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HD_ReturnVectorNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (Vector)HD_ReturnVectorFromRegNum(lv_a, lp_gs);
                lv_b = HD_ReturnVectorState(lv_c, lp_gs);
                if ((lv_b == lp_State))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动VG_添加Vector到Vector组。相同Vector被认为是同一个，非高级功能不提供专用状态检查，如果Vector没有设置过Vector组专用状态，那么首次添加到Vector组不会赋予"true"（之后可通过"互动V_设定Vector状态"、"互动VG_设定Vector组的Vector状态"修改）。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HD_AddVectorToGroup_Simple(Vector lp_vector, string lp_gs)
        {
            HD_RegVector_Simple(lp_vector, lp_gs);
        }

        /// <summary>
        /// 【MM_函数库】互动VG_添加Vector到Vector组（高级）。相同Vector被认为是同一个，高级功能提供专用状态检查，如果Vector没有设置过Vector组专用状态，那么首次添加到Vector组会赋予"true"（之后可通过"互动V_设定Vector状态"、"互动VG_设定Vector组的Vector状态"修改）。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HD_AddVectorToGroup(Vector lp_vector, string lp_gs)
        {
            HD_RegVector_Simple(lp_vector, lp_gs);
            if (DataTableStringKeyExists(true, ("HD_VectorState" + lp_gs + "Vector_" + HD_RegVectorTagAndReturn(lp_vector))) == false)
            {
                DataTableStringSave0(true, ("HD_VectorState" + lp_gs + "Vector_" + HD_RegVectorTagAndReturn(lp_vector)), "true");
                //Console.WriteLine(lp_gs + "=>" + HD_RegVectorTagAndReturn(lp_vector));
            }
        }

        /// <summary>
        /// 【MM_函数库】互动VG_移除Vector组中的元素。使用"互动VG_添加Vector到Vector组"后可使用本函数进行移除元素。移除使用了"互动V_移除Vector"，同一个存储区（Vector组ID）序号重排，移除时该存储区如有其他操作会排队等待。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HD_ClearVectorFromGroup(Vector lp_vector, string lp_gs)
        {
            HD_RemoveVector(lp_vector, lp_gs);
        }

        //互动VG_为Vector组中的每个序号
        //GE（星际2的Galaxy Editor）的宏让编辑器保存时自动生成脚本并整合进脚本进行格式调整，C#仅参考需自行编写
        // #AUTOVAR(vs, string) = "#PARAM(group)";//"#PARAM(group)"是与字段、变量名一致的元素组名称，宏去声明string类型名为“Auto随机编号_vs”的自动变量，然后=右侧字符
        // #AUTOVAR(ae) = HD_ReturnVectorNumMax(#AUTOVAR(vs));//宏去声明默认int类型名为“Auto随机编号_ae”的自动变量，然后=右侧字符
        // #INITAUTOVAR(ai,increment)//宏去声明int类型名为“Auto随机编号_ai”的自动变量，用于下面for循环增量（increment是传入参数）
        // #PARAM(var) = #PARAM(s);//#PARAM(var)是传进来的参数，用作“当前被挑选到的元素”（任意变量-整数 lp_var）， #PARAM(s)是传进来的参数用作"开始"（int lp_s）
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #PARAM(var) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #PARAM(var) >= #AUTOVAR(ae)) ) ; #PARAM(var) += #AUTOVAR(ai) ) {
        //     #SUBFUNCS(actions)//代表用户GUI填写的所有动作
        // }

        /// <summary>
        /// 【MM_函数库】互动VG_为Vector组中的每个序号。每次挑选的元素序号会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素序号，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void HD_ForEachVectorNumFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            int lv_ae = HD_ReturnVectorNumMax(lp_gs);
            int lv_var = lp_start;
            int lv_ai = lp_increment;
            for (; (lv_ai >= 0 && lv_var <= lv_ae) || (lv_ai < 0 && lv_var >= lv_ae); lv_var += lv_ai)
            {
                lp_funcref(lv_var);//用户填写的所有动作
            }
        }

        //互动VG_为Vector组中的每个元素
        // #AUTOVAR(vs, string) = "#PARAM(group)";
        // #AUTOVAR(ae) = HD_ReturnVectorNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= #PARAM(s);
        // #INITAUTOVAR(ai,increment)
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     DataTableSave(false, "VectorGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)), HD_ReturnVectorFromRegNum(#AUTOVAR(va),#AUTOVAR(vs)));
        // }
        // #AUTOVAR(va)= #PARAM(s);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #PARAM(var) = DataTableLoad(false, "VectorGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)));
        //     #SUBFUNCS(actions)
        // }

        /// <summary>
        /// 【MM_函数库】互动VG_为Vector组中的每个元素。每次挑选的元素会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void HD_ForEachVectorFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            string lv_vs = lp_gs;
            int lv_ae = HD_ReturnVectorNumMax(lv_vs);
            int lv_va = lp_start;
            int lv_ai = lp_increment;
            Vector lv_vector;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                DataTableVectorSave0(false, "VectorGFor" + lv_vs + lv_va.ToString(), (Vector)HD_ReturnVectorFromRegNum(lv_va, lv_vs));
            }
            lv_va = lp_start;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                lv_vector = (Vector)DataTableVectorLoad0(false, "VectorGFor" + lv_vs + lv_va.ToString());
                lp_funcref(lv_vector);//用户填写的所有动作
            }
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector组中随机元素。返回指定Vector组中的随机Vector。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns>错误时返回new Vector(0,0)</returns>
        public static Vector HD_ReturnRandomVectorFromVectorGFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_num;
            int lv_a;
            Vector lv_c = new Vector(0, 0);
            // Variable Initialization
            lv_num = HD_ReturnVectorNumMax(lp_gs);
            // Implementation
            if ((lv_num >= 1))
            {
                lv_a = RandomInt(1, lv_num);
                lv_c = (Vector)HD_ReturnVectorFromRegNum(lv_a, lp_gs);
            }
            return lv_c;
        }

        //互动VG_添加Vector组到Vector组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = HD_ReturnVectorNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = HD_ReturnVectorFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     HD_AddVectorToGroup(#AUTOVAR(var), #AUTOVAR(vsb));
        // }


        /// <summary>
        /// 【MM_函数库】互动VG_添加Vector组到Vector组。添加一个Vector组A的元素到另一个Vector组B，相同Vector被认为是同一个。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void HD_AddVectorGToVectorG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = HD_ReturnVectorNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            Vector lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = (Vector)HD_ReturnVectorFromRegNum(lv_va, lv_vsa);
                HD_AddVectorToGroup(lv_var, lv_vsb);
            }
        }

        //互动VG_从Vector组移除Vector组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = HD_ReturnVectorNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = HD_ReturnVectorFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     HD_RemoveVector(#AUTOVAR(var), #AUTOVAR(vsb));
        // }

        /// <summary>
        /// 【MM_函数库】互动VG_从Vector组移除Vector组。将Vector组A的元素从Vector组B中移除，相同Vector被认为是同一个。移除使用了"互动V_移除Vector"，同一个存储区（Vector组ID）序号重排，移除时该存储区如有其他操作会排队等待。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void HD_ClearVectorGFromVectorG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = HD_ReturnVectorNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            Vector lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = (Vector)HD_ReturnVectorFromRegNum(lv_va, lv_vsa);
                HD_RemoveVector(lv_var, lv_vsb);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动VG_移除Vector组全部元素。将Vector组（Key区）存储的元素全部移除，相同Vector被认为是同一个。移除时同一个存储区（Vector组ID）序号不进行重排，但该存储区如有其他操作会排队等待。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Vector组名称</param>
        public static void HD_RemoveVectorGAll(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag = "";
            int lv_a;
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            // Implementation
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_VectorGroup" + lv_str, true);
            for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
            {
                lv_tag = DataTableIntLoad1(true, (lp_key + "VectorTag"), lv_a).ToString();
                lv_num -= 1;
                DataTableBoolClear0(true, "HD_IfVectorTag" + lv_str + "_" + lv_tag);
                DataTableStringClear0(true, "HD_VectorCV" + lv_str + "_" + lv_tag);
                DataTableStringClear0(true, "HD_VectorState" + lv_str + "_" + lv_tag);
                DataTableIntSave0(true, (lp_key + "VectorNum"), lv_num);
            }
            ThreadWaitSet(true, "Key_VectorGroup" + lv_str, false);
        }

        //--------------------------------------------------------------------------------------------------
        // 二维向量组End
        //--------------------------------------------------------------------------------------------------

        #endregion

        #region 计时器

        //提示：尽可能使用对口类型，以防值类型与引用类型发生转换时拆装箱降低性能

        //--------------------------------------------------------------------------------------------------
        // 计时器组Start
        //--------------------------------------------------------------------------------------------------

        /// <summary>
        /// 【MM_函数库】互动T_注册Timer标签句柄并返回。为Timer自动设置新的标签句柄，重复时会返回已注册的Timer标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns>返回一个Timer的已注册标签</returns>
        private static int HD_RegTimerTagAndReturn_Int(Timer lp_timer)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = DataTableIntLoad0(true, "HD_TimerJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                DataTableIntSave0(true, "HD_TimerJBNum", lv_j);
                DataTableTimerSave0(true, ("HD_Timer_" + lv_j.ToString()), lp_timer);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if (DataTableTimerLoad0(true, ("HD_Timer_" + lv_j.ToString())) == lp_timer)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            DataTableIntSave0(true, "HD_TimerJBNum", lv_j);
                            DataTableTimerSave0(true, ("HD_Timer_" + lv_j.ToString()), lp_timer);
                        }
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer已注册标签句柄
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns>返回一个Timer的已注册标签，错误返回0</returns>
        public static int HD_ReturnTimerTag_Int(Timer lp_timer)
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = DataTableIntLoad0(true, "HD_TimerJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if (DataTableTimerLoad0(true, "HD_Timer_" + lv_j.ToString()) == lp_timer)
                {
                    break;
                }
                else
                {
                    if ((lv_j == lv_jBNum))
                    {
                        lv_j = 0;
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动T_注册Timer标签句柄并返回。为Timer自动设置新的标签句柄，重复时会返回已注册的Timer标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns>返回一个Timer的已注册标签</returns>
        private static string HD_RegTimerTagAndReturn(Timer lp_timer)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = DataTableIntLoad0(true, "HD_TimerJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                DataTableIntSave0(true, "HD_TimerJBNum", lv_j);
                DataTableTimerSave0(true, ("HD_Timer_" + lv_j.ToString()), lp_timer);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if (DataTableTimerLoad0(true, "HD_Timer_" + lv_j.ToString()) == lp_timer)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            DataTableIntSave0(true, "HD_TimerJBNum", lv_j);
                            DataTableTimerSave0(true, ("HD_Timer_" + lv_j.ToString()), lp_timer);
                        }
                    }
                }
            }
            lv_tag = lv_j.ToString();
            //Console.WriteLine(("Tag：" + lv_tag));
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer已注册标签句柄
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns>返回一个Timer的已注册标签，错误返回""</returns>
        public static string HD_ReturnTimerTag(Timer lp_timer)
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag = "";
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = DataTableIntLoad0(true, "HD_TimerJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if (DataTableTimerLoad0(true, "HD_Timer_" + lv_j.ToString()) == lp_timer)
                {
                    lv_tag = lv_j.ToString();
                    break;
                }
            }
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动T_注册Timer(高级)。在指定Key存入Timer，固有状态、自定义值是Timer独一无二的标志（本函数重复注册会刷新），之后可用互动T_"返回Timer注册总数"、"返回Timer序号"、"返回序号对应Timer"、"返回序号对应Timer标签"、"返回Timer自定义值"。Timer组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Timer组转为Key。首次注册时固有状态为true（相当于单位组单位活体），如需另外设置多个标记可使用"互动T_设定Timer状态/自定义值"
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        /// <param name="lp_inherentStats">固有状态</param>
        /// <param name="lp_inherentCustomValue">固有自定义值</param>
        public static void HD_RegTimer(Timer lp_timer, string lp_key, string lp_inherentStats, string lp_inherentCustomValue)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;

            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_jBNum = DataTableIntLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = HD_RegTimerTagAndReturn(lp_timer);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                DataTableIntSave0(true, (lv_str + "Num"), lv_i);
                DataTableStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                DataTableBoolSave0(true, (("HD_IfTimerTag" + "") + "_" + lv_tagStr), true);
                DataTableBoolSave1(true, ("HD_IfTimerTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if (DataTableIntLoad1(true, lv_str + "Tag", lv_i).ToString() == lv_tagStr)
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                DataTableIntSave0(true, (lv_str + "Num"), lv_i);
                                DataTableStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                DataTableBoolSave0(true, (("HD_IfTimerTag" + "") + "_" + lv_tagStr), true);
                                DataTableBoolSave1(true, ("HD_IfTimerTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            DataTableStringSave0(true, ("HD_TimerState" + "" + "_" + lv_tagStr), lp_inherentStats);
            DataTableStringSave0(true, ("HD_TimerCV" + "" + "_" + lv_tagStr), lp_inherentCustomValue);
        }

        /// <summary>
        /// 【MM_函数库】互动T_注册Timer。在指定Key存入Timer，固有状态、自定义值是Timer独一无二的标志（本函数重复注册不会刷新），之后可用互动T_"返回Timer注册总数"、"返回Timer序号"、"返回序号对应Timer"、"返回Timer自定义值"。Timer组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Timer组转为Key。首次注册时固有状态为true（相当于单位组单位活体），之后只能通过"互动T_注册Timer（高级）"改写，如需另外设置多个标记可使用"互动T_设定Timer状态/自定义值"
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        public static void HD_RegTimer_Simple(Timer lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;

            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_jBNum = DataTableIntLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = HD_RegTimerTagAndReturn(lp_timer);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                DataTableIntSave0(true, (lv_str + "Num"), lv_i);
                DataTableStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                DataTableBoolSave0(true, (("HD_IfTimerTag" + "") + "_" + lv_tagStr), true);
                DataTableBoolSave1(true, ("HD_IfTimerTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if (DataTableIntLoad1(true, lv_str + "Tag", lv_i).ToString() == lv_tagStr)
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                DataTableIntSave0(true, (lv_str + "Num"), lv_i);
                                DataTableStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                DataTableBoolSave0(true, (("HD_IfTimerTag" + "") + "_" + lv_tagStr), true);
                                DataTableBoolSave1(true, ("HD_IfTimerTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            if ((DataTableBoolKeyExists(true, ("HD_Timer" + "State" + "_" + lv_tag.ToString())) == false))
            {
                DataTableStringSave1(true, (("HD_Timer" + "State")), lv_tag, "true");
            }
        }

        /// <summary>
        /// 【MM_函数库】互动T_注销Timer。用"互动T_注册Timer"到Key，之后可用本函数彻底摧毁注册信息并将序号重排（包括Timer标签有效状态、固有状态及自定义值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动T_设定Timer状态"让Timer状态失效（类似单位组的单位活体状态）。Timer组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Timer组转为Key。本函数无法摧毁用"互动T_设定Timer状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Timer组变量ID时会清空Timer组专用状态
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        public static void HD_DestroyTimer(Timer lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag;
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_tag = HD_ReturnTimerTag(lp_timer);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                ThreadWaitSet(true, "Key_TimerGroup" + lv_str, true);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((DataTableIntLoad1(true, (lp_key + "TimerTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        DataTableBoolClear0(true, "HD_IfTimerTag_" + lv_tag);
                        DataTableBoolClear0(true, "HD_IfTimerTag" + lv_str + "_" + lv_tag);
                        DataTableTimerClear0(true, "HD_Timer_" + lv_tag);
                        DataTableStringClear0(true, "HD_TimerCV_" + lv_tag);
                        DataTableStringClear0(true, "HD_TimerState_" + lv_tag);
                        DataTableStringClear0(true, "HD_TimerCV" + lv_str + "_" + lv_tag);
                        DataTableStringClear0(true, "HD_TimerState" + lv_str + "_" + lv_tag);
                        DataTableIntSave0(true, (lp_key + "TimerNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = DataTableIntLoad1(true, (lp_key + "TimerTag"), lv_b + 1).ToString();
                            DataTableStringSave1(true, (lp_key + "TimerTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                ThreadWaitSet(true, "Key_TimerGroup" + lv_str, false);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动T_移除Timer。用"互动T_注册Timer"到Key，之后可用本函数仅摧毁Key区注册的信息并将序号重排，用于Timer组或多个键区仅移除Timer（保留Timer标签有效状态、固有值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动T_设定Timer状态"让Timer状态失效（类似单位组的单位活体状态）。Timer组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Timer组转为Key。本函数无法摧毁用"互动T_设定Timer状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Timer组变量ID时会清空Timer组专用状态
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        public static void HD_RemoveTimer(Timer lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag;
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_tag = HD_ReturnTimerTag(lp_timer);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                ThreadWaitSet(true, "Key_TimerGroup" + lv_str, true);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((DataTableIntLoad1(true, (lp_key + "TimerTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        DataTableBoolClear0(true, "HD_IfTimerTag" + lv_str + "_" + lv_tag);
                        DataTableStringClear0(true, "HD_TimerCV" + lv_str + "_" + lv_tag);
                        DataTableStringClear0(true, "HD_TimerState" + lv_str + "_" + lv_tag);
                        DataTableIntSave0(true, (lp_key + "TimerNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = DataTableIntLoad1(true, (lp_key + "TimerTag"), lv_b + 1).ToString();
                            DataTableStringSave1(true, (lp_key + "TimerTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                ThreadWaitSet(true, "Key_TimerGroup" + lv_str, false);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer注册总数。必须先使用"互动T_注册Timer"才能返回指定Key里的注册总数。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key。
        /// </summary>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        /// <returns></returns>
        public static int HD_ReturnTimerNumMax(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            // Implementation
            return lv_num;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer序号。使用"互动T_注册Timer"后使用本函数可返回Key里的注册序号，Key无元素返回0，Key有元素但对象不在里面则返回-1，Timer标签尚未注册则返回-2。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        /// <returns></returns>
        public static int HD_ReturnTimerNum(Timer lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_i;
            string lv_tag;
            int lv_torf;
            // Automatic Variable Declarations
            const int auto_n = 1;
            int auto_i;
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_tag = HD_ReturnTimerTag(lp_timer);
            lv_torf = -1;
            // Implementation
            for (auto_i = 1; auto_i <= auto_n; auto_i += 1)
            {
                if ((lv_tag != null))
                {
                    lv_torf = -2;
                    break;
                }
                if ((lv_num == 0))
                {
                    lv_torf = 0;
                }
                else
                {
                    if ((lv_num >= 1))
                    {
                        auto_ae = lv_num;
                        auto_var = 1;
                        for (; auto_var <= auto_ae; auto_var += 1)
                        {
                            lv_i = auto_var;
                            if ((DataTableIntLoad1(true, (lv_str + "Tag"), lv_i).ToString() == lv_tag))
                            {
                                lv_torf = lv_i;
                                break;
                            }
                        }
                    }
                }
            }
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回序号对应Timer。使用"互动T_注册Timer"后，在参数填入注册序号可返回Timer。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_regNum"></param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        /// <returns></returns>
        public static Timer HD_ReturnTimerFromRegNum(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = DataTableIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return DataTableTimerLoad0(true, ("HD_Timer_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回句柄标签对应Timer。使用"互动T_注册Timer"后，在参数填入句柄标签（整数）可返回Timer，标签是Timer的句柄。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_tag">句柄标签</param>
        /// <returns></returns>
        public static Timer HD_ReturnTimerFromTag(int lp_tag)
        {
            // Variable Declarations
            string lv_tag;
            // Variable Initialization
            lv_tag = lp_tag.ToString();
            // Implementation
            return DataTableTimerLoad0(true, ("HD_Timer_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回序号对应Timer标签句柄。使用"互动T_注册Timer"后，在参数填入注册序号可返回Timer标签（字符串）。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        /// <returns></returns>
        public static string HD_ReturnTimerTagFromRegNum_String(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = DataTableIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回序号对应Timer标签句柄。使用"互动T_注册Timer"后，在参数填入注册序号可返回Timer标签（整数）。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        /// <returns></returns>
        public static int HD_ReturnTimerTagFromRegNum_Int(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = DataTableIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return Convert.ToInt32(lv_tag);
        }

        /// <summary>
        /// 【MM_函数库】互动T_设置Timer状态。必须先"注册"获得功能库内部句柄，再使用本函数给Timer设定一个状态值，之后可用"互动T_返回Timer状态"。类型参数用以记录多个不同状态，仅当"类型"参数填Timer组ID转的Timer串时，状态值"true"和"false"是Timer的Timer组专用状态值，用于内部函数筛选Timer状态（相当于单位组单位索引是否有效），其他类型不会干扰系统内部，可随意填写。虽然注销时反向清空注册信息，但用"互动T_设定Timer状态/自定义值"创建的值需要手工填入""来排泄（非大量注销则提升内存量极小，可不管）。注：固有状态值是注册函数赋予的系统内部变量（相当于单位组单位是否活体），只能通过"互动T_注册Timer（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <param name="lp_stats">状态</param>
        public static void HD_SetTimerState(Timer lp_timer, string lp_key, string lp_stats)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = HD_RegTimerTagAndReturn(lp_timer);
            // Implementation
            DataTableStringSave0(true, ("HD_TimerState" + lv_str + "_" + lv_tag), lp_stats);
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer状态。使用"互动T_设定Timer状态"后可使用本函数，将本函数参数"类型"设为空时返回固有值。类型参数用以记录多个不同状态，仅当"类型"参数为Timer组ID转的字符串时，返回的状态值"true"和"false"是Timer的Timer组专用状态值，用于内部函数筛选Timer状态（相当于单位组单位索引是否有效）
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <returns></returns>
        public static string HD_ReturnTimerState(Timer lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = HD_ReturnTimerTag(lp_timer);
            lv_stats = DataTableStringLoad0(true, ("HD_TimerState" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动T_设置Timer自定义值。必须先"注册"获得功能库内部句柄，再使用本函数设定Timer的自定义值，之后可使用"互动T_返回Timer自定义值"，类型参数用以记录多个不同自定义值。注：固有自定义值是注册函数赋予的系统内部变量，只能通过"互动T_注册Timer（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <param name="lp_customValue">自定义值</param>
        public static void HD_SetTimerCV(Timer lp_timer, string lp_key, string lp_customValue)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = HD_RegTimerTagAndReturn(lp_timer);
            // Implementation
            DataTableStringSave0(true, ("HD_TimerCV" + lv_str + "_" + lv_tag), lp_customValue);
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer自定义值。使用"互动T_设定Timer自定义值"后可使用本函数，将本函数参数"类型"设为空时返回固有值，该参数用以记录多个不同自定义值
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <returns></returns>
        public static string HD_ReturnTimerCV(Timer lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = HD_ReturnTimerTag(lp_timer);
            lv_customValue = DataTableStringLoad0(true, ("HD_TimerCV" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer固有状态。必须先使用"互动T_注册Timer"才能返回到该值，固有状态是独一无二的标记（相当于单位组单位是否活体）
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns></returns>
        public static string HD_ReturnTimerState_Only(Timer lp_timer)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_tag = HD_ReturnTimerTag(lp_timer);
            lv_stats = DataTableStringLoad0(true, ("HD_TimerState" + "" + "_" + lv_tag));
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer固有自定义值。必须先使用"互动T_注册Timer"才能返回到该值，固有值是独一无二的标记
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns></returns>
        public static string HD_ReturnTimerCV_Only(Timer lp_timer)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_tag = HD_ReturnTimerTag(lp_timer);
            lv_customValue = DataTableStringLoad0(true, ("HD_TimerCV" + "" + "_" + lv_tag));
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动T_设置Timer的实数标记。必须先"注册"获得功能库内部句柄，再使用本函数让Timer携带一个实数值，之后可使用"互动T_返回Timer的实数标记"。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_realNumTag">实数标记</param>
        public static void HD_SetTimerDouble(Timer lp_timer, double lp_realNumTag)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = HD_RegTimerTagAndReturn(lp_timer);
            // Implementation
            DataTableDoubleSave0(true, ("HD_CDDouble_Timer_" + lv_tag), lp_realNumTag);
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer的实数标记。使用"互动T_设定Timer的实数标记"后可使用本函数。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns>错误时返回null</returns>
        public static double HD_ReturnTimerDouble(Timer lp_timer)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = HD_ReturnTimerTag(lp_timer);
            // Implementation
            return DataTableDoubleLoad0(true, ("HD_CDDouble_Timer_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer标签句柄有效状态。将Timer视作独一无二的个体，标签是它本身，有效状态则类似"单位是否有效"，当使用"互动T_注册Timer"或"互动TG_添加Timer到Timer组"后激活Timer有效状态（值为"true"），除非使用"互动T_注册Timer（高级）"改写，否则直到注销才会摧毁
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns>错误时返回null</returns>
        public static bool HD_ReturnIfTimerTag(Timer lp_timer)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = HD_ReturnTimerTag(lp_timer);
            // Implementation
            return DataTableBoolLoad0(true, ("HD_IfTimerTag" + "" + "_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer注册状态。使用"互动T_注册Timer"或"互动TG_添加Timer到Timer组"后可使用本函数获取注册Timer在Key中的注册状态，该状态只能注销或从Timer组中移除时清空。Timer组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        /// <returns>错误时返回null</returns>
        public static bool HD_ReturnIfTimerTagKey(Timer lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = HD_ReturnTimerTag(lp_timer);
            // Implementation
            return DataTableBoolLoad0(true, ("HD_IfTimerTag" + lv_str + "_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动TG_根据自定义值类型将Timer组排序。根据Timer携带的自定义值类型，对指定的Timer组元素进行冒泡排序。Timer组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Timer组名称</param>
        /// <param name="lp_cVStr">自定义值类型</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void HD_TimerGSortCV(string lp_key, string lp_cVStr, bool lp_big)
        {
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            string lv_tagValuestr;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_TimerGroup" + lv_str, true);
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = HD_ReturnTimerTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValuestr = HD_ReturnTimerCV((Timer)HD_ReturnTimerFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    DataTableIntSave1(false, "IntStackOutTag", 1, lv_tag);
                    DataTableIntSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < DataTableIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DataTableIntSave1(false, "IntStackOutTag", lv_c, DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    DataTableIntSave1(false, "IntStackOutTagValue", lv_c, DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_c, DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                DataTableIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                DataTableIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > DataTableIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(HD_ReturnTimerTagFromRegNum(lv_b, lp_key))+"值"+IntToString(DataTableIntLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DataTableIntSave1(false, "IntStackOutTag", lv_c, DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DataTableIntSave1(false, "IntStackOutTagValue", lv_c, DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_c, DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                DataTableIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DataTableIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        DataTableIntSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DataTableIntSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = DataTableIntLoad1(true, (lp_key + "TimerTag"), lv_a).ToString(); //原始序号元素
                lv_tag = DataTableIntLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValuestr = HD_ReturnTimerCV((Timer)HD_ReturnTimerFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = DataTableIntLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    DataTableIntSave1(true, (lp_key + "TimerTag"), lv_a, lv_tag); //lv_tag放入新序号
                    //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            ThreadWaitSet(true, "Key_TimerGroup" + lv_str, false);
        }

        /// <summary>
        /// 【MM_函数库】互动TG_Timer组排序。对指定的Timer组元素进行冒泡排序（根据元素句柄）。Timer组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Timer组名称</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void HD_TimerGSort(string lp_key, bool lp_big)
        {
            // Automatic Variable Declarations
            // Implementation
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_TimerGroup" + lv_str, true);
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = HD_ReturnTimerTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValue = lv_tag;
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    DataTableIntSave1(false, "IntStackOutTag", 1, lv_tag);
                    DataTableIntSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < DataTableIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DataTableIntSave1(false, "IntStackOutTag", lv_c, DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    DataTableIntSave1(false, "IntStackOutTagValue", lv_c, DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_c, DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                DataTableIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                DataTableIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > DataTableIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(HD_ReturnTimerTagFromRegNum(lv_b, lp_key))+"值"+IntToString(DataTableIntLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DataTableIntSave1(false, "IntStackOutTag", lv_c, DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DataTableIntSave1(false, "IntStackOutTagValue", lv_c, DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_c, DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                DataTableIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DataTableIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        DataTableIntSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DataTableIntSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = DataTableIntLoad1(true, (lp_key + "TimerTag"), lv_a).ToString(); //原始序号元素
                lv_tag = DataTableIntLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValue = lv_tag;
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = DataTableIntLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                                                                                  //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    DataTableIntSave1(true, (lp_key + "TimerTag"), lv_a, lv_tag); //lv_tag放入新序号
                                                                                  //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            ThreadWaitSet(true, "Key_TimerGroup" + lv_str, false);
        }

        /// <summary>
        /// 【MM_函数库】互动TG_设定Timer的Timer组专用状态。给Timer组的Timer设定一个状态值（字符串），之后可用"互动T_返回Timer、互动TG_返回Timer组的Timer状态"。状态值"true"和"false"是Timer的Timer组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效），而本函数可以重设干预，影响函数"互动TG_返回Timer组元素数量（仅检索XX状态）"。与"互动T_设定Timer状态"功能相同，只是状态参数在Timer组中被固定为"Timer组变量的内部ID"。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_timerGroup"></param>
        /// <param name="lp_groupState"></param>
        public static void HD_SetTimerGState(Timer lp_timer, string lp_timerGroup, string lp_groupState)
        {
            HD_SetTimerState(lp_timer, lp_timerGroup, lp_groupState);
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer的Timer组专用状态。使用"互动T_设定Timer、互动TG_设定Timer组的Timer状态"后可使用本函数。与"互动T_返回Timer状态"功能相同，只是状态参数在Timer组中被固定为"Timer组变量的内部ID"。状态值"true"和"false"是Timer的Timer组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效）。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_timerGroup"></param>
        public static void HD_ReturnTimerGState(Timer lp_timer, string lp_timerGroup)
        {
            HD_ReturnTimerState(lp_timer, lp_timerGroup);
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer组元素序号对应元素。返回Timer组元素序号指定Timer。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static Timer HD_ReturnTimerFromTimerGFunc(int lp_regNum, string lp_gs)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_gs + "Timer");
            lv_tag = DataTableIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return DataTableTimerLoad0(true, ("HD_Timer_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer组元素总数。返回指定Timer组的元素数量。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HD_ReturnTimerGNumMax(string lp_gs)
        {
            return DataTableIntLoad0(true, lp_gs + "TimerNum");
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer组元素总数（仅检测Timer组专用状态="true"）。返回指定Timer组的元素数量。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HD_ReturnTimerGNumMax_StateTrueFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Timer lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HD_ReturnTimerNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (Timer)HD_ReturnTimerFromRegNum(lv_a, lp_gs);
                lv_b = HD_ReturnTimerState(lv_c, lp_gs);
                if ((lv_b == "true"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer组元素总数（仅检测Timer组专用状态="false"）。返回指定Timer组的元素数量。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HD_ReturnTimerGNumMax_StateFalseFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Timer lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HD_ReturnTimerNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (Timer)HD_ReturnTimerFromRegNum(lv_a, lp_gs);
                lv_b = HD_ReturnTimerState(lv_c, lp_gs);
                if ((lv_b == "false"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer组元素总数（仅检测Timer组无效专用状态："false"或""）。返回指定Timer组的元素数量（false、""、null）。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HD_ReturnTimerGNumMax_StateUselessFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Timer lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HD_ReturnTimerNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (Timer)HD_ReturnTimerFromRegNum(lv_a, lp_gs);
                lv_b = HD_ReturnTimerState(lv_c, lp_gs);
                if (((lv_b == "false") || (lv_b == "") || (lv_b == null)))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer组元素总数（仅检测Timer组指定专用状态）。返回指定Timer组的元素数量。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_State">Timer组专用状态</param>
        /// <returns></returns>
        public static int HD_ReturnTimerGNumMax_StateFunc_Specify(string lp_gs, string lp_State)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Timer lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HD_ReturnTimerNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (Timer)HD_ReturnTimerFromRegNum(lv_a, lp_gs);
                lv_b = HD_ReturnTimerState(lv_c, lp_gs);
                if ((lv_b == lp_State))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动TG_添加Timer到Timer组。相同Timer被认为是同一个，非高级功能不提供专用状态检查，如果Timer没有设置过Timer组专用状态，那么首次添加到Timer组不会赋予"true"（之后可通过"互动T_设定Timer状态"、"互动TG_设定Timer组的Timer状态"修改）。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HD_AddTimerToGroup_Simple(Timer lp_timer, string lp_gs)
        {
            HD_RegTimer_Simple(lp_timer, lp_gs);
        }

        /// <summary>
        /// 【MM_函数库】互动TG_添加Timer到Timer组（高级）。相同Timer被认为是同一个，高级功能提供专用状态检查，如果Timer没有设置过Timer组专用状态，那么首次添加到Timer组会赋予"true"（之后可通过"互动T_设定Timer状态"、"互动TG_设定Timer组的Timer状态"修改）。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HD_AddTimerToGroup(Timer lp_timer, string lp_gs)
        {
            HD_RegTimer_Simple(lp_timer, lp_gs);
            if (DataTableStringKeyExists(true, ("HD_TimerState" + lp_gs + "Timer_" + HD_RegTimerTagAndReturn(lp_timer))) == false)
            {
                DataTableStringSave0(true, ("HD_TimerState" + lp_gs + "Timer_" + HD_RegTimerTagAndReturn(lp_timer)), "true");
                //Console.WriteLine(lp_gs + "=>" + HD_RegTimerTagAndReturn(lp_timer));
            }
        }

        /// <summary>
        /// 【MM_函数库】互动TG_移除Timer组中的元素。使用"互动TG_添加Timer到Timer组"后可使用本函数进行移除元素。移除使用了"互动T_移除Timer"，同一个存储区（Timer组ID）序号重排，移除时该存储区如有其他操作会排队等待。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HD_ClearTimerFromGroup(Timer lp_timer, string lp_gs)
        {
            HD_RemoveTimer(lp_timer, lp_gs);
        }

        //互动TG_为Timer组中的每个序号
        //GE（星际2的Galaxy Editor）的宏让编辑器保存时自动生成脚本并整合进脚本进行格式调整，C#仅参考需自行编写
        // #AUTOVAR(vs, string) = "#PARAM(group)";//"#PARAM(group)"是与字段、变量名一致的元素组名称，宏去声明string类型名为“Auto随机编号_vs”的自动变量，然后=右侧字符
        // #AUTOVAR(ae) = HD_ReturnTimerNumMax(#AUTOVAR(vs));//宏去声明默认int类型名为“Auto随机编号_ae”的自动变量，然后=右侧字符
        // #INITAUTOVAR(ai,increment)//宏去声明int类型名为“Auto随机编号_ai”的自动变量，用于下面for循环增量（increment是传入参数）
        // #PARAM(var) = #PARAM(s);//#PARAM(var)是传进来的参数，用作“当前被挑选到的元素”（任意变量-整数 lp_var）， #PARAM(s)是传进来的参数用作"开始"（int lp_s）
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #PARAM(var) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #PARAM(var) >= #AUTOVAR(ae)) ) ; #PARAM(var) += #AUTOVAR(ai) ) {
        //     #SUBFUNCS(actions)//代表用户GUI填写的所有动作
        // }

        /// <summary>
        /// 【MM_函数库】互动TG_为Timer组中的每个序号。每次挑选的元素序号会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素序号，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void HD_ForEachTimerNumFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            int lv_ae = HD_ReturnTimerNumMax(lp_gs);
            int lv_var = lp_start;
            int lv_ai = lp_increment;
            for (; (lv_ai >= 0 && lv_var <= lv_ae) || (lv_ai < 0 && lv_var >= lv_ae); lv_var += lv_ai)
            {
                lp_funcref(lv_var);//用户填写的所有动作
            }
        }

        //互动TG_为Timer组中的每个元素
        // #AUTOVAR(vs, string) = "#PARAM(group)";
        // #AUTOVAR(ae) = HD_ReturnTimerNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= #PARAM(s);
        // #INITAUTOVAR(ai,increment)
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     DataTableSave(false, "TimerGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)), HD_ReturnTimerFromRegNum(#AUTOVAR(va),#AUTOVAR(vs)));
        // }
        // #AUTOVAR(va)= #PARAM(s);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #PARAM(var) = DataTableLoad(false, "TimerGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)));
        //     #SUBFUNCS(actions)
        // }

        /// <summary>
        /// 【MM_函数库】互动TG_为Timer组中的每个元素。每次挑选的元素会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void HD_ForEachTimerFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            string lv_vs = lp_gs;
            int lv_ae = HD_ReturnTimerNumMax(lv_vs);
            int lv_va = lp_start;
            int lv_ai = lp_increment;
            Timer lv_timer;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                DataTableTimerSave0(false, "TimerGFor" + lv_vs + lv_va.ToString(), (Timer)HD_ReturnTimerFromRegNum(lv_va, lv_vs));
            }
            lv_va = lp_start;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                lv_timer = (Timer)DataTableTimerLoad0(false, "TimerGFor" + lv_vs + lv_va.ToString());
                lp_funcref(lv_timer);//用户填写的所有动作
            }
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer组中随机元素。返回指定Timer组中的随机Timer。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static Timer HD_ReturnRandomTimerFromTimerGFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_num;
            int lv_a;
            Timer lv_c = null;
            // Variable Initialization
            lv_num = HD_ReturnTimerNumMax(lp_gs);
            // Implementation
            if ((lv_num >= 1))
            {
                lv_a = RandomInt(1, lv_num);
                lv_c = (Timer)HD_ReturnTimerFromRegNum(lv_a, lp_gs);
            }
            return lv_c;
        }

        //互动TG_添加Timer组到Timer组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = HD_ReturnTimerNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = HD_ReturnTimerFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     HD_AddTimerToGroup(#AUTOVAR(var), #AUTOVAR(vsb));
        // }


        /// <summary>
        /// 【MM_函数库】互动TG_添加Timer组到Timer组。添加一个Timer组A的元素到另一个Timer组B，相同Timer被认为是同一个。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void HD_AddTimerGToTimerG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = HD_ReturnTimerNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            Timer lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = (Timer)HD_ReturnTimerFromRegNum(lv_va, lv_vsa);
                HD_AddTimerToGroup(lv_var, lv_vsb);
            }
        }

        //互动TG_从Timer组移除Timer组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = HD_ReturnTimerNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = HD_ReturnTimerFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     HD_RemoveTimer(#AUTOVAR(var), #AUTOVAR(vsb));
        // }

        /// <summary>
        /// 【MM_函数库】互动TG_从Timer组移除Timer组。将Timer组A的元素从Timer组B中移除，相同Timer被认为是同一个。移除使用了"互动T_移除Timer"，同一个存储区（Timer组ID）序号重排，移除时该存储区如有其他操作会排队等待。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void HD_ClearTimerGFromTimerG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = HD_ReturnTimerNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            Timer lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = (Timer)HD_ReturnTimerFromRegNum(lv_va, lv_vsa);
                HD_RemoveTimer(lv_var, lv_vsb);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动TG_移除Timer组全部元素。将Timer组（Key区）存储的元素全部移除，相同Timer被认为是同一个。移除时同一个存储区（Timer组ID）序号不进行重排，但该存储区如有其他操作会排队等待。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Timer组名称</param>
        public static void HD_RemoveTimerGAll(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag = "";
            int lv_a;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            // Implementation
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_TimerGroup" + lv_str, true);
            for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
            {
                lv_tag = DataTableIntLoad1(true, (lp_key + "TimerTag"), lv_a).ToString();
                lv_num -= 1;
                DataTableBoolClear0(true, "HD_IfTimerTag" + lv_str + "_" + lv_tag);
                DataTableStringClear0(true, "HD_TimerCV" + lv_str + "_" + lv_tag);
                DataTableStringClear0(true, "HD_TimerState" + lv_str + "_" + lv_tag);
                DataTableIntSave0(true, (lp_key + "TimerNum"), lv_num);
            }
            ThreadWaitSet(true, "Key_TimerGroup" + lv_str, false);
        }

        //--------------------------------------------------------------------------------------------------
        // 计时器组End
        //--------------------------------------------------------------------------------------------------

        #endregion

        #region 字符串

        //提示：尽可能使用对口类型，以防值类型与引用类型发生转换时拆装箱降低性能

        //--------------------------------------------------------------------------------------------------
        // 字符串组Start
        //--------------------------------------------------------------------------------------------------

        /// <summary>
        /// 【MM_函数库】互动S_注册String标签句柄并返回。为String自动设置新的标签句柄，重复时会返回已注册的String标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns>返回一个String的已注册标签</returns>
        private static int HD_RegStringTagAndReturn_Int(string lp_timer)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = DataTableIntLoad0(true, "HD_StringJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                DataTableIntSave0(true, "HD_StringJBNum", lv_j);
                DataTableStringSave0(true, ("HD_String_" + lv_j.ToString()), lp_timer);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if (DataTableStringLoad0(true, ("HD_String_" + lv_j.ToString())) == lp_timer)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            DataTableIntSave0(true, "HD_StringJBNum", lv_j);
                            DataTableStringSave0(true, ("HD_String_" + lv_j.ToString()), lp_timer);
                        }
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String已注册标签句柄
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns>返回一个String的已注册标签，错误返回0</returns>
        public static int HD_ReturnStringTag_Int(string lp_timer)
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = DataTableIntLoad0(true, "HD_StringJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if (DataTableStringLoad0(true, "HD_String_" + lv_j.ToString()) == lp_timer)
                {
                    break;
                }
                else
                {
                    if ((lv_j == lv_jBNum))
                    {
                        lv_j = 0;
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动S_注册String标签句柄并返回。为String自动设置新的标签句柄，重复时会返回已注册的String标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns>返回一个String的已注册标签</returns>
        private static string HD_RegStringTagAndReturn(string lp_timer)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = DataTableIntLoad0(true, "HD_StringJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                DataTableIntSave0(true, "HD_StringJBNum", lv_j);
                DataTableStringSave0(true, ("HD_String_" + lv_j.ToString()), lp_timer);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if (DataTableStringLoad0(true, "HD_String_" + lv_j.ToString()) == lp_timer)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            DataTableIntSave0(true, "HD_StringJBNum", lv_j);
                            DataTableStringSave0(true, ("HD_String_" + lv_j.ToString()), lp_timer);
                        }
                    }
                }
            }
            lv_tag = lv_j.ToString();
            //Console.WriteLine(("Tag：" + lv_tag));
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String已注册标签句柄
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns>返回一个String的已注册标签，错误返回""</returns>
        public static string HD_ReturnStringTag(string lp_timer)
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag = "";
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = DataTableIntLoad0(true, "HD_StringJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if (DataTableStringLoad0(true, "HD_String_" + lv_j.ToString()) == lp_timer)
                {
                    lv_tag = lv_j.ToString();
                    break;
                }
            }
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动S_注册String(高级)。在指定Key存入String，固有状态、自定义值是String独一无二的标志（本函数重复注册会刷新），之后可用互动S_"返回String注册总数"、"返回String序号"、"返回序号对应String"、"返回序号对应String标签"、"返回String自定义值"。String组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将String组转为Key。首次注册时固有状态为true（相当于单位组单位活体），如需另外设置多个标记可使用"互动S_设定String状态/自定义值"
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        /// <param name="lp_inherentStats">固有状态</param>
        /// <param name="lp_inherentCustomValue">固有自定义值</param>
        public static void HD_RegString(string lp_timer, string lp_key, string lp_inherentStats, string lp_inherentCustomValue)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;

            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_jBNum = DataTableIntLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = HD_RegStringTagAndReturn(lp_timer);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                DataTableIntSave0(true, (lv_str + "Num"), lv_i);
                DataTableStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                DataTableBoolSave0(true, (("HD_IfStringTag" + "") + "_" + lv_tagStr), true);
                DataTableBoolSave1(true, ("HD_IfStringTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if (DataTableIntLoad1(true, lv_str + "Tag", lv_i).ToString() == lv_tagStr)
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                DataTableIntSave0(true, (lv_str + "Num"), lv_i);
                                DataTableStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                DataTableBoolSave0(true, (("HD_IfStringTag" + "") + "_" + lv_tagStr), true);
                                DataTableBoolSave1(true, ("HD_IfStringTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            DataTableStringSave0(true, ("HD_StringState" + "" + "_" + lv_tagStr), lp_inherentStats);
            DataTableStringSave0(true, ("HD_StringCV" + "" + "_" + lv_tagStr), lp_inherentCustomValue);
        }

        /// <summary>
        /// 【MM_函数库】互动S_注册String。在指定Key存入String，固有状态、自定义值是String独一无二的标志（本函数重复注册不会刷新），之后可用互动S_"返回String注册总数"、"返回String序号"、"返回序号对应String"、"返回String自定义值"。String组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将String组转为Key。首次注册时固有状态为true（相当于单位组单位活体），之后只能通过"互动S_注册String（高级）"改写，如需另外设置多个标记可使用"互动S_设定String状态/自定义值"
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        public static void HD_RegString_Simple(string lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;

            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_jBNum = DataTableIntLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = HD_RegStringTagAndReturn(lp_timer);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                DataTableIntSave0(true, (lv_str + "Num"), lv_i);
                DataTableStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                DataTableBoolSave0(true, (("HD_IfStringTag" + "") + "_" + lv_tagStr), true);
                DataTableBoolSave1(true, ("HD_IfStringTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if (DataTableIntLoad1(true, lv_str + "Tag", lv_i).ToString() == lv_tagStr)
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                DataTableIntSave0(true, (lv_str + "Num"), lv_i);
                                DataTableStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                DataTableBoolSave0(true, (("HD_IfStringTag" + "") + "_" + lv_tagStr), true);
                                DataTableBoolSave1(true, ("HD_IfStringTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            if ((DataTableBoolKeyExists(true, ("HD_String" + "State" + "_" + lv_tag.ToString())) == false))
            {
                DataTableStringSave1(true, (("HD_String" + "State")), lv_tag, "true");
            }
        }

        /// <summary>
        /// 【MM_函数库】互动S_注销String。用"互动S_注册String"到Key，之后可用本函数彻底摧毁注册信息并将序号重排（包括String标签有效状态、固有状态及自定义值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动S_设定String状态"让String状态失效（类似单位组的单位活体状态）。String组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将String组转为Key。本函数无法摧毁用"互动S_设定String状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填String组变量ID时会清空String组专用状态
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        public static void HD_DestroyString(string lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag;
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_tag = HD_ReturnStringTag(lp_timer);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                ThreadWaitSet(true, "Key_StringGroup" + lv_str, true);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((DataTableIntLoad1(true, (lp_key + "StringTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        DataTableBoolClear0(true, "HD_IfStringTag_" + lv_tag);
                        DataTableBoolClear0(true, "HD_IfStringTag" + lv_str + "_" + lv_tag);
                        DataTableStringClear0(true, "HD_String_" + lv_tag);
                        DataTableStringClear0(true, "HD_StringCV_" + lv_tag);
                        DataTableStringClear0(true, "HD_StringState_" + lv_tag);
                        DataTableStringClear0(true, "HD_StringCV" + lv_str + "_" + lv_tag);
                        DataTableStringClear0(true, "HD_StringState" + lv_str + "_" + lv_tag);
                        DataTableIntSave0(true, (lp_key + "StringNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = DataTableIntLoad1(true, (lp_key + "StringTag"), lv_b + 1).ToString();
                            DataTableStringSave1(true, (lp_key + "StringTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                ThreadWaitSet(true, "Key_StringGroup" + lv_str, false);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动S_移除String。用"互动S_注册String"到Key，之后可用本函数仅摧毁Key区注册的信息并将序号重排，用于String组或多个键区仅移除String（保留String标签有效状态、固有值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动S_设定String状态"让String状态失效（类似单位组的单位活体状态）。String组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将String组转为Key。本函数无法摧毁用"互动S_设定String状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填String组变量ID时会清空String组专用状态
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        public static void HD_RemoveString(string lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag;
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_tag = HD_ReturnStringTag(lp_timer);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                ThreadWaitSet(true, "Key_StringGroup" + lv_str, true);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((DataTableIntLoad1(true, (lp_key + "StringTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        DataTableBoolClear0(true, "HD_IfStringTag" + lv_str + "_" + lv_tag);
                        DataTableStringClear0(true, "HD_StringCV" + lv_str + "_" + lv_tag);
                        DataTableStringClear0(true, "HD_StringState" + lv_str + "_" + lv_tag);
                        DataTableIntSave0(true, (lp_key + "StringNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = DataTableIntLoad1(true, (lp_key + "StringTag"), lv_b + 1).ToString();
                            DataTableStringSave1(true, (lp_key + "StringTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                ThreadWaitSet(true, "Key_StringGroup" + lv_str, false);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String注册总数。必须先使用"互动S_注册String"才能返回指定Key里的注册总数。String组使用时，可用"获取变量的内部名称"将String组转为Key。
        /// </summary>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        /// <returns></returns>
        public static int HD_ReturnStringNumMax(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            // Implementation
            return lv_num;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String序号。使用"互动S_注册String"后使用本函数可返回Key里的注册序号，Key无元素返回0，Key有元素但对象不在里面则返回-1，String标签尚未注册则返回-2。String组使用时，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        /// <returns></returns>
        public static int HD_ReturnStringNum(string lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_i;
            string lv_tag;
            int lv_torf;
            // Automatic Variable Declarations
            const int auto_n = 1;
            int auto_i;
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_tag = HD_ReturnStringTag(lp_timer);
            lv_torf = -1;
            // Implementation
            for (auto_i = 1; auto_i <= auto_n; auto_i += 1)
            {
                if ((lv_tag != null))
                {
                    lv_torf = -2;
                    break;
                }
                if ((lv_num == 0))
                {
                    lv_torf = 0;
                }
                else
                {
                    if ((lv_num >= 1))
                    {
                        auto_ae = lv_num;
                        auto_var = 1;
                        for (; auto_var <= auto_ae; auto_var += 1)
                        {
                            lv_i = auto_var;
                            if ((DataTableIntLoad1(true, (lv_str + "Tag"), lv_i).ToString() == lv_tag))
                            {
                                lv_torf = lv_i;
                                break;
                            }
                        }
                    }
                }
            }
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回序号对应String。使用"互动S_注册String"后，在参数填入注册序号可返回String。String组使用时，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_regNum"></param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        /// <returns></returns>
        public static string HD_ReturnStringFromRegNum(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = DataTableIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return DataTableStringLoad0(true, ("HD_String_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回句柄标签对应String。使用"互动S_注册String"后，在参数填入句柄标签（整数）可返回String，标签是String的句柄。String组使用时，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_tag">句柄标签</param>
        /// <returns></returns>
        public static string HD_ReturnStringFromTag(int lp_tag)
        {
            // Variable Declarations
            string lv_tag;
            // Variable Initialization
            lv_tag = lp_tag.ToString();
            // Implementation
            return DataTableStringLoad0(true, ("HD_String_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回序号对应String标签句柄。使用"互动S_注册String"后，在参数填入注册序号可返回String标签（字符串）。String组使用时，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        /// <returns></returns>
        public static string HD_ReturnStringTagFromRegNum_String(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = DataTableIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回序号对应String标签句柄。使用"互动S_注册String"后，在参数填入注册序号可返回String标签（整数）。String组使用时，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        /// <returns></returns>
        public static int HD_ReturnStringTagFromRegNum_Int(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = DataTableIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return Convert.ToInt32(lv_tag);
        }

        /// <summary>
        /// 【MM_函数库】互动S_设置String状态。必须先"注册"获得功能库内部句柄，再使用本函数给String设定一个状态值，之后可用"互动S_返回String状态"。类型参数用以记录多个不同状态，仅当"类型"参数填String组ID转的String串时，状态值"true"和"false"是String的String组专用状态值，用于内部函数筛选String状态（相当于单位组单位索引是否有效），其他类型不会干扰系统内部，可随意填写。虽然注销时反向清空注册信息，但用"互动S_设定String状态/自定义值"创建的值需要手工填入""来排泄（非大量注销则提升内存量极小，可不管）。注：固有状态值是注册函数赋予的系统内部变量（相当于单位组单位是否活体），只能通过"互动S_注册String（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <param name="lp_stats">状态</param>
        public static void HD_SetStringState(string lp_timer, string lp_key, string lp_stats)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = HD_RegStringTagAndReturn(lp_timer);
            // Implementation
            DataTableStringSave0(true, ("HD_StringState" + lv_str + "_" + lv_tag), lp_stats);
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String状态。使用"互动S_设定String状态"后可使用本函数，将本函数参数"类型"设为空时返回固有值。类型参数用以记录多个不同状态，仅当"类型"参数为String组ID转的字符串时，返回的状态值"true"和"false"是String的String组专用状态值，用于内部函数筛选String状态（相当于单位组单位索引是否有效）
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <returns></returns>
        public static string HD_ReturnStringState(string lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = HD_ReturnStringTag(lp_timer);
            lv_stats = DataTableStringLoad0(true, ("HD_StringState" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动S_设置String自定义值。必须先"注册"获得功能库内部句柄，再使用本函数设定String的自定义值，之后可使用"互动S_返回String自定义值"，类型参数用以记录多个不同自定义值。注：固有自定义值是注册函数赋予的系统内部变量，只能通过"互动S_注册String（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <param name="lp_customValue">自定义值</param>
        public static void HD_SetStringCV(string lp_timer, string lp_key, string lp_customValue)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = HD_RegStringTagAndReturn(lp_timer);
            // Implementation
            DataTableStringSave0(true, ("HD_StringCV" + lv_str + "_" + lv_tag), lp_customValue);
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String自定义值。使用"互动S_设定String自定义值"后可使用本函数，将本函数参数"类型"设为空时返回固有值，该参数用以记录多个不同自定义值
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <returns></returns>
        public static string HD_ReturnStringCV(string lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = HD_ReturnStringTag(lp_timer);
            lv_customValue = DataTableStringLoad0(true, ("HD_StringCV" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String固有状态。必须先使用"互动S_注册String"才能返回到该值，固有状态是独一无二的标记（相当于单位组单位是否活体）
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns></returns>
        public static string HD_ReturnStringState_Only(string lp_timer)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_tag = HD_ReturnStringTag(lp_timer);
            lv_stats = DataTableStringLoad0(true, ("HD_StringState" + "" + "_" + lv_tag));
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String固有自定义值。必须先使用"互动S_注册String"才能返回到该值，固有值是独一无二的标记
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns></returns>
        public static string HD_ReturnStringCV_Only(string lp_timer)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_tag = HD_ReturnStringTag(lp_timer);
            lv_customValue = DataTableStringLoad0(true, ("HD_StringCV" + "" + "_" + lv_tag));
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动S_设置String的实数标记。必须先"注册"获得功能库内部句柄，再使用本函数让String携带一个实数值，之后可使用"互动S_返回String的实数标记"。String组使用时，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_realNumTag">实数标记</param>
        public static void HD_SetStringDouble(string lp_timer, double lp_realNumTag)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = HD_RegStringTagAndReturn(lp_timer);
            // Implementation
            DataTableDoubleSave0(true, ("HD_CDDouble_String_" + lv_tag), lp_realNumTag);
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String的实数标记。使用"互动S_设定String的实数标记"后可使用本函数。String组使用时，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns></returns>
        public static double HD_ReturnStringDouble(string lp_timer)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = HD_ReturnStringTag(lp_timer);
            // Implementation
            return DataTableDoubleLoad0(true, ("HD_CDDouble_String_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String标签句柄有效状态。将String视作独一无二的个体，标签是它本身，有效状态则类似"单位是否有效"，当使用"互动S_注册String"或"互动SG_添加String到String组"后激活String有效状态（值为"true"），除非使用"互动S_注册String（高级）"改写，否则直到注销才会摧毁
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns></returns>
        public static bool HD_ReturnIfStringTag(string lp_timer)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = HD_ReturnStringTag(lp_timer);
            // Implementation
            return DataTableBoolLoad0(true, ("HD_IfStringTag" + "" + "_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String注册状态。使用"互动S_注册String"或"互动SG_添加String到String组"后可使用本函数获取注册String在Key中的注册状态，该状态只能注销或从String组中移除时清空。String组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        /// <returns></returns>
        public static bool HD_ReturnIfStringTagKey(string lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = HD_ReturnStringTag(lp_timer);
            // Implementation
            return DataTableBoolLoad0(true, ("HD_IfStringTag" + lv_str + "_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动SG_根据自定义值类型将String组排序。根据String携带的自定义值类型，对指定的String组元素进行冒泡排序。String组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填String组名称</param>
        /// <param name="lp_cVStr">自定义值类型</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void HD_StringGSortCV(string lp_key, string lp_cVStr, bool lp_big)
        {
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            string lv_tagValuestr;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "String");
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_StringGroup" + lv_str, true);
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = HD_ReturnStringTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValuestr = HD_ReturnStringCV((string)HD_ReturnStringFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    DataTableIntSave1(false, "IntStackOutTag", 1, lv_tag);
                    DataTableIntSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < DataTableIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DataTableIntSave1(false, "IntStackOutTag", lv_c, DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    DataTableIntSave1(false, "IntStackOutTagValue", lv_c, DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_c, DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                DataTableIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                DataTableIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > DataTableIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(HD_ReturnStringTagFromRegNum(lv_b, lp_key))+"值"+IntToString(DataTableIntLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DataTableIntSave1(false, "IntStackOutTag", lv_c, DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DataTableIntSave1(false, "IntStackOutTagValue", lv_c, DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_c, DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                DataTableIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DataTableIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        DataTableIntSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DataTableIntSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = DataTableIntLoad1(true, (lp_key + "StringTag"), lv_a).ToString(); //原始序号元素
                lv_tag = DataTableIntLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValuestr = HD_ReturnStringCV((string)HD_ReturnStringFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = DataTableIntLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    DataTableIntSave1(true, (lp_key + "StringTag"), lv_a, lv_tag); //lv_tag放入新序号
                    //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            ThreadWaitSet(true, "Key_StringGroup" + lv_str, false);
        }

        /// <summary>
        /// 【MM_函数库】互动SG_String组排序。对指定的String组元素进行冒泡排序（根据元素句柄）。String组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填String组名称</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void HD_StringGSort(string lp_key, bool lp_big)
        {
            // Automatic Variable Declarations
            // Implementation
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "String");
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_StringGroup" + lv_str, true);
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = HD_ReturnStringTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValue = lv_tag;
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    DataTableIntSave1(false, "IntStackOutTag", 1, lv_tag);
                    DataTableIntSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < DataTableIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DataTableIntSave1(false, "IntStackOutTag", lv_c, DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    DataTableIntSave1(false, "IntStackOutTagValue", lv_c, DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_c, DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                DataTableIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                DataTableIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > DataTableIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(HD_ReturnStringTagFromRegNum(lv_b, lp_key))+"值"+IntToString(DataTableIntLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DataTableIntSave1(false, "IntStackOutTag", lv_c, DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DataTableIntSave1(false, "IntStackOutTagValue", lv_c, DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_c, DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                DataTableIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DataTableIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        DataTableIntSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DataTableIntSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = DataTableIntLoad1(true, (lp_key + "StringTag"), lv_a).ToString(); //原始序号元素
                lv_tag = DataTableIntLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValue = lv_tag;
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = DataTableIntLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                                                                                  //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    DataTableIntSave1(true, (lp_key + "StringTag"), lv_a, lv_tag); //lv_tag放入新序号
                                                                                   //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            ThreadWaitSet(true, "Key_StringGroup" + lv_str, false);
        }

        /// <summary>
        /// 【MM_函数库】互动SG_设定String的String组专用状态。给String组的String设定一个状态值（字符串），之后可用"互动S_返回String、互动SG_返回String组的String状态"。状态值"true"和"false"是String的String组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效），而本函数可以重设干预，影响函数"互动SG_返回String组元素数量（仅检索XX状态）"。与"互动S_设定String状态"功能相同，只是状态参数在String组中被固定为"String组变量的内部ID"。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_timerGroup"></param>
        /// <param name="lp_groupState"></param>
        public static void HD_SetStringGState(string lp_timer, string lp_timerGroup, string lp_groupState)
        {
            HD_SetStringState(lp_timer, lp_timerGroup, lp_groupState);
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String的String组专用状态。使用"互动S_设定String、互动SG_设定String组的String状态"后可使用本函数。与"互动S_返回String状态"功能相同，只是状态参数在String组中被固定为"String组变量的内部ID"。状态值"true"和"false"是String的String组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效）。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_timerGroup"></param>
        public static void HD_ReturnStringGState(string lp_timer, string lp_timerGroup)
        {
            HD_ReturnStringState(lp_timer, lp_timerGroup);
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String组元素序号对应元素。返回String组元素序号指定String。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static string HD_ReturnStringFromStringGFunc(int lp_regNum, string lp_gs)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_gs + "String");
            lv_tag = DataTableIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return DataTableStringLoad0(true, ("HD_String_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String组元素总数。返回指定String组的元素数量。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HD_ReturnStringGNumMax(string lp_gs)
        {
            return DataTableIntLoad0(true, lp_gs + "StringNum");
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String组元素总数（仅检测String组专用状态="true"）。返回指定String组的元素数量。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HD_ReturnStringGNumMax_StateTrueFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            string lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HD_ReturnStringNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (string)HD_ReturnStringFromRegNum(lv_a, lp_gs);
                lv_b = HD_ReturnStringState(lv_c, lp_gs);
                if ((lv_b == "true"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String组元素总数（仅检测String组专用状态="false"）。返回指定String组的元素数量。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HD_ReturnStringGNumMax_StateFalseFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            string lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HD_ReturnStringNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (string)HD_ReturnStringFromRegNum(lv_a, lp_gs);
                lv_b = HD_ReturnStringState(lv_c, lp_gs);
                if ((lv_b == "false"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String组元素总数（仅检测String组无效专用状态："false"或""）。返回指定String组的元素数量（false、""、null）。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HD_ReturnStringGNumMax_StateUselessFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            string lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HD_ReturnStringNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (string)HD_ReturnStringFromRegNum(lv_a, lp_gs);
                lv_b = HD_ReturnStringState(lv_c, lp_gs);
                if (((lv_b == "false") || (lv_b == "") || (lv_b == null)))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String组元素总数（仅检测String组指定专用状态）。返回指定String组的元素数量。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_State">String组专用状态</param>
        /// <returns></returns>
        public static int HD_ReturnStringGNumMax_StateFunc_Specify(string lp_gs, string lp_State)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            string lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HD_ReturnStringNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (string)HD_ReturnStringFromRegNum(lv_a, lp_gs);
                lv_b = HD_ReturnStringState(lv_c, lp_gs);
                if ((lv_b == lp_State))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动SG_添加String到String组。相同String被认为是同一个，非高级功能不提供专用状态检查，如果String没有设置过String组专用状态，那么首次添加到String组不会赋予"true"（之后可通过"互动S_设定String状态"、"互动SG_设定String组的String状态"修改）。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HD_AddStringToGroup_Simple(string lp_timer, string lp_gs)
        {
            HD_RegString_Simple(lp_timer, lp_gs);
        }

        /// <summary>
        /// 【MM_函数库】互动SG_添加String到String组（高级）。相同String被认为是同一个，高级功能提供专用状态检查，如果String没有设置过String组专用状态，那么首次添加到String组会赋予"true"（之后可通过"互动S_设定String状态"、"互动SG_设定String组的String状态"修改）。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HD_AddStringToGroup(string lp_timer, string lp_gs)
        {
            HD_RegString_Simple(lp_timer, lp_gs);
            if (DataTableStringKeyExists(true, ("HD_StringState" + lp_gs + "String_" + HD_RegStringTagAndReturn(lp_timer))) == false)
            {
                DataTableStringSave0(true, ("HD_StringState" + lp_gs + "String_" + HD_RegStringTagAndReturn(lp_timer)), "true");
                //Console.WriteLine(lp_gs + "=>" + HD_RegStringTagAndReturn(lp_timer));
            }
        }

        /// <summary>
        /// 【MM_函数库】互动SG_移除String组中的元素。使用"互动SG_添加String到String组"后可使用本函数进行移除元素。移除使用了"互动S_移除String"，同一个存储区（String组ID）序号重排，移除时该存储区如有其他操作会排队等待。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HD_ClearStringFromGroup(string lp_timer, string lp_gs)
        {
            HD_RemoveString(lp_timer, lp_gs);
        }

        //互动SG_为String组中的每个序号
        //GE（星际2的Galaxy Editor）的宏让编辑器保存时自动生成脚本并整合进脚本进行格式调整，C#仅参考需自行编写
        // #AUTOVAR(vs, string) = "#PARAM(group)";//"#PARAM(group)"是与字段、变量名一致的元素组名称，宏去声明string类型名为“Auto随机编号_vs”的自动变量，然后=右侧字符
        // #AUTOVAR(ae) = HD_ReturnStringNumMax(#AUTOVAR(vs));//宏去声明默认int类型名为“Auto随机编号_ae”的自动变量，然后=右侧字符
        // #INITAUTOVAR(ai,increment)//宏去声明int类型名为“Auto随机编号_ai”的自动变量，用于下面for循环增量（increment是传入参数）
        // #PARAM(var) = #PARAM(s);//#PARAM(var)是传进来的参数，用作“当前被挑选到的元素”（任意变量-整数 lp_var）， #PARAM(s)是传进来的参数用作"开始"（int lp_s）
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #PARAM(var) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #PARAM(var) >= #AUTOVAR(ae)) ) ; #PARAM(var) += #AUTOVAR(ai) ) {
        //     #SUBFUNCS(actions)//代表用户GUI填写的所有动作
        // }

        /// <summary>
        /// 【MM_函数库】互动SG_为String组中的每个序号。每次挑选的元素序号会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素序号，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void HD_ForEachStringNumFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            int lv_ae = HD_ReturnStringNumMax(lp_gs);
            int lv_var = lp_start;
            int lv_ai = lp_increment;
            for (; (lv_ai >= 0 && lv_var <= lv_ae) || (lv_ai < 0 && lv_var >= lv_ae); lv_var += lv_ai)
            {
                lp_funcref(lv_var);//用户填写的所有动作
            }
        }

        //互动SG_为String组中的每个元素
        // #AUTOVAR(vs, string) = "#PARAM(group)";
        // #AUTOVAR(ae) = HD_ReturnStringNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= #PARAM(s);
        // #INITAUTOVAR(ai,increment)
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     DataTableSave(false, "StringGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)), HD_ReturnStringFromRegNum(#AUTOVAR(va),#AUTOVAR(vs)));
        // }
        // #AUTOVAR(va)= #PARAM(s);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #PARAM(var) = DataTableLoad(false, "StringGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)));
        //     #SUBFUNCS(actions)
        // }

        /// <summary>
        /// 【MM_函数库】互动SG_为String组中的每个元素。每次挑选的元素会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void HD_ForEachStringFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            string lv_vs = lp_gs;
            int lv_ae = HD_ReturnStringNumMax(lv_vs);
            int lv_va = lp_start;
            int lv_ai = lp_increment;
            string lv_timer;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                DataTableStringSave0(false, "StringGFor" + lv_vs + lv_va.ToString(), (string)HD_ReturnStringFromRegNum(lv_va, lv_vs));
            }
            lv_va = lp_start;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                lv_timer = (string)DataTableStringLoad0(false, "StringGFor" + lv_vs + lv_va.ToString());
                lp_funcref(lv_timer);//用户填写的所有动作
            }
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String组中随机元素。返回指定String组中的随机String。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static string HD_ReturnRandomStringFromStringGFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_num;
            int lv_a;
            string lv_c = null;
            // Variable Initialization
            lv_num = HD_ReturnStringNumMax(lp_gs);
            // Implementation
            if ((lv_num >= 1))
            {
                lv_a = RandomInt(1, lv_num);
                lv_c = (string)HD_ReturnStringFromRegNum(lv_a, lp_gs);
            }
            return lv_c;
        }

        //互动SG_添加String组到String组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = HD_ReturnStringNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = HD_ReturnStringFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     HD_AddStringToGroup(#AUTOVAR(var), #AUTOVAR(vsb));
        // }


        /// <summary>
        /// 【MM_函数库】互动SG_添加String组到String组。添加一个String组A的元素到另一个String组B，相同String被认为是同一个。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void HD_AddStringGToStringG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = HD_ReturnStringNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            string lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = (string)HD_ReturnStringFromRegNum(lv_va, lv_vsa);
                HD_AddStringToGroup(lv_var, lv_vsb);
            }
        }

        //互动SG_从String组移除String组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = HD_ReturnStringNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = HD_ReturnStringFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     HD_RemoveString(#AUTOVAR(var), #AUTOVAR(vsb));
        // }

        /// <summary>
        /// 【MM_函数库】互动SG_从String组移除String组。将String组A的元素从String组B中移除，相同String被认为是同一个。移除使用了"互动S_移除String"，同一个存储区（String组ID）序号重排，移除时该存储区如有其他操作会排队等待。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void HD_ClearStringGFromStringG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = HD_ReturnStringNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            string lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = (string)HD_ReturnStringFromRegNum(lv_va, lv_vsa);
                HD_RemoveString(lv_var, lv_vsb);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动SG_移除String组全部元素。将String组（Key区）存储的元素全部移除，相同String被认为是同一个。移除时同一个存储区（String组ID）序号不进行重排，但该存储区如有其他操作会排队等待。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_key">存储键区，默认填String组名称</param>
        public static void HD_RemoveStringGAll(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag = "";
            int lv_a;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            // Implementation
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_StringGroup" + lv_str, true);
            for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
            {
                lv_tag = DataTableIntLoad1(true, (lp_key + "StringTag"), lv_a).ToString();
                lv_num -= 1;
                DataTableBoolClear0(true, "HD_IfStringTag" + lv_str + "_" + lv_tag);
                DataTableStringClear0(true, "HD_StringCV" + lv_str + "_" + lv_tag);
                DataTableStringClear0(true, "HD_StringState" + lv_str + "_" + lv_tag);
                DataTableIntSave0(true, (lp_key + "StringNum"), lv_num);
            }
            ThreadWaitSet(true, "Key_StringGroup" + lv_str, false);
        }

        //--------------------------------------------------------------------------------------------------
        // 字符串组End
        //--------------------------------------------------------------------------------------------------

        #endregion

        #region 数字

        //提示：尽可能使用对口类型，以防值类型与引用类型发生转换时拆装箱降低性能

        //--------------------------------------------------------------------------------------------------
        // 数字组Start
        //--------------------------------------------------------------------------------------------------

        /// <summary>
        /// 【MM_函数库】互动I_注册Int标签句柄并返回。为Int自动设置新的标签句柄，重复时会返回已注册的Int标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns>返回一个Int的已注册标签</returns>
        private static int HD_RegIntTagAndReturn_Int(int lp_vector)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = DataTableIntLoad0(true, "HD_IntJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                DataTableIntSave0(true, "HD_IntJBNum", lv_j);
                DataTableIntSave0(true, ("HD_Int_" + lv_j.ToString()), lp_vector);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if (DataTableIntLoad0(true, ("HD_Int_" + lv_j.ToString())) == lp_vector)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            DataTableIntSave0(true, "HD_IntJBNum", lv_j);
                            DataTableIntSave0(true, ("HD_Int_" + lv_j.ToString()), lp_vector);
                        }
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Int已注册标签句柄
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns>返回一个Int的已注册标签，错误返回0</returns>
        public static int HD_ReturnIntTag_Int(int lp_vector)
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = DataTableIntLoad0(true, "HD_IntJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if (DataTableIntLoad0(true, "HD_Int_" + lv_j.ToString()) == lp_vector)
                {
                    break;
                }
                else
                {
                    if ((lv_j == lv_jBNum))
                    {
                        lv_j = 0;
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动I_注册Int标签句柄并返回。为Int自动设置新的标签句柄，重复时会返回已注册的Int标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns>返回一个Int的已注册标签</returns>
        private static string HD_RegIntTagAndReturn(int lp_vector)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            try { lv_jBNum = DataTableIntLoad0(true, "HD_IntJBNum"); } catch { lv_jBNum = 0; }
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                DataTableIntSave0(true, "HD_IntJBNum", lv_j);
                DataTableIntSave0(true, ("HD_Int_" + lv_j.ToString()), lp_vector);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if (DataTableIntLoad0(true, "HD_Int_" + lv_j.ToString()) == lp_vector)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            DataTableIntSave0(true, "HD_IntJBNum", lv_j);
                            DataTableIntSave0(true, ("HD_Int_" + lv_j.ToString()), lp_vector);
                        }
                    }
                }
            }
            lv_tag = lv_j.ToString();
            //Console.WriteLine(("Tag：" + lv_tag));
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Int已注册标签句柄
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns>返回一个Int的已注册标签，错误返回""</returns>
        public static string HD_ReturnIntTag(int lp_vector)
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag = "";
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = DataTableIntLoad0(true, "HD_IntJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if (DataTableIntLoad0(true, "HD_Int_" + lv_j.ToString()) == lp_vector)
                {
                    lv_tag = lv_j.ToString();
                    break;
                }
            }
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动I_注册Int(高级)。在指定Key存入Int，固有状态、自定义值是Int独一无二的标志（本函数重复注册会刷新），之后可用互动I_"返回Int注册总数"、"返回Int序号"、"返回序号对应Int"、"返回序号对应Int标签"、"返回Int自定义值"。Int组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Int组转为Key。首次注册时固有状态为true（相当于单位组单位活体），如需另外设置多个标记可使用"互动I_设定Int状态/自定义值"
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Int"</param>
        /// <param name="lp_inherentStats">固有状态</param>
        /// <param name="lp_inherentCustomValue">固有自定义值</param>
        public static void HD_RegInt(int lp_vector, string lp_key, string lp_inherentStats, string lp_inherentCustomValue)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;

            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_jBNum = DataTableIntLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = HD_RegIntTagAndReturn(lp_vector);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                DataTableIntSave0(true, (lv_str + "Num"), lv_i);
                DataTableStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                DataTableBoolSave0(true, (("HD_IfIntTag" + "") + "_" + lv_tagStr), true);
                DataTableBoolSave1(true, ("HD_IfIntTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if (DataTableIntLoad1(true, lv_str + "Tag", lv_i).ToString() == lv_tagStr)
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                DataTableIntSave0(true, (lv_str + "Num"), lv_i);
                                DataTableStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                DataTableBoolSave0(true, (("HD_IfIntTag" + "") + "_" + lv_tagStr), true);
                                DataTableBoolSave1(true, ("HD_IfIntTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            DataTableStringSave0(true, ("HD_IntState" + "" + "_" + lv_tagStr), lp_inherentStats);
            DataTableStringSave0(true, ("HD_IntCV" + "" + "_" + lv_tagStr), lp_inherentCustomValue);
        }

        /// <summary>
        /// 【MM_函数库】互动I_注册Int。在指定Key存入Int，固有状态、自定义值是Int独一无二的标志（本函数重复注册不会刷新），之后可用互动I_"返回Int注册总数"、"返回Int序号"、"返回序号对应Int"、"返回Int自定义值"。Int组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Int组转为Key。首次注册时固有状态为true（相当于单位组单位活体），之后只能通过"互动I_注册Int（高级）"改写，如需另外设置多个标记可使用"互动I_设定Int状态/自定义值"
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Int"</param>
        public static void HD_RegInt_Simple(int lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;

            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Int");
            try { lv_num = DataTableIntLoad0(true, (lv_str + "Num")); }
            catch { lv_num = 0; }
            try { lv_jBNum = DataTableIntLoad0(true, (lv_str + "JBNum")); }
            catch { lv_jBNum = 0; }
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = HD_RegIntTagAndReturn(lp_vector);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                DataTableIntSave0(true, (lv_str + "Num"), lv_i);
                DataTableStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                DataTableBoolSave0(true, (("HD_IfIntTag" + "") + "_" + lv_tagStr), true);
                DataTableBoolSave1(true, ("HD_IfIntTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if (DataTableIntLoad1(true, lv_str + "Tag", lv_i).ToString() == lv_tagStr)
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                DataTableIntSave0(true, (lv_str + "Num"), lv_i);
                                DataTableStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                DataTableBoolSave0(true, (("HD_IfIntTag" + "") + "_" + lv_tagStr), true);
                                DataTableBoolSave1(true, ("HD_IfIntTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            if ((DataTableBoolKeyExists(true, ("HD_Int" + "State" + "_" + lv_tag.ToString())) == false))
            {
                DataTableStringSave1(true, (("HD_Int" + "State")), lv_tag, "true");
            }
        }

        /// <summary>
        /// 【MM_函数库】互动I_注销Int。用"互动I_注册Int"到Key，之后可用本函数彻底摧毁注册信息并将序号重排（包括Int标签有效状态、固有状态及自定义值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动I_设定Int状态"让Int状态失效（类似单位组的单位活体状态）。Int组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Int组转为Key。本函数无法摧毁用"互动I_设定Int状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Int组变量ID时会清空Int组专用状态
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Int"</param>
        public static void HD_DestroyInt(int lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag;
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_tag = HD_ReturnIntTag(lp_vector);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                ThreadWaitSet(true, "Key_IntGroup" + lv_str, true);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((DataTableIntLoad1(true, (lp_key + "IntTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        DataTableBoolClear0(true, "HD_IfIntTag_" + lv_tag);
                        DataTableBoolClear0(true, "HD_IfIntTag" + lv_str + "_" + lv_tag);
                        DataTableIntClear0(true, "HD_Int_" + lv_tag);
                        DataTableStringClear0(true, "HD_IntCV_" + lv_tag);
                        DataTableStringClear0(true, "HD_IntState_" + lv_tag);
                        DataTableStringClear0(true, "HD_IntCV" + lv_str + "_" + lv_tag);
                        DataTableStringClear0(true, "HD_IntState" + lv_str + "_" + lv_tag);
                        DataTableIntSave0(true, (lp_key + "IntNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = DataTableIntLoad1(true, (lp_key + "IntTag"), lv_b + 1).ToString();
                            DataTableStringSave1(true, (lp_key + "IntTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                ThreadWaitSet(true, "Key_IntGroup" + lv_str, false);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动I_移除Int。用"互动I_注册Int"到Key，之后可用本函数仅摧毁Key区注册的信息并将序号重排，用于Int组或多个键区仅移除Int（保留Int标签有效状态、固有值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动I_设定Int状态"让Int状态失效（类似单位组的单位活体状态）。Int组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Int组转为Key。本函数无法摧毁用"互动I_设定Int状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Int组变量ID时会清空Int组专用状态
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Int"</param>
        public static void HD_RemoveInt(int lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag;
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_tag = HD_ReturnIntTag(lp_vector);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                ThreadWaitSet(true, "Key_IntGroup" + lv_str, true);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((DataTableIntLoad1(true, (lp_key + "IntTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        DataTableBoolClear0(true, "HD_IfIntTag" + lv_str + "_" + lv_tag);
                        DataTableStringClear0(true, "HD_IntCV" + lv_str + "_" + lv_tag);
                        DataTableStringClear0(true, "HD_IntState" + lv_str + "_" + lv_tag);
                        DataTableIntSave0(true, (lp_key + "IntNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = DataTableIntLoad1(true, (lp_key + "IntTag"), lv_b + 1).ToString();
                            DataTableStringSave1(true, (lp_key + "IntTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                ThreadWaitSet(true, "Key_IntGroup" + lv_str, false);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Int注册总数。必须先使用"互动I_注册Int"才能返回指定Key里的注册总数。Int组使用时，可用"获取变量的内部名称"将Int组转为Key。
        /// </summary>
        /// <param name="lp_key">存储键区，默认值"_Int"</param>
        /// <returns></returns>
        public static int HD_ReturnIntNumMax(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            // Implementation
            return lv_num;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Int序号。使用"互动I_注册Int"后使用本函数可返回Key里的注册序号，Key无元素返回0，Key有元素但对象不在里面则返回-1，Int标签尚未注册则返回-2。Int组使用时，可用"获取变量的内部名称"将Int组转为Key
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Int"</param>
        /// <returns></returns>
        public static int HD_ReturnIntNum(int lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_i;
            string lv_tag;
            int lv_torf;
            // Automatic Variable Declarations
            const int auto_n = 1;
            int auto_i;
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_tag = HD_ReturnIntTag(lp_vector);
            lv_torf = -1;
            // Implementation
            for (auto_i = 1; auto_i <= auto_n; auto_i += 1)
            {
                if ((lv_tag != null))
                {
                    lv_torf = -2;
                    break;
                }
                if ((lv_num == 0))
                {
                    lv_torf = 0;
                }
                else
                {
                    if ((lv_num >= 1))
                    {
                        auto_ae = lv_num;
                        auto_var = 1;
                        for (; auto_var <= auto_ae; auto_var += 1)
                        {
                            lv_i = auto_var;
                            if ((DataTableIntLoad1(true, (lv_str + "Tag"), lv_i).ToString() == lv_tag))
                            {
                                lv_torf = lv_i;
                                break;
                            }
                        }
                    }
                }
            }
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回序号对应Int。使用"互动I_注册Int"后，在参数填入注册序号可返回Int。Int组使用时，可用"获取变量的内部名称"将Int组转为Key
        /// </summary>
        /// <param name="lp_regNum"></param>
        /// <param name="lp_key">存储键区，默认值"_Int"</param>
        /// <returns></returns>
        public static int HD_ReturnIntFromRegNum(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_tag = DataTableIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return DataTableIntLoad0(true, ("HD_Int_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回句柄标签对应Int。使用"互动I_注册Int"后，在参数填入句柄标签（整数）可返回Int，标签是Int的句柄。Int组使用时，可用"获取变量的内部名称"将Int组转为Key
        /// </summary>
        /// <param name="lp_tag">句柄标签</param>
        /// <returns></returns>
        public static int HD_ReturnIntFromTag(int lp_tag)
        {
            // Variable Declarations
            string lv_tag;
            // Variable Initialization
            lv_tag = lp_tag.ToString();
            // Implementation
            return DataTableIntLoad0(true, ("HD_Int_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回序号对应Int标签句柄。使用"互动I_注册Int"后，在参数填入注册序号可返回Int标签（字符串）。Int组使用时，可用"获取变量的内部名称"将Int组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Int"</param>
        /// <returns></returns>
        public static string HD_ReturnIntTagFromRegNum_String(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_tag = DataTableIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回序号对应Int标签句柄。使用"互动I_注册Int"后，在参数填入注册序号可返回Int标签（整数）。Int组使用时，可用"获取变量的内部名称"将Int组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Int"</param>
        /// <returns></returns>
        public static int HD_ReturnIntTagFromRegNum_Int(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_tag = DataTableIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return Convert.ToInt32(lv_tag);
        }

        /// <summary>
        /// 【MM_函数库】互动I_设置Int状态。必须先"注册"获得功能库内部句柄，再使用本函数给Int设定一个状态值，之后可用"互动I_返回Int状态"。类型参数用以记录多个不同状态，仅当"类型"参数填Int组ID转的Int串时，状态值"true"和"false"是Int的Int组专用状态值，用于内部函数筛选Int状态（相当于单位组单位索引是否有效），其他类型不会干扰系统内部，可随意填写。虽然注销时反向清空注册信息，但用"互动I_设定Int状态/自定义值"创建的值需要手工填入""来排泄（非大量注销则提升内存量极小，可不管）。注：固有状态值是注册函数赋予的系统内部变量（相当于单位组单位是否活体），只能通过"互动I_注册Int（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <param name="lp_stats">状态</param>
        public static void HD_SetIntState(int lp_vector, string lp_key, string lp_stats)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_tag = HD_RegIntTagAndReturn(lp_vector);
            // Implementation
            DataTableStringSave0(true, ("HD_IntState" + lv_str + "_" + lv_tag), lp_stats);
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Int状态。使用"互动I_设定Int状态"后可使用本函数，将本函数参数"类型"设为空时返回固有值。类型参数用以记录多个不同状态，仅当"类型"参数为Int组ID转的字符串时，返回的状态值"true"和"false"是Int的Int组专用状态值，用于内部函数筛选Int状态（相当于单位组单位索引是否有效）
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <returns></returns>
        public static string HD_ReturnIntState(int lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_tag = HD_ReturnIntTag(lp_vector);
            lv_stats = DataTableStringLoad0(true, ("HD_IntState" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动I_设置Int自定义值。必须先"注册"获得功能库内部句柄，再使用本函数设定Int的自定义值，之后可使用"互动I_返回Int自定义值"，类型参数用以记录多个不同自定义值。注：固有自定义值是注册函数赋予的系统内部变量，只能通过"互动I_注册Int（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <param name="lp_customValue">自定义值</param>
        public static void HD_SetIntCV(int lp_vector, string lp_key, string lp_customValue)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_tag = HD_RegIntTagAndReturn(lp_vector);
            // Implementation
            DataTableStringSave0(true, ("HD_IntCV" + lv_str + "_" + lv_tag), lp_customValue);
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Int自定义值。使用"互动I_设定Int自定义值"后可使用本函数，将本函数参数"类型"设为空时返回固有值，该参数用以记录多个不同自定义值
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <returns></returns>
        public static string HD_ReturnIntCV(int lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_tag = HD_ReturnIntTag(lp_vector);
            lv_customValue = DataTableStringLoad0(true, ("HD_IntCV" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Int固有状态。必须先使用"互动I_注册Int"才能返回到该值，固有状态是独一无二的标记（相当于单位组单位是否活体）
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns></returns>
        public static string HD_ReturnIntState_Only(int lp_vector)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_tag = HD_ReturnIntTag(lp_vector);
            lv_stats = DataTableStringLoad0(true, ("HD_IntState" + "" + "_" + lv_tag));
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Int固有自定义值。必须先使用"互动I_注册Int"才能返回到该值，固有值是独一无二的标记
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns></returns>
        public static string HD_ReturnIntCV_Only(int lp_vector)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_tag = HD_ReturnIntTag(lp_vector);
            lv_customValue = DataTableStringLoad0(true, ("HD_IntCV" + "" + "_" + lv_tag));
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动I_设置Int的实数标记。必须先"注册"获得功能库内部句柄，再使用本函数让Int携带一个实数值，之后可使用"互动I_返回Int的实数标记"。Int组使用时，可用"获取变量的内部名称"将Int组转为Key
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_realNumTag">实数标记</param>
        public static void HD_SetIntDouble(int lp_vector, double lp_realNumTag)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = HD_RegIntTagAndReturn(lp_vector);
            // Implementation
            DataTableDoubleSave0(true, ("HD_CDDouble_Int_" + lv_tag), lp_realNumTag);
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Int的实数标记。使用"互动I_设定Int的实数标记"后可使用本函数。Int组使用时，可用"获取变量的内部名称"将Int组转为Key
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns></returns>
        public static double HD_ReturnIntDouble(int lp_vector)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = HD_ReturnIntTag(lp_vector);
            // Implementation
            return DataTableDoubleLoad0(true, ("HD_CDDouble_Int_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Int标签句柄有效状态。将Int视作独一无二的个体，标签是它本身，有效状态则类似"单位是否有效"，当使用"互动I_注册Int"或"互动IG_添加Int到Int组"后激活Int有效状态（值为"true"），除非使用"互动I_注册Int（高级）"改写，否则直到注销才会摧毁
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns></returns>
        public static bool HD_ReturnIfIntTag(int lp_vector)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = HD_ReturnIntTag(lp_vector);
            // Implementation
            return DataTableBoolLoad0(true, ("HD_IfIntTag" + "" + "_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Int注册状态。使用"互动I_注册Int"或"互动IG_添加Int到Int组"后可使用本函数获取注册Int在Key中的注册状态，该状态只能注销或从Int组中移除时清空。Int组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Int组转为Key
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Int"</param>
        /// <returns></returns>
        public static bool HD_ReturnIfIntTagKey(int lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_tag = HD_ReturnIntTag(lp_vector);
            // Implementation
            return DataTableBoolLoad0(true, ("HD_IfIntTag" + lv_str + "_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动IG_根据自定义值类型将Int组排序。根据Int携带的自定义值类型，对指定的Int组元素进行冒泡排序。Int组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Int组名称</param>
        /// <param name="lp_cVStr">自定义值类型</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void HD_IntGSortCV(string lp_key, string lp_cVStr, bool lp_big)
        {
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            string lv_tagValuestr;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Int");
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_IntGroup" + lv_str, true);
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = HD_ReturnIntTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValuestr = HD_ReturnIntCV(HD_ReturnIntFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    DataTableIntSave1(false, "IntStackOutTag", 1, lv_tag);
                    DataTableIntSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < DataTableIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DataTableIntSave1(false, "IntStackOutTag", lv_c, DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    DataTableIntSave1(false, "IntStackOutTagValue", lv_c, DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_c, DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                DataTableIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                DataTableIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > DataTableIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(HD_ReturnIntTagFromRegNum(lv_b, lp_key))+"值"+IntToString(DataTableIntLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DataTableIntSave1(false, "IntStackOutTag", lv_c, DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DataTableIntSave1(false, "IntStackOutTagValue", lv_c, DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_c, DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                DataTableIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DataTableIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        DataTableIntSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DataTableIntSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = DataTableIntLoad1(true, (lp_key + "IntTag"), lv_a).ToString(); //原始序号元素
                lv_tag = DataTableIntLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValuestr = HD_ReturnIntCV(HD_ReturnIntFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = DataTableIntLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    DataTableIntSave1(true, (lp_key + "IntTag"), lv_a, lv_tag); //lv_tag放入新序号
                    //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            ThreadWaitSet(true, "Key_IntGroup" + lv_str, false);
        }

        /// <summary>
        /// 【MM_函数库】互动IG_Int组排序。对指定的Int组元素进行冒泡排序（根据元素句柄）。Int组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Int组名称</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void HD_IntGSort(string lp_key, bool lp_big)
        {
            // Automatic Variable Declarations
            // Implementation
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Int");
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_IntGroup" + lv_str, true);
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = HD_ReturnIntTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValue = lv_tag;
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    DataTableIntSave1(false, "IntStackOutTag", 1, lv_tag);
                    DataTableIntSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < DataTableIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DataTableIntSave1(false, "IntStackOutTag", lv_c, DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    DataTableIntSave1(false, "IntStackOutTagValue", lv_c, DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_c, DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                DataTableIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                DataTableIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > DataTableIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(HD_ReturnIntTagFromRegNum(lv_b, lp_key))+"值"+IntToString(DataTableIntLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DataTableIntSave1(false, "IntStackOutTag", lv_c, DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(DataTableIntLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DataTableIntSave1(false, "IntStackOutTagValue", lv_c, DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(DataTableIntLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_c, DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(DataTableIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                DataTableIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DataTableIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        DataTableIntSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DataTableIntSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DataTableIntSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = DataTableIntLoad1(true, (lp_key + "IntTag"), lv_a).ToString(); //原始序号元素
                lv_tag = DataTableIntLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValue = lv_tag;
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = DataTableIntLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                                                                                  //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    DataTableIntSave1(true, (lp_key + "IntTag"), lv_a, lv_tag); //lv_tag放入新序号
                                                                                //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            ThreadWaitSet(true, "Key_IntGroup" + lv_str, false);
        }

        /// <summary>
        /// 【MM_函数库】互动IG_设定Int的Int组专用状态。给Int组的Int设定一个状态值（字符串），之后可用"互动I_返回Int、互动IG_返回Int组的Int状态"。状态值"true"和"false"是Int的Int组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效），而本函数可以重设干预，影响函数"互动IG_返回Int组元素数量（仅检索XX状态）"。与"互动I_设定Int状态"功能相同，只是状态参数在Int组中被固定为"Int组变量的内部ID"。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_vectorGroup"></param>
        /// <param name="lp_groupState"></param>
        public static void HD_SetIntGState(int lp_vector, string lp_vectorGroup, string lp_groupState)
        {
            HD_SetIntState(lp_vector, lp_vectorGroup, lp_groupState);
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Int的Int组专用状态。使用"互动I_设定Int、互动IG_设定Int组的Int状态"后可使用本函数。与"互动I_返回Int状态"功能相同，只是状态参数在Int组中被固定为"Int组变量的内部ID"。状态值"true"和"false"是Int的Int组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效）。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_vectorGroup"></param>
        public static void HD_ReturnIntGState(int lp_vector, string lp_vectorGroup)
        {
            HD_ReturnIntState(lp_vector, lp_vectorGroup);
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Int组元素序号对应元素。返回Int组元素序号指定Int。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HD_ReturnIntFromIntGFunc(int lp_regNum, string lp_gs)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_gs + "Int");
            lv_tag = DataTableIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return DataTableIntLoad0(true, ("HD_Int_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Int组元素总数。返回指定Int组的元素数量。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HD_ReturnIntGNumMax(string lp_gs)
        {
            return DataTableIntLoad0(true, lp_gs + "IntNum");
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Int组元素总数（仅检测Int组专用状态="true"）。返回指定Int组的元素数量。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HD_ReturnIntGNumMax_StateTrueFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            int lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HD_ReturnIntNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HD_ReturnIntFromRegNum(lv_a, lp_gs);
                lv_b = HD_ReturnIntState(lv_c, lp_gs);
                if ((lv_b == "true"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Int组元素总数（仅检测Int组专用状态="false"）。返回指定Int组的元素数量。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HD_ReturnIntGNumMax_StateFalseFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            int lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HD_ReturnIntNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HD_ReturnIntFromRegNum(lv_a, lp_gs);
                lv_b = HD_ReturnIntState(lv_c, lp_gs);
                if ((lv_b == "false"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Int组元素总数（仅检测Int组无效专用状态："false"或""）。返回指定Int组的元素数量（false、""、null）。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HD_ReturnIntGNumMax_StateUselessFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            int lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HD_ReturnIntNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HD_ReturnIntFromRegNum(lv_a, lp_gs);
                lv_b = HD_ReturnIntState(lv_c, lp_gs);
                if (((lv_b == "false") || (lv_b == "") || (lv_b == null)))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Int组元素总数（仅检测Int组指定专用状态）。返回指定Int组的元素数量。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_State">Int组专用状态</param>
        /// <returns></returns>
        public static int HD_ReturnIntGNumMax_StateFunc_Specify(string lp_gs, string lp_State)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            int lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HD_ReturnIntNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HD_ReturnIntFromRegNum(lv_a, lp_gs);
                lv_b = HD_ReturnIntState(lv_c, lp_gs);
                if ((lv_b == lp_State))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动IG_添加Int到Int组。相同Int被认为是同一个，非高级功能不提供专用状态检查，如果Int没有设置过Int组专用状态，那么首次添加到Int组不会赋予"true"（之后可通过"互动I_设定Int状态"、"互动IG_设定Int组的Int状态"修改）。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HD_AddIntToGroup_Simple(int lp_vector, string lp_gs)
        {
            HD_RegInt_Simple(lp_vector, lp_gs);
        }

        /// <summary>
        /// 【MM_函数库】互动IG_添加Int到Int组（高级）。相同Int被认为是同一个，高级功能提供专用状态检查，如果Int没有设置过Int组专用状态，那么首次添加到Int组会赋予"true"（之后可通过"互动I_设定Int状态"、"互动IG_设定Int组的Int状态"修改）。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HD_AddIntToGroup(int lp_vector, string lp_gs)
        {
            HD_RegInt_Simple(lp_vector, lp_gs);
            if (DataTableStringKeyExists(true, ("HD_IntState" + lp_gs + "Int_" + HD_RegIntTagAndReturn(lp_vector))) == false)
            {
                DataTableStringSave0(true, ("HD_IntState" + lp_gs + "Int_" + HD_RegIntTagAndReturn(lp_vector)), "true");
                //Console.WriteLine(lp_gs + "=>" + HD_RegIntTagAndReturn(lp_vector));
            }
        }

        /// <summary>
        /// 【MM_函数库】互动IG_移除Int组中的元素。使用"互动IG_添加Int到Int组"后可使用本函数进行移除元素。移除使用了"互动I_移除Int"，同一个存储区（Int组ID）序号重排，移除时该存储区如有其他操作会排队等待。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HD_ClearIntFromGroup(int lp_vector, string lp_gs)
        {
            HD_RemoveInt(lp_vector, lp_gs);
        }

        //互动IG_为Int组中的每个序号
        //GE（星际2的Galaxy Editor）的宏让编辑器保存时自动生成脚本并整合进脚本进行格式调整，C#仅参考需自行编写
        // #AUTOVAR(vs, string) = "#PARAM(group)";//"#PARAM(group)"是与字段、变量名一致的元素组名称，宏去声明string类型名为“Auto随机编号_vs”的自动变量，然后=右侧字符
        // #AUTOVAR(ae) = HD_ReturnIntNumMax(#AUTOVAR(vs));//宏去声明默认int类型名为“Auto随机编号_ae”的自动变量，然后=右侧字符
        // #INITAUTOVAR(ai,increment)//宏去声明int类型名为“Auto随机编号_ai”的自动变量，用于下面for循环增量（increment是传入参数）
        // #PARAM(var) = #PARAM(s);//#PARAM(var)是传进来的参数，用作“当前被挑选到的元素”（任意变量-整数 lp_var）， #PARAM(s)是传进来的参数用作"开始"（int lp_s）
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #PARAM(var) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #PARAM(var) >= #AUTOVAR(ae)) ) ; #PARAM(var) += #AUTOVAR(ai) ) {
        //     #SUBFUNCS(actions)//代表用户GUI填写的所有动作
        // }

        /// <summary>
        /// 【MM_函数库】互动IG_为Int组中的每个序号。每次挑选的元素序号会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素序号，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void HD_ForEachIntNumFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            int lv_ae = HD_ReturnIntNumMax(lp_gs);
            int lv_var = lp_start;
            int lv_ai = lp_increment;
            for (; (lv_ai >= 0 && lv_var <= lv_ae) || (lv_ai < 0 && lv_var >= lv_ae); lv_var += lv_ai)
            {
                lp_funcref(lv_var);//用户填写的所有动作
            }
        }

        //互动IG_为Int组中的每个元素
        // #AUTOVAR(vs, string) = "#PARAM(group)";
        // #AUTOVAR(ae) = HD_ReturnIntNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= #PARAM(s);
        // #INITAUTOVAR(ai,increment)
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     DataTableSave(false, "IntGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)), HD_ReturnIntFromRegNum(#AUTOVAR(va),#AUTOVAR(vs)));
        // }
        // #AUTOVAR(va)= #PARAM(s);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #PARAM(var) = DataTableLoad(false, "IntGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)));
        //     #SUBFUNCS(actions)
        // }

        /// <summary>
        /// 【MM_函数库】互动IG_为Int组中的每个元素。每次挑选的元素会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void HD_ForEachIntFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            string lv_vs = lp_gs;
            int lv_ae = HD_ReturnIntNumMax(lv_vs);
            int lv_va = lp_start;
            int lv_ai = lp_increment;
            int lv_vector;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                DataTableIntSave0(false, "IntGFor" + lv_vs + lv_va.ToString(), HD_ReturnIntFromRegNum(lv_va, lv_vs));
            }
            lv_va = lp_start;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                lv_vector = DataTableIntLoad0(false, "IntGFor" + lv_vs + lv_va.ToString());
                lp_funcref(lv_vector);//用户填写的所有动作
            }
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Int组中随机元素。返回指定Int组中的随机Int。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HD_ReturnRandomIntFromIntGFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_num;
            int lv_a;
            int lv_c = 0;
            // Variable Initialization
            lv_num = HD_ReturnIntNumMax(lp_gs);
            // Implementation
            if ((lv_num >= 1))
            {
                lv_a = RandomInt(1, lv_num);
                lv_c = HD_ReturnIntFromRegNum(lv_a, lp_gs);
            }
            return lv_c;
        }

        //互动IG_添加Int组到Int组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = HD_ReturnIntNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = HD_ReturnIntFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     HD_AddIntToGroup(#AUTOVAR(var), #AUTOVAR(vsb));
        // }


        /// <summary>
        /// 【MM_函数库】互动IG_添加Int组到Int组。添加一个Int组A的元素到另一个Int组B，相同Int被认为是同一个。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void HD_AddIntGToIntG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = HD_ReturnIntNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            int lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = HD_ReturnIntFromRegNum(lv_va, lv_vsa);
                HD_AddIntToGroup(lv_var, lv_vsb);
            }
        }

        //互动IG_从Int组移除Int组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = HD_ReturnIntNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = HD_ReturnIntFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     HD_RemoveInt(#AUTOVAR(var), #AUTOVAR(vsb));
        // }

        /// <summary>
        /// 【MM_函数库】互动IG_从Int组移除Int组。将Int组A的元素从Int组B中移除，相同Int被认为是同一个。移除使用了"互动I_移除Int"，同一个存储区（Int组ID）序号重排，移除时该存储区如有其他操作会排队等待。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void HD_ClearIntGFromIntG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = HD_ReturnIntNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            int lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = HD_ReturnIntFromRegNum(lv_va, lv_vsa);
                HD_RemoveInt(lv_var, lv_vsb);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动IG_移除Int组全部元素。将Int组（Key区）存储的元素全部移除，相同Int被认为是同一个。移除时同一个存储区（Int组ID）序号不进行重排，但该存储区如有其他操作会排队等待。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Int组名称</param>
        public static void HD_RemoveIntGAll(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag = "";
            int lv_a;
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_num = DataTableIntLoad0(true, (lv_str + "Num"));
            // Implementation
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_IntGroup" + lv_str, true);
            for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
            {
                lv_tag = DataTableIntLoad1(true, (lp_key + "IntTag"), lv_a).ToString();
                lv_num -= 1;
                DataTableBoolClear0(true, "HD_IfIntTag" + lv_str + "_" + lv_tag);
                DataTableStringClear0(true, "HD_IntCV" + lv_str + "_" + lv_tag);
                DataTableStringClear0(true, "HD_IntState" + lv_str + "_" + lv_tag);
                DataTableIntSave0(true, (lp_key + "IntNum"), lv_num);
            }
            ThreadWaitSet(true, "Key_IntGroup" + lv_str, false);
        }

        //--------------------------------------------------------------------------------------------------
        // 数字组End
        //--------------------------------------------------------------------------------------------------

        #endregion

        #endregion

        #region 系统互动

        #region 字典互动

        #region 任意类型

        //提示：可以将任意类型作为模板修改后产生其他类型
        //提示：尽可能使用对口类型，以防值类型与引用类型发生转换时拆装箱降低性能

        //--------------------------------------------------------------------------------------------------
        // 任意类型组Start
        //--------------------------------------------------------------------------------------------------

        /// <summary>
        /// 【MM_函数库】互动O_注册Object标签句柄并返回。为Object自动设置新的标签句柄，重复时会返回已注册的Object标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns>返回一个Object的已注册标签</returns>
        private static int DHD_RegObjectTagAndReturn_Int(object lp_object)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)DictionaryIntLoad0(true, "DHD_ObjectJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                DictionaryIntSave0(true, "DHD_ObjectJBNum", lv_j);
                DictionaryObjectSave0(true, ("DHD_Object_" + lv_j.ToString()), lp_object);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if (DictionaryObjectLoad0(true, ("DHD_Object_" + lv_j.ToString())) == lp_object)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            DictionaryIntSave0(true, "DHD_ObjectJBNum", lv_j);
                            DictionaryObjectSave0(true, ("DHD_Object_" + lv_j.ToString()), lp_object);
                        }
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object已注册标签句柄
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns>返回一个Object的已注册标签，错误返回0</returns>
        public static int DHD_ReturnObjectTag_Int(object lp_object)
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)DictionaryIntLoad0(true, "DHD_ObjectJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if (DictionaryObjectLoad0(true, "DHD_Object_" + lv_j.ToString()) == lp_object)
                {
                    break;
                }
                else
                {
                    if ((lv_j == lv_jBNum))
                    {
                        lv_j = 0;
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动O_注册Object标签句柄并返回。为Object自动设置新的标签句柄，重复时会返回已注册的Object标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns>返回一个Object的已注册标签</returns>
        private static string DHD_RegObjectTagAndReturn(object lp_object)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)DictionaryIntLoad0(true, "DHD_ObjectJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                DictionaryIntSave0(true, "DHD_ObjectJBNum", lv_j);
                DictionaryObjectSave0(true, ("DHD_Object_" + lv_j.ToString()), lp_object);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if (DictionaryObjectLoad0(true, "DHD_Object_" + lv_j.ToString()) == lp_object)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            DictionaryIntSave0(true, "DHD_ObjectJBNum", lv_j);
                            DictionaryObjectSave0(true, ("DHD_Object_" + lv_j.ToString()), lp_object);
                        }
                    }
                }
            }
            lv_tag = lv_j.ToString();
            //Console.WriteLine(("Tag：" + lv_tag));
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object已注册标签句柄
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns>返回一个Object的已注册标签，错误返回""</returns>
        public static string DHD_ReturnObjectTag(object lp_object)
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag = "";
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)DictionaryIntLoad0(true, "DHD_ObjectJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if (DictionaryObjectLoad0(true, "DHD_Object_" + lv_j.ToString()) == lp_object)
                {
                    lv_tag = lv_j.ToString();
                    break;
                }
            }
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动O_注册Object(高级)。在指定Key存入Object，固有状态、自定义值是Object独一无二的标志（本函数重复注册会刷新），之后可用互动O_"返回Object注册总数"、"返回Object序号"、"返回序号对应Object"、"返回序号对应Object标签"、"返回Object自定义值"。Object组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Object组转为Key。首次注册时固有状态为true（相当于单位组单位活体），如需另外设置多个标记可使用"互动O_设定Object状态/自定义值"
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        /// <param name="lp_inherentStats">固有状态</param>
        /// <param name="lp_inherentCustomValue">固有自定义值</param>
        public static void DHD_RegObject(object lp_object, string lp_key, string lp_inherentStats, string lp_inherentCustomValue)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;

            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_jBNum = (int)DictionaryIntLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = DHD_RegObjectTagAndReturn(lp_object);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                DictionaryIntSave0(true, (lv_str + "Num"), lv_i);
                DictionaryStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                DictionaryBoolSave0(true, (("DHD_IfObjectTag" + "") + "_" + lv_tagStr), true);
                DictionaryBoolSave1(true, ("DHD_IfObjectTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if (DictionaryIntLoad1(true, lv_str + "Tag", lv_i).ToString() == lv_tagStr)
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                DictionaryIntSave0(true, (lv_str + "Num"), lv_i);
                                DictionaryStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                DictionaryBoolSave0(true, (("DHD_IfObjectTag" + "") + "_" + lv_tagStr), true);
                                DictionaryBoolSave1(true, ("DHD_IfObjectTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            DictionaryStringSave0(true, ("DHD_ObjectState" + "" + "_" + lv_tagStr), lp_inherentStats);
            DictionaryStringSave0(true, ("DHD_ObjectCV" + "" + "_" + lv_tagStr), lp_inherentCustomValue);
        }

        /// <summary>
        /// 【MM_函数库】互动O_注册Object。在指定Key存入Object，固有状态、自定义值是Object独一无二的标志（本函数重复注册不会刷新），之后可用互动O_"返回Object注册总数"、"返回Object序号"、"返回序号对应Object"、"返回Object自定义值"。Object组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Object组转为Key。首次注册时固有状态为true（相当于单位组单位活体），之后只能通过"互动O_注册Object（高级）"改写，如需另外设置多个标记可使用"互动O_设定Object状态/自定义值"
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        public static void DHD_RegObject_Simple(object lp_object, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;

            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_jBNum = (int)DictionaryIntLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = DHD_RegObjectTagAndReturn(lp_object);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                DictionaryIntSave0(true, (lv_str + "Num"), lv_i);
                DictionaryStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                DictionaryBoolSave0(true, (("DHD_IfObjectTag" + "") + "_" + lv_tagStr), true);
                DictionaryBoolSave1(true, ("DHD_IfObjectTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if (DictionaryIntLoad1(true, lv_str + "Tag", lv_i).ToString() == lv_tagStr)
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                DictionaryIntSave0(true, (lv_str + "Num"), lv_i);
                                DictionaryStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                DictionaryBoolSave0(true, (("DHD_IfObjectTag" + "") + "_" + lv_tagStr), true);
                                DictionaryBoolSave1(true, ("DHD_IfObjectTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            if ((DictionaryBoolKeyExists(true, ("DHD_Object" + "State" + "_" + lv_tag.ToString())) == false))
            {
                DictionaryStringSave1(true, (("DHD_Object" + "State")), lv_tag, "true");
            }
        }

        /// <summary>
        /// 【MM_函数库】互动O_注销Object。用"互动O_注册Object"到Key，之后可用本函数彻底摧毁注册信息并将序号重排（包括Object标签有效状态、固有状态及自定义值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动O_设定Object状态"让Object状态失效（类似单位组的单位活体状态）。Object组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Object组转为Key。本函数无法摧毁用"互动O_设定Object状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Object组变量ID时会清空Object组专用状态
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        public static void DHD_DestroyObject(object lp_object, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag;
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_tag = DHD_ReturnObjectTag(lp_object);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                ThreadWaitSet(true, "Key_ObjectGroup" + lv_str, true);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((DictionaryIntLoad1(true, (lp_key + "ObjectTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        DictionaryBoolClear0(true, "DHD_IfObjectTag_" + lv_tag);
                        DictionaryBoolClear0(true, "DHD_IfObjectTag" + lv_str + "_" + lv_tag);
                        DictionaryObjectClear0(true, "DHD_Object_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_ObjectCV_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_ObjectState_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_ObjectCV" + lv_str + "_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_ObjectState" + lv_str + "_" + lv_tag);
                        DictionaryIntSave0(true, (lp_key + "ObjectNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = DictionaryIntLoad1(true, (lp_key + "ObjectTag"), lv_b + 1).ToString();
                            DictionaryStringSave1(true, (lp_key + "ObjectTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                ThreadWaitSet(true, "Key_ObjectGroup" + lv_str, false);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动O_移除Object。用"互动O_注册Object"到Key，之后可用本函数仅摧毁Key区注册的信息并将序号重排，用于Object组或多个键区仅移除Object（保留Object标签有效状态、固有值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动O_设定Object状态"让Object状态失效（类似单位组的单位活体状态）。Object组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Object组转为Key。本函数无法摧毁用"互动O_设定Object状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Object组变量ID时会清空Object组专用状态
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        public static void DHD_RemoveObject(object lp_object, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag;
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_tag = DHD_ReturnObjectTag(lp_object);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                ThreadWaitSet(true, "Key_ObjectGroup" + lv_str, true);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((DictionaryIntLoad1(true, (lp_key + "ObjectTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        DictionaryBoolClear0(true, "DHD_IfObjectTag" + lv_str + "_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_ObjectCV" + lv_str + "_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_ObjectState" + lv_str + "_" + lv_tag);
                        DictionaryIntSave0(true, (lp_key + "ObjectNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = DictionaryIntLoad1(true, (lp_key + "ObjectTag"), lv_b + 1).ToString();
                            DictionaryStringSave1(true, (lp_key + "ObjectTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                ThreadWaitSet(true, "Key_ObjectGroup" + lv_str, false);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object注册总数。必须先使用"互动O_注册Object"才能返回指定Key里的注册总数。Object组使用时，可用"获取变量的内部名称"将Object组转为Key。
        /// </summary>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        /// <returns></returns>
        public static int DHD_ReturnObjectNumMax(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            // Implementation
            return lv_num;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object序号。使用"互动O_注册Object"后使用本函数可返回Key里的注册序号，Key无元素返回0，Key有元素但对象不在里面则返回-1，Object标签尚未注册则返回-2。Object组使用时，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        /// <returns></returns>
        public static int DHD_ReturnObjectNum(object lp_object, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_i;
            string lv_tag;
            int lv_torf;
            // Automatic Variable Declarations
            const int auto_n = 1;
            int auto_i;
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_tag = DHD_ReturnObjectTag(lp_object);
            lv_torf = -1;
            // Implementation
            for (auto_i = 1; auto_i <= auto_n; auto_i += 1)
            {
                if ((lv_tag != null))
                {
                    lv_torf = -2;
                    break;
                }
                if ((lv_num == 0))
                {
                    lv_torf = 0;
                }
                else
                {
                    if ((lv_num >= 1))
                    {
                        auto_ae = lv_num;
                        auto_var = 1;
                        for (; auto_var <= auto_ae; auto_var += 1)
                        {
                            lv_i = auto_var;
                            if ((DictionaryIntLoad1(true, (lv_str + "Tag"), lv_i).ToString() == lv_tag))
                            {
                                lv_torf = lv_i;
                                break;
                            }
                        }
                    }
                }
            }
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回序号对应Object。使用"互动O_注册Object"后，在参数填入注册序号可返回Object。Object组使用时，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_regNum"></param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        /// <returns></returns>
        public static object DHD_ReturnObjectFromRegNum(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            object lv_object;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = DictionaryIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            lv_object = DictionaryObjectLoad0(true, ("DHD_Object_" + lv_tag));
            // Implementation
            return lv_object;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回句柄标签对应Object。使用"互动O_注册Object"后，在参数填入句柄标签（整数）可返回Object，标签是Object的句柄。Object组使用时，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_tag">句柄标签</param>
        /// <returns></returns>
        public static object DHD_ReturnObjectFromTag(int lp_tag)
        {
            // Variable Declarations
            string lv_tag;
            object lv_object;
            // Variable Initialization
            lv_tag = lp_tag.ToString();
            lv_object = DictionaryObjectLoad0(true, ("DHD_Object_" + lv_tag));
            // Implementation
            return lv_object;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回序号对应Object标签句柄。使用"互动O_注册Object"后，在参数填入注册序号可返回Object标签（字符串）。Object组使用时，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        /// <returns></returns>
        public static string DHD_ReturnObjectTagFromRegNum_String(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = DictionaryIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回序号对应Object标签句柄。使用"互动O_注册Object"后，在参数填入注册序号可返回Object标签（整数）。Object组使用时，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        /// <returns></returns>
        public static int DHD_ReturnObjectTagFromRegNum_Int(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = DictionaryIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return Convert.ToInt32(lv_tag);
        }

        /// <summary>
        /// 【MM_函数库】互动O_设置Object状态。必须先"注册"获得功能库内部句柄，再使用本函数给Object设定一个状态值，之后可用"互动O_返回Object状态"。类型参数用以记录多个不同状态，仅当"类型"参数填Object组ID转的Object串时，状态值"true"和"false"是Object的Object组专用状态值，用于内部函数筛选Object状态（相当于单位组单位索引是否有效），其他类型不会干扰系统内部，可随意填写。虽然注销时反向清空注册信息，但用"互动O_设定Object状态/自定义值"创建的值需要手工填入""来排泄（非大量注销则提升内存量极小，可不管）。注：固有状态值是注册函数赋予的系统内部变量（相当于单位组单位是否活体），只能通过"互动O_注册Object（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <param name="lp_stats">状态</param>
        public static void DHD_SetObjectState(object lp_object, string lp_key, string lp_stats)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = DHD_RegObjectTagAndReturn(lp_object);
            // Implementation
            DictionaryStringSave0(true, ("DHD_ObjectState" + lv_str + "_" + lv_tag), lp_stats);
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object状态。使用"互动O_设定Object状态"后可使用本函数，将本函数参数"类型"设为空时返回固有值。类型参数用以记录多个不同状态，仅当"类型"参数为Object组ID转的字符串时，返回的状态值"true"和"false"是Object的Object组专用状态值，用于内部函数筛选Object状态（相当于单位组单位索引是否有效）
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <returns></returns>
        public static string DHD_ReturnObjectState(object lp_object, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = DHD_ReturnObjectTag(lp_object);
            lv_stats = DictionaryStringLoad0(true, ("DHD_ObjectState" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动O_设置Object自定义值。必须先"注册"获得功能库内部句柄，再使用本函数设定Object的自定义值，之后可使用"互动O_返回Object自定义值"，类型参数用以记录多个不同自定义值。注：固有自定义值是注册函数赋予的系统内部变量，只能通过"互动O_注册Object（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <param name="lp_customValue">自定义值</param>
        public static void DHD_SetObjectCV(object lp_object, string lp_key, string lp_customValue)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = DHD_RegObjectTagAndReturn(lp_object);
            // Implementation
            DictionaryStringSave0(true, ("DHD_ObjectCV" + lv_str + "_" + lv_tag), lp_customValue);
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object自定义值。使用"互动O_设定Object自定义值"后可使用本函数，将本函数参数"类型"设为空时返回固有值，该参数用以记录多个不同自定义值
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <returns></returns>
        public static string DHD_ReturnObjectCV(object lp_object, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = DHD_ReturnObjectTag(lp_object);
            lv_customValue = DictionaryStringLoad0(true, ("DHD_ObjectCV" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object固有状态。必须先使用"互动O_注册Object"才能返回到该值，固有状态是独一无二的标记（相当于单位组单位是否活体）
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns></returns>
        public static string DHD_ReturnObjectState_Only(object lp_object)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_tag = DHD_ReturnObjectTag(lp_object);
            lv_stats = DictionaryStringLoad0(true, ("DHD_ObjectState" + "" + "_" + lv_tag));
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object固有自定义值。必须先使用"互动O_注册Object"才能返回到该值，固有值是独一无二的标记
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns></returns>
        public static string DHD_ReturnObjectCV_Only(object lp_object)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_tag = DHD_ReturnObjectTag(lp_object);
            lv_customValue = DictionaryStringLoad0(true, ("DHD_ObjectCV" + "" + "_" + lv_tag));
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动O_设置Object的实数标记。必须先"注册"获得功能库内部句柄，再使用本函数让Object携带一个实数值，之后可使用"互动O_返回Object的实数标记"。Object组使用时，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_realNumTag">实数标记</param>
        public static void DHD_SetObjectDouble(object lp_object, double lp_realNumTag)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = DHD_RegObjectTagAndReturn(lp_object);
            // Implementation
            DictionaryDoubleSave0(true, ("DHD_CDDouble_Object_" + lv_tag), lp_realNumTag);
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object的实数标记。使用"互动O_设定Object的实数标记"后可使用本函数。Object组使用时，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns></returns>
        public static double DHD_ReturnObjectDouble(object lp_object)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = DHD_ReturnObjectTag(lp_object);
            // Implementation
            return DictionaryDoubleLoad0(true, ("DHD_CDDouble_Object_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object标签句柄有效状态。将Object视作独一无二的个体，标签是它本身，有效状态则类似"单位是否有效"，当使用"互动O_注册Object"或"互动OG_添加Object到Object组"后激活Object有效状态（值为"true"），除非使用"互动O_注册Object（高级）"改写，否则直到注销才会摧毁
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns></returns>
        public static bool DHD_ReturnIfObjectTag(object lp_object)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = DHD_ReturnObjectTag(lp_object);
            // Implementation
            return DictionaryBoolLoad0(true, ("DHD_IfObjectTag" + "" + "_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object注册状态。使用"互动O_注册Object"或"互动OG_添加Object到Object组"后可使用本函数获取注册Object在Key中的注册状态，该状态只能注销或从Object组中移除时清空。Object组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        /// <returns></returns>
        public static bool DHD_ReturnIfObjectTagKey(object lp_object, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = DHD_ReturnObjectTag(lp_object);
            // Implementation
            return DictionaryBoolLoad0(true, ("DHD_IfObjectTag" + lv_str + "_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动OG_根据自定义值类型将Object组排序。根据Object携带的自定义值类型，对指定的Object组元素进行冒泡排序。Object组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Object组名称</param>
        /// <param name="lp_cVStr">自定义值类型</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void DHD_ObjectGSortCV(string lp_key, string lp_cVStr, bool lp_big)
        {
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            string lv_tagValuestr;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_ObjectGroup" + lv_str, true);
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = DHD_ReturnObjectTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValuestr = DHD_ReturnObjectCV(DHD_ReturnObjectFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    DictionaryIntSave1(false, "IntStackOutTag", 1, lv_tag);
                    DictionaryIntSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DictionaryIntSave1(false, "IntStackOutTag", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    DictionaryIntSave1(false, "IntStackOutTagValue", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                DictionaryIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                DictionaryIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(DHD_ReturnObjectTagFromRegNum(lv_b, lp_key))+"值"+IntToString(DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DictionaryIntSave1(false, "IntStackOutTag", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DictionaryIntSave1(false, "IntStackOutTagValue", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                DictionaryIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DictionaryIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        DictionaryIntSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DictionaryIntSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = DictionaryIntLoad1(true, (lp_key + "ObjectTag"), lv_a).ToString(); //原始序号元素
                lv_tag = (int)DictionaryIntLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValuestr = DHD_ReturnObjectCV(DHD_ReturnObjectFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    DictionaryIntSave1(true, (lp_key + "ObjectTag"), lv_a, lv_tag); //lv_tag放入新序号
                    //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            ThreadWaitSet(true, "Key_ObjectGroup" + lv_str, false);
        }

        /// <summary>
        /// 【MM_函数库】互动OG_Object组排序。对指定的Object组元素进行冒泡排序（根据元素句柄）。Object组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Object组名称</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void DHD_ObjectGSort(string lp_key, bool lp_big)
        {
            // Automatic Variable Declarations
            // Implementation
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_ObjectGroup" + lv_str, true);
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = DHD_ReturnObjectTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValue = lv_tag;
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    DictionaryIntSave1(false, "IntStackOutTag", 1, lv_tag);
                    DictionaryIntSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DictionaryIntSave1(false, "IntStackOutTag", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    DictionaryIntSave1(false, "IntStackOutTagValue", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                DictionaryIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                DictionaryIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(DHD_ReturnObjectTagFromRegNum(lv_b, lp_key))+"值"+IntToString(DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DictionaryIntSave1(false, "IntStackOutTag", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DictionaryIntSave1(false, "IntStackOutTagValue", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                DictionaryIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DictionaryIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        DictionaryIntSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DictionaryIntSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = DictionaryIntLoad1(true, (lp_key + "ObjectTag"), lv_a).ToString(); //原始序号元素
                lv_tag = (int)DictionaryIntLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValue = lv_tag;
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                                                                                        //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    DictionaryIntSave1(true, (lp_key + "ObjectTag"), lv_a, lv_tag); //lv_tag放入新序号
                                                                                    //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            ThreadWaitSet(true, "Key_ObjectGroup" + lv_str, false);
        }

        /// <summary>
        /// 【MM_函数库】互动OG_设定Object的Object组专用状态。给Object组的Object设定一个状态值（字符串），之后可用"互动O_返回Object、互动OG_返回Object组的Object状态"。状态值"true"和"false"是Object的Object组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效），而本函数可以重设干预，影响函数"互动OG_返回Object组元素数量（仅检索XX状态）"。与"互动O_设定Object状态"功能相同，只是状态参数在Object组中被固定为"Object组变量的内部ID"。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_objectGroup"></param>
        /// <param name="lp_groupState"></param>
        public static void DHD_SetObjectGState(object lp_object, string lp_objectGroup, string lp_groupState)
        {
            DHD_SetObjectState(lp_object, lp_objectGroup, lp_groupState);
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object的Object组专用状态。使用"互动O_设定Object、互动OG_设定Object组的Object状态"后可使用本函数。与"互动O_返回Object状态"功能相同，只是状态参数在Object组中被固定为"Object组变量的内部ID"。状态值"true"和"false"是Object的Object组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效）。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_objectGroup"></param>
        public static void DHD_ReturnObjectGState(object lp_object, string lp_objectGroup)
        {
            DHD_ReturnObjectState(lp_object, lp_objectGroup);
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object组元素序号对应元素。返回Object组元素序号指定Object。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static object DHD_ReturnObjectFromObjectGFunc(int lp_regNum, string lp_gs)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            object lv_object;
            // Variable Initialization
            lv_str = (lp_gs + "Object");
            lv_tag = DictionaryIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            lv_object = DictionaryObjectLoad0(true, ("DHD_Object_" + lv_tag));
            // Implementation
            return lv_object;
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object组元素总数。返回指定Object组的元素数量。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int DHD_ReturnObjectGNumMax(string lp_gs)
        {
            return DictionaryIntLoad0(true, lp_gs + "ObjectNum");
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object组元素总数（仅检测Object组专用状态="true"）。返回指定Object组的元素数量。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int DHD_ReturnObjectGNumMax_StateTrueFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            object lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = DHD_ReturnObjectNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = DHD_ReturnObjectFromRegNum(lv_a, lp_gs);
                lv_b = DHD_ReturnObjectState(lv_c, lp_gs);
                if ((lv_b == "true"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object组元素总数（仅检测Object组专用状态="false"）。返回指定Object组的元素数量。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int DHD_ReturnObjectGNumMax_StateFalseFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            object lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = DHD_ReturnObjectNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = DHD_ReturnObjectFromRegNum(lv_a, lp_gs);
                lv_b = DHD_ReturnObjectState(lv_c, lp_gs);
                if ((lv_b == "false"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object组元素总数（仅检测Object组无效专用状态："false"或""）。返回指定Object组的元素数量（false、""、null）。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int DHD_ReturnObjectGNumMax_StateUselessFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            object lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = DHD_ReturnObjectNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = DHD_ReturnObjectFromRegNum(lv_a, lp_gs);
                lv_b = DHD_ReturnObjectState(lv_c, lp_gs);
                if (((lv_b == "false") || (lv_b == "") || (lv_b == null)))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object组元素总数（仅检测Object组指定专用状态）。返回指定Object组的元素数量。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_State">Object组专用状态</param>
        /// <returns></returns>
        public static int DHD_ReturnObjectGNumMax_StateFunc_Specify(string lp_gs, string lp_State)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            object lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = DHD_ReturnObjectNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = DHD_ReturnObjectFromRegNum(lv_a, lp_gs);
                lv_b = DHD_ReturnObjectState(lv_c, lp_gs);
                if ((lv_b == lp_State))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动OG_添加Object到Object组。相同Object被认为是同一个，非高级功能不提供专用状态检查，如果Object没有设置过Object组专用状态，那么首次添加到Object组不会赋予"true"（之后可通过"互动O_设定Object状态"、"互动OG_设定Object组的Object状态"修改）。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void DHD_AddObjectToGroup_Simple(object lp_object, string lp_gs)
        {
            DHD_RegObject_Simple(lp_object, lp_gs);
        }

        /// <summary>
        /// 【MM_函数库】互动OG_添加Object到Object组（高级）。相同Object被认为是同一个，高级功能提供专用状态检查，如果Object没有设置过Object组专用状态，那么首次添加到Object组会赋予"true"（之后可通过"互动O_设定Object状态"、"互动OG_设定Object组的Object状态"修改）。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void DHD_AddObjectToGroup(object lp_object, string lp_gs)
        {
            DHD_RegObject_Simple(lp_object, lp_gs);
            if (DictionaryStringKeyExists(true, ("DHD_ObjectState" + lp_gs + "Object_" + DHD_RegObjectTagAndReturn(lp_object))) == false)
            {
                DictionaryStringSave0(true, ("DHD_ObjectState" + lp_gs + "Object_" + DHD_RegObjectTagAndReturn(lp_object)), "true");
                //Console.WriteLine(lp_gs + "=>" + DHD_RegObjectTagAndReturn(lp_object));
            }
        }

        /// <summary>
        /// 【MM_函数库】互动OG_移除Object组中的元素。使用"互动OG_添加Object到Object组"后可使用本函数进行移除元素。移除使用了"互动O_移除Object"，同一个存储区（Object组ID）序号重排，移除时该存储区如有其他操作会排队等待。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void DHD_ClearObjectFromGroup(object lp_object, string lp_gs)
        {
            DHD_RemoveObject(lp_object, lp_gs);
        }

        //互动OG_为Object组中的每个序号
        //GE（星际2的Galaxy Editor）的宏让编辑器保存时自动生成脚本并整合进脚本进行格式调整，C#仅参考需自行编写
        // #AUTOVAR(vs, string) = "#PARAM(group)";//"#PARAM(group)"是与字段、变量名一致的元素组名称，宏去声明string类型名为“Auto随机编号_vs”的自动变量，然后=右侧字符
        // #AUTOVAR(ae) = DHD_ReturnObjectNumMax(#AUTOVAR(vs));//宏去声明默认int类型名为“Auto随机编号_ae”的自动变量，然后=右侧字符
        // #INITAUTOVAR(ai,increment)//宏去声明int类型名为“Auto随机编号_ai”的自动变量，用于下面for循环增量（increment是传入参数）
        // #PARAM(var) = #PARAM(s);//#PARAM(var)是传进来的参数，用作“当前被挑选到的元素”（任意变量-整数 lp_var）， #PARAM(s)是传进来的参数用作"开始"（int lp_s）
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #PARAM(var) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #PARAM(var) >= #AUTOVAR(ae)) ) ; #PARAM(var) += #AUTOVAR(ai) ) {
        //     #SUBFUNCS(actions)//代表用户GUI填写的所有动作
        // }

        /// <summary>
        /// 【MM_函数库】互动OG_为Object组中的每个序号。每次挑选的元素序号会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素序号，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void DHD_ForEachObjectNumFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            int lv_ae = DHD_ReturnObjectNumMax(lp_gs);
            int lv_var = lp_start;
            int lv_ai = lp_increment;
            for (; (lv_ai >= 0 && lv_var <= lv_ae) || (lv_ai < 0 && lv_var >= lv_ae); lv_var += lv_ai)
            {
                lp_funcref(lv_var);//用户填写的所有动作
            }
        }

        //互动OG_为Object组中的每个元素
        // #AUTOVAR(vs, string) = "#PARAM(group)";
        // #AUTOVAR(ae) = DHD_ReturnObjectNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= #PARAM(s);
        // #INITAUTOVAR(ai,increment)
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     DictionarySave(false, "ObjectGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)), DHD_ReturnObjectFromRegNum(#AUTOVAR(va),#AUTOVAR(vs)));
        // }
        // #AUTOVAR(va)= #PARAM(s);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #PARAM(var) = DictionaryLoad(false, "ObjectGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)));
        //     #SUBFUNCS(actions)
        // }

        /// <summary>
        /// 【MM_函数库】互动OG_为Object组中的每个元素。每次挑选的元素会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void DHD_ForEachObjectFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            string lv_vs = lp_gs;
            int lv_ae = DHD_ReturnObjectNumMax(lv_vs);
            int lv_va = lp_start;
            int lv_ai = lp_increment;
            object lv_object;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                DictionaryObjectSave0(false, "ObjectGFor" + lv_vs + lv_va.ToString(), DHD_ReturnObjectFromRegNum(lv_va, lv_vs));
            }
            lv_va = lp_start;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                lv_object = DictionaryObjectLoad0(false, "ObjectGFor" + lv_vs + lv_va.ToString());
                lp_funcref(lv_object);//用户填写的所有动作
            }
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object组中随机元素。返回指定Object组中的随机Object。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static object DHD_ReturnRandomObjectFromObjectGFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_num;
            int lv_a;
            object lv_c = null;
            // Variable Initialization
            lv_num = DHD_ReturnObjectNumMax(lp_gs);
            // Implementation
            if ((lv_num >= 1))
            {
                lv_a = RandomInt(1, lv_num);
                lv_c = DHD_ReturnObjectFromRegNum(lv_a, lp_gs);
            }
            return lv_c;
        }

        //互动OG_添加Object组到Object组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = DHD_ReturnObjectNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = DHD_ReturnObjectFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     DHD_AddObjectToGroup(#AUTOVAR(var), #AUTOVAR(vsb));
        // }


        /// <summary>
        /// 【MM_函数库】互动OG_添加Object组到Object组。添加一个Object组A的元素到另一个Object组B，相同Object被认为是同一个。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void DHD_AddObjectGToObjectG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = DHD_ReturnObjectNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            object lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = DHD_ReturnObjectFromRegNum(lv_va, lv_vsa);
                DHD_AddObjectToGroup(lv_var, lv_vsb);
            }
        }

        //互动OG_从Object组移除Object组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = DHD_ReturnObjectNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = DHD_ReturnObjectFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     DHD_RemoveObject(#AUTOVAR(var), #AUTOVAR(vsb));
        // }

        /// <summary>
        /// 【MM_函数库】互动OG_从Object组移除Object组。将Object组A的元素从Object组B中移除，相同Object被认为是同一个。移除使用了"互动O_移除Object"，同一个存储区（Object组ID）序号重排，移除时该存储区如有其他操作会排队等待。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void DHD_ClearObjectGFromObjectG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = DHD_ReturnObjectNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            object lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = DHD_ReturnObjectFromRegNum(lv_va, lv_vsa);
                DHD_RemoveObject(lv_var, lv_vsb);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动OG_移除Object组全部元素。将Object组（Key区）存储的元素全部移除，相同Object被认为是同一个。移除时同一个存储区（Object组ID）序号不进行重排，但该存储区如有其他操作会排队等待。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Object组名称</param>
        public static void DHD_RemoveObjectGAll(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag = "";
            int lv_a;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            // Implementation
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_ObjectGroup" + lv_str, true);
            for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
            {
                lv_tag = DictionaryIntLoad1(true, (lp_key + "ObjectTag"), lv_a).ToString();
                lv_num -= 1;
                DictionaryBoolClear0(true, "DHD_IfObjectTag" + lv_str + "_" + lv_tag);
                DictionaryStringClear0(true, "DHD_ObjectCV" + lv_str + "_" + lv_tag);
                DictionaryStringClear0(true, "DHD_ObjectState" + lv_str + "_" + lv_tag);
                DictionaryIntSave0(true, (lp_key + "ObjectNum"), lv_num);
            }
            ThreadWaitSet(true, "Key_ObjectGroup" + lv_str, false);
        }

        //--------------------------------------------------------------------------------------------------
        // 任意类型组End
        //--------------------------------------------------------------------------------------------------

        #endregion

        #region 二维向量

        //提示：尽可能使用对口类型，以防值类型与引用类型发生转换时拆装箱降低性能

        //--------------------------------------------------------------------------------------------------
        // 二维向量组Start
        //--------------------------------------------------------------------------------------------------

        /// <summary>
        /// 【MM_函数库】互动V_注册Vector标签句柄并返回。为Vector自动设置新的标签句柄，重复时会返回已注册的Vector标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns>返回一个Vector的已注册标签</returns>
        private static int DHD_RegVectorTagAndReturn_Int(Vector lp_vector)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)DictionaryIntLoad0(true, "DHD_VectorJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                DictionaryIntSave0(true, "DHD_VectorJBNum", lv_j);
                DictionaryVectorSave0(true, ("DHD_Vector_" + lv_j.ToString()), lp_vector);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if (DictionaryVectorLoad0(true, ("DHD_Vector_" + lv_j.ToString())) == lp_vector)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            DictionaryIntSave0(true, "DHD_VectorJBNum", lv_j);
                            DictionaryVectorSave0(true, ("DHD_Vector_" + lv_j.ToString()), lp_vector);
                        }
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector已注册标签句柄
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns>返回一个Vector的已注册标签，错误返回0</returns>
        public static int DHD_ReturnVectorTag_Int(Vector lp_vector)
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)DictionaryIntLoad0(true, "DHD_VectorJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if (DictionaryVectorLoad0(true, "DHD_Vector_" + lv_j.ToString()) == lp_vector)
                {
                    break;
                }
                else
                {
                    if ((lv_j == lv_jBNum))
                    {
                        lv_j = 0;
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动V_注册Vector标签句柄并返回。为Vector自动设置新的标签句柄，重复时会返回已注册的Vector标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns>返回一个Vector的已注册标签</returns>
        private static string DHD_RegVectorTagAndReturn(Vector lp_vector)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)DictionaryIntLoad0(true, "DHD_VectorJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                DictionaryIntSave0(true, "DHD_VectorJBNum", lv_j);
                DictionaryVectorSave0(true, ("DHD_Vector_" + lv_j.ToString()), lp_vector);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if (DictionaryVectorLoad0(true, "DHD_Vector_" + lv_j.ToString()) == lp_vector)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            DictionaryIntSave0(true, "DHD_VectorJBNum", lv_j);
                            DictionaryVectorSave0(true, ("DHD_Vector_" + lv_j.ToString()), lp_vector);
                        }
                    }
                }
            }
            lv_tag = lv_j.ToString();
            //Console.WriteLine(("Tag：" + lv_tag));
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector已注册标签句柄
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns>返回一个Vector的已注册标签，错误返回""</returns>
        public static string DHD_ReturnVectorTag(Vector lp_vector)
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag = "";
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)DictionaryIntLoad0(true, "DHD_VectorJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if (DictionaryVectorLoad0(true, "DHD_Vector_" + lv_j.ToString()) == lp_vector)
                {
                    lv_tag = lv_j.ToString();
                    break;
                }
            }
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动V_注册Vector(高级)。在指定Key存入Vector，固有状态、自定义值是Vector独一无二的标志（本函数重复注册会刷新），之后可用互动V_"返回Vector注册总数"、"返回Vector序号"、"返回序号对应Vector"、"返回序号对应Vector标签"、"返回Vector自定义值"。Vector组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Vector组转为Key。首次注册时固有状态为true（相当于单位组单位活体），如需另外设置多个标记可使用"互动V_设定Vector状态/自定义值"
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        /// <param name="lp_inherentStats">固有状态</param>
        /// <param name="lp_inherentCustomValue">固有自定义值</param>
        public static void DHD_RegVector(Vector lp_vector, string lp_key, string lp_inherentStats, string lp_inherentCustomValue)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;

            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_jBNum = (int)DictionaryIntLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = DHD_RegVectorTagAndReturn(lp_vector);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                DictionaryIntSave0(true, (lv_str + "Num"), lv_i);
                DictionaryStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                DictionaryBoolSave0(true, (("DHD_IfVectorTag" + "") + "_" + lv_tagStr), true);
                DictionaryBoolSave1(true, ("DHD_IfVectorTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if (DictionaryIntLoad1(true, lv_str + "Tag", lv_i).ToString() == lv_tagStr)
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                DictionaryIntSave0(true, (lv_str + "Num"), lv_i);
                                DictionaryStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                DictionaryBoolSave0(true, (("DHD_IfVectorTag" + "") + "_" + lv_tagStr), true);
                                DictionaryBoolSave1(true, ("DHD_IfVectorTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            DictionaryStringSave0(true, ("DHD_VectorState" + "" + "_" + lv_tagStr), lp_inherentStats);
            DictionaryStringSave0(true, ("DHD_VectorCV" + "" + "_" + lv_tagStr), lp_inherentCustomValue);
        }

        /// <summary>
        /// 【MM_函数库】互动V_注册Vector。在指定Key存入Vector，固有状态、自定义值是Vector独一无二的标志（本函数重复注册不会刷新），之后可用互动V_"返回Vector注册总数"、"返回Vector序号"、"返回序号对应Vector"、"返回Vector自定义值"。Vector组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Vector组转为Key。首次注册时固有状态为true（相当于单位组单位活体），之后只能通过"互动V_注册Vector（高级）"改写，如需另外设置多个标记可使用"互动V_设定Vector状态/自定义值"
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        public static void DHD_RegVector_Simple(Vector lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;

            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_jBNum = (int)DictionaryIntLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = DHD_RegVectorTagAndReturn(lp_vector);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                DictionaryIntSave0(true, (lv_str + "Num"), lv_i);
                DictionaryStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                DictionaryBoolSave0(true, (("DHD_IfVectorTag" + "") + "_" + lv_tagStr), true);
                DictionaryBoolSave1(true, ("DHD_IfVectorTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if (DictionaryIntLoad1(true, lv_str + "Tag", lv_i).ToString() == lv_tagStr)
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                DictionaryIntSave0(true, (lv_str + "Num"), lv_i);
                                DictionaryStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                DictionaryBoolSave0(true, (("DHD_IfVectorTag" + "") + "_" + lv_tagStr), true);
                                DictionaryBoolSave1(true, ("DHD_IfVectorTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            if ((DictionaryBoolKeyExists(true, ("DHD_Vector" + "State" + "_" + lv_tag.ToString())) == false))
            {
                DictionaryStringSave1(true, (("DHD_Vector" + "State")), lv_tag, "true");
            }
        }

        /// <summary>
        /// 【MM_函数库】互动V_注销Vector。用"互动V_注册Vector"到Key，之后可用本函数彻底摧毁注册信息并将序号重排（包括Vector标签有效状态、固有状态及自定义值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动V_设定Vector状态"让Vector状态失效（类似单位组的单位活体状态）。Vector组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Vector组转为Key。本函数无法摧毁用"互动V_设定Vector状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Vector组变量ID时会清空Vector组专用状态
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        public static void DHD_DestroyVector(Vector lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag;
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_tag = DHD_ReturnVectorTag(lp_vector);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                ThreadWaitSet(true, "Key_VectorGroup" + lv_str, true);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((DictionaryIntLoad1(true, (lp_key + "VectorTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        DictionaryBoolClear0(true, "DHD_IfVectorTag_" + lv_tag);
                        DictionaryBoolClear0(true, "DHD_IfVectorTag" + lv_str + "_" + lv_tag);
                        DictionaryVectorClear0(true, "DHD_Vector_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_VectorCV_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_VectorState_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_VectorCV" + lv_str + "_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_VectorState" + lv_str + "_" + lv_tag);
                        DictionaryIntSave0(true, (lp_key + "VectorNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = DictionaryIntLoad1(true, (lp_key + "VectorTag"), lv_b + 1).ToString();
                            DictionaryStringSave1(true, (lp_key + "VectorTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                ThreadWaitSet(true, "Key_VectorGroup" + lv_str, false);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动V_移除Vector。用"互动V_注册Vector"到Key，之后可用本函数仅摧毁Key区注册的信息并将序号重排，用于Vector组或多个键区仅移除Vector（保留Vector标签有效状态、固有值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动V_设定Vector状态"让Vector状态失效（类似单位组的单位活体状态）。Vector组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Vector组转为Key。本函数无法摧毁用"互动V_设定Vector状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Vector组变量ID时会清空Vector组专用状态
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        public static void DHD_RemoveVector(Vector lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag;
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_tag = DHD_ReturnVectorTag(lp_vector);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                ThreadWaitSet(true, "Key_VectorGroup" + lv_str, true);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((DictionaryIntLoad1(true, (lp_key + "VectorTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        DictionaryBoolClear0(true, "DHD_IfVectorTag" + lv_str + "_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_VectorCV" + lv_str + "_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_VectorState" + lv_str + "_" + lv_tag);
                        DictionaryIntSave0(true, (lp_key + "VectorNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = DictionaryIntLoad1(true, (lp_key + "VectorTag"), lv_b + 1).ToString();
                            DictionaryStringSave1(true, (lp_key + "VectorTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                ThreadWaitSet(true, "Key_VectorGroup" + lv_str, false);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector注册总数。必须先使用"互动V_注册Vector"才能返回指定Key里的注册总数。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key。
        /// </summary>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        /// <returns></returns>
        public static int DHD_ReturnVectorNumMax(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            // Implementation
            return lv_num;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector序号。使用"互动V_注册Vector"后使用本函数可返回Key里的注册序号，Key无元素返回0，Key有元素但对象不在里面则返回-1，Vector标签尚未注册则返回-2。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        /// <returns></returns>
        public static int DHD_ReturnVectorNum(Vector lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_i;
            string lv_tag;
            int lv_torf;
            // Automatic Variable Declarations
            const int auto_n = 1;
            int auto_i;
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_tag = DHD_ReturnVectorTag(lp_vector);
            lv_torf = -1;
            // Implementation
            for (auto_i = 1; auto_i <= auto_n; auto_i += 1)
            {
                if ((lv_tag != null))
                {
                    lv_torf = -2;
                    break;
                }
                if ((lv_num == 0))
                {
                    lv_torf = 0;
                }
                else
                {
                    if ((lv_num >= 1))
                    {
                        auto_ae = lv_num;
                        auto_var = 1;
                        for (; auto_var <= auto_ae; auto_var += 1)
                        {
                            lv_i = auto_var;
                            if ((DictionaryIntLoad1(true, (lv_str + "Tag"), lv_i).ToString() == lv_tag))
                            {
                                lv_torf = lv_i;
                                break;
                            }
                        }
                    }
                }
            }
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回序号对应Vector。使用"互动V_注册Vector"后，在参数填入注册序号可返回Vector。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_regNum"></param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        /// <returns></returns>
        public static Vector DHD_ReturnVectorFromRegNum(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            lv_tag = DictionaryIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return DictionaryVectorLoad0(true, ("DHD_Vector_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回句柄标签对应Vector。使用"互动V_注册Vector"后，在参数填入句柄标签（整数）可返回Vector，标签是Vector的句柄。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_tag">句柄标签</param>
        /// <returns></returns>
        public static Vector DHD_ReturnVectorFromTag(int lp_tag)
        {
            // Variable Declarations
            string lv_tag;
            // Variable Initialization
            lv_tag = lp_tag.ToString();
            // Implementation
            return DictionaryVectorLoad0(true, ("DHD_Vector_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回序号对应Vector标签句柄。使用"互动V_注册Vector"后，在参数填入注册序号可返回Vector标签（字符串）。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        /// <returns></returns>
        public static string DHD_ReturnVectorTagFromRegNum_String(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            lv_tag = DictionaryIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回序号对应Vector标签句柄。使用"互动V_注册Vector"后，在参数填入注册序号可返回Vector标签（整数）。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        /// <returns></returns>
        public static int DHD_ReturnVectorTagFromRegNum_Int(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            lv_tag = DictionaryIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return Convert.ToInt32(lv_tag);
        }

        /// <summary>
        /// 【MM_函数库】互动V_设置Vector状态。必须先"注册"获得功能库内部句柄，再使用本函数给Vector设定一个状态值，之后可用"互动V_返回Vector状态"。类型参数用以记录多个不同状态，仅当"类型"参数填Vector组ID转的Vector串时，状态值"true"和"false"是Vector的Vector组专用状态值，用于内部函数筛选Vector状态（相当于单位组单位索引是否有效），其他类型不会干扰系统内部，可随意填写。虽然注销时反向清空注册信息，但用"互动V_设定Vector状态/自定义值"创建的值需要手工填入""来排泄（非大量注销则提升内存量极小，可不管）。注：固有状态值是注册函数赋予的系统内部变量（相当于单位组单位是否活体），只能通过"互动V_注册Vector（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <param name="lp_stats">状态</param>
        public static void DHD_SetVectorState(Vector lp_vector, string lp_key, string lp_stats)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            lv_tag = DHD_RegVectorTagAndReturn(lp_vector);
            // Implementation
            DictionaryStringSave0(true, ("DHD_VectorState" + lv_str + "_" + lv_tag), lp_stats);
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector状态。使用"互动V_设定Vector状态"后可使用本函数，将本函数参数"类型"设为空时返回固有值。类型参数用以记录多个不同状态，仅当"类型"参数为Vector组ID转的字符串时，返回的状态值"true"和"false"是Vector的Vector组专用状态值，用于内部函数筛选Vector状态（相当于单位组单位索引是否有效）
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <returns></returns>
        public static string DHD_ReturnVectorState(Vector lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            lv_tag = DHD_ReturnVectorTag(lp_vector);
            lv_stats = DictionaryStringLoad0(true, ("DHD_VectorState" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动V_设置Vector自定义值。必须先"注册"获得功能库内部句柄，再使用本函数设定Vector的自定义值，之后可使用"互动V_返回Vector自定义值"，类型参数用以记录多个不同自定义值。注：固有自定义值是注册函数赋予的系统内部变量，只能通过"互动V_注册Vector（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <param name="lp_customValue">自定义值</param>
        public static void DHD_SetVectorCV(Vector lp_vector, string lp_key, string lp_customValue)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            lv_tag = DHD_RegVectorTagAndReturn(lp_vector);
            // Implementation
            DictionaryStringSave0(true, ("DHD_VectorCV" + lv_str + "_" + lv_tag), lp_customValue);
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector自定义值。使用"互动V_设定Vector自定义值"后可使用本函数，将本函数参数"类型"设为空时返回固有值，该参数用以记录多个不同自定义值
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <returns></returns>
        public static string DHD_ReturnVectorCV(Vector lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            lv_tag = DHD_ReturnVectorTag(lp_vector);
            lv_customValue = DictionaryStringLoad0(true, ("DHD_VectorCV" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector固有状态。必须先使用"互动V_注册Vector"才能返回到该值，固有状态是独一无二的标记（相当于单位组单位是否活体）
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns></returns>
        public static string DHD_ReturnVectorState_Only(Vector lp_vector)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_tag = DHD_ReturnVectorTag(lp_vector);
            lv_stats = DictionaryStringLoad0(true, ("DHD_VectorState" + "" + "_" + lv_tag));
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector固有自定义值。必须先使用"互动V_注册Vector"才能返回到该值，固有值是独一无二的标记
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns></returns>
        public static string DHD_ReturnVectorCV_Only(Vector lp_vector)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_tag = DHD_ReturnVectorTag(lp_vector);
            lv_customValue = DictionaryStringLoad0(true, ("DHD_VectorCV" + "" + "_" + lv_tag));
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动V_设置Vector的实数标记。必须先"注册"获得功能库内部句柄，再使用本函数让Vector携带一个实数值，之后可使用"互动V_返回Vector的实数标记"。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_realNumTag">实数标记</param>
        public static void DHD_SetVectorDouble(Vector lp_vector, double lp_realNumTag)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = DHD_RegVectorTagAndReturn(lp_vector);
            // Implementation
            DictionaryDoubleSave0(true, ("DHD_CDDouble_Vector_" + lv_tag), lp_realNumTag);
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector的实数标记。使用"互动V_设定Vector的实数标记"后可使用本函数。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns></returns>
        public static double DHD_ReturnVectorDouble(Vector lp_vector)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = DHD_ReturnVectorTag(lp_vector);
            // Implementation
            return DictionaryDoubleLoad0(true, ("DHD_CDDouble_Vector_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector标签句柄有效状态。将Vector视作独一无二的个体，标签是它本身，有效状态则类似"单位是否有效"，当使用"互动V_注册Vector"或"互动VG_添加Vector到Vector组"后激活Vector有效状态（值为"true"），除非使用"互动V_注册Vector（高级）"改写，否则直到注销才会摧毁
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns></returns>
        public static bool DHD_ReturnIfVectorTag(Vector lp_vector)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = DHD_ReturnVectorTag(lp_vector);
            // Implementation
            return DictionaryBoolLoad0(true, ("DHD_IfVectorTag" + "" + "_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector注册状态。使用"互动V_注册Vector"或"互动VG_添加Vector到Vector组"后可使用本函数获取注册Vector在Key中的注册状态，该状态只能注销或从Vector组中移除时清空。Vector组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        /// <returns></returns>
        public static bool DHD_ReturnIfVectorTagKey(Vector lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            lv_tag = DHD_ReturnVectorTag(lp_vector);
            // Implementation
            return DictionaryBoolLoad0(true, ("DHD_IfVectorTag" + lv_str + "_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动VG_根据自定义值类型将Vector组排序。根据Vector携带的自定义值类型，对指定的Vector组元素进行冒泡排序。Vector组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Vector组名称</param>
        /// <param name="lp_cVStr">自定义值类型</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void DHD_VectorGSortCV(string lp_key, string lp_cVStr, bool lp_big)
        {
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            string lv_tagValuestr;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_VectorGroup" + lv_str, true);
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = DHD_ReturnVectorTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValuestr = DHD_ReturnVectorCV((Vector)DHD_ReturnVectorFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    DictionaryIntSave1(false, "IntStackOutTag", 1, lv_tag);
                    DictionaryIntSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DictionaryIntSave1(false, "IntStackOutTag", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    DictionaryIntSave1(false, "IntStackOutTagValue", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                DictionaryIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                DictionaryIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(DHD_ReturnVectorTagFromRegNum(lv_b, lp_key))+"值"+IntToString(DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DictionaryIntSave1(false, "IntStackOutTag", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DictionaryIntSave1(false, "IntStackOutTagValue", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                DictionaryIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DictionaryIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        DictionaryIntSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DictionaryIntSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = DictionaryIntLoad1(true, (lp_key + "VectorTag"), lv_a).ToString(); //原始序号元素
                lv_tag = (int)DictionaryIntLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValuestr = DHD_ReturnVectorCV((Vector)DHD_ReturnVectorFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    DictionaryIntSave1(true, (lp_key + "VectorTag"), lv_a, lv_tag); //lv_tag放入新序号
                    //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            ThreadWaitSet(true, "Key_VectorGroup" + lv_str, false);
        }

        /// <summary>
        /// 【MM_函数库】互动VG_Vector组排序。对指定的Vector组元素进行冒泡排序（根据元素句柄）。Vector组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Vector组名称</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void DHD_VectorGSort(string lp_key, bool lp_big)
        {
            // Automatic Variable Declarations
            // Implementation
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_VectorGroup" + lv_str, true);
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = DHD_ReturnVectorTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValue = lv_tag;
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    DictionaryIntSave1(false, "IntStackOutTag", 1, lv_tag);
                    DictionaryIntSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DictionaryIntSave1(false, "IntStackOutTag", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    DictionaryIntSave1(false, "IntStackOutTagValue", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                DictionaryIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                DictionaryIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(DHD_ReturnVectorTagFromRegNum(lv_b, lp_key))+"值"+IntToString(DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DictionaryIntSave1(false, "IntStackOutTag", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DictionaryIntSave1(false, "IntStackOutTagValue", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                DictionaryIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DictionaryIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        DictionaryIntSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DictionaryIntSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = DictionaryIntLoad1(true, (lp_key + "VectorTag"), lv_a).ToString(); //原始序号元素
                lv_tag = (int)DictionaryIntLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValue = lv_tag;
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                                                                                        //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    DictionaryIntSave1(true, (lp_key + "VectorTag"), lv_a, lv_tag); //lv_tag放入新序号
                                                                                    //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            ThreadWaitSet(true, "Key_VectorGroup" + lv_str, false);
        }

        /// <summary>
        /// 【MM_函数库】互动VG_设定Vector的Vector组专用状态。给Vector组的Vector设定一个状态值（字符串），之后可用"互动V_返回Vector、互动VG_返回Vector组的Vector状态"。状态值"true"和"false"是Vector的Vector组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效），而本函数可以重设干预，影响函数"互动VG_返回Vector组元素数量（仅检索XX状态）"。与"互动V_设定Vector状态"功能相同，只是状态参数在Vector组中被固定为"Vector组变量的内部ID"。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_vectorGroup"></param>
        /// <param name="lp_groupState"></param>
        public static void DHD_SetVectorGState(Vector lp_vector, string lp_vectorGroup, string lp_groupState)
        {
            DHD_SetVectorState(lp_vector, lp_vectorGroup, lp_groupState);
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector的Vector组专用状态。使用"互动V_设定Vector、互动VG_设定Vector组的Vector状态"后可使用本函数。与"互动V_返回Vector状态"功能相同，只是状态参数在Vector组中被固定为"Vector组变量的内部ID"。状态值"true"和"false"是Vector的Vector组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效）。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_vectorGroup"></param>
        public static void DHD_ReturnVectorGState(Vector lp_vector, string lp_vectorGroup)
        {
            DHD_ReturnVectorState(lp_vector, lp_vectorGroup);
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector组元素序号对应元素。返回Vector组元素序号指定Vector。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static Vector DHD_ReturnVectorFromVectorGFunc(int lp_regNum, string lp_gs)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_gs + "Vector");
            lv_tag = DictionaryIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return DictionaryVectorLoad0(true, ("DHD_Vector_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector组元素总数。返回指定Vector组的元素数量。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int DHD_ReturnVectorGNumMax(string lp_gs)
        {
            return DictionaryIntLoad0(true, lp_gs + "VectorNum");
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector组元素总数（仅检测Vector组专用状态="true"）。返回指定Vector组的元素数量。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int DHD_ReturnVectorGNumMax_StateTrueFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Vector lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = DHD_ReturnVectorNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (Vector)DHD_ReturnVectorFromRegNum(lv_a, lp_gs);
                lv_b = DHD_ReturnVectorState(lv_c, lp_gs);
                if ((lv_b == "true"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector组元素总数（仅检测Vector组专用状态="false"）。返回指定Vector组的元素数量。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int DHD_ReturnVectorGNumMax_StateFalseFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Vector lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = DHD_ReturnVectorNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (Vector)DHD_ReturnVectorFromRegNum(lv_a, lp_gs);
                lv_b = DHD_ReturnVectorState(lv_c, lp_gs);
                if ((lv_b == "false"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector组元素总数（仅检测Vector组无效专用状态："false"或""）。返回指定Vector组的元素数量（false、""、null）。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int DHD_ReturnVectorGNumMax_StateUselessFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Vector lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = DHD_ReturnVectorNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (Vector)DHD_ReturnVectorFromRegNum(lv_a, lp_gs);
                lv_b = DHD_ReturnVectorState(lv_c, lp_gs);
                if (((lv_b == "false") || (lv_b == "") || (lv_b == null)))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector组元素总数（仅检测Vector组指定专用状态）。返回指定Vector组的元素数量。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_State">Vector组专用状态</param>
        /// <returns></returns>
        public static int DHD_ReturnVectorGNumMax_StateFunc_Specify(string lp_gs, string lp_State)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Vector lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = DHD_ReturnVectorNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (Vector)DHD_ReturnVectorFromRegNum(lv_a, lp_gs);
                lv_b = DHD_ReturnVectorState(lv_c, lp_gs);
                if ((lv_b == lp_State))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动VG_添加Vector到Vector组。相同Vector被认为是同一个，非高级功能不提供专用状态检查，如果Vector没有设置过Vector组专用状态，那么首次添加到Vector组不会赋予"true"（之后可通过"互动V_设定Vector状态"、"互动VG_设定Vector组的Vector状态"修改）。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void DHD_AddVectorToGroup_Simple(Vector lp_vector, string lp_gs)
        {
            DHD_RegVector_Simple(lp_vector, lp_gs);
        }

        /// <summary>
        /// 【MM_函数库】互动VG_添加Vector到Vector组（高级）。相同Vector被认为是同一个，高级功能提供专用状态检查，如果Vector没有设置过Vector组专用状态，那么首次添加到Vector组会赋予"true"（之后可通过"互动V_设定Vector状态"、"互动VG_设定Vector组的Vector状态"修改）。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void DHD_AddVectorToGroup(Vector lp_vector, string lp_gs)
        {
            DHD_RegVector_Simple(lp_vector, lp_gs);
            if (DictionaryStringKeyExists(true, ("DHD_VectorState" + lp_gs + "Vector_" + DHD_RegVectorTagAndReturn(lp_vector))) == false)
            {
                DictionaryStringSave0(true, ("DHD_VectorState" + lp_gs + "Vector_" + DHD_RegVectorTagAndReturn(lp_vector)), "true");
                //Console.WriteLine(lp_gs + "=>" + DHD_RegVectorTagAndReturn(lp_vector));
            }
        }

        /// <summary>
        /// 【MM_函数库】互动VG_移除Vector组中的元素。使用"互动VG_添加Vector到Vector组"后可使用本函数进行移除元素。移除使用了"互动V_移除Vector"，同一个存储区（Vector组ID）序号重排，移除时该存储区如有其他操作会排队等待。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void DHD_ClearVectorFromGroup(Vector lp_vector, string lp_gs)
        {
            DHD_RemoveVector(lp_vector, lp_gs);
        }

        //互动VG_为Vector组中的每个序号
        //GE（星际2的Galaxy Editor）的宏让编辑器保存时自动生成脚本并整合进脚本进行格式调整，C#仅参考需自行编写
        // #AUTOVAR(vs, string) = "#PARAM(group)";//"#PARAM(group)"是与字段、变量名一致的元素组名称，宏去声明string类型名为“Auto随机编号_vs”的自动变量，然后=右侧字符
        // #AUTOVAR(ae) = DHD_ReturnVectorNumMax(#AUTOVAR(vs));//宏去声明默认int类型名为“Auto随机编号_ae”的自动变量，然后=右侧字符
        // #INITAUTOVAR(ai,increment)//宏去声明int类型名为“Auto随机编号_ai”的自动变量，用于下面for循环增量（increment是传入参数）
        // #PARAM(var) = #PARAM(s);//#PARAM(var)是传进来的参数，用作“当前被挑选到的元素”（任意变量-整数 lp_var）， #PARAM(s)是传进来的参数用作"开始"（int lp_s）
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #PARAM(var) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #PARAM(var) >= #AUTOVAR(ae)) ) ; #PARAM(var) += #AUTOVAR(ai) ) {
        //     #SUBFUNCS(actions)//代表用户GUI填写的所有动作
        // }

        /// <summary>
        /// 【MM_函数库】互动VG_为Vector组中的每个序号。每次挑选的元素序号会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素序号，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void DHD_ForEachVectorNumFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            int lv_ae = DHD_ReturnVectorNumMax(lp_gs);
            int lv_var = lp_start;
            int lv_ai = lp_increment;
            for (; (lv_ai >= 0 && lv_var <= lv_ae) || (lv_ai < 0 && lv_var >= lv_ae); lv_var += lv_ai)
            {
                lp_funcref(lv_var);//用户填写的所有动作
            }
        }

        //互动VG_为Vector组中的每个元素
        // #AUTOVAR(vs, string) = "#PARAM(group)";
        // #AUTOVAR(ae) = DHD_ReturnVectorNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= #PARAM(s);
        // #INITAUTOVAR(ai,increment)
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     DictionarySave(false, "VectorGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)), DHD_ReturnVectorFromRegNum(#AUTOVAR(va),#AUTOVAR(vs)));
        // }
        // #AUTOVAR(va)= #PARAM(s);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #PARAM(var) = DictionaryLoad(false, "VectorGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)));
        //     #SUBFUNCS(actions)
        // }

        /// <summary>
        /// 【MM_函数库】互动VG_为Vector组中的每个元素。每次挑选的元素会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void DHD_ForEachVectorFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            string lv_vs = lp_gs;
            int lv_ae = DHD_ReturnVectorNumMax(lv_vs);
            int lv_va = lp_start;
            int lv_ai = lp_increment;
            Vector lv_vector;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                DictionaryVectorSave0(false, "VectorGFor" + lv_vs + lv_va.ToString(), (Vector)DHD_ReturnVectorFromRegNum(lv_va, lv_vs));
            }
            lv_va = lp_start;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                lv_vector = (Vector)DictionaryVectorLoad0(false, "VectorGFor" + lv_vs + lv_va.ToString());
                lp_funcref(lv_vector);//用户填写的所有动作
            }
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector组中随机元素。返回指定Vector组中的随机Vector。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static Vector DHD_ReturnRandomVectorFromVectorGFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_num;
            int lv_a;
            Vector lv_c = new Vector(0, 0);
            // Variable Initialization
            lv_num = DHD_ReturnVectorNumMax(lp_gs);
            // Implementation
            if ((lv_num >= 1))
            {
                lv_a = RandomInt(1, lv_num);
                lv_c = (Vector)DHD_ReturnVectorFromRegNum(lv_a, lp_gs);
            }
            return lv_c;
        }

        //互动VG_添加Vector组到Vector组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = DHD_ReturnVectorNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = DHD_ReturnVectorFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     DHD_AddVectorToGroup(#AUTOVAR(var), #AUTOVAR(vsb));
        // }


        /// <summary>
        /// 【MM_函数库】互动VG_添加Vector组到Vector组。添加一个Vector组A的元素到另一个Vector组B，相同Vector被认为是同一个。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void DHD_AddVectorGToVectorG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = DHD_ReturnVectorNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            Vector lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = (Vector)DHD_ReturnVectorFromRegNum(lv_va, lv_vsa);
                DHD_AddVectorToGroup(lv_var, lv_vsb);
            }
        }

        //互动VG_从Vector组移除Vector组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = DHD_ReturnVectorNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = DHD_ReturnVectorFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     DHD_RemoveVector(#AUTOVAR(var), #AUTOVAR(vsb));
        // }

        /// <summary>
        /// 【MM_函数库】互动VG_从Vector组移除Vector组。将Vector组A的元素从Vector组B中移除，相同Vector被认为是同一个。移除使用了"互动V_移除Vector"，同一个存储区（Vector组ID）序号重排，移除时该存储区如有其他操作会排队等待。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void DHD_ClearVectorGFromVectorG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = DHD_ReturnVectorNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            Vector lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = (Vector)DHD_ReturnVectorFromRegNum(lv_va, lv_vsa);
                DHD_RemoveVector(lv_var, lv_vsb);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动VG_移除Vector组全部元素。将Vector组（Key区）存储的元素全部移除，相同Vector被认为是同一个。移除时同一个存储区（Vector组ID）序号不进行重排，但该存储区如有其他操作会排队等待。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Vector组名称</param>
        public static void DHD_RemoveVectorGAll(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag = "";
            int lv_a;
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            // Implementation
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_VectorGroup" + lv_str, true);
            for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
            {
                lv_tag = DictionaryIntLoad1(true, (lp_key + "VectorTag"), lv_a).ToString();
                lv_num -= 1;
                DictionaryBoolClear0(true, "DHD_IfVectorTag" + lv_str + "_" + lv_tag);
                DictionaryStringClear0(true, "DHD_VectorCV" + lv_str + "_" + lv_tag);
                DictionaryStringClear0(true, "DHD_VectorState" + lv_str + "_" + lv_tag);
                DictionaryIntSave0(true, (lp_key + "VectorNum"), lv_num);
            }
            ThreadWaitSet(true, "Key_VectorGroup" + lv_str, false);
        }

        //--------------------------------------------------------------------------------------------------
        // 二维向量组End
        //--------------------------------------------------------------------------------------------------

        #endregion

        #region 计时器

        //提示：尽可能使用对口类型，以防值类型与引用类型发生转换时拆装箱降低性能

        //--------------------------------------------------------------------------------------------------
        // 计时器组Start
        //--------------------------------------------------------------------------------------------------

        /// <summary>
        /// 【MM_函数库】互动T_注册Timer标签句柄并返回。为Timer自动设置新的标签句柄，重复时会返回已注册的Timer标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns>返回一个Timer的已注册标签</returns>
        private static int DHD_RegTimerTagAndReturn_Int(Timer lp_timer)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)DictionaryIntLoad0(true, "DHD_TimerJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                DictionaryIntSave0(true, "DHD_TimerJBNum", lv_j);
                DictionaryTimerSave0(true, ("DHD_Timer_" + lv_j.ToString()), lp_timer);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if (DictionaryTimerLoad0(true, ("DHD_Timer_" + lv_j.ToString())) == lp_timer)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            DictionaryIntSave0(true, "DHD_TimerJBNum", lv_j);
                            DictionaryTimerSave0(true, ("DHD_Timer_" + lv_j.ToString()), lp_timer);
                        }
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer已注册标签句柄
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns>返回一个Timer的已注册标签，错误返回0</returns>
        public static int DHD_ReturnTimerTag_Int(Timer lp_timer)
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)DictionaryIntLoad0(true, "DHD_TimerJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if (DictionaryTimerLoad0(true, "DHD_Timer_" + lv_j.ToString()) == lp_timer)
                {
                    break;
                }
                else
                {
                    if ((lv_j == lv_jBNum))
                    {
                        lv_j = 0;
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动T_注册Timer标签句柄并返回。为Timer自动设置新的标签句柄，重复时会返回已注册的Timer标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns>返回一个Timer的已注册标签</returns>
        private static string DHD_RegTimerTagAndReturn(Timer lp_timer)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)DictionaryIntLoad0(true, "DHD_TimerJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                DictionaryIntSave0(true, "DHD_TimerJBNum", lv_j);
                DictionaryTimerSave0(true, ("DHD_Timer_" + lv_j.ToString()), lp_timer);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if (DictionaryTimerLoad0(true, "DHD_Timer_" + lv_j.ToString()) == lp_timer)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            DictionaryIntSave0(true, "DHD_TimerJBNum", lv_j);
                            DictionaryTimerSave0(true, ("DHD_Timer_" + lv_j.ToString()), lp_timer);
                        }
                    }
                }
            }
            lv_tag = lv_j.ToString();
            //Console.WriteLine(("Tag：" + lv_tag));
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer已注册标签句柄
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns>返回一个Timer的已注册标签，错误返回""</returns>
        public static string DHD_ReturnTimerTag(Timer lp_timer)
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag = "";
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)DictionaryIntLoad0(true, "DHD_TimerJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if (DictionaryTimerLoad0(true, "DHD_Timer_" + lv_j.ToString()) == lp_timer)
                {
                    lv_tag = lv_j.ToString();
                    break;
                }
            }
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动T_注册Timer(高级)。在指定Key存入Timer，固有状态、自定义值是Timer独一无二的标志（本函数重复注册会刷新），之后可用互动T_"返回Timer注册总数"、"返回Timer序号"、"返回序号对应Timer"、"返回序号对应Timer标签"、"返回Timer自定义值"。Timer组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Timer组转为Key。首次注册时固有状态为true（相当于单位组单位活体），如需另外设置多个标记可使用"互动T_设定Timer状态/自定义值"
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        /// <param name="lp_inherentStats">固有状态</param>
        /// <param name="lp_inherentCustomValue">固有自定义值</param>
        public static void DHD_RegTimer(Timer lp_timer, string lp_key, string lp_inherentStats, string lp_inherentCustomValue)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;

            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_jBNum = (int)DictionaryIntLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = DHD_RegTimerTagAndReturn(lp_timer);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                DictionaryIntSave0(true, (lv_str + "Num"), lv_i);
                DictionaryStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                DictionaryBoolSave0(true, (("DHD_IfTimerTag" + "") + "_" + lv_tagStr), true);
                DictionaryBoolSave1(true, ("DHD_IfTimerTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if (DictionaryIntLoad1(true, lv_str + "Tag", lv_i).ToString() == lv_tagStr)
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                DictionaryIntSave0(true, (lv_str + "Num"), lv_i);
                                DictionaryStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                DictionaryBoolSave0(true, (("DHD_IfTimerTag" + "") + "_" + lv_tagStr), true);
                                DictionaryBoolSave1(true, ("DHD_IfTimerTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            DictionaryStringSave0(true, ("DHD_TimerState" + "" + "_" + lv_tagStr), lp_inherentStats);
            DictionaryStringSave0(true, ("DHD_TimerCV" + "" + "_" + lv_tagStr), lp_inherentCustomValue);
        }

        /// <summary>
        /// 【MM_函数库】互动T_注册Timer。在指定Key存入Timer，固有状态、自定义值是Timer独一无二的标志（本函数重复注册不会刷新），之后可用互动T_"返回Timer注册总数"、"返回Timer序号"、"返回序号对应Timer"、"返回Timer自定义值"。Timer组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Timer组转为Key。首次注册时固有状态为true（相当于单位组单位活体），之后只能通过"互动T_注册Timer（高级）"改写，如需另外设置多个标记可使用"互动T_设定Timer状态/自定义值"
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        public static void DHD_RegTimer_Simple(Timer lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;

            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_jBNum = (int)DictionaryIntLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = DHD_RegTimerTagAndReturn(lp_timer);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                DictionaryIntSave0(true, (lv_str + "Num"), lv_i);
                DictionaryStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                DictionaryBoolSave0(true, (("DHD_IfTimerTag" + "") + "_" + lv_tagStr), true);
                DictionaryBoolSave1(true, ("DHD_IfTimerTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if (DictionaryIntLoad1(true, lv_str + "Tag", lv_i).ToString() == lv_tagStr)
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                DictionaryIntSave0(true, (lv_str + "Num"), lv_i);
                                DictionaryStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                DictionaryBoolSave0(true, (("DHD_IfTimerTag" + "") + "_" + lv_tagStr), true);
                                DictionaryBoolSave1(true, ("DHD_IfTimerTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            if ((DictionaryBoolKeyExists(true, ("DHD_Timer" + "State" + "_" + lv_tag.ToString())) == false))
            {
                DictionaryStringSave1(true, (("DHD_Timer" + "State")), lv_tag, "true");
            }
        }

        /// <summary>
        /// 【MM_函数库】互动T_注销Timer。用"互动T_注册Timer"到Key，之后可用本函数彻底摧毁注册信息并将序号重排（包括Timer标签有效状态、固有状态及自定义值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动T_设定Timer状态"让Timer状态失效（类似单位组的单位活体状态）。Timer组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Timer组转为Key。本函数无法摧毁用"互动T_设定Timer状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Timer组变量ID时会清空Timer组专用状态
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        public static void DHD_DestroyTimer(Timer lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag;
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_tag = DHD_ReturnTimerTag(lp_timer);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                ThreadWaitSet(true, "Key_TimerGroup" + lv_str, true);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((DictionaryIntLoad1(true, (lp_key + "TimerTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        DictionaryBoolClear0(true, "DHD_IfTimerTag_" + lv_tag);
                        DictionaryBoolClear0(true, "DHD_IfTimerTag" + lv_str + "_" + lv_tag);
                        DictionaryTimerClear0(true, "DHD_Timer_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_TimerCV_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_TimerState_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_TimerCV" + lv_str + "_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_TimerState" + lv_str + "_" + lv_tag);
                        DictionaryIntSave0(true, (lp_key + "TimerNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = DictionaryIntLoad1(true, (lp_key + "TimerTag"), lv_b + 1).ToString();
                            DictionaryStringSave1(true, (lp_key + "TimerTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                ThreadWaitSet(true, "Key_TimerGroup" + lv_str, false);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动T_移除Timer。用"互动T_注册Timer"到Key，之后可用本函数仅摧毁Key区注册的信息并将序号重排，用于Timer组或多个键区仅移除Timer（保留Timer标签有效状态、固有值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动T_设定Timer状态"让Timer状态失效（类似单位组的单位活体状态）。Timer组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Timer组转为Key。本函数无法摧毁用"互动T_设定Timer状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Timer组变量ID时会清空Timer组专用状态
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        public static void DHD_RemoveTimer(Timer lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag;
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_tag = DHD_ReturnTimerTag(lp_timer);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                ThreadWaitSet(true, "Key_TimerGroup" + lv_str, true);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((DictionaryIntLoad1(true, (lp_key + "TimerTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        DictionaryBoolClear0(true, "DHD_IfTimerTag" + lv_str + "_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_TimerCV" + lv_str + "_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_TimerState" + lv_str + "_" + lv_tag);
                        DictionaryIntSave0(true, (lp_key + "TimerNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = DictionaryIntLoad1(true, (lp_key + "TimerTag"), lv_b + 1).ToString();
                            DictionaryStringSave1(true, (lp_key + "TimerTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                ThreadWaitSet(true, "Key_TimerGroup" + lv_str, false);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer注册总数。必须先使用"互动T_注册Timer"才能返回指定Key里的注册总数。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key。
        /// </summary>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        /// <returns></returns>
        public static int DHD_ReturnTimerNumMax(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            // Implementation
            return lv_num;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer序号。使用"互动T_注册Timer"后使用本函数可返回Key里的注册序号，Key无元素返回0，Key有元素但对象不在里面则返回-1，Timer标签尚未注册则返回-2。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        /// <returns></returns>
        public static int DHD_ReturnTimerNum(Timer lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_i;
            string lv_tag;
            int lv_torf;
            // Automatic Variable Declarations
            const int auto_n = 1;
            int auto_i;
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_tag = DHD_ReturnTimerTag(lp_timer);
            lv_torf = -1;
            // Implementation
            for (auto_i = 1; auto_i <= auto_n; auto_i += 1)
            {
                if ((lv_tag != null))
                {
                    lv_torf = -2;
                    break;
                }
                if ((lv_num == 0))
                {
                    lv_torf = 0;
                }
                else
                {
                    if ((lv_num >= 1))
                    {
                        auto_ae = lv_num;
                        auto_var = 1;
                        for (; auto_var <= auto_ae; auto_var += 1)
                        {
                            lv_i = auto_var;
                            if ((DictionaryIntLoad1(true, (lv_str + "Tag"), lv_i).ToString() == lv_tag))
                            {
                                lv_torf = lv_i;
                                break;
                            }
                        }
                    }
                }
            }
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回序号对应Timer。使用"互动T_注册Timer"后，在参数填入注册序号可返回Timer。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_regNum"></param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        /// <returns></returns>
        public static Timer DHD_ReturnTimerFromRegNum(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = DictionaryIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return DictionaryTimerLoad0(true, ("DHD_Timer_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回句柄标签对应Timer。使用"互动T_注册Timer"后，在参数填入句柄标签（整数）可返回Timer，标签是Timer的句柄。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_tag">句柄标签</param>
        /// <returns></returns>
        public static Timer DHD_ReturnTimerFromTag(int lp_tag)
        {
            // Variable Declarations
            string lv_tag;
            // Variable Initialization
            lv_tag = lp_tag.ToString();
            // Implementation
            return DictionaryTimerLoad0(true, ("DHD_Timer_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回序号对应Timer标签句柄。使用"互动T_注册Timer"后，在参数填入注册序号可返回Timer标签（字符串）。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        /// <returns></returns>
        public static string DHD_ReturnTimerTagFromRegNum_String(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = DictionaryIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回序号对应Timer标签句柄。使用"互动T_注册Timer"后，在参数填入注册序号可返回Timer标签（整数）。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        /// <returns></returns>
        public static int DHD_ReturnTimerTagFromRegNum_Int(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = DictionaryIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return Convert.ToInt32(lv_tag);
        }

        /// <summary>
        /// 【MM_函数库】互动T_设置Timer状态。必须先"注册"获得功能库内部句柄，再使用本函数给Timer设定一个状态值，之后可用"互动T_返回Timer状态"。类型参数用以记录多个不同状态，仅当"类型"参数填Timer组ID转的Timer串时，状态值"true"和"false"是Timer的Timer组专用状态值，用于内部函数筛选Timer状态（相当于单位组单位索引是否有效），其他类型不会干扰系统内部，可随意填写。虽然注销时反向清空注册信息，但用"互动T_设定Timer状态/自定义值"创建的值需要手工填入""来排泄（非大量注销则提升内存量极小，可不管）。注：固有状态值是注册函数赋予的系统内部变量（相当于单位组单位是否活体），只能通过"互动T_注册Timer（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <param name="lp_stats">状态</param>
        public static void DHD_SetTimerState(Timer lp_timer, string lp_key, string lp_stats)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = DHD_RegTimerTagAndReturn(lp_timer);
            // Implementation
            DictionaryStringSave0(true, ("DHD_TimerState" + lv_str + "_" + lv_tag), lp_stats);
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer状态。使用"互动T_设定Timer状态"后可使用本函数，将本函数参数"类型"设为空时返回固有值。类型参数用以记录多个不同状态，仅当"类型"参数为Timer组ID转的字符串时，返回的状态值"true"和"false"是Timer的Timer组专用状态值，用于内部函数筛选Timer状态（相当于单位组单位索引是否有效）
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <returns></returns>
        public static string DHD_ReturnTimerState(Timer lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = DHD_ReturnTimerTag(lp_timer);
            lv_stats = DictionaryStringLoad0(true, ("DHD_TimerState" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动T_设置Timer自定义值。必须先"注册"获得功能库内部句柄，再使用本函数设定Timer的自定义值，之后可使用"互动T_返回Timer自定义值"，类型参数用以记录多个不同自定义值。注：固有自定义值是注册函数赋予的系统内部变量，只能通过"互动T_注册Timer（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <param name="lp_customValue">自定义值</param>
        public static void DHD_SetTimerCV(Timer lp_timer, string lp_key, string lp_customValue)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = DHD_RegTimerTagAndReturn(lp_timer);
            // Implementation
            DictionaryStringSave0(true, ("DHD_TimerCV" + lv_str + "_" + lv_tag), lp_customValue);
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer自定义值。使用"互动T_设定Timer自定义值"后可使用本函数，将本函数参数"类型"设为空时返回固有值，该参数用以记录多个不同自定义值
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <returns></returns>
        public static string DHD_ReturnTimerCV(Timer lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = DHD_ReturnTimerTag(lp_timer);
            lv_customValue = DictionaryStringLoad0(true, ("DHD_TimerCV" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer固有状态。必须先使用"互动T_注册Timer"才能返回到该值，固有状态是独一无二的标记（相当于单位组单位是否活体）
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns></returns>
        public static string DHD_ReturnTimerState_Only(Timer lp_timer)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_tag = DHD_ReturnTimerTag(lp_timer);
            lv_stats = DictionaryStringLoad0(true, ("DHD_TimerState" + "" + "_" + lv_tag));
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer固有自定义值。必须先使用"互动T_注册Timer"才能返回到该值，固有值是独一无二的标记
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns></returns>
        public static string DHD_ReturnTimerCV_Only(Timer lp_timer)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_tag = DHD_ReturnTimerTag(lp_timer);
            lv_customValue = DictionaryStringLoad0(true, ("DHD_TimerCV" + "" + "_" + lv_tag));
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动T_设置Timer的实数标记。必须先"注册"获得功能库内部句柄，再使用本函数让Timer携带一个实数值，之后可使用"互动T_返回Timer的实数标记"。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_realNumTag">实数标记</param>
        public static void DHD_SetTimerDouble(Timer lp_timer, double lp_realNumTag)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = DHD_RegTimerTagAndReturn(lp_timer);
            // Implementation
            DictionaryDoubleSave0(true, ("DHD_CDDouble_Timer_" + lv_tag), lp_realNumTag);
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer的实数标记。使用"互动T_设定Timer的实数标记"后可使用本函数。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns></returns>
        public static double DHD_ReturnTimerDouble(Timer lp_timer)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = DHD_ReturnTimerTag(lp_timer);
            // Implementation
            return DictionaryDoubleLoad0(true, ("DHD_CDDouble_Timer_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer标签句柄有效状态。将Timer视作独一无二的个体，标签是它本身，有效状态则类似"单位是否有效"，当使用"互动T_注册Timer"或"互动TG_添加Timer到Timer组"后激活Timer有效状态（值为"true"），除非使用"互动T_注册Timer（高级）"改写，否则直到注销才会摧毁
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns></returns>
        public static bool DHD_ReturnIfTimerTag(Timer lp_timer)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = DHD_ReturnTimerTag(lp_timer);
            // Implementation
            return DictionaryBoolLoad0(true, ("DHD_IfTimerTag" + "" + "_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer注册状态。使用"互动T_注册Timer"或"互动TG_添加Timer到Timer组"后可使用本函数获取注册Timer在Key中的注册状态，该状态只能注销或从Timer组中移除时清空。Timer组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        /// <returns></returns>
        public static bool DHD_ReturnIfTimerTagKey(Timer lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = DHD_ReturnTimerTag(lp_timer);
            // Implementation
            return DictionaryBoolLoad0(true, ("DHD_IfTimerTag" + lv_str + "_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动TG_根据自定义值类型将Timer组排序。根据Timer携带的自定义值类型，对指定的Timer组元素进行冒泡排序。Timer组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Timer组名称</param>
        /// <param name="lp_cVStr">自定义值类型</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void DHD_TimerGSortCV(string lp_key, string lp_cVStr, bool lp_big)
        {
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            string lv_tagValuestr;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_TimerGroup" + lv_str, true);
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = DHD_ReturnTimerTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValuestr = DHD_ReturnTimerCV((Timer)DHD_ReturnTimerFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    DictionaryIntSave1(false, "IntStackOutTag", 1, lv_tag);
                    DictionaryIntSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DictionaryIntSave1(false, "IntStackOutTag", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    DictionaryIntSave1(false, "IntStackOutTagValue", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                DictionaryIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                DictionaryIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(DHD_ReturnTimerTagFromRegNum(lv_b, lp_key))+"值"+IntToString(DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DictionaryIntSave1(false, "IntStackOutTag", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DictionaryIntSave1(false, "IntStackOutTagValue", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                DictionaryIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DictionaryIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        DictionaryIntSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DictionaryIntSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = DictionaryIntLoad1(true, (lp_key + "TimerTag"), lv_a).ToString(); //原始序号元素
                lv_tag = (int)DictionaryIntLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValuestr = DHD_ReturnTimerCV((Timer)DHD_ReturnTimerFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    DictionaryIntSave1(true, (lp_key + "TimerTag"), lv_a, lv_tag); //lv_tag放入新序号
                    //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            ThreadWaitSet(true, "Key_TimerGroup" + lv_str, false);
        }

        /// <summary>
        /// 【MM_函数库】互动TG_Timer组排序。对指定的Timer组元素进行冒泡排序（根据元素句柄）。Timer组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Timer组名称</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void DHD_TimerGSort(string lp_key, bool lp_big)
        {
            // Automatic Variable Declarations
            // Implementation
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_TimerGroup" + lv_str, true);
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = DHD_ReturnTimerTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValue = lv_tag;
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    DictionaryIntSave1(false, "IntStackOutTag", 1, lv_tag);
                    DictionaryIntSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DictionaryIntSave1(false, "IntStackOutTag", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    DictionaryIntSave1(false, "IntStackOutTagValue", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                DictionaryIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                DictionaryIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(DHD_ReturnTimerTagFromRegNum(lv_b, lp_key))+"值"+IntToString(DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DictionaryIntSave1(false, "IntStackOutTag", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DictionaryIntSave1(false, "IntStackOutTagValue", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                DictionaryIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DictionaryIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        DictionaryIntSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DictionaryIntSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = DictionaryIntLoad1(true, (lp_key + "TimerTag"), lv_a).ToString(); //原始序号元素
                lv_tag = (int)DictionaryIntLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValue = lv_tag;
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                                                                                        //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    DictionaryIntSave1(true, (lp_key + "TimerTag"), lv_a, lv_tag); //lv_tag放入新序号
                                                                                   //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            ThreadWaitSet(true, "Key_TimerGroup" + lv_str, false);
        }

        /// <summary>
        /// 【MM_函数库】互动TG_设定Timer的Timer组专用状态。给Timer组的Timer设定一个状态值（字符串），之后可用"互动T_返回Timer、互动TG_返回Timer组的Timer状态"。状态值"true"和"false"是Timer的Timer组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效），而本函数可以重设干预，影响函数"互动TG_返回Timer组元素数量（仅检索XX状态）"。与"互动T_设定Timer状态"功能相同，只是状态参数在Timer组中被固定为"Timer组变量的内部ID"。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_timerGroup"></param>
        /// <param name="lp_groupState"></param>
        public static void DHD_SetTimerGState(Timer lp_timer, string lp_timerGroup, string lp_groupState)
        {
            DHD_SetTimerState(lp_timer, lp_timerGroup, lp_groupState);
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer的Timer组专用状态。使用"互动T_设定Timer、互动TG_设定Timer组的Timer状态"后可使用本函数。与"互动T_返回Timer状态"功能相同，只是状态参数在Timer组中被固定为"Timer组变量的内部ID"。状态值"true"和"false"是Timer的Timer组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效）。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_timerGroup"></param>
        public static void DHD_ReturnTimerGState(Timer lp_timer, string lp_timerGroup)
        {
            DHD_ReturnTimerState(lp_timer, lp_timerGroup);
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer组元素序号对应元素。返回Timer组元素序号指定Timer。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static Timer DHD_ReturnTimerFromTimerGFunc(int lp_regNum, string lp_gs)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_gs + "Timer");
            lv_tag = DictionaryIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return DictionaryTimerLoad0(true, ("DHD_Timer_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer组元素总数。返回指定Timer组的元素数量。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int DHD_ReturnTimerGNumMax(string lp_gs)
        {
            return DictionaryIntLoad0(true, lp_gs + "TimerNum");
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer组元素总数（仅检测Timer组专用状态="true"）。返回指定Timer组的元素数量。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int DHD_ReturnTimerGNumMax_StateTrueFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Timer lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = DHD_ReturnTimerNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (Timer)DHD_ReturnTimerFromRegNum(lv_a, lp_gs);
                lv_b = DHD_ReturnTimerState(lv_c, lp_gs);
                if ((lv_b == "true"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer组元素总数（仅检测Timer组专用状态="false"）。返回指定Timer组的元素数量。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int DHD_ReturnTimerGNumMax_StateFalseFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Timer lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = DHD_ReturnTimerNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (Timer)DHD_ReturnTimerFromRegNum(lv_a, lp_gs);
                lv_b = DHD_ReturnTimerState(lv_c, lp_gs);
                if ((lv_b == "false"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer组元素总数（仅检测Timer组无效专用状态："false"或""）。返回指定Timer组的元素数量（false、""、null）。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int DHD_ReturnTimerGNumMax_StateUselessFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Timer lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = DHD_ReturnTimerNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (Timer)DHD_ReturnTimerFromRegNum(lv_a, lp_gs);
                lv_b = DHD_ReturnTimerState(lv_c, lp_gs);
                if (((lv_b == "false") || (lv_b == "") || (lv_b == null)))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer组元素总数（仅检测Timer组指定专用状态）。返回指定Timer组的元素数量。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_State">Timer组专用状态</param>
        /// <returns></returns>
        public static int DHD_ReturnTimerGNumMax_StateFunc_Specify(string lp_gs, string lp_State)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Timer lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = DHD_ReturnTimerNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (Timer)DHD_ReturnTimerFromRegNum(lv_a, lp_gs);
                lv_b = DHD_ReturnTimerState(lv_c, lp_gs);
                if ((lv_b == lp_State))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动TG_添加Timer到Timer组。相同Timer被认为是同一个，非高级功能不提供专用状态检查，如果Timer没有设置过Timer组专用状态，那么首次添加到Timer组不会赋予"true"（之后可通过"互动T_设定Timer状态"、"互动TG_设定Timer组的Timer状态"修改）。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void DHD_AddTimerToGroup_Simple(Timer lp_timer, string lp_gs)
        {
            DHD_RegTimer_Simple(lp_timer, lp_gs);
        }

        /// <summary>
        /// 【MM_函数库】互动TG_添加Timer到Timer组（高级）。相同Timer被认为是同一个，高级功能提供专用状态检查，如果Timer没有设置过Timer组专用状态，那么首次添加到Timer组会赋予"true"（之后可通过"互动T_设定Timer状态"、"互动TG_设定Timer组的Timer状态"修改）。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void DHD_AddTimerToGroup(Timer lp_timer, string lp_gs)
        {
            DHD_RegTimer_Simple(lp_timer, lp_gs);
            if (DictionaryStringKeyExists(true, ("DHD_TimerState" + lp_gs + "Timer_" + DHD_RegTimerTagAndReturn(lp_timer))) == false)
            {
                DictionaryStringSave0(true, ("DHD_TimerState" + lp_gs + "Timer_" + DHD_RegTimerTagAndReturn(lp_timer)), "true");
                //Console.WriteLine(lp_gs + "=>" + DHD_RegTimerTagAndReturn(lp_timer));
            }
        }

        /// <summary>
        /// 【MM_函数库】互动TG_移除Timer组中的元素。使用"互动TG_添加Timer到Timer组"后可使用本函数进行移除元素。移除使用了"互动T_移除Timer"，同一个存储区（Timer组ID）序号重排，移除时该存储区如有其他操作会排队等待。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void DHD_ClearTimerFromGroup(Timer lp_timer, string lp_gs)
        {
            DHD_RemoveTimer(lp_timer, lp_gs);
        }

        //互动TG_为Timer组中的每个序号
        //GE（星际2的Galaxy Editor）的宏让编辑器保存时自动生成脚本并整合进脚本进行格式调整，C#仅参考需自行编写
        // #AUTOVAR(vs, string) = "#PARAM(group)";//"#PARAM(group)"是与字段、变量名一致的元素组名称，宏去声明string类型名为“Auto随机编号_vs”的自动变量，然后=右侧字符
        // #AUTOVAR(ae) = DHD_ReturnTimerNumMax(#AUTOVAR(vs));//宏去声明默认int类型名为“Auto随机编号_ae”的自动变量，然后=右侧字符
        // #INITAUTOVAR(ai,increment)//宏去声明int类型名为“Auto随机编号_ai”的自动变量，用于下面for循环增量（increment是传入参数）
        // #PARAM(var) = #PARAM(s);//#PARAM(var)是传进来的参数，用作“当前被挑选到的元素”（任意变量-整数 lp_var）， #PARAM(s)是传进来的参数用作"开始"（int lp_s）
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #PARAM(var) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #PARAM(var) >= #AUTOVAR(ae)) ) ; #PARAM(var) += #AUTOVAR(ai) ) {
        //     #SUBFUNCS(actions)//代表用户GUI填写的所有动作
        // }

        /// <summary>
        /// 【MM_函数库】互动TG_为Timer组中的每个序号。每次挑选的元素序号会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素序号，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void DHD_ForEachTimerNumFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            int lv_ae = DHD_ReturnTimerNumMax(lp_gs);
            int lv_var = lp_start;
            int lv_ai = lp_increment;
            for (; (lv_ai >= 0 && lv_var <= lv_ae) || (lv_ai < 0 && lv_var >= lv_ae); lv_var += lv_ai)
            {
                lp_funcref(lv_var);//用户填写的所有动作
            }
        }

        //互动TG_为Timer组中的每个元素
        // #AUTOVAR(vs, string) = "#PARAM(group)";
        // #AUTOVAR(ae) = DHD_ReturnTimerNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= #PARAM(s);
        // #INITAUTOVAR(ai,increment)
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     DictionarySave(false, "TimerGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)), DHD_ReturnTimerFromRegNum(#AUTOVAR(va),#AUTOVAR(vs)));
        // }
        // #AUTOVAR(va)= #PARAM(s);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #PARAM(var) = DictionaryLoad(false, "TimerGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)));
        //     #SUBFUNCS(actions)
        // }

        /// <summary>
        /// 【MM_函数库】互动TG_为Timer组中的每个元素。每次挑选的元素会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void DHD_ForEachTimerFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            string lv_vs = lp_gs;
            int lv_ae = DHD_ReturnTimerNumMax(lv_vs);
            int lv_va = lp_start;
            int lv_ai = lp_increment;
            Timer lv_timer;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                DictionaryTimerSave0(false, "TimerGFor" + lv_vs + lv_va.ToString(), (Timer)DHD_ReturnTimerFromRegNum(lv_va, lv_vs));
            }
            lv_va = lp_start;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                lv_timer = (Timer)DictionaryTimerLoad0(false, "TimerGFor" + lv_vs + lv_va.ToString());
                lp_funcref(lv_timer);//用户填写的所有动作
            }
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer组中随机元素。返回指定Timer组中的随机Timer。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static Timer DHD_ReturnRandomTimerFromTimerGFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_num;
            int lv_a;
            Timer lv_c = null;
            // Variable Initialization
            lv_num = DHD_ReturnTimerNumMax(lp_gs);
            // Implementation
            if ((lv_num >= 1))
            {
                lv_a = RandomInt(1, lv_num);
                lv_c = (Timer)DHD_ReturnTimerFromRegNum(lv_a, lp_gs);
            }
            return lv_c;
        }

        //互动TG_添加Timer组到Timer组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = DHD_ReturnTimerNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = DHD_ReturnTimerFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     DHD_AddTimerToGroup(#AUTOVAR(var), #AUTOVAR(vsb));
        // }


        /// <summary>
        /// 【MM_函数库】互动TG_添加Timer组到Timer组。添加一个Timer组A的元素到另一个Timer组B，相同Timer被认为是同一个。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void DHD_AddTimerGToTimerG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = DHD_ReturnTimerNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            Timer lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = (Timer)DHD_ReturnTimerFromRegNum(lv_va, lv_vsa);
                DHD_AddTimerToGroup(lv_var, lv_vsb);
            }
        }

        //互动TG_从Timer组移除Timer组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = DHD_ReturnTimerNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = DHD_ReturnTimerFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     DHD_RemoveTimer(#AUTOVAR(var), #AUTOVAR(vsb));
        // }

        /// <summary>
        /// 【MM_函数库】互动TG_从Timer组移除Timer组。将Timer组A的元素从Timer组B中移除，相同Timer被认为是同一个。移除使用了"互动T_移除Timer"，同一个存储区（Timer组ID）序号重排，移除时该存储区如有其他操作会排队等待。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void DHD_ClearTimerGFromTimerG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = DHD_ReturnTimerNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            Timer lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = (Timer)DHD_ReturnTimerFromRegNum(lv_va, lv_vsa);
                DHD_RemoveTimer(lv_var, lv_vsb);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动TG_移除Timer组全部元素。将Timer组（Key区）存储的元素全部移除，相同Timer被认为是同一个。移除时同一个存储区（Timer组ID）序号不进行重排，但该存储区如有其他操作会排队等待。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Timer组名称</param>
        public static void DHD_RemoveTimerGAll(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag = "";
            int lv_a;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            // Implementation
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_TimerGroup" + lv_str, true);
            for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
            {
                lv_tag = DictionaryIntLoad1(true, (lp_key + "TimerTag"), lv_a).ToString();
                lv_num -= 1;
                DictionaryBoolClear0(true, "DHD_IfTimerTag" + lv_str + "_" + lv_tag);
                DictionaryStringClear0(true, "DHD_TimerCV" + lv_str + "_" + lv_tag);
                DictionaryStringClear0(true, "DHD_TimerState" + lv_str + "_" + lv_tag);
                DictionaryIntSave0(true, (lp_key + "TimerNum"), lv_num);
            }
            ThreadWaitSet(true, "Key_TimerGroup" + lv_str, false);
        }

        //--------------------------------------------------------------------------------------------------
        // 计时器组End
        //--------------------------------------------------------------------------------------------------

        #endregion

        #region 字符串

        //提示：尽可能使用对口类型，以防值类型与引用类型发生转换时拆装箱降低性能

        //--------------------------------------------------------------------------------------------------
        // 字符串组Start
        //--------------------------------------------------------------------------------------------------

        /// <summary>
        /// 【MM_函数库】互动S_注册String标签句柄并返回。为String自动设置新的标签句柄，重复时会返回已注册的String标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns>返回一个String的已注册标签</returns>
        private static int DHD_RegStringTagAndReturn_Int(string lp_timer)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)DictionaryIntLoad0(true, "DHD_StringJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                DictionaryIntSave0(true, "DHD_StringJBNum", lv_j);
                DictionaryStringSave0(true, ("DHD_String_" + lv_j.ToString()), lp_timer);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if (DictionaryStringLoad0(true, ("DHD_String_" + lv_j.ToString())) == lp_timer)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            DictionaryIntSave0(true, "DHD_StringJBNum", lv_j);
                            DictionaryStringSave0(true, ("DHD_String_" + lv_j.ToString()), lp_timer);
                        }
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String已注册标签句柄
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns>返回一个String的已注册标签，错误返回0</returns>
        public static int DHD_ReturnStringTag_Int(string lp_timer)
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)DictionaryIntLoad0(true, "DHD_StringJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if (DictionaryStringLoad0(true, "DHD_String_" + lv_j.ToString()) == lp_timer)
                {
                    break;
                }
                else
                {
                    if ((lv_j == lv_jBNum))
                    {
                        lv_j = 0;
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动S_注册String标签句柄并返回。为String自动设置新的标签句柄，重复时会返回已注册的String标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns>返回一个String的已注册标签</returns>
        private static string DHD_RegStringTagAndReturn(string lp_timer)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)DictionaryIntLoad0(true, "DHD_StringJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                DictionaryIntSave0(true, "DHD_StringJBNum", lv_j);
                DictionaryStringSave0(true, ("DHD_String_" + lv_j.ToString()), lp_timer);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if (DictionaryStringLoad0(true, "DHD_String_" + lv_j.ToString()) == lp_timer)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            DictionaryIntSave0(true, "DHD_StringJBNum", lv_j);
                            DictionaryStringSave0(true, ("DHD_String_" + lv_j.ToString()), lp_timer);
                        }
                    }
                }
            }
            lv_tag = lv_j.ToString();
            //Console.WriteLine(("Tag：" + lv_tag));
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String已注册标签句柄
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns>返回一个String的已注册标签，错误返回""</returns>
        public static string DHD_ReturnStringTag(string lp_timer)
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag = "";
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)DictionaryIntLoad0(true, "DHD_StringJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if (DictionaryStringLoad0(true, "DHD_String_" + lv_j.ToString()) == lp_timer)
                {
                    lv_tag = lv_j.ToString();
                    break;
                }
            }
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动S_注册String(高级)。在指定Key存入String，固有状态、自定义值是String独一无二的标志（本函数重复注册会刷新），之后可用互动S_"返回String注册总数"、"返回String序号"、"返回序号对应String"、"返回序号对应String标签"、"返回String自定义值"。String组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将String组转为Key。首次注册时固有状态为true（相当于单位组单位活体），如需另外设置多个标记可使用"互动S_设定String状态/自定义值"
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        /// <param name="lp_inherentStats">固有状态</param>
        /// <param name="lp_inherentCustomValue">固有自定义值</param>
        public static void DHD_RegString(string lp_timer, string lp_key, string lp_inherentStats, string lp_inherentCustomValue)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;

            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_jBNum = (int)DictionaryIntLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = DHD_RegStringTagAndReturn(lp_timer);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                DictionaryIntSave0(true, (lv_str + "Num"), lv_i);
                DictionaryStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                DictionaryBoolSave0(true, (("DHD_IfStringTag" + "") + "_" + lv_tagStr), true);
                DictionaryBoolSave1(true, ("DHD_IfStringTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if (DictionaryIntLoad1(true, lv_str + "Tag", lv_i).ToString() == lv_tagStr)
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                DictionaryIntSave0(true, (lv_str + "Num"), lv_i);
                                DictionaryStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                DictionaryBoolSave0(true, (("DHD_IfStringTag" + "") + "_" + lv_tagStr), true);
                                DictionaryBoolSave1(true, ("DHD_IfStringTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            DictionaryStringSave0(true, ("DHD_StringState" + "" + "_" + lv_tagStr), lp_inherentStats);
            DictionaryStringSave0(true, ("DHD_StringCV" + "" + "_" + lv_tagStr), lp_inherentCustomValue);
        }

        /// <summary>
        /// 【MM_函数库】互动S_注册String。在指定Key存入String，固有状态、自定义值是String独一无二的标志（本函数重复注册不会刷新），之后可用互动S_"返回String注册总数"、"返回String序号"、"返回序号对应String"、"返回String自定义值"。String组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将String组转为Key。首次注册时固有状态为true（相当于单位组单位活体），之后只能通过"互动S_注册String（高级）"改写，如需另外设置多个标记可使用"互动S_设定String状态/自定义值"
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        public static void DHD_RegString_Simple(string lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;

            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_jBNum = (int)DictionaryIntLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = DHD_RegStringTagAndReturn(lp_timer);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                DictionaryIntSave0(true, (lv_str + "Num"), lv_i);
                DictionaryStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                DictionaryBoolSave0(true, (("DHD_IfStringTag" + "") + "_" + lv_tagStr), true);
                DictionaryBoolSave1(true, ("DHD_IfStringTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if (DictionaryIntLoad1(true, lv_str + "Tag", lv_i).ToString() == lv_tagStr)
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                DictionaryIntSave0(true, (lv_str + "Num"), lv_i);
                                DictionaryStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                DictionaryBoolSave0(true, (("DHD_IfStringTag" + "") + "_" + lv_tagStr), true);
                                DictionaryBoolSave1(true, ("DHD_IfStringTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            if ((DictionaryBoolKeyExists(true, ("DHD_String" + "State" + "_" + lv_tag.ToString())) == false))
            {
                DictionaryStringSave1(true, (("DHD_String" + "State")), lv_tag, "true");
            }
        }

        /// <summary>
        /// 【MM_函数库】互动S_注销String。用"互动S_注册String"到Key，之后可用本函数彻底摧毁注册信息并将序号重排（包括String标签有效状态、固有状态及自定义值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动S_设定String状态"让String状态失效（类似单位组的单位活体状态）。String组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将String组转为Key。本函数无法摧毁用"互动S_设定String状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填String组变量ID时会清空String组专用状态
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        public static void DHD_DestroyString(string lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag;
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_tag = DHD_ReturnStringTag(lp_timer);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                ThreadWaitSet(true, "Key_StringGroup" + lv_str, true);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((DictionaryIntLoad1(true, (lp_key + "StringTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        DictionaryBoolClear0(true, "DHD_IfStringTag_" + lv_tag);
                        DictionaryBoolClear0(true, "DHD_IfStringTag" + lv_str + "_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_String_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_StringCV_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_StringState_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_StringCV" + lv_str + "_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_StringState" + lv_str + "_" + lv_tag);
                        DictionaryIntSave0(true, (lp_key + "StringNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = DictionaryIntLoad1(true, (lp_key + "StringTag"), lv_b + 1).ToString();
                            DictionaryStringSave1(true, (lp_key + "StringTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                ThreadWaitSet(true, "Key_StringGroup" + lv_str, false);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动S_移除String。用"互动S_注册String"到Key，之后可用本函数仅摧毁Key区注册的信息并将序号重排，用于String组或多个键区仅移除String（保留String标签有效状态、固有值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动S_设定String状态"让String状态失效（类似单位组的单位活体状态）。String组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将String组转为Key。本函数无法摧毁用"互动S_设定String状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填String组变量ID时会清空String组专用状态
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        public static void DHD_RemoveString(string lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag;
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_tag = DHD_ReturnStringTag(lp_timer);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                ThreadWaitSet(true, "Key_StringGroup" + lv_str, true);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((DictionaryIntLoad1(true, (lp_key + "StringTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        DictionaryBoolClear0(true, "DHD_IfStringTag" + lv_str + "_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_StringCV" + lv_str + "_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_StringState" + lv_str + "_" + lv_tag);
                        DictionaryIntSave0(true, (lp_key + "StringNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = DictionaryIntLoad1(true, (lp_key + "StringTag"), lv_b + 1).ToString();
                            DictionaryStringSave1(true, (lp_key + "StringTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                ThreadWaitSet(true, "Key_StringGroup" + lv_str, false);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String注册总数。必须先使用"互动S_注册String"才能返回指定Key里的注册总数。String组使用时，可用"获取变量的内部名称"将String组转为Key。
        /// </summary>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        /// <returns></returns>
        public static int DHD_ReturnStringNumMax(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            // Implementation
            return lv_num;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String序号。使用"互动S_注册String"后使用本函数可返回Key里的注册序号，Key无元素返回0，Key有元素但对象不在里面则返回-1，String标签尚未注册则返回-2。String组使用时，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        /// <returns></returns>
        public static int DHD_ReturnStringNum(string lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_i;
            string lv_tag;
            int lv_torf;
            // Automatic Variable Declarations
            const int auto_n = 1;
            int auto_i;
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_tag = DHD_ReturnStringTag(lp_timer);
            lv_torf = -1;
            // Implementation
            for (auto_i = 1; auto_i <= auto_n; auto_i += 1)
            {
                if ((lv_tag != null))
                {
                    lv_torf = -2;
                    break;
                }
                if ((lv_num == 0))
                {
                    lv_torf = 0;
                }
                else
                {
                    if ((lv_num >= 1))
                    {
                        auto_ae = lv_num;
                        auto_var = 1;
                        for (; auto_var <= auto_ae; auto_var += 1)
                        {
                            lv_i = auto_var;
                            if ((DictionaryIntLoad1(true, (lv_str + "Tag"), lv_i).ToString() == lv_tag))
                            {
                                lv_torf = lv_i;
                                break;
                            }
                        }
                    }
                }
            }
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回序号对应String。使用"互动S_注册String"后，在参数填入注册序号可返回String。String组使用时，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_regNum"></param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        /// <returns></returns>
        public static string DHD_ReturnStringFromRegNum(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = DictionaryIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return DictionaryStringLoad0(true, ("DHD_String_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回句柄标签对应String。使用"互动S_注册String"后，在参数填入句柄标签（整数）可返回String，标签是String的句柄。String组使用时，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_tag">句柄标签</param>
        /// <returns></returns>
        public static string DHD_ReturnStringFromTag(int lp_tag)
        {
            // Variable Declarations
            string lv_tag;
            // Variable Initialization
            lv_tag = lp_tag.ToString();
            // Implementation
            return DictionaryStringLoad0(true, ("DHD_String_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回序号对应String标签句柄。使用"互动S_注册String"后，在参数填入注册序号可返回String标签（字符串）。String组使用时，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        /// <returns></returns>
        public static string DHD_ReturnStringTagFromRegNum_String(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = DictionaryIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回序号对应String标签句柄。使用"互动S_注册String"后，在参数填入注册序号可返回String标签（整数）。String组使用时，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        /// <returns></returns>
        public static int DHD_ReturnStringTagFromRegNum_Int(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = DictionaryIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return Convert.ToInt32(lv_tag);
        }

        /// <summary>
        /// 【MM_函数库】互动S_设置String状态。必须先"注册"获得功能库内部句柄，再使用本函数给String设定一个状态值，之后可用"互动S_返回String状态"。类型参数用以记录多个不同状态，仅当"类型"参数填String组ID转的String串时，状态值"true"和"false"是String的String组专用状态值，用于内部函数筛选String状态（相当于单位组单位索引是否有效），其他类型不会干扰系统内部，可随意填写。虽然注销时反向清空注册信息，但用"互动S_设定String状态/自定义值"创建的值需要手工填入""来排泄（非大量注销则提升内存量极小，可不管）。注：固有状态值是注册函数赋予的系统内部变量（相当于单位组单位是否活体），只能通过"互动S_注册String（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <param name="lp_stats">状态</param>
        public static void DHD_SetStringState(string lp_timer, string lp_key, string lp_stats)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = DHD_RegStringTagAndReturn(lp_timer);
            // Implementation
            DictionaryStringSave0(true, ("DHD_StringState" + lv_str + "_" + lv_tag), lp_stats);
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String状态。使用"互动S_设定String状态"后可使用本函数，将本函数参数"类型"设为空时返回固有值。类型参数用以记录多个不同状态，仅当"类型"参数为String组ID转的字符串时，返回的状态值"true"和"false"是String的String组专用状态值，用于内部函数筛选String状态（相当于单位组单位索引是否有效）
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <returns></returns>
        public static string DHD_ReturnStringState(string lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = DHD_ReturnStringTag(lp_timer);
            lv_stats = DictionaryStringLoad0(true, ("DHD_StringState" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动S_设置String自定义值。必须先"注册"获得功能库内部句柄，再使用本函数设定String的自定义值，之后可使用"互动S_返回String自定义值"，类型参数用以记录多个不同自定义值。注：固有自定义值是注册函数赋予的系统内部变量，只能通过"互动S_注册String（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <param name="lp_customValue">自定义值</param>
        public static void DHD_SetStringCV(string lp_timer, string lp_key, string lp_customValue)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = DHD_RegStringTagAndReturn(lp_timer);
            // Implementation
            DictionaryStringSave0(true, ("DHD_StringCV" + lv_str + "_" + lv_tag), lp_customValue);
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String自定义值。使用"互动S_设定String自定义值"后可使用本函数，将本函数参数"类型"设为空时返回固有值，该参数用以记录多个不同自定义值
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <returns></returns>
        public static string DHD_ReturnStringCV(string lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = DHD_ReturnStringTag(lp_timer);
            lv_customValue = DictionaryStringLoad0(true, ("DHD_StringCV" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String固有状态。必须先使用"互动S_注册String"才能返回到该值，固有状态是独一无二的标记（相当于单位组单位是否活体）
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns></returns>
        public static string DHD_ReturnStringState_Only(string lp_timer)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_tag = DHD_ReturnStringTag(lp_timer);
            lv_stats = DictionaryStringLoad0(true, ("DHD_StringState" + "" + "_" + lv_tag));
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String固有自定义值。必须先使用"互动S_注册String"才能返回到该值，固有值是独一无二的标记
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns></returns>
        public static string DHD_ReturnStringCV_Only(string lp_timer)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_tag = DHD_ReturnStringTag(lp_timer);
            lv_customValue = DictionaryStringLoad0(true, ("DHD_StringCV" + "" + "_" + lv_tag));
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动S_设置String的实数标记。必须先"注册"获得功能库内部句柄，再使用本函数让String携带一个实数值，之后可使用"互动S_返回String的实数标记"。String组使用时，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_realNumTag">实数标记</param>
        public static void DHD_SetStringDouble(string lp_timer, double lp_realNumTag)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = DHD_RegStringTagAndReturn(lp_timer);
            // Implementation
            DictionaryDoubleSave0(true, ("DHD_CDDouble_String_" + lv_tag), lp_realNumTag);
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String的实数标记。使用"互动S_设定String的实数标记"后可使用本函数。String组使用时，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns></returns>
        public static double DHD_ReturnStringDouble(string lp_timer)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = DHD_ReturnStringTag(lp_timer);
            // Implementation
            return DictionaryDoubleLoad0(true, ("DHD_CDDouble_String_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String标签句柄有效状态。将String视作独一无二的个体，标签是它本身，有效状态则类似"单位是否有效"，当使用"互动S_注册String"或"互动SG_添加String到String组"后激活String有效状态（值为"true"），除非使用"互动S_注册String（高级）"改写，否则直到注销才会摧毁
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns></returns>
        public static bool DHD_ReturnIfStringTag(string lp_timer)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = DHD_ReturnStringTag(lp_timer);
            // Implementation
            return DictionaryBoolLoad0(true, ("DHD_IfStringTag" + "" + "_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String注册状态。使用"互动S_注册String"或"互动SG_添加String到String组"后可使用本函数获取注册String在Key中的注册状态，该状态只能注销或从String组中移除时清空。String组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        /// <returns></returns>
        public static bool DHD_ReturnIfStringTagKey(string lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = DHD_ReturnStringTag(lp_timer);
            // Implementation
            return DictionaryBoolLoad0(true, ("DHD_IfStringTag" + lv_str + "_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动SG_根据自定义值类型将String组排序。根据String携带的自定义值类型，对指定的String组元素进行冒泡排序。String组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填String组名称</param>
        /// <param name="lp_cVStr">自定义值类型</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void DHD_StringGSortCV(string lp_key, string lp_cVStr, bool lp_big)
        {
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            string lv_tagValuestr;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "String");
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_StringGroup" + lv_str, true);
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = DHD_ReturnStringTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValuestr = DHD_ReturnStringCV((string)DHD_ReturnStringFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    DictionaryIntSave1(false, "IntStackOutTag", 1, lv_tag);
                    DictionaryIntSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DictionaryIntSave1(false, "IntStackOutTag", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    DictionaryIntSave1(false, "IntStackOutTagValue", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                DictionaryIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                DictionaryIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(DHD_ReturnStringTagFromRegNum(lv_b, lp_key))+"值"+IntToString(DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DictionaryIntSave1(false, "IntStackOutTag", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DictionaryIntSave1(false, "IntStackOutTagValue", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                DictionaryIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DictionaryIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        DictionaryIntSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DictionaryIntSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = DictionaryIntLoad1(true, (lp_key + "StringTag"), lv_a).ToString(); //原始序号元素
                lv_tag = (int)DictionaryIntLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValuestr = DHD_ReturnStringCV((string)DHD_ReturnStringFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    DictionaryIntSave1(true, (lp_key + "StringTag"), lv_a, lv_tag); //lv_tag放入新序号
                    //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            ThreadWaitSet(true, "Key_StringGroup" + lv_str, false);
        }

        /// <summary>
        /// 【MM_函数库】互动SG_String组排序。对指定的String组元素进行冒泡排序（根据元素句柄）。String组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填String组名称</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void DHD_StringGSort(string lp_key, bool lp_big)
        {
            // Automatic Variable Declarations
            // Implementation
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "String");
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_StringGroup" + lv_str, true);
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = DHD_ReturnStringTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValue = lv_tag;
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    DictionaryIntSave1(false, "IntStackOutTag", 1, lv_tag);
                    DictionaryIntSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DictionaryIntSave1(false, "IntStackOutTag", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    DictionaryIntSave1(false, "IntStackOutTagValue", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                DictionaryIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                DictionaryIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(DHD_ReturnStringTagFromRegNum(lv_b, lp_key))+"值"+IntToString(DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DictionaryIntSave1(false, "IntStackOutTag", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DictionaryIntSave1(false, "IntStackOutTagValue", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                DictionaryIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DictionaryIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        DictionaryIntSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DictionaryIntSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = DictionaryIntLoad1(true, (lp_key + "StringTag"), lv_a).ToString(); //原始序号元素
                lv_tag = (int)DictionaryIntLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValue = lv_tag;
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                                                                                        //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    DictionaryIntSave1(true, (lp_key + "StringTag"), lv_a, lv_tag); //lv_tag放入新序号
                                                                                    //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            ThreadWaitSet(true, "Key_StringGroup" + lv_str, false);
        }

        /// <summary>
        /// 【MM_函数库】互动SG_设定String的String组专用状态。给String组的String设定一个状态值（字符串），之后可用"互动S_返回String、互动SG_返回String组的String状态"。状态值"true"和"false"是String的String组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效），而本函数可以重设干预，影响函数"互动SG_返回String组元素数量（仅检索XX状态）"。与"互动S_设定String状态"功能相同，只是状态参数在String组中被固定为"String组变量的内部ID"。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_timerGroup"></param>
        /// <param name="lp_groupState"></param>
        public static void DHD_SetStringGState(string lp_timer, string lp_timerGroup, string lp_groupState)
        {
            DHD_SetStringState(lp_timer, lp_timerGroup, lp_groupState);
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String的String组专用状态。使用"互动S_设定String、互动SG_设定String组的String状态"后可使用本函数。与"互动S_返回String状态"功能相同，只是状态参数在String组中被固定为"String组变量的内部ID"。状态值"true"和"false"是String的String组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效）。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_timerGroup"></param>
        public static void DHD_ReturnStringGState(string lp_timer, string lp_timerGroup)
        {
            DHD_ReturnStringState(lp_timer, lp_timerGroup);
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String组元素序号对应元素。返回String组元素序号指定String。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static string DHD_ReturnStringFromStringGFunc(int lp_regNum, string lp_gs)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_gs + "String");
            lv_tag = DictionaryIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return DictionaryStringLoad0(true, ("DHD_String_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String组元素总数。返回指定String组的元素数量。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int DHD_ReturnStringGNumMax(string lp_gs)
        {
            return DictionaryIntLoad0(true, lp_gs + "StringNum");
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String组元素总数（仅检测String组专用状态="true"）。返回指定String组的元素数量。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int DHD_ReturnStringGNumMax_StateTrueFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            string lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = DHD_ReturnStringNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (string)DHD_ReturnStringFromRegNum(lv_a, lp_gs);
                lv_b = DHD_ReturnStringState(lv_c, lp_gs);
                if ((lv_b == "true"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String组元素总数（仅检测String组专用状态="false"）。返回指定String组的元素数量。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int DHD_ReturnStringGNumMax_StateFalseFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            string lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = DHD_ReturnStringNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (string)DHD_ReturnStringFromRegNum(lv_a, lp_gs);
                lv_b = DHD_ReturnStringState(lv_c, lp_gs);
                if ((lv_b == "false"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String组元素总数（仅检测String组无效专用状态："false"或""）。返回指定String组的元素数量（false、""、null）。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int DHD_ReturnStringGNumMax_StateUselessFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            string lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = DHD_ReturnStringNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (string)DHD_ReturnStringFromRegNum(lv_a, lp_gs);
                lv_b = DHD_ReturnStringState(lv_c, lp_gs);
                if (((lv_b == "false") || (lv_b == "") || (lv_b == null)))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String组元素总数（仅检测String组指定专用状态）。返回指定String组的元素数量。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_State">String组专用状态</param>
        /// <returns></returns>
        public static int DHD_ReturnStringGNumMax_StateFunc_Specify(string lp_gs, string lp_State)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            string lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = DHD_ReturnStringNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (string)DHD_ReturnStringFromRegNum(lv_a, lp_gs);
                lv_b = DHD_ReturnStringState(lv_c, lp_gs);
                if ((lv_b == lp_State))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动SG_添加String到String组。相同String被认为是同一个，非高级功能不提供专用状态检查，如果String没有设置过String组专用状态，那么首次添加到String组不会赋予"true"（之后可通过"互动S_设定String状态"、"互动SG_设定String组的String状态"修改）。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void DHD_AddStringToGroup_Simple(string lp_timer, string lp_gs)
        {
            DHD_RegString_Simple(lp_timer, lp_gs);
        }

        /// <summary>
        /// 【MM_函数库】互动SG_添加String到String组（高级）。相同String被认为是同一个，高级功能提供专用状态检查，如果String没有设置过String组专用状态，那么首次添加到String组会赋予"true"（之后可通过"互动S_设定String状态"、"互动SG_设定String组的String状态"修改）。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void DHD_AddStringToGroup(string lp_timer, string lp_gs)
        {
            DHD_RegString_Simple(lp_timer, lp_gs);
            if (DictionaryStringKeyExists(true, ("DHD_StringState" + lp_gs + "String_" + DHD_RegStringTagAndReturn(lp_timer))) == false)
            {
                DictionaryStringSave0(true, ("DHD_StringState" + lp_gs + "String_" + DHD_RegStringTagAndReturn(lp_timer)), "true");
                //Console.WriteLine(lp_gs + "=>" + DHD_RegStringTagAndReturn(lp_timer));
            }
        }

        /// <summary>
        /// 【MM_函数库】互动SG_移除String组中的元素。使用"互动SG_添加String到String组"后可使用本函数进行移除元素。移除使用了"互动S_移除String"，同一个存储区（String组ID）序号重排，移除时该存储区如有其他操作会排队等待。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void DHD_ClearStringFromGroup(string lp_timer, string lp_gs)
        {
            DHD_RemoveString(lp_timer, lp_gs);
        }

        //互动SG_为String组中的每个序号
        //GE（星际2的Galaxy Editor）的宏让编辑器保存时自动生成脚本并整合进脚本进行格式调整，C#仅参考需自行编写
        // #AUTOVAR(vs, string) = "#PARAM(group)";//"#PARAM(group)"是与字段、变量名一致的元素组名称，宏去声明string类型名为“Auto随机编号_vs”的自动变量，然后=右侧字符
        // #AUTOVAR(ae) = DHD_ReturnStringNumMax(#AUTOVAR(vs));//宏去声明默认int类型名为“Auto随机编号_ae”的自动变量，然后=右侧字符
        // #INITAUTOVAR(ai,increment)//宏去声明int类型名为“Auto随机编号_ai”的自动变量，用于下面for循环增量（increment是传入参数）
        // #PARAM(var) = #PARAM(s);//#PARAM(var)是传进来的参数，用作“当前被挑选到的元素”（任意变量-整数 lp_var）， #PARAM(s)是传进来的参数用作"开始"（int lp_s）
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #PARAM(var) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #PARAM(var) >= #AUTOVAR(ae)) ) ; #PARAM(var) += #AUTOVAR(ai) ) {
        //     #SUBFUNCS(actions)//代表用户GUI填写的所有动作
        // }

        /// <summary>
        /// 【MM_函数库】互动SG_为String组中的每个序号。每次挑选的元素序号会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素序号，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void DHD_ForEachStringNumFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            int lv_ae = DHD_ReturnStringNumMax(lp_gs);
            int lv_var = lp_start;
            int lv_ai = lp_increment;
            for (; (lv_ai >= 0 && lv_var <= lv_ae) || (lv_ai < 0 && lv_var >= lv_ae); lv_var += lv_ai)
            {
                lp_funcref(lv_var);//用户填写的所有动作
            }
        }

        //互动SG_为String组中的每个元素
        // #AUTOVAR(vs, string) = "#PARAM(group)";
        // #AUTOVAR(ae) = DHD_ReturnStringNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= #PARAM(s);
        // #INITAUTOVAR(ai,increment)
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     DictionarySave(false, "StringGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)), DHD_ReturnStringFromRegNum(#AUTOVAR(va),#AUTOVAR(vs)));
        // }
        // #AUTOVAR(va)= #PARAM(s);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #PARAM(var) = DictionaryLoad(false, "StringGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)));
        //     #SUBFUNCS(actions)
        // }

        /// <summary>
        /// 【MM_函数库】互动SG_为String组中的每个元素。每次挑选的元素会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void DHD_ForEachStringFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            string lv_vs = lp_gs;
            int lv_ae = DHD_ReturnStringNumMax(lv_vs);
            int lv_va = lp_start;
            int lv_ai = lp_increment;
            string lv_timer;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                DictionaryStringSave0(false, "StringGFor" + lv_vs + lv_va.ToString(), (string)DHD_ReturnStringFromRegNum(lv_va, lv_vs));
            }
            lv_va = lp_start;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                lv_timer = (string)DictionaryStringLoad0(false, "StringGFor" + lv_vs + lv_va.ToString());
                lp_funcref(lv_timer);//用户填写的所有动作
            }
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String组中随机元素。返回指定String组中的随机String。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static string DHD_ReturnRandomStringFromStringGFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_num;
            int lv_a;
            string lv_c = null;
            // Variable Initialization
            lv_num = DHD_ReturnStringNumMax(lp_gs);
            // Implementation
            if ((lv_num >= 1))
            {
                lv_a = RandomInt(1, lv_num);
                lv_c = (string)DHD_ReturnStringFromRegNum(lv_a, lp_gs);
            }
            return lv_c;
        }

        //互动SG_添加String组到String组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = DHD_ReturnStringNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = DHD_ReturnStringFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     DHD_AddStringToGroup(#AUTOVAR(var), #AUTOVAR(vsb));
        // }


        /// <summary>
        /// 【MM_函数库】互动SG_添加String组到String组。添加一个String组A的元素到另一个String组B，相同String被认为是同一个。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void DHD_AddStringGToStringG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = DHD_ReturnStringNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            string lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = (string)DHD_ReturnStringFromRegNum(lv_va, lv_vsa);
                DHD_AddStringToGroup(lv_var, lv_vsb);
            }
        }

        //互动SG_从String组移除String组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = DHD_ReturnStringNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = DHD_ReturnStringFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     DHD_RemoveString(#AUTOVAR(var), #AUTOVAR(vsb));
        // }

        /// <summary>
        /// 【MM_函数库】互动SG_从String组移除String组。将String组A的元素从String组B中移除，相同String被认为是同一个。移除使用了"互动S_移除String"，同一个存储区（String组ID）序号重排，移除时该存储区如有其他操作会排队等待。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void DHD_ClearStringGFromStringG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = DHD_ReturnStringNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            string lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = (string)DHD_ReturnStringFromRegNum(lv_va, lv_vsa);
                DHD_RemoveString(lv_var, lv_vsb);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动SG_移除String组全部元素。将String组（Key区）存储的元素全部移除，相同String被认为是同一个。移除时同一个存储区（String组ID）序号不进行重排，但该存储区如有其他操作会排队等待。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_key">存储键区，默认填String组名称</param>
        public static void DHD_RemoveStringGAll(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag = "";
            int lv_a;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            // Implementation
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_StringGroup" + lv_str, true);
            for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
            {
                lv_tag = DictionaryIntLoad1(true, (lp_key + "StringTag"), lv_a).ToString();
                lv_num -= 1;
                DictionaryBoolClear0(true, "DHD_IfStringTag" + lv_str + "_" + lv_tag);
                DictionaryStringClear0(true, "DHD_StringCV" + lv_str + "_" + lv_tag);
                DictionaryStringClear0(true, "DHD_StringState" + lv_str + "_" + lv_tag);
                DictionaryIntSave0(true, (lp_key + "StringNum"), lv_num);
            }
            ThreadWaitSet(true, "Key_StringGroup" + lv_str, false);
        }

        //--------------------------------------------------------------------------------------------------
        // 字符串组End
        //--------------------------------------------------------------------------------------------------

        #endregion

        #region 数字

        //提示：尽可能使用对口类型，以防值类型与引用类型发生转换时拆装箱降低性能

        //--------------------------------------------------------------------------------------------------
        // 数字组Start
        //--------------------------------------------------------------------------------------------------

        /// <summary>
        /// 【MM_函数库】互动I_注册Int标签句柄并返回。为Int自动设置新的标签句柄，重复时会返回已注册的Int标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns>返回一个Int的已注册标签</returns>
        private static int DHD_RegIntTagAndReturn_Int(int lp_vector)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)DictionaryIntLoad0(true, "DHD_IntJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                DictionaryIntSave0(true, "DHD_IntJBNum", lv_j);
                DictionaryIntSave0(true, ("DHD_Int_" + lv_j.ToString()), lp_vector);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if (DictionaryIntLoad0(true, ("DHD_Int_" + lv_j.ToString())) == lp_vector)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            DictionaryIntSave0(true, "DHD_IntJBNum", lv_j);
                            DictionaryIntSave0(true, ("DHD_Int_" + lv_j.ToString()), lp_vector);
                        }
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Int已注册标签句柄
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns>返回一个Int的已注册标签，错误返回0</returns>
        public static int DHD_ReturnIntTag_Int(int lp_vector)
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)DictionaryIntLoad0(true, "DHD_IntJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if (DictionaryIntLoad0(true, "DHD_Int_" + lv_j.ToString()) == lp_vector)
                {
                    break;
                }
                else
                {
                    if ((lv_j == lv_jBNum))
                    {
                        lv_j = 0;
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动I_注册Int标签句柄并返回。为Int自动设置新的标签句柄，重复时会返回已注册的Int标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns>返回一个Int的已注册标签</returns>
        private static string DHD_RegIntTagAndReturn(int lp_vector)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)DictionaryIntLoad0(true, "DHD_IntJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                DictionaryIntSave0(true, "DHD_IntJBNum", lv_j);
                DictionaryIntSave0(true, ("DHD_Int_" + lv_j.ToString()), lp_vector);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if (DictionaryIntLoad0(true, "DHD_Int_" + lv_j.ToString()) == lp_vector)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            DictionaryIntSave0(true, "DHD_IntJBNum", lv_j);
                            DictionaryIntSave0(true, ("DHD_Int_" + lv_j.ToString()), lp_vector);
                        }
                    }
                }
            }
            lv_tag = lv_j.ToString();
            //Console.WriteLine(("Tag：" + lv_tag));
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Int已注册标签句柄
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns>返回一个Int的已注册标签，错误返回""</returns>
        public static string DHD_ReturnIntTag(int lp_vector)
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag = "";
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)DictionaryIntLoad0(true, "DHD_IntJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if (DictionaryIntLoad0(true, "DHD_Int_" + lv_j.ToString()) == lp_vector)
                {
                    lv_tag = lv_j.ToString();
                    break;
                }
            }
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动I_注册Int(高级)。在指定Key存入Int，固有状态、自定义值是Int独一无二的标志（本函数重复注册会刷新），之后可用互动I_"返回Int注册总数"、"返回Int序号"、"返回序号对应Int"、"返回序号对应Int标签"、"返回Int自定义值"。Int组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Int组转为Key。首次注册时固有状态为true（相当于单位组单位活体），如需另外设置多个标记可使用"互动I_设定Int状态/自定义值"
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Int"</param>
        /// <param name="lp_inherentStats">固有状态</param>
        /// <param name="lp_inherentCustomValue">固有自定义值</param>
        public static void DHD_RegInt(int lp_vector, string lp_key, string lp_inherentStats, string lp_inherentCustomValue)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;

            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_jBNum = (int)DictionaryIntLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = DHD_RegIntTagAndReturn(lp_vector);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                DictionaryIntSave0(true, (lv_str + "Num"), lv_i);
                DictionaryStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                DictionaryBoolSave0(true, (("DHD_IfIntTag" + "") + "_" + lv_tagStr), true);
                DictionaryBoolSave1(true, ("DHD_IfIntTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if (DictionaryIntLoad1(true, lv_str + "Tag", lv_i).ToString() == lv_tagStr)
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                DictionaryIntSave0(true, (lv_str + "Num"), lv_i);
                                DictionaryStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                DictionaryBoolSave0(true, (("DHD_IfIntTag" + "") + "_" + lv_tagStr), true);
                                DictionaryBoolSave1(true, ("DHD_IfIntTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            DictionaryStringSave0(true, ("DHD_IntState" + "" + "_" + lv_tagStr), lp_inherentStats);
            DictionaryStringSave0(true, ("DHD_IntCV" + "" + "_" + lv_tagStr), lp_inherentCustomValue);
        }

        /// <summary>
        /// 【MM_函数库】互动I_注册Int。在指定Key存入Int，固有状态、自定义值是Int独一无二的标志（本函数重复注册不会刷新），之后可用互动I_"返回Int注册总数"、"返回Int序号"、"返回序号对应Int"、"返回Int自定义值"。Int组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Int组转为Key。首次注册时固有状态为true（相当于单位组单位活体），之后只能通过"互动I_注册Int（高级）"改写，如需另外设置多个标记可使用"互动I_设定Int状态/自定义值"
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Int"</param>
        public static void DHD_RegInt_Simple(int lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;

            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_jBNum = (int)DictionaryIntLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = DHD_RegIntTagAndReturn(lp_vector);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                DictionaryIntSave0(true, (lv_str + "Num"), lv_i);
                DictionaryStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                DictionaryBoolSave0(true, (("DHD_IfIntTag" + "") + "_" + lv_tagStr), true);
                DictionaryBoolSave1(true, ("DHD_IfIntTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if (DictionaryIntLoad1(true, lv_str + "Tag", lv_i).ToString() == lv_tagStr)
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                DictionaryIntSave0(true, (lv_str + "Num"), lv_i);
                                DictionaryStringSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                DictionaryBoolSave0(true, (("DHD_IfIntTag" + "") + "_" + lv_tagStr), true);
                                DictionaryBoolSave1(true, ("DHD_IfIntTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            if ((DictionaryBoolKeyExists(true, ("DHD_Int" + "State" + "_" + lv_tag.ToString())) == false))
            {
                DictionaryStringSave1(true, (("DHD_Int" + "State")), lv_tag, "true");
            }
        }

        /// <summary>
        /// 【MM_函数库】互动I_注销Int。用"互动I_注册Int"到Key，之后可用本函数彻底摧毁注册信息并将序号重排（包括Int标签有效状态、固有状态及自定义值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动I_设定Int状态"让Int状态失效（类似单位组的单位活体状态）。Int组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Int组转为Key。本函数无法摧毁用"互动I_设定Int状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Int组变量ID时会清空Int组专用状态
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Int"</param>
        public static void DHD_DestroyInt(int lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag;
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_tag = DHD_ReturnIntTag(lp_vector);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                ThreadWaitSet(true, "Key_IntGroup" + lv_str, true);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((DictionaryIntLoad1(true, (lp_key + "IntTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        DictionaryBoolClear0(true, "DHD_IfIntTag_" + lv_tag);
                        DictionaryBoolClear0(true, "DHD_IfIntTag" + lv_str + "_" + lv_tag);
                        DictionaryIntClear0(true, "DHD_Int_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_IntCV_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_IntState_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_IntCV" + lv_str + "_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_IntState" + lv_str + "_" + lv_tag);
                        DictionaryIntSave0(true, (lp_key + "IntNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = DictionaryIntLoad1(true, (lp_key + "IntTag"), lv_b + 1).ToString();
                            DictionaryStringSave1(true, (lp_key + "IntTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                ThreadWaitSet(true, "Key_IntGroup" + lv_str, false);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动I_移除Int。用"互动I_注册Int"到Key，之后可用本函数仅摧毁Key区注册的信息并将序号重排，用于Int组或多个键区仅移除Int（保留Int标签有效状态、固有值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动I_设定Int状态"让Int状态失效（类似单位组的单位活体状态）。Int组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Int组转为Key。本函数无法摧毁用"互动I_设定Int状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Int组变量ID时会清空Int组专用状态
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Int"</param>
        public static void DHD_RemoveInt(int lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag;
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_tag = DHD_ReturnIntTag(lp_vector);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                ThreadWaitSet(true, "Key_IntGroup" + lv_str, true);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((DictionaryIntLoad1(true, (lp_key + "IntTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        DictionaryBoolClear0(true, "DHD_IfIntTag" + lv_str + "_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_IntCV" + lv_str + "_" + lv_tag);
                        DictionaryStringClear0(true, "DHD_IntState" + lv_str + "_" + lv_tag);
                        DictionaryIntSave0(true, (lp_key + "IntNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = DictionaryIntLoad1(true, (lp_key + "IntTag"), lv_b + 1).ToString();
                            DictionaryStringSave1(true, (lp_key + "IntTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                ThreadWaitSet(true, "Key_IntGroup" + lv_str, false);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Int注册总数。必须先使用"互动I_注册Int"才能返回指定Key里的注册总数。Int组使用时，可用"获取变量的内部名称"将Int组转为Key。
        /// </summary>
        /// <param name="lp_key">存储键区，默认值"_Int"</param>
        /// <returns></returns>
        public static int DHD_ReturnIntNumMax(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            // Implementation
            return lv_num;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Int序号。使用"互动I_注册Int"后使用本函数可返回Key里的注册序号，Key无元素返回0，Key有元素但对象不在里面则返回-1，Int标签尚未注册则返回-2。Int组使用时，可用"获取变量的内部名称"将Int组转为Key
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Int"</param>
        /// <returns></returns>
        public static int DHD_ReturnIntNum(int lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_i;
            string lv_tag;
            int lv_torf;
            // Automatic Variable Declarations
            const int auto_n = 1;
            int auto_i;
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_tag = DHD_ReturnIntTag(lp_vector);
            lv_torf = -1;
            // Implementation
            for (auto_i = 1; auto_i <= auto_n; auto_i += 1)
            {
                if ((lv_tag != null))
                {
                    lv_torf = -2;
                    break;
                }
                if ((lv_num == 0))
                {
                    lv_torf = 0;
                }
                else
                {
                    if ((lv_num >= 1))
                    {
                        auto_ae = lv_num;
                        auto_var = 1;
                        for (; auto_var <= auto_ae; auto_var += 1)
                        {
                            lv_i = auto_var;
                            if ((DictionaryIntLoad1(true, (lv_str + "Tag"), lv_i).ToString() == lv_tag))
                            {
                                lv_torf = lv_i;
                                break;
                            }
                        }
                    }
                }
            }
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回序号对应Int。使用"互动I_注册Int"后，在参数填入注册序号可返回Int。Int组使用时，可用"获取变量的内部名称"将Int组转为Key
        /// </summary>
        /// <param name="lp_regNum"></param>
        /// <param name="lp_key">存储键区，默认值"_Int"</param>
        /// <returns></returns>
        public static int DHD_ReturnIntFromRegNum(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_tag = DictionaryIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return DictionaryIntLoad0(true, ("DHD_Int_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回句柄标签对应Int。使用"互动I_注册Int"后，在参数填入句柄标签（整数）可返回Int，标签是Int的句柄。Int组使用时，可用"获取变量的内部名称"将Int组转为Key
        /// </summary>
        /// <param name="lp_tag">句柄标签</param>
        /// <returns></returns>
        public static int DHD_ReturnIntFromTag(int lp_tag)
        {
            // Variable Declarations
            string lv_tag;
            // Variable Initialization
            lv_tag = lp_tag.ToString();
            // Implementation
            return DictionaryIntLoad0(true, ("DHD_Int_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回序号对应Int标签句柄。使用"互动I_注册Int"后，在参数填入注册序号可返回Int标签（字符串）。Int组使用时，可用"获取变量的内部名称"将Int组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Int"</param>
        /// <returns></returns>
        public static string DHD_ReturnIntTagFromRegNum_String(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_tag = DictionaryIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回序号对应Int标签句柄。使用"互动I_注册Int"后，在参数填入注册序号可返回Int标签（整数）。Int组使用时，可用"获取变量的内部名称"将Int组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Int"</param>
        /// <returns></returns>
        public static int DHD_ReturnIntTagFromRegNum_Int(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_tag = DictionaryIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return Convert.ToInt32(lv_tag);
        }

        /// <summary>
        /// 【MM_函数库】互动I_设置Int状态。必须先"注册"获得功能库内部句柄，再使用本函数给Int设定一个状态值，之后可用"互动I_返回Int状态"。类型参数用以记录多个不同状态，仅当"类型"参数填Int组ID转的Int串时，状态值"true"和"false"是Int的Int组专用状态值，用于内部函数筛选Int状态（相当于单位组单位索引是否有效），其他类型不会干扰系统内部，可随意填写。虽然注销时反向清空注册信息，但用"互动I_设定Int状态/自定义值"创建的值需要手工填入""来排泄（非大量注销则提升内存量极小，可不管）。注：固有状态值是注册函数赋予的系统内部变量（相当于单位组单位是否活体），只能通过"互动I_注册Int（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <param name="lp_stats">状态</param>
        public static void DHD_SetIntState(int lp_vector, string lp_key, string lp_stats)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_tag = DHD_RegIntTagAndReturn(lp_vector);
            // Implementation
            DictionaryStringSave0(true, ("DHD_IntState" + lv_str + "_" + lv_tag), lp_stats);
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Int状态。使用"互动I_设定Int状态"后可使用本函数，将本函数参数"类型"设为空时返回固有值。类型参数用以记录多个不同状态，仅当"类型"参数为Int组ID转的字符串时，返回的状态值"true"和"false"是Int的Int组专用状态值，用于内部函数筛选Int状态（相当于单位组单位索引是否有效）
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <returns></returns>
        public static string DHD_ReturnIntState(int lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_tag = DHD_ReturnIntTag(lp_vector);
            lv_stats = DictionaryStringLoad0(true, ("DHD_IntState" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动I_设置Int自定义值。必须先"注册"获得功能库内部句柄，再使用本函数设定Int的自定义值，之后可使用"互动I_返回Int自定义值"，类型参数用以记录多个不同自定义值。注：固有自定义值是注册函数赋予的系统内部变量，只能通过"互动I_注册Int（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <param name="lp_customValue">自定义值</param>
        public static void DHD_SetIntCV(int lp_vector, string lp_key, string lp_customValue)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_tag = DHD_RegIntTagAndReturn(lp_vector);
            // Implementation
            DictionaryStringSave0(true, ("DHD_IntCV" + lv_str + "_" + lv_tag), lp_customValue);
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Int自定义值。使用"互动I_设定Int自定义值"后可使用本函数，将本函数参数"类型"设为空时返回固有值，该参数用以记录多个不同自定义值
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <returns></returns>
        public static string DHD_ReturnIntCV(int lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_tag = DHD_ReturnIntTag(lp_vector);
            lv_customValue = DictionaryStringLoad0(true, ("DHD_IntCV" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Int固有状态。必须先使用"互动I_注册Int"才能返回到该值，固有状态是独一无二的标记（相当于单位组单位是否活体）
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns></returns>
        public static string DHD_ReturnIntState_Only(int lp_vector)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_tag = DHD_ReturnIntTag(lp_vector);
            lv_stats = DictionaryStringLoad0(true, ("DHD_IntState" + "" + "_" + lv_tag));
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Int固有自定义值。必须先使用"互动I_注册Int"才能返回到该值，固有值是独一无二的标记
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns></returns>
        public static string DHD_ReturnIntCV_Only(int lp_vector)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_tag = DHD_ReturnIntTag(lp_vector);
            lv_customValue = DictionaryStringLoad0(true, ("DHD_IntCV" + "" + "_" + lv_tag));
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动I_设置Int的实数标记。必须先"注册"获得功能库内部句柄，再使用本函数让Int携带一个实数值，之后可使用"互动I_返回Int的实数标记"。Int组使用时，可用"获取变量的内部名称"将Int组转为Key
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_realNumTag">实数标记</param>
        public static void DHD_SetIntDouble(int lp_vector, double lp_realNumTag)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = DHD_RegIntTagAndReturn(lp_vector);
            // Implementation
            DictionaryDoubleSave0(true, ("DHD_CDDouble_Int_" + lv_tag), lp_realNumTag);
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Int的实数标记。使用"互动I_设定Int的实数标记"后可使用本函数。Int组使用时，可用"获取变量的内部名称"将Int组转为Key
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns></returns>
        public static double DHD_ReturnIntDouble(int lp_vector)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = DHD_ReturnIntTag(lp_vector);
            // Implementation
            return DictionaryDoubleLoad0(true, ("DHD_CDDouble_Int_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Int标签句柄有效状态。将Int视作独一无二的个体，标签是它本身，有效状态则类似"单位是否有效"，当使用"互动I_注册Int"或"互动IG_添加Int到Int组"后激活Int有效状态（值为"true"），除非使用"互动I_注册Int（高级）"改写，否则直到注销才会摧毁
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns></returns>
        public static bool DHD_ReturnIfIntTag(int lp_vector)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = DHD_ReturnIntTag(lp_vector);
            // Implementation
            return DictionaryBoolLoad0(true, ("DHD_IfIntTag" + "" + "_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Int注册状态。使用"互动I_注册Int"或"互动IG_添加Int到Int组"后可使用本函数获取注册Int在Key中的注册状态，该状态只能注销或从Int组中移除时清空。Int组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Int组转为Key
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Int"</param>
        /// <returns></returns>
        public static bool DHD_ReturnIfIntTagKey(int lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_tag = DHD_ReturnIntTag(lp_vector);
            // Implementation
            return DictionaryBoolLoad0(true, ("DHD_IfIntTag" + lv_str + "_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动IG_根据自定义值类型将Int组排序。根据Int携带的自定义值类型，对指定的Int组元素进行冒泡排序。Int组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Int组名称</param>
        /// <param name="lp_cVStr">自定义值类型</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void DHD_IntGSortCV(string lp_key, string lp_cVStr, bool lp_big)
        {
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            string lv_tagValuestr;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Int");
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_IntGroup" + lv_str, true);
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = DHD_ReturnIntTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValuestr = DHD_ReturnIntCV((int)DHD_ReturnIntFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    DictionaryIntSave1(false, "IntStackOutTag", 1, lv_tag);
                    DictionaryIntSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DictionaryIntSave1(false, "IntStackOutTag", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    DictionaryIntSave1(false, "IntStackOutTagValue", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                DictionaryIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                DictionaryIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(DHD_ReturnIntTagFromRegNum(lv_b, lp_key))+"值"+IntToString(DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DictionaryIntSave1(false, "IntStackOutTag", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DictionaryIntSave1(false, "IntStackOutTagValue", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                DictionaryIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DictionaryIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        DictionaryIntSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DictionaryIntSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = DictionaryIntLoad1(true, (lp_key + "IntTag"), lv_a).ToString(); //原始序号元素
                lv_tag = (int)DictionaryIntLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValuestr = DHD_ReturnIntCV((int)DHD_ReturnIntFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    DictionaryIntSave1(true, (lp_key + "IntTag"), lv_a, lv_tag); //lv_tag放入新序号
                    //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            ThreadWaitSet(true, "Key_IntGroup" + lv_str, false);
        }

        /// <summary>
        /// 【MM_函数库】互动IG_Int组排序。对指定的Int组元素进行冒泡排序（根据元素句柄）。Int组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Int组名称</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void DHD_IntGSort(string lp_key, bool lp_big)
        {
            // Automatic Variable Declarations
            // Implementation
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Int");
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_IntGroup" + lv_str, true);
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = DHD_ReturnIntTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValue = lv_tag;
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    DictionaryIntSave1(false, "IntStackOutTag", 1, lv_tag);
                    DictionaryIntSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DictionaryIntSave1(false, "IntStackOutTag", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    DictionaryIntSave1(false, "IntStackOutTagValue", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                DictionaryIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                DictionaryIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(DHD_ReturnIntTagFromRegNum(lv_b, lp_key))+"值"+IntToString(DictionaryIntLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    DictionaryIntSave1(false, "IntStackOutTag", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(DictionaryIntLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DictionaryIntSave1(false, "IntStackOutTagValue", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(DictionaryIntLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_c, (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                DictionaryIntSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DictionaryIntSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        DictionaryIntSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DictionaryIntSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        DictionaryIntSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = DictionaryIntLoad1(true, (lp_key + "IntTag"), lv_a).ToString(); //原始序号元素
                lv_tag = (int)DictionaryIntLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValue = lv_tag;
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = (int)DictionaryIntLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                                                                                        //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    DictionaryIntSave1(true, (lp_key + "IntTag"), lv_a, lv_tag); //lv_tag放入新序号
                                                                                 //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            ThreadWaitSet(true, "Key_IntGroup" + lv_str, false);
        }

        /// <summary>
        /// 【MM_函数库】互动IG_设定Int的Int组专用状态。给Int组的Int设定一个状态值（字符串），之后可用"互动I_返回Int、互动IG_返回Int组的Int状态"。状态值"true"和"false"是Int的Int组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效），而本函数可以重设干预，影响函数"互动IG_返回Int组元素数量（仅检索XX状态）"。与"互动I_设定Int状态"功能相同，只是状态参数在Int组中被固定为"Int组变量的内部ID"。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_vectorGroup"></param>
        /// <param name="lp_groupState"></param>
        public static void DHD_SetIntGState(int lp_vector, string lp_vectorGroup, string lp_groupState)
        {
            DHD_SetIntState(lp_vector, lp_vectorGroup, lp_groupState);
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Int的Int组专用状态。使用"互动I_设定Int、互动IG_设定Int组的Int状态"后可使用本函数。与"互动I_返回Int状态"功能相同，只是状态参数在Int组中被固定为"Int组变量的内部ID"。状态值"true"和"false"是Int的Int组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效）。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_vectorGroup"></param>
        public static void DHD_ReturnIntGState(int lp_vector, string lp_vectorGroup)
        {
            DHD_ReturnIntState(lp_vector, lp_vectorGroup);
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Int组元素序号对应元素。返回Int组元素序号指定Int。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int DHD_ReturnIntFromIntGFunc(int lp_regNum, string lp_gs)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_gs + "Int");
            lv_tag = DictionaryIntLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return DictionaryIntLoad0(true, ("DHD_Int_" + lv_tag));
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Int组元素总数。返回指定Int组的元素数量。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int DHD_ReturnIntGNumMax(string lp_gs)
        {
            return DictionaryIntLoad0(true, lp_gs + "IntNum");
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Int组元素总数（仅检测Int组专用状态="true"）。返回指定Int组的元素数量。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int DHD_ReturnIntGNumMax_StateTrueFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            int lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = DHD_ReturnIntNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (int)DHD_ReturnIntFromRegNum(lv_a, lp_gs);
                lv_b = DHD_ReturnIntState(lv_c, lp_gs);
                if ((lv_b == "true"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Int组元素总数（仅检测Int组专用状态="false"）。返回指定Int组的元素数量。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int DHD_ReturnIntGNumMax_StateFalseFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            int lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = DHD_ReturnIntNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (int)DHD_ReturnIntFromRegNum(lv_a, lp_gs);
                lv_b = DHD_ReturnIntState(lv_c, lp_gs);
                if ((lv_b == "false"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Int组元素总数（仅检测Int组无效专用状态："false"或""）。返回指定Int组的元素数量（false、""、null）。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int DHD_ReturnIntGNumMax_StateUselessFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            int lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = DHD_ReturnIntNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (int)DHD_ReturnIntFromRegNum(lv_a, lp_gs);
                lv_b = DHD_ReturnIntState(lv_c, lp_gs);
                if (((lv_b == "false") || (lv_b == "") || (lv_b == null)))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Int组元素总数（仅检测Int组指定专用状态）。返回指定Int组的元素数量。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_State">Int组专用状态</param>
        /// <returns></returns>
        public static int DHD_ReturnIntGNumMax_StateFunc_Specify(string lp_gs, string lp_State)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            int lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = DHD_ReturnIntNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = (int)DHD_ReturnIntFromRegNum(lv_a, lp_gs);
                lv_b = DHD_ReturnIntState(lv_c, lp_gs);
                if ((lv_b == lp_State))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动IG_添加Int到Int组。相同Int被认为是同一个，非高级功能不提供专用状态检查，如果Int没有设置过Int组专用状态，那么首次添加到Int组不会赋予"true"（之后可通过"互动I_设定Int状态"、"互动IG_设定Int组的Int状态"修改）。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void DHD_AddIntToGroup_Simple(int lp_vector, string lp_gs)
        {
            DHD_RegInt_Simple(lp_vector, lp_gs);
        }

        /// <summary>
        /// 【MM_函数库】互动IG_添加Int到Int组（高级）。相同Int被认为是同一个，高级功能提供专用状态检查，如果Int没有设置过Int组专用状态，那么首次添加到Int组会赋予"true"（之后可通过"互动I_设定Int状态"、"互动IG_设定Int组的Int状态"修改）。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void DHD_AddIntToGroup(int lp_vector, string lp_gs)
        {
            DHD_RegInt_Simple(lp_vector, lp_gs);
            if (DictionaryStringKeyExists(true, ("DHD_IntState" + lp_gs + "Int_" + DHD_RegIntTagAndReturn(lp_vector))) == false)
            {
                DictionaryStringSave0(true, ("DHD_IntState" + lp_gs + "Int_" + DHD_RegIntTagAndReturn(lp_vector)), "true");
                //Console.WriteLine(lp_gs + "=>" + DHD_RegIntTagAndReturn(lp_vector));
            }
        }

        /// <summary>
        /// 【MM_函数库】互动IG_移除Int组中的元素。使用"互动IG_添加Int到Int组"后可使用本函数进行移除元素。移除使用了"互动I_移除Int"，同一个存储区（Int组ID）序号重排，移除时该存储区如有其他操作会排队等待。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void DHD_ClearIntFromGroup(int lp_vector, string lp_gs)
        {
            DHD_RemoveInt(lp_vector, lp_gs);
        }

        //互动IG_为Int组中的每个序号
        //GE（星际2的Galaxy Editor）的宏让编辑器保存时自动生成脚本并整合进脚本进行格式调整，C#仅参考需自行编写
        // #AUTOVAR(vs, string) = "#PARAM(group)";//"#PARAM(group)"是与字段、变量名一致的元素组名称，宏去声明string类型名为“Auto随机编号_vs”的自动变量，然后=右侧字符
        // #AUTOVAR(ae) = DHD_ReturnIntNumMax(#AUTOVAR(vs));//宏去声明默认int类型名为“Auto随机编号_ae”的自动变量，然后=右侧字符
        // #INITAUTOVAR(ai,increment)//宏去声明int类型名为“Auto随机编号_ai”的自动变量，用于下面for循环增量（increment是传入参数）
        // #PARAM(var) = #PARAM(s);//#PARAM(var)是传进来的参数，用作“当前被挑选到的元素”（任意变量-整数 lp_var）， #PARAM(s)是传进来的参数用作"开始"（int lp_s）
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #PARAM(var) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #PARAM(var) >= #AUTOVAR(ae)) ) ; #PARAM(var) += #AUTOVAR(ai) ) {
        //     #SUBFUNCS(actions)//代表用户GUI填写的所有动作
        // }

        /// <summary>
        /// 【MM_函数库】互动IG_为Int组中的每个序号。每次挑选的元素序号会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素序号，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void DHD_ForEachIntNumFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            int lv_ae = DHD_ReturnIntNumMax(lp_gs);
            int lv_var = lp_start;
            int lv_ai = lp_increment;
            for (; (lv_ai >= 0 && lv_var <= lv_ae) || (lv_ai < 0 && lv_var >= lv_ae); lv_var += lv_ai)
            {
                lp_funcref(lv_var);//用户填写的所有动作
            }
        }

        //互动IG_为Int组中的每个元素
        // #AUTOVAR(vs, string) = "#PARAM(group)";
        // #AUTOVAR(ae) = DHD_ReturnIntNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= #PARAM(s);
        // #INITAUTOVAR(ai,increment)
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     DictionarySave(false, "IntGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)), DHD_ReturnIntFromRegNum(#AUTOVAR(va),#AUTOVAR(vs)));
        // }
        // #AUTOVAR(va)= #PARAM(s);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #PARAM(var) = DictionaryLoad(false, "IntGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)));
        //     #SUBFUNCS(actions)
        // }

        /// <summary>
        /// 【MM_函数库】互动IG_为Int组中的每个元素。每次挑选的元素会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void DHD_ForEachIntFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            string lv_vs = lp_gs;
            int lv_ae = DHD_ReturnIntNumMax(lv_vs);
            int lv_va = lp_start;
            int lv_ai = lp_increment;
            int lv_vector;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                DictionaryIntSave0(false, "IntGFor" + lv_vs + lv_va.ToString(), (int)DHD_ReturnIntFromRegNum(lv_va, lv_vs));
            }
            lv_va = lp_start;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                lv_vector = (int)DictionaryIntLoad0(false, "IntGFor" + lv_vs + lv_va.ToString());
                lp_funcref(lv_vector);//用户填写的所有动作
            }
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Int组中随机元素。返回指定Int组中的随机Int。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int DHD_ReturnRandomIntFromIntGFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_num;
            int lv_a;
            int lv_c = 0;
            // Variable Initialization
            lv_num = DHD_ReturnIntNumMax(lp_gs);
            // Implementation
            if ((lv_num >= 1))
            {
                lv_a = RandomInt(1, lv_num);
                lv_c = DHD_ReturnIntFromRegNum(lv_a, lp_gs);
            }
            return lv_c;
        }

        //互动IG_添加Int组到Int组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = DHD_ReturnIntNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = DHD_ReturnIntFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     DHD_AddIntToGroup(#AUTOVAR(var), #AUTOVAR(vsb));
        // }


        /// <summary>
        /// 【MM_函数库】互动IG_添加Int组到Int组。添加一个Int组A的元素到另一个Int组B，相同Int被认为是同一个。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void DHD_AddIntGToIntG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = DHD_ReturnIntNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            int lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = (int)DHD_ReturnIntFromRegNum(lv_va, lv_vsa);
                DHD_AddIntToGroup(lv_var, lv_vsb);
            }
        }

        //互动IG_从Int组移除Int组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = DHD_ReturnIntNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = DHD_ReturnIntFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     DHD_RemoveInt(#AUTOVAR(var), #AUTOVAR(vsb));
        // }

        /// <summary>
        /// 【MM_函数库】互动IG_从Int组移除Int组。将Int组A的元素从Int组B中移除，相同Int被认为是同一个。移除使用了"互动I_移除Int"，同一个存储区（Int组ID）序号重排，移除时该存储区如有其他操作会排队等待。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void DHD_ClearIntGFromIntG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = DHD_ReturnIntNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            int lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = (int)DHD_ReturnIntFromRegNum(lv_va, lv_vsa);
                DHD_RemoveInt(lv_var, lv_vsb);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动IG_移除Int组全部元素。将Int组（Key区）存储的元素全部移除，相同Int被认为是同一个。移除时同一个存储区（Int组ID）序号不进行重排，但该存储区如有其他操作会排队等待。Int组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Int组到Int组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Int组名称</param>
        public static void DHD_RemoveIntGAll(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag = "";
            int lv_a;
            // Variable Initialization
            lv_str = (lp_key + "Int");
            lv_num = (int)DictionaryIntLoad0(true, (lv_str + "Num"));
            // Implementation
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_IntGroup" + lv_str, true);
            for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
            {
                lv_tag = DictionaryIntLoad1(true, (lp_key + "IntTag"), lv_a).ToString();
                lv_num -= 1;
                DictionaryBoolClear0(true, "DHD_IfIntTag" + lv_str + "_" + lv_tag);
                DictionaryStringClear0(true, "DHD_IntCV" + lv_str + "_" + lv_tag);
                DictionaryStringClear0(true, "DHD_IntState" + lv_str + "_" + lv_tag);
                DictionaryIntSave0(true, (lp_key + "IntNum"), lv_num);
            }
            ThreadWaitSet(true, "Key_IntGroup" + lv_str, false);
        }

        //--------------------------------------------------------------------------------------------------
        // 数字组End
        //--------------------------------------------------------------------------------------------------

        #endregion

        #endregion

        #region 哈希表互动

        //注：值与引用类型转换时没字典（Dictionary）效率，因为会发生拆装箱

        #region 任意类型

        //提示：可以将任意类型作为模板修改后产生其他类型
        //提示：尽可能使用对口类型，以防值类型与引用类型发生转换时拆装箱降低性能

        //--------------------------------------------------------------------------------------------------
        // 任意类型组Start
        //--------------------------------------------------------------------------------------------------

        /// <summary>
        /// 【MM_函数库】互动O_注册Object标签句柄并返回。为Object自动设置新的标签句柄，重复时会返回已注册的Object标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns>返回一个Object的已注册标签</returns>
        private static int HHD_RegObjectTagAndReturn_Int(object lp_object)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)HashTableLoad0(true, "HHD_ObjectJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                HashTableSave0(true, "HHD_ObjectJBNum", lv_j);
                HashTableSave0(true, ("HHD_Object_" + lv_j.ToString()), lp_object);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if ((object)HashTableLoad0(true, ("HHD_Object_" + lv_j.ToString())) == lp_object)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            HashTableSave0(true, "HHD_ObjectJBNum", lv_j);
                            HashTableSave0(true, ("HHD_Object_" + lv_j.ToString()), lp_object);
                        }
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object已注册标签句柄
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns>返回一个Object的已注册标签，错误返回0</returns>
        public static int HHD_ReturnObjectTag_Int(object lp_object)
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)HashTableLoad0(true, "HHD_ObjectJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if ((object)HashTableLoad0(true, "HHD_Object_" + lv_j.ToString()) == lp_object)
                {
                    break;
                }
                else
                {
                    if ((lv_j == lv_jBNum))
                    {
                        lv_j = 0;
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动O_注册Object标签句柄并返回。为Object自动设置新的标签句柄，重复时会返回已注册的Object标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns>返回一个Object的已注册标签</returns>
        private static string HHD_RegObjectTagAndReturn(object lp_object)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)HashTableLoad0(true, "HHD_ObjectJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                HashTableSave0(true, "HHD_ObjectJBNum", lv_j);
                HashTableSave0(true, ("HHD_Object_" + lv_j.ToString()), lp_object);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if ((object)HashTableLoad0(true, "HHD_Object_" + lv_j.ToString()) == lp_object)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            HashTableSave0(true, "HHD_ObjectJBNum", lv_j);
                            HashTableSave0(true, ("HHD_Object_" + lv_j.ToString()), lp_object);
                        }
                    }
                }
            }
            lv_tag = lv_j.ToString();
            //Console.WriteLine(("Tag：" + lv_tag));
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object已注册标签句柄
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns>返回一个Object的已注册标签，错误返回""</returns>
        public static string HHD_ReturnObjectTag(object lp_object)
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag = "";
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)HashTableLoad0(true, "HHD_ObjectJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if ((object)HashTableLoad0(true, "HHD_Object_" + lv_j.ToString()) == lp_object)
                {
                    lv_tag = lv_j.ToString();
                    break;
                }
            }
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动O_注册Object(高级)。在指定Key存入Object，固有状态、自定义值是Object独一无二的标志（本函数重复注册会刷新），之后可用互动O_"返回Object注册总数"、"返回Object序号"、"返回序号对应Object"、"返回序号对应Object标签"、"返回Object自定义值"。Object组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Object组转为Key。首次注册时固有状态为true（相当于单位组单位活体），如需另外设置多个标记可使用"互动O_设定Object状态/自定义值"
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        /// <param name="lp_inherentStats">固有状态</param>
        /// <param name="lp_inherentCustomValue">固有自定义值</param>
        public static void HHD_RegObject(object lp_object, string lp_key, string lp_inherentStats, string lp_inherentCustomValue)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;

            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_jBNum = (int)HashTableLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = HHD_RegObjectTagAndReturn(lp_object);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                HashTableSave0(true, (lv_str + "Num"), lv_i);
                HashTableSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                HashTableSave0(true, (("HHD_IfObjectTag" + "") + "_" + lv_tagStr), true);
                HashTableSave1(true, ("HHD_IfObjectTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if (HashTableLoad1(true, lv_str + "Tag", lv_i).ToString() == lv_tagStr)
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                HashTableSave0(true, (lv_str + "Num"), lv_i);
                                HashTableSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                HashTableSave0(true, (("HHD_IfObjectTag" + "") + "_" + lv_tagStr), true);
                                HashTableSave1(true, ("HHD_IfObjectTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            HashTableSave0(true, ("HHD_ObjectState" + "" + "_" + lv_tagStr), lp_inherentStats);
            HashTableSave0(true, ("HHD_ObjectCV" + "" + "_" + lv_tagStr), lp_inherentCustomValue);
        }

        /// <summary>
        /// 【MM_函数库】互动O_注册Object。在指定Key存入Object，固有状态、自定义值是Object独一无二的标志（本函数重复注册不会刷新），之后可用互动O_"返回Object注册总数"、"返回Object序号"、"返回序号对应Object"、"返回Object自定义值"。Object组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Object组转为Key。首次注册时固有状态为true（相当于单位组单位活体），之后只能通过"互动O_注册Object（高级）"改写，如需另外设置多个标记可使用"互动O_设定Object状态/自定义值"
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        public static void HHD_RegObject_Simple(object lp_object, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;

            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_jBNum = (int)HashTableLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = HHD_RegObjectTagAndReturn(lp_object);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                HashTableSave0(true, (lv_str + "Num"), lv_i);
                HashTableSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                HashTableSave0(true, (("HHD_IfObjectTag" + "") + "_" + lv_tagStr), true);
                HashTableSave1(true, ("HHD_IfObjectTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if (HashTableLoad1(true, lv_str + "Tag", lv_i).ToString() == lv_tagStr)
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                HashTableSave0(true, (lv_str + "Num"), lv_i);
                                HashTableSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                HashTableSave0(true, (("HHD_IfObjectTag" + "") + "_" + lv_tagStr), true);
                                HashTableSave1(true, ("HHD_IfObjectTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            if ((HashTableKeyExists(true, ("HHD_Object" + "State" + "_" + lv_tag.ToString())) == false))
            {
                HashTableSave1(true, (("HHD_Object" + "State")), lv_tag, "true");
            }
        }

        /// <summary>
        /// 【MM_函数库】互动O_注销Object。用"互动O_注册Object"到Key，之后可用本函数彻底摧毁注册信息并将序号重排（包括Object标签有效状态、固有状态及自定义值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动O_设定Object状态"让Object状态失效（类似单位组的单位活体状态）。Object组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Object组转为Key。本函数无法摧毁用"互动O_设定Object状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Object组变量ID时会清空Object组专用状态
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        public static void HHD_DestroyObject(object lp_object, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag;
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_tag = HHD_ReturnObjectTag(lp_object);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                HashTableSave0(true, "Key_ObjectGroup" + lv_str, 1);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((HashTableLoad1(true, (lp_key + "ObjectTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        HashTableClear0(true, "HHD_IfObjectTag_" + lv_tag);
                        HashTableClear0(true, "HHD_IfObjectTag" + lv_str + "_" + lv_tag);
                        HashTableClear0(true, "HHD_Object_" + lv_tag);
                        HashTableClear0(true, "HHD_ObjectCV_" + lv_tag);
                        HashTableClear0(true, "HHD_ObjectState_" + lv_tag);
                        HashTableClear0(true, "HHD_ObjectCV" + lv_str + "_" + lv_tag);
                        HashTableClear0(true, "HHD_ObjectState" + lv_str + "_" + lv_tag);
                        HashTableSave0(true, (lp_key + "ObjectNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = HashTableLoad1(true, (lp_key + "ObjectTag"), lv_b + 1).ToString();
                            HashTableSave1(true, (lp_key + "ObjectTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                HashTableSave0(true, "Key_ObjectGroup" + lv_str, 0);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动O_移除Object。用"互动O_注册Object"到Key，之后可用本函数仅摧毁Key区注册的信息并将序号重排，用于Object组或多个键区仅移除Object（保留Object标签有效状态、固有值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动O_设定Object状态"让Object状态失效（类似单位组的单位活体状态）。Object组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Object组转为Key。本函数无法摧毁用"互动O_设定Object状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Object组变量ID时会清空Object组专用状态
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        public static void HHD_RemoveObject(object lp_object, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag;
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_tag = HHD_ReturnObjectTag(lp_object);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                HashTableSave0(true, "Key_ObjectGroup" + lv_str, 1);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((HashTableLoad1(true, (lp_key + "ObjectTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        HashTableClear0(true, "HHD_IfObjectTag" + lv_str + "_" + lv_tag);
                        HashTableClear0(true, "HHD_ObjectCV" + lv_str + "_" + lv_tag);
                        HashTableClear0(true, "HHD_ObjectState" + lv_str + "_" + lv_tag);
                        HashTableSave0(true, (lp_key + "ObjectNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = HashTableLoad1(true, (lp_key + "ObjectTag"), lv_b + 1).ToString();
                            HashTableSave1(true, (lp_key + "ObjectTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                HashTableSave0(true, "Key_ObjectGroup" + lv_str, 0);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object注册总数。必须先使用"互动O_注册Object"才能返回指定Key里的注册总数。Object组使用时，可用"获取变量的内部名称"将Object组转为Key。
        /// </summary>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        /// <returns></returns>
        public static int HHD_ReturnObjectNumMax(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            // Implementation
            return lv_num;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object序号。使用"互动O_注册Object"后使用本函数可返回Key里的注册序号，Key无元素返回0，Key有元素但对象不在里面则返回-1，Object标签尚未注册则返回-2。Object组使用时，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        /// <returns></returns>
        public static int HHD_ReturnObjectNum(object lp_object, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_i;
            string lv_tag;
            int lv_torf;
            // Automatic Variable Declarations
            const int auto_n = 1;
            int auto_i;
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_tag = HHD_ReturnObjectTag(lp_object);
            lv_torf = -1;
            // Implementation
            for (auto_i = 1; auto_i <= auto_n; auto_i += 1)
            {
                if ((lv_tag != null))
                {
                    lv_torf = -2;
                    break;
                }
                if ((lv_num == 0))
                {
                    lv_torf = 0;
                }
                else
                {
                    if ((lv_num >= 1))
                    {
                        auto_ae = lv_num;
                        auto_var = 1;
                        for (; auto_var <= auto_ae; auto_var += 1)
                        {
                            lv_i = auto_var;
                            if ((HashTableLoad1(true, (lv_str + "Tag"), lv_i).ToString() == lv_tag))
                            {
                                lv_torf = lv_i;
                                break;
                            }
                        }
                    }
                }
            }
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回序号对应Object。使用"互动O_注册Object"后，在参数填入注册序号可返回Object。Object组使用时，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_regNum"></param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        /// <returns></returns>
        public static object HHD_ReturnObjectFromRegNum(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            object lv_object;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = HashTableLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            lv_object = (object)HashTableLoad0(true, ("HHD_Object_" + lv_tag));
            // Implementation
            return lv_object;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回句柄标签对应Object。使用"互动O_注册Object"后，在参数填入句柄标签（整数）可返回Object，标签是Object的句柄。Object组使用时，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_tag">句柄标签</param>
        /// <returns></returns>
        public static object HHD_ReturnObjectFromTag(int lp_tag)
        {
            // Variable Declarations
            string lv_tag;
            object lv_object;
            // Variable Initialization
            lv_tag = lp_tag.ToString();
            lv_object = (object)HashTableLoad0(true, ("HHD_Object_" + lv_tag));
            // Implementation
            return lv_object;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回序号对应Object标签句柄。使用"互动O_注册Object"后，在参数填入注册序号可返回Object标签（字符串）。Object组使用时，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        /// <returns></returns>
        public static string HHD_ReturnObjectTagFromRegNum_String(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = HashTableLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回序号对应Object标签句柄。使用"互动O_注册Object"后，在参数填入注册序号可返回Object标签（整数）。Object组使用时，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        /// <returns></returns>
        public static int HHD_ReturnObjectTagFromRegNum_Int(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = HashTableLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return Convert.ToInt32(lv_tag);
        }

        /// <summary>
        /// 【MM_函数库】互动O_设置Object状态。必须先"注册"获得功能库内部句柄，再使用本函数给Object设定一个状态值，之后可用"互动O_返回Object状态"。类型参数用以记录多个不同状态，仅当"类型"参数填Object组ID转的Object串时，状态值"true"和"false"是Object的Object组专用状态值，用于内部函数筛选Object状态（相当于单位组单位索引是否有效），其他类型不会干扰系统内部，可随意填写。虽然注销时反向清空注册信息，但用"互动O_设定Object状态/自定义值"创建的值需要手工填入""来排泄（非大量注销则提升内存量极小，可不管）。注：固有状态值是注册函数赋予的系统内部变量（相当于单位组单位是否活体），只能通过"互动O_注册Object（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <param name="lp_stats">状态</param>
        public static void HHD_SetObjectState(object lp_object, string lp_key, string lp_stats)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = HHD_RegObjectTagAndReturn(lp_object);
            // Implementation
            HashTableSave0(true, ("HHD_ObjectState" + lv_str + "_" + lv_tag), lp_stats);
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object状态。使用"互动O_设定Object状态"后可使用本函数，将本函数参数"类型"设为空时返回固有值。类型参数用以记录多个不同状态，仅当"类型"参数为Object组ID转的字符串时，返回的状态值"true"和"false"是Object的Object组专用状态值，用于内部函数筛选Object状态（相当于单位组单位索引是否有效）
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <returns></returns>
        public static string HHD_ReturnObjectState(object lp_object, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = HHD_ReturnObjectTag(lp_object);
            lv_stats = HashTableLoad0(true, ("HHD_ObjectState" + lv_str + "_" + lv_tag)).ToString();
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动O_设置Object自定义值。必须先"注册"获得功能库内部句柄，再使用本函数设定Object的自定义值，之后可使用"互动O_返回Object自定义值"，类型参数用以记录多个不同自定义值。注：固有自定义值是注册函数赋予的系统内部变量，只能通过"互动O_注册Object（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <param name="lp_customValue">自定义值</param>
        public static void HHD_SetObjectCV(object lp_object, string lp_key, string lp_customValue)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = HHD_RegObjectTagAndReturn(lp_object);
            // Implementation
            HashTableSave0(true, ("HHD_ObjectCV" + lv_str + "_" + lv_tag), lp_customValue);
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object自定义值。使用"互动O_设定Object自定义值"后可使用本函数，将本函数参数"类型"设为空时返回固有值，该参数用以记录多个不同自定义值
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <returns></returns>
        public static string HHD_ReturnObjectCV(object lp_object, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = HHD_ReturnObjectTag(lp_object);
            lv_customValue = HashTableLoad0(true, ("HHD_ObjectCV" + lv_str + "_" + lv_tag)).ToString();
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object固有状态。必须先使用"互动O_注册Object"才能返回到该值，固有状态是独一无二的标记（相当于单位组单位是否活体）
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns></returns>
        public static string HHD_ReturnObjectState_Only(object lp_object)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_tag = HHD_ReturnObjectTag(lp_object);
            lv_stats = HashTableLoad0(true, ("HHD_ObjectState" + "" + "_" + lv_tag)).ToString();
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object固有自定义值。必须先使用"互动O_注册Object"才能返回到该值，固有值是独一无二的标记
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns></returns>
        public static string HHD_ReturnObjectCV_Only(object lp_object)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_tag = HHD_ReturnObjectTag(lp_object);
            lv_customValue = HashTableLoad0(true, ("HHD_ObjectCV" + "" + "_" + lv_tag)).ToString();
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动O_设置Object的实数标记。必须先"注册"获得功能库内部句柄，再使用本函数让Object携带一个实数值，之后可使用"互动O_返回Object的实数标记"。Object组使用时，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_realNumTag">实数标记</param>
        public static void HHD_SetObjectDouble(object lp_object, double lp_realNumTag)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = HHD_RegObjectTagAndReturn(lp_object);
            // Implementation
            HashTableSave0(true, ("HHD_CDDouble_T_" + lv_tag), lp_realNumTag);
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object的实数标记。使用"互动O_设定Object的实数标记"后可使用本函数。Object组使用时，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns></returns>
        public static double HHD_ReturnObjectDouble(object lp_object)
        {
            // Variable Declarations
            string lv_tag = "";
            double lv_f;
            // Variable Initialization
            lv_tag = HHD_ReturnObjectTag(lp_object);
            lv_f = (double)HashTableLoad0(true, ("HHD_CDDouble_T_" + lv_tag));
            // Implementation
            return lv_f;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object标签句柄有效状态。将Object视作独一无二的个体，标签是它本身，有效状态则类似"单位是否有效"，当使用"互动O_注册Object"或"互动OG_添加Object到Object组"后激活Object有效状态（值为"true"），除非使用"互动O_注册Object（高级）"改写，否则直到注销才会摧毁
        /// </summary>
        /// <param name="lp_object"></param>
        /// <returns></returns>
        public static bool HHD_ReturnIfObjectTag(object lp_object)
        {
            // Variable Declarations
            string lv_tag = "";
            bool lv_torf;
            // Variable Initialization
            lv_tag = HHD_ReturnObjectTag(lp_object);
            lv_torf = (bool)HashTableLoad0(true, ("HHD_IfObjectTag" + "" + "_" + lv_tag));
            // Implementation
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动O_返回Object注册状态。使用"互动O_注册Object"或"互动OG_添加Object到Object组"后可使用本函数获取注册Object在Key中的注册状态，该状态只能注销或从Object组中移除时清空。Object组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Object组转为Key
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_key">存储键区，默认值"_Object"</param>
        /// <returns></returns>
        public static bool HHD_ReturnIfObjectTagKey(object lp_object, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            bool lv_torf;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_tag = HHD_ReturnObjectTag(lp_object);
            lv_torf = (bool)HashTableLoad0(true, ("HHD_IfObjectTag" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动OG_根据自定义值类型将Object组排序。根据Object携带的自定义值类型，对指定的Object组元素进行冒泡排序。Object组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Object组名称</param>
        /// <param name="lp_cVStr">自定义值类型</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void HHD_ObjectGSortCV(string lp_key, string lp_cVStr, bool lp_big)
        {
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            string lv_tagValuestr;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            ThreadWait(lv_str);
            HashTableSave0(true, "Key_ObjectGroup" + lv_str, 1);
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = HHD_ReturnObjectTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValuestr = HHD_ReturnObjectCV(HHD_ReturnObjectFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    HashTableSave1(false, "IntStackOutTag", 1, lv_tag);
                    HashTableSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    HashTableSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < (int)HashTableLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    HashTableSave1(false, "IntStackOutTag", lv_c, HashTableLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    HashTableSave1(false, "IntStackOutTagValue", lv_c, HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    HashTableSave1(false, "IntStackOutTagIteraOrig", lv_c, HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                HashTableSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                HashTableSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                HashTableSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > (int)HashTableLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(HHD_ReturnObjectTagFromRegNum(lv_b, lp_key))+"值"+IntToString(HashTableLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    HashTableSave1(false, "IntStackOutTag", lv_c, HashTableLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(HashTableLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    HashTableSave1(false, "IntStackOutTagValue", lv_c, HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    HashTableSave1(false, "IntStackOutTagIteraOrig", lv_c, HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                HashTableSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                HashTableSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                HashTableSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        HashTableSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        HashTableSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        HashTableSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = HashTableLoad1(true, (lp_key + "ObjectTag"), lv_a).ToString(); //原始序号元素
                lv_tag = (int)HashTableLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValuestr = HHD_ReturnObjectCV(HHD_ReturnObjectFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = (int)HashTableLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    HashTableSave1(true, (lp_key + "ObjectTag"), lv_a, lv_tag); //lv_tag放入新序号
                    //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            HashTableSave0(true, "Key_ObjectGroup" + lv_str, 0);
        }

        /// <summary>
        /// 【MM_函数库】互动OG_Object组排序。对指定的Object组元素进行冒泡排序（根据元素句柄）。Object组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Object组名称</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void HHD_ObjectGSort(string lp_key, bool lp_big)
        {
            // Automatic Variable Declarations
            // Implementation
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            ThreadWait(lv_str);
            HashTableSave0(true, "Key_ObjectGroup" + lv_str, 1);
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = HHD_ReturnObjectTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValue = lv_tag;
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    HashTableSave1(false, "IntStackOutTag", 1, lv_tag);
                    HashTableSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    HashTableSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < (int)HashTableLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    HashTableSave1(false, "IntStackOutTag", lv_c, HashTableLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    HashTableSave1(false, "IntStackOutTagValue", lv_c, HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    HashTableSave1(false, "IntStackOutTagIteraOrig", lv_c, HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                HashTableSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                HashTableSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                HashTableSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > (int)HashTableLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(HHD_ReturnObjectTagFromRegNum(lv_b, lp_key))+"值"+IntToString(HashTableLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    HashTableSave1(false, "IntStackOutTag", lv_c, HashTableLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(HashTableLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    HashTableSave1(false, "IntStackOutTagValue", lv_c, HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    HashTableSave1(false, "IntStackOutTagIteraOrig", lv_c, HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                HashTableSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                HashTableSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                HashTableSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        HashTableSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        HashTableSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        HashTableSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = HashTableLoad1(true, (lp_key + "ObjectTag"), lv_a).ToString(); //原始序号元素
                lv_tag = (int)HashTableLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValue = lv_tag;
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = (int)HashTableLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                                                                                    //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    HashTableSave1(true, (lp_key + "ObjectTag"), lv_a, lv_tag); //lv_tag放入新序号
                                                                                //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            HashTableSave0(true, "Key_ObjectGroup" + lv_str, 0);
        }

        /// <summary>
        /// 【MM_函数库】互动OG_设定Object的Object组专用状态。给Object组的Object设定一个状态值（字符串），之后可用"互动O_返回Object、互动OG_返回Object组的Object状态"。状态值"true"和"false"是Object的Object组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效），而本函数可以重设干预，影响函数"互动OG_返回Object组元素数量（仅检索XX状态）"。与"互动O_设定Object状态"功能相同，只是状态参数在Object组中被固定为"Object组变量的内部ID"。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_objectGroup"></param>
        /// <param name="lp_groupState"></param>
        public static void HHD_SetObjectGState(object lp_object, string lp_objectGroup, string lp_groupState)
        {
            HHD_SetObjectState(lp_object, lp_objectGroup, lp_groupState);
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object的Object组专用状态。使用"互动O_设定Object、互动OG_设定Object组的Object状态"后可使用本函数。与"互动O_返回Object状态"功能相同，只是状态参数在Object组中被固定为"Object组变量的内部ID"。状态值"true"和"false"是Object的Object组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效）。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_objectGroup"></param>
        public static void HHD_ReturnObjectGState(object lp_object, string lp_objectGroup)
        {
            HHD_ReturnObjectState(lp_object, lp_objectGroup);
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object组元素序号对应元素。返回Object组元素序号指定Object。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static object HHD_ReturnObjectFromObjectGFunc(int lp_regNum, string lp_gs)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            object lv_object;
            // Variable Initialization
            lv_str = (lp_gs + "Object");
            lv_tag = HashTableLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            lv_object = (object)HashTableLoad0(true, ("HHD_Object_" + lv_tag));
            // Implementation
            return lv_object;
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object组元素总数。返回指定Object组的元素数量。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HHD_ReturnObjectGNumMax(string lp_gs)
        {
            return (int)HashTableLoad0(true, lp_gs + "ObjectNum");
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object组元素总数（仅检测Object组专用状态="true"）。返回指定Object组的元素数量。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HHD_ReturnObjectGNumMax_StateTrueFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            object lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HHD_ReturnObjectNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HHD_ReturnObjectFromRegNum(lv_a, lp_gs);
                lv_b = HHD_ReturnObjectState(lv_c, lp_gs);
                if ((lv_b == "true"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object组元素总数（仅检测Object组专用状态="false"）。返回指定Object组的元素数量。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HHD_ReturnObjectGNumMax_StateFalseFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            object lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HHD_ReturnObjectNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HHD_ReturnObjectFromRegNum(lv_a, lp_gs);
                lv_b = HHD_ReturnObjectState(lv_c, lp_gs);
                if ((lv_b == "false"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object组元素总数（仅检测Object组无效专用状态："false"或""）。返回指定Object组的元素数量（false、""、null）。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HHD_ReturnObjectGNumMax_StateUselessFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            object lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HHD_ReturnObjectNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HHD_ReturnObjectFromRegNum(lv_a, lp_gs);
                lv_b = HHD_ReturnObjectState(lv_c, lp_gs);
                if (((lv_b == "false") || (lv_b == "") || (lv_b == null)))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object组元素总数（仅检测Object组指定专用状态）。返回指定Object组的元素数量。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_State">Object组专用状态</param>
        /// <returns></returns>
        public static int HHD_ReturnObjectGNumMax_StateFunc_Specify(string lp_gs, string lp_State)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            object lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HHD_ReturnObjectNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HHD_ReturnObjectFromRegNum(lv_a, lp_gs);
                lv_b = HHD_ReturnObjectState(lv_c, lp_gs);
                if ((lv_b == lp_State))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动OG_添加Object到Object组。相同Object被认为是同一个，非高级功能不提供专用状态检查，如果Object没有设置过Object组专用状态，那么首次添加到Object组不会赋予"true"（之后可通过"互动O_设定Object状态"、"互动OG_设定Object组的Object状态"修改）。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HHD_AddObjectToGroup_Simple(object lp_object, string lp_gs)
        {
            HHD_RegObject_Simple(lp_object, lp_gs);
        }

        /// <summary>
        /// 【MM_函数库】互动OG_添加Object到Object组（高级）。相同Object被认为是同一个，高级功能提供专用状态检查，如果Object没有设置过Object组专用状态，那么首次添加到Object组会赋予"true"（之后可通过"互动O_设定Object状态"、"互动OG_设定Object组的Object状态"修改）。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HHD_AddObjectToGroup(object lp_object, string lp_gs)
        {
            HHD_RegObject_Simple(lp_object, lp_gs);
            if (HashTableKeyExists(true, ("HHD_ObjectState" + lp_gs + "Object_" + HHD_RegObjectTagAndReturn(lp_object))) == false)
            {
                HashTableSave0(true, ("HHD_ObjectState" + lp_gs + "Object_" + HHD_RegObjectTagAndReturn(lp_object)), "true");
                //Console.WriteLine(lp_gs + "=>" + HHD_RegObjectTagAndReturn(lp_object));
            }
        }

        /// <summary>
        /// 【MM_函数库】互动OG_移除Object组中的元素。使用"互动OG_添加Object到Object组"后可使用本函数进行移除元素。移除使用了"互动O_移除Object"，同一个存储区（Object组ID）序号重排，移除时该存储区如有其他操作会排队等待。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_object"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HHD_ClearObjectFromGroup(object lp_object, string lp_gs)
        {
            HHD_RemoveObject(lp_object, lp_gs);
        }

        //互动OG_为Object组中的每个序号
        //GE（星际2的Galaxy Editor）的宏让编辑器保存时自动生成脚本并整合进脚本进行格式调整，C#仅参考需自行编写
        // #AUTOVAR(vs, string) = "#PARAM(group)";//"#PARAM(group)"是与字段、变量名一致的元素组名称，宏去声明string类型名为“Auto随机编号_vs”的自动变量，然后=右侧字符
        // #AUTOVAR(ae) = HHD_ReturnObjectNumMax(#AUTOVAR(vs));//宏去声明默认int类型名为“Auto随机编号_ae”的自动变量，然后=右侧字符
        // #INITAUTOVAR(ai,increment)//宏去声明int类型名为“Auto随机编号_ai”的自动变量，用于下面for循环增量（increment是传入参数）
        // #PARAM(var) = #PARAM(s);//#PARAM(var)是传进来的参数，用作“当前被挑选到的元素”（任意变量-整数 lp_var）， #PARAM(s)是传进来的参数用作"开始"（int lp_s）
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #PARAM(var) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #PARAM(var) >= #AUTOVAR(ae)) ) ; #PARAM(var) += #AUTOVAR(ai) ) {
        //     #SUBFUNCS(actions)//代表用户GUI填写的所有动作
        // }

        /// <summary>
        /// 【MM_函数库】互动OG_为Object组中的每个序号。每次挑选的元素序号会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素序号，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void HHD_ForEachObjectNumFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            int lv_ae = HHD_ReturnObjectNumMax(lp_gs);
            int lv_var = lp_start;
            int lv_ai = lp_increment;
            for (; (lv_ai >= 0 && lv_var <= lv_ae) || (lv_ai < 0 && lv_var >= lv_ae); lv_var += lv_ai)
            {
                lp_funcref(lv_var);//用户填写的所有动作
            }
        }

        //互动OG_为Object组中的每个元素
        // #AUTOVAR(vs, string) = "#PARAM(group)";
        // #AUTOVAR(ae) = HHD_ReturnObjectNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= #PARAM(s);
        // #INITAUTOVAR(ai,increment)
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     HashTableSave(false, "ObjectGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)), HHD_ReturnObjectFromRegNum(#AUTOVAR(va),#AUTOVAR(vs)));
        // }
        // #AUTOVAR(va)= #PARAM(s);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #PARAM(var) = HashTableLoad(false, "ObjectGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)));
        //     #SUBFUNCS(actions)
        // }

        /// <summary>
        /// 【MM_函数库】互动OG_为Object组中的每个元素。每次挑选的元素会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void HHD_ForEachObjectFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            string lv_vs = lp_gs;
            int lv_ae = HHD_ReturnObjectNumMax(lv_vs);
            int lv_va = lp_start;
            int lv_ai = lp_increment;
            object lv_object;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                HashTableSave0(false, "ObjectGFor" + lv_vs + lv_va.ToString(), HHD_ReturnObjectFromRegNum(lv_va, lv_vs));
            }
            lv_va = lp_start;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                lv_object = HashTableLoad0(false, "ObjectGFor" + lv_vs + lv_va.ToString());
                lp_funcref(lv_object);//用户填写的所有动作
            }
        }

        /// <summary>
        /// 【MM_函数库】互动OG_返回Object组中随机元素。返回指定Object组中的随机Object。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static object HHD_ReturnRandomObjectFromObjectGFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_num;
            int lv_a;
            object lv_c = null;
            // Variable Initialization
            lv_num = HHD_ReturnObjectNumMax(lp_gs);
            // Implementation
            if ((lv_num >= 1))
            {
                lv_a = RandomInt(1, lv_num);
                lv_c = HHD_ReturnObjectFromRegNum(lv_a, lp_gs);
            }
            return lv_c;
        }

        //互动OG_添加Object组到Object组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = HHD_ReturnObjectNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = HHD_ReturnObjectFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     HHD_AddObjectToGroup(#AUTOVAR(var), #AUTOVAR(vsb));
        // }


        /// <summary>
        /// 【MM_函数库】互动OG_添加Object组到Object组。添加一个Object组A的元素到另一个Object组B，相同Object被认为是同一个。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void HHD_AddObjectGToObjectG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = HHD_ReturnObjectNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            object lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = HHD_ReturnObjectFromRegNum(lv_va, lv_vsa);
                HHD_AddObjectToGroup(lv_var, lv_vsb);
            }
        }

        //互动OG_从Object组移除Object组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = HHD_ReturnObjectNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = HHD_ReturnObjectFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     HHD_RemoveObject(#AUTOVAR(var), #AUTOVAR(vsb));
        // }

        /// <summary>
        /// 【MM_函数库】互动OG_从Object组移除Object组。将Object组A的元素从Object组B中移除，相同Object被认为是同一个。移除使用了"互动O_移除Object"，同一个存储区（Object组ID）序号重排，移除时该存储区如有其他操作会排队等待。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void HHD_ClearObjectGFromObjectG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = HHD_ReturnObjectNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            object lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = HHD_ReturnObjectFromRegNum(lv_va, lv_vsa);
                HHD_RemoveObject(lv_var, lv_vsb);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动OG_移除Object组全部元素。将Object组（Key区）存储的元素全部移除，相同Object被认为是同一个。移除时同一个存储区（Object组ID）序号不进行重排，但该存储区如有其他操作会排队等待。Object组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Object组到Object组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Object组名称</param>
        public static void HHD_RemoveObjectGAll(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag = "";
            int lv_a;
            // Variable Initialization
            lv_str = (lp_key + "Object");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            // Implementation
            ThreadWait(lv_str);
            HashTableSave0(true, "Key_ObjectGroup" + lv_str, 1);
            for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
            {
                lv_tag = HashTableLoad1(true, (lp_key + "ObjectTag"), lv_a).ToString();
                lv_num -= 1;
                HashTableClear0(true, "HHD_IfObjectTag" + lv_str + "_" + lv_tag);
                HashTableClear0(true, "HHD_ObjectCV" + lv_str + "_" + lv_tag);
                HashTableClear0(true, "HHD_ObjectState" + lv_str + "_" + lv_tag);
                HashTableSave0(true, (lp_key + "ObjectNum"), lv_num);
            }
            HashTableSave0(true, "Key_ObjectGroup" + lv_str, 0);
        }

        //--------------------------------------------------------------------------------------------------
        // 任意类型组End
        //--------------------------------------------------------------------------------------------------

        #endregion

        #region 二维向量

        //提示：尽可能使用对口类型，以防值类型与引用类型发生转换时拆装箱降低性能

        //--------------------------------------------------------------------------------------------------
        // 二维向量组Start
        //--------------------------------------------------------------------------------------------------

        /// <summary>
        /// 【MM_函数库】互动V_注册Vector标签句柄并返回。为Vector自动设置新的标签句柄，重复时会返回已注册的Vector标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns>返回一个Vector的已注册标签</returns>
        private static int HHD_RegVectorTagAndReturn_Int(Vector lp_vector)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)HashTableLoad0(true, "HHD_VectorJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                HashTableSave0(true, "HHD_VectorJBNum", lv_j);
                HashTableSave0(true, ("HHD_Vector_" + lv_j.ToString()), lp_vector);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if ((Vector)HashTableLoad0(true, ("HHD_Vector_" + lv_j.ToString())) == lp_vector)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            HashTableSave0(true, "HHD_VectorJBNum", lv_j);
                            HashTableSave0(true, ("HHD_Vector_" + lv_j.ToString()), lp_vector);
                        }
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector已注册标签句柄
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns>返回一个Vector的已注册标签，错误返回0</returns>
        public static int HHD_ReturnVectorTag_Int(Vector lp_vector)
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)HashTableLoad0(true, "HHD_VectorJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if ((Vector)HashTableLoad0(true, "HHD_Vector_" + lv_j.ToString()) == lp_vector)
                {
                    break;
                }
                else
                {
                    if ((lv_j == lv_jBNum))
                    {
                        lv_j = 0;
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动V_注册Vector标签句柄并返回。为Vector自动设置新的标签句柄，重复时会返回已注册的Vector标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns>返回一个Vector的已注册标签</returns>
        private static string HHD_RegVectorTagAndReturn(Vector lp_vector)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag = "";
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)HashTableLoad0(true, "HHD_VectorJBNum");
            lv_tag = "";
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                HashTableSave0(true, "HHD_VectorJBNum", lv_j);
                HashTableSave0(true, ("HHD_Vector_" + lv_j.ToString()), lp_vector);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if ((Vector)HashTableLoad0(true, "HHD_Vector_" + lv_j.ToString()) == lp_vector)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            HashTableSave0(true, "HHD_VectorJBNum", lv_j);
                            HashTableSave0(true, ("HHD_Vector_" + lv_j.ToString()), lp_vector);
                        }
                    }
                }
            }
            lv_tag = lv_j.ToString();
            //Console.WriteLine(("Tag：" + lv_tag));
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector已注册标签句柄
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns>返回一个Vector的已注册标签，错误返回""</returns>
        public static string HHD_ReturnVectorTag(Vector lp_vector)
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag = "";
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)HashTableLoad0(true, "HHD_VectorJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if ((Vector)HashTableLoad0(true, "HHD_Vector_" + lv_j.ToString()) == lp_vector)
                {
                    lv_tag = lv_j.ToString();
                    break;
                }
            }
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动V_注册Vector(高级)。在指定Key存入Vector，固有状态、自定义值是Vector独一无二的标志（本函数重复注册会刷新），之后可用互动V_"返回Vector注册总数"、"返回Vector序号"、"返回序号对应Vector"、"返回序号对应Vector标签"、"返回Vector自定义值"。Vector组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Vector组转为Key。首次注册时固有状态为true（相当于单位组单位活体），如需另外设置多个标记可使用"互动V_设定Vector状态/自定义值"
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        /// <param name="lp_inherentStats">固有状态</param>
        /// <param name="lp_inherentCustomValue">固有自定义值</param>
        public static void HHD_RegVector(Vector lp_vector, string lp_key, string lp_inherentStats, string lp_inherentCustomValue)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_jBNum = (int)HashTableLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = HHD_RegVectorTagAndReturn(lp_vector);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                HashTableSave0(true, (lv_str + "Num"), lv_i);
                HashTableSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                HashTableSave0(true, (("HHD_IfVectorTag" + "") + "_" + lv_tagStr), true);
                HashTableSave1(true, ("HHD_IfVectorTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if ((HashTableLoad1(true, (lv_str + "Tag"), lv_i).ToString() == lv_tagStr))
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                HashTableSave0(true, (lv_str + "Num"), lv_i);
                                HashTableSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                HashTableSave0(true, (("HHD_IfVectorTag" + "") + "_" + lv_tagStr), true);
                                HashTableSave1(true, ("HHD_IfVectorTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            HashTableSave0(true, ("HHD_VectorState" + "" + "_" + lv_tagStr), lp_inherentStats);
            HashTableSave0(true, ("HHD_VectorCV" + "" + "_" + lv_tagStr), lp_inherentCustomValue);
        }

        /// <summary>
        /// 【MM_函数库】互动V_注册Vector。在指定Key存入Vector，固有状态、自定义值是Vector独一无二的标志（本函数重复注册不会刷新），之后可用互动V_"返回Vector注册总数"、"返回Vector序号"、"返回序号对应Vector"、"返回Vector自定义值"。Vector组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Vector组转为Key。首次注册时固有状态为true（相当于单位组单位活体），之后只能通过"互动V_注册Vector（高级）"改写，如需另外设置多个标记可使用"互动V_设定Vector状态/自定义值"
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        public static void HHD_RegVector_Simple(Vector lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_jBNum = (int)HashTableLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = HHD_RegVectorTagAndReturn(lp_vector);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                HashTableSave0(true, (lv_str + "Num"), lv_i);
                HashTableSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                HashTableSave0(true, (("HHD_IfVectorTag" + "") + "_" + lv_tagStr), true);
                HashTableSave1(true, ("HHD_IfVectorTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if ((HashTableLoad1(true, (lv_str + "Tag"), lv_i).ToString() == lv_tagStr))
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                HashTableSave0(true, (lv_str + "Num"), lv_i);
                                HashTableSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                HashTableSave0(true, (("HHD_IfVectorTag" + "") + "_" + lv_tagStr), true);
                                HashTableSave1(true, ("HHD_IfVectorTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            if ((HashTableKeyExists(true, ("HHD_Vector" + "State" + "_" + lv_tag.ToString())) == false))
            {
                HashTableSave1(true, (("HHD_Vector" + "State")), lv_tag, "true");
            }
        }

        /// <summary>
        /// 【MM_函数库】互动V_注销Vector。用"互动V_注册Vector"到Key，之后可用本函数彻底摧毁注册信息并将序号重排（包括Vector标签有效状态、固有状态及自定义值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动V_设定Vector状态"让Vector状态失效（类似单位组的单位活体状态）。Vector组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Vector组转为Key。本函数无法摧毁用"互动V_设定Vector状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Vector组变量ID时会清空Vector组专用状态
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        public static void HHD_DestroyVector(Vector lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag = "";
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_tag = HHD_ReturnVectorTag(lp_vector);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                HashTableSave0(true, "Key_VectorGroup" + lv_str, 1);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((HashTableLoad1(true, (lp_key + "VectorTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        HashTableClear0(true, "HHD_IfVectorTag_" + lv_tag);
                        HashTableClear0(true, "HHD_IfVectorTag" + lv_str + "_" + lv_tag);
                        HashTableClear0(true, "HHD_Vector_" + lv_tag);
                        HashTableClear0(true, "HHD_VectorCV_" + lv_tag);
                        HashTableClear0(true, "HHD_VectorState_" + lv_tag);
                        HashTableClear0(true, "HHD_VectorCV" + lv_str + "_" + lv_tag);
                        HashTableClear0(true, "HHD_VectorState" + lv_str + "_" + lv_tag);
                        HashTableSave0(true, (lp_key + "VectorNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = HashTableLoad1(true, (lp_key + "VectorTag"), lv_b + 1).ToString();
                            HashTableSave1(true, (lp_key + "VectorTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                HashTableSave0(true, "Key_VectorGroup" + lv_str, 0);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动V_移除Vector。用"互动V_注册Vector"到Key，之后可用本函数仅摧毁Key区注册的信息并将序号重排，用于Vector组或多个键区仅移除Vector（保留Vector标签有效状态、固有值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动V_设定Vector状态"让Vector状态失效（类似单位组的单位活体状态）。Vector组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Vector组转为Key。本函数无法摧毁用"互动V_设定Vector状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Vector组变量ID时会清空Vector组专用状态
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        public static void HHD_RemoveVector(Vector lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag = "";
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_tag = HHD_ReturnVectorTag(lp_vector);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                HashTableSave0(true, "Key_VectorGroup" + lv_str, 1);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((HashTableLoad1(true, (lp_key + "VectorTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        HashTableClear0(true, "HHD_IfVectorTag" + lv_str + "_" + lv_tag);
                        HashTableClear0(true, "HHD_VectorCV" + lv_str + "_" + lv_tag);
                        HashTableClear0(true, "HHD_VectorState" + lv_str + "_" + lv_tag);
                        HashTableSave0(true, (lp_key + "VectorNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = HashTableLoad1(true, (lp_key + "VectorTag"), lv_b + 1).ToString();
                            HashTableSave1(true, (lp_key + "VectorTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                HashTableSave0(true, "Key_VectorGroup" + lv_str, 0);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector注册总数。必须先使用"互动V_注册Vector"才能返回指定Key里的注册总数。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key。
        /// </summary>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        /// <returns></returns>
        public static int HHD_ReturnVectorNumMax(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            // Implementation
            return lv_num;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector序号。使用"互动V_注册Vector"后使用本函数可返回Key里的注册序号，Key无元素返回0，Key有元素但对象不在里面则返回-1，Vector标签尚未注册则返回-2。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        /// <returns></returns>
        public static int HHD_ReturnVectorNum(Vector lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_i;
            string lv_tag = "";
            int lv_torf;
            // Automatic Variable Declarations
            const int auto_n = 1;
            int auto_i;
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_tag = HHD_ReturnVectorTag(lp_vector);
            lv_torf = -1;
            // Implementation
            for (auto_i = 1; auto_i <= auto_n; auto_i += 1)
            {
                if ((lv_tag != null))
                {
                    lv_torf = -2;
                    break;
                }
                if ((lv_num == 0))
                {
                    lv_torf = 0;
                }
                else
                {
                    if ((lv_num >= 1))
                    {
                        auto_ae = lv_num;
                        auto_var = 1;
                        for (; auto_var <= auto_ae; auto_var += 1)
                        {
                            lv_i = auto_var;
                            if ((HashTableLoad1(true, (lv_str + "Tag"), lv_i).ToString() == lv_tag))
                            {
                                lv_torf = lv_i;
                                break;
                            }
                        }
                    }
                }
            }
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回序号对应Vector。使用"互动V_注册Vector"后，在参数填入注册序号可返回Vector。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_regNum"></param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        /// <returns></returns>
        public static Vector HHD_ReturnVectorFromRegNum(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            Vector lv_vector;
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            lv_tag = HashTableLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            lv_vector = (Vector)HashTableLoad0(true, ("HHD_Vector_" + lv_tag));
            // Implementation
            return lv_vector;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回句柄标签对应Vector。使用"互动V_注册Vector"后，在参数填入句柄标签（整数）可返回Vector，标签是Vector的句柄。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_tag">句柄标签</param>
        /// <returns></returns>
        public static Vector HHD_ReturnVectorFromTag(int lp_tag)
        {
            // Variable Declarations
            string lv_tag = "";
            Vector lv_vector;
            // Variable Initialization
            lv_tag = lp_tag.ToString();
            lv_vector = (Vector)HashTableLoad0(true, ("HHD_Vector_" + lv_tag));
            // Implementation
            return lv_vector;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回序号对应Vector标签句柄。使用"互动V_注册Vector"后，在参数填入注册序号可返回Vector标签（字符串）。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        /// <returns></returns>
        public static string HHD_ReturnVectorTagFromRegNum_String(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            lv_tag = HashTableLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回序号对应Vector标签句柄。使用"互动V_注册Vector"后，在参数填入注册序号可返回Vector标签（整数）。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        /// <returns></returns>
        public static int HHD_ReturnVectorTagFromRegNum_Int(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            lv_tag = HashTableLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return Convert.ToInt32(lv_tag);
        }

        /// <summary>
        /// 【MM_函数库】互动V_设置Vector状态。必须先"注册"获得功能库内部句柄，再使用本函数给Vector设定一个状态值，之后可用"互动V_返回Vector状态"。类型参数用以记录多个不同状态，仅当"类型"参数填Vector组ID转的Vector串时，状态值"true"和"false"是Vector的Vector组专用状态值，用于内部函数筛选Vector状态（相当于单位组单位索引是否有效），其他类型不会干扰系统内部，可随意填写。虽然注销时反向清空注册信息，但用"互动V_设定Vector状态/自定义值"创建的值需要手工填入""来排泄（非大量注销则提升内存量极小，可不管）。注：固有状态值是注册函数赋予的系统内部变量（相当于单位组单位是否活体），只能通过"互动V_注册Vector（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <param name="lp_stats">状态</param>
        public static void HHD_SetVectorState(Vector lp_vector, string lp_key, string lp_stats)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            lv_tag = HHD_RegVectorTagAndReturn(lp_vector);
            // Implementation
            HashTableSave0(true, ("HHD_VectorState" + lv_str + "_" + lv_tag), lp_stats);
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector状态。使用"互动V_设定Vector状态"后可使用本函数，将本函数参数"类型"设为空时返回固有值。类型参数用以记录多个不同状态，仅当"类型"参数为Vector组ID转的字符串时，返回的状态值"true"和"false"是Vector的Vector组专用状态值，用于内部函数筛选Vector状态（相当于单位组单位索引是否有效）
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <returns></returns>
        public static string HHD_ReturnVectorState(Vector lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            lv_tag = HHD_ReturnVectorTag(lp_vector);
            lv_stats = HashTableLoad0(true, ("HHD_VectorState" + lv_str + "_" + lv_tag)).ToString();
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动V_设置Vector自定义值。必须先"注册"获得功能库内部句柄，再使用本函数设定Vector的自定义值，之后可使用"互动V_返回Vector自定义值"，类型参数用以记录多个不同自定义值。注：固有自定义值是注册函数赋予的系统内部变量，只能通过"互动V_注册Vector（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <param name="lp_customValue">自定义值</param>
        public static void HHD_SetVectorCV(Vector lp_vector, string lp_key, string lp_customValue)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            lv_tag = HHD_RegVectorTagAndReturn(lp_vector);
            // Implementation
            HashTableSave0(true, ("HHD_VectorCV" + lv_str + "_" + lv_tag), lp_customValue);
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector自定义值。使用"互动V_设定Vector自定义值"后可使用本函数，将本函数参数"类型"设为空时返回固有值，该参数用以记录多个不同自定义值
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <returns></returns>
        public static string HHD_ReturnVectorCV(Vector lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            lv_tag = HHD_ReturnVectorTag(lp_vector);
            lv_customValue = HashTableLoad0(true, ("HHD_VectorCV" + lv_str + "_" + lv_tag)).ToString();
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector固有状态。必须先使用"互动V_注册Vector"才能返回到该值，固有状态是独一无二的标记（相当于单位组单位是否活体）
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns></returns>
        public static string HHD_ReturnVectorState_Only(Vector lp_vector)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_tag = HHD_ReturnVectorTag(lp_vector);
            lv_stats = HashTableLoad0(true, ("HHD_VectorState" + "" + "_" + lv_tag)).ToString();
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector固有自定义值。必须先使用"互动V_注册Vector"才能返回到该值，固有值是独一无二的标记
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns></returns>
        public static string HHD_ReturnVectorCV_Only(Vector lp_vector)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_tag = HHD_ReturnVectorTag(lp_vector);
            lv_customValue = HashTableLoad0(true, ("HHD_VectorCV" + "" + "_" + lv_tag)).ToString();
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动V_设置Vector的实数标记。必须先"注册"获得功能库内部句柄，再使用本函数让Vector携带一个实数值，之后可使用"互动V_返回Vector的实数标记"。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_realNumTag">实数标记</param>
        public static void HHD_SetVectorDouble(Vector lp_vector, double lp_realNumTag)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = HHD_RegVectorTagAndReturn(lp_vector);
            // Implementation
            HashTableSave0(true, ("HHD_CDDouble_T_" + lv_tag), lp_realNumTag);
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector的实数标记。使用"互动V_设定Vector的实数标记"后可使用本函数。Vector组使用时，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns></returns>
        public static double HHD_ReturnVectorDouble(Vector lp_vector)
        {
            // Variable Declarations
            string lv_tag = "";
            double lv_f;
            // Variable Initialization
            lv_tag = HHD_ReturnVectorTag(lp_vector);
            lv_f = (double)HashTableLoad0(true, ("HHD_CDDouble_T_" + lv_tag));
            // Implementation
            return lv_f;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector标签句柄有效状态。将Vector视作独一无二的个体，标签是它本身，有效状态则类似"单位是否有效"，当使用"互动V_注册Vector"或"互动VG_添加Vector到Vector组"后激活Vector有效状态（值为"true"），除非使用"互动V_注册Vector（高级）"改写，否则直到注销才会摧毁
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <returns></returns>
        public static bool HHD_ReturnIfVectorTag(Vector lp_vector)
        {
            // Variable Declarations
            string lv_tag = "";
            bool lv_torf;
            // Variable Initialization
            lv_tag = HHD_ReturnVectorTag(lp_vector);
            lv_torf = (bool)HashTableLoad0(true, ("HHD_IfVectorTag" + "" + "_" + lv_tag));
            // Implementation
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动V_返回Vector注册状态。使用"互动V_注册Vector"或"互动VG_添加Vector到Vector组"后可使用本函数获取注册Vector在Key中的注册状态，该状态只能注销或从Vector组中移除时清空。Vector组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Vector组转为Key
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_key">存储键区，默认值"_Vector"</param>
        /// <returns></returns>
        public static bool HHD_ReturnIfVectorTagKey(Vector lp_vector, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            bool lv_torf;
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            lv_tag = HHD_ReturnVectorTag(lp_vector);
            lv_torf = (bool)HashTableLoad0(true, ("HHD_IfVectorTag" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动VG_根据自定义值类型将Vector组排序。根据Vector携带的自定义值类型，对指定的Vector组元素进行冒泡排序。Vector组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Vector组名称</param>
        /// <param name="lp_cVStr">自定义值类型</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void HHD_VectorGSortCV(string lp_key, string lp_cVStr, bool lp_big)
        {
            // Automatic Variable Declarations
            // Implementation
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            string lv_tagValuestr;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            ThreadWait(lv_str);
            HashTableSave0(true, "Key_VectorGroup" + lv_str, 1);
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = HHD_ReturnVectorTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValuestr = HHD_ReturnVectorCV(HHD_ReturnVectorFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    HashTableSave1(false, "IntStackOutTag", 1, lv_tag);
                    HashTableSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    HashTableSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < (int)HashTableLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    HashTableSave1(false, "IntStackOutTag", lv_c, HashTableLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    HashTableSave1(false, "IntStackOutTagValue", lv_c, HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    HashTableSave1(false, "IntStackOutTagIteraOrig", lv_c, HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                HashTableSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                HashTableSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                HashTableSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > (int)HashTableLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(HHD_ReturnVectorTagFromRegNum(lv_b, lp_key))+"值"+IntToString(HashTableLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    HashTableSave1(false, "IntStackOutTag", lv_c, HashTableLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(HashTableLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    HashTableSave1(false, "IntStackOutTagValue", lv_c, HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    HashTableSave1(false, "IntStackOutTagIteraOrig", lv_c, HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                HashTableSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                HashTableSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                HashTableSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        HashTableSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        HashTableSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        HashTableSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = HashTableLoad1(true, (lp_key + "VectorTag"), lv_a).ToString(); //原始序号元素
                lv_tag = (int)HashTableLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValuestr = HHD_ReturnVectorCV(HHD_ReturnVectorFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = (int)HashTableLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    HashTableSave1(true, (lp_key + "VectorTag"), lv_a, lv_tag); //lv_tag放入新序号
                    //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            HashTableSave0(true, "Key_VectorGroup" + lv_str, 0);
        }

        /// <summary>
        /// 【MM_函数库】互动VG_Vector组排序。对指定的Vector组元素进行冒泡排序（根据元素句柄）。Vector组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Vector组名称</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void HHD_VectorGSort(string lp_key, bool lp_big)
        {
            // Automatic Variable Declarations
            // Implementation
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            ThreadWait(lv_str);
            HashTableSave0(true, "Key_VectorGroup" + lv_str, 1);
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = HHD_ReturnVectorTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValue = lv_tag;
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    HashTableSave1(false, "IntStackOutTag", 1, lv_tag);
                    HashTableSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    HashTableSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < (int)HashTableLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    HashTableSave1(false, "IntStackOutTag", lv_c, HashTableLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    HashTableSave1(false, "IntStackOutTagValue", lv_c, HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    HashTableSave1(false, "IntStackOutTagIteraOrig", lv_c, HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                HashTableSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                HashTableSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                HashTableSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > (int)HashTableLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(HHD_ReturnVectorTagFromRegNum(lv_b, lp_key))+"值"+IntToString(HashTableLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    HashTableSave1(false, "IntStackOutTag", lv_c, HashTableLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(HashTableLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    HashTableSave1(false, "IntStackOutTagValue", lv_c, HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    HashTableSave1(false, "IntStackOutTagIteraOrig", lv_c, HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                HashTableSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                HashTableSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                HashTableSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        HashTableSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        HashTableSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        HashTableSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = HashTableLoad1(true, (lp_key + "VectorTag"), lv_a).ToString(); //原始序号元素
                lv_tag = (int)HashTableLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValue = lv_tag;
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = (int)HashTableLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                                                                                    //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    HashTableSave1(true, (lp_key + "VectorTag"), lv_a, lv_tag); //lv_tag放入新序号
                                                                                //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            HashTableSave0(true, "Key_VectorGroup" + lv_str, 0);
        }

        /// <summary>
        /// 【MM_函数库】互动VG_设定Vector的Vector组专用状态。给Vector组的Vector设定一个状态值（字符串），之后可用"互动V_返回Vector、互动VG_返回Vector组的Vector状态"。状态值"true"和"false"是Vector的Vector组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效），而本函数可以重设干预，影响函数"互动VG_返回Vector组元素数量（仅检索XX状态）"。与"互动V_设定Vector状态"功能相同，只是状态参数在Vector组中被固定为"Vector组变量的内部ID"。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_vectorGroup"></param>
        /// <param name="lp_groupState"></param>
        public static void HHD_SetVectorGState(Vector lp_vector, string lp_vectorGroup, string lp_groupState)
        {
            HHD_SetVectorState(lp_vector, lp_vectorGroup, lp_groupState);
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector的Vector组专用状态。使用"互动V_设定Vector、互动VG_设定Vector组的Vector状态"后可使用本函数。与"互动V_返回Vector状态"功能相同，只是状态参数在Vector组中被固定为"Vector组变量的内部ID"。状态值"true"和"false"是Vector的Vector组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效）。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_vectorGroup"></param>
        public static void HHD_ReturnVectorGState(Vector lp_vector, string lp_vectorGroup)
        {
            HHD_ReturnVectorState(lp_vector, lp_vectorGroup);
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector组元素序号对应元素。返回Vector组元素序号指定Vector。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static Vector HHD_ReturnVectorFromVectorGFunc(int lp_regNum, string lp_gs)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            Vector lv_vector;
            // Variable Initialization
            lv_str = (lp_gs + "Vector");
            lv_tag = HashTableLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            lv_vector = (Vector)HashTableLoad0(true, ("HHD_Vector_" + lv_tag));
            // Implementation
            return lv_vector;
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector组元素总数。返回指定Vector组的元素数量。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HHD_ReturnVectorGNumMax(string lp_gs)
        {
            return (int)HashTableLoad0(true, lp_gs + "VectorNum");
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector组元素总数（仅检测Vector组专用状态="true"）。返回指定Vector组的元素数量。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HHD_ReturnVectorGNumMax_StateTrueFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Vector lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HHD_ReturnVectorNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HHD_ReturnVectorFromRegNum(lv_a, lp_gs);
                lv_b = HHD_ReturnVectorState(lv_c, lp_gs);
                if ((lv_b == "true"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector组元素总数（仅检测Vector组专用状态="false"）。返回指定Vector组的元素数量。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HHD_ReturnVectorGNumMax_StateFalseFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Vector lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HHD_ReturnVectorNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HHD_ReturnVectorFromRegNum(lv_a, lp_gs);
                lv_b = HHD_ReturnVectorState(lv_c, lp_gs);
                if ((lv_b == "false"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector组元素总数（仅检测Vector组无效专用状态："false"或""）。返回指定Vector组的元素数量（false、""、null）。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HHD_ReturnVectorGNumMax_StateUselessFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Vector lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HHD_ReturnVectorNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HHD_ReturnVectorFromRegNum(lv_a, lp_gs);
                lv_b = HHD_ReturnVectorState(lv_c, lp_gs);
                if (((lv_b == "false") || (lv_b == "") || (lv_b == null)))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector组元素总数（仅检测Vector组指定专用状态）。返回指定Vector组的元素数量。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_State">Vector组专用状态</param>
        /// <returns></returns>
        public static int HHD_ReturnVectorGNumMax_StateFunc_Specify(string lp_gs, string lp_State)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Vector lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HHD_ReturnVectorNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HHD_ReturnVectorFromRegNum(lv_a, lp_gs);
                lv_b = HHD_ReturnVectorState(lv_c, lp_gs);
                if ((lv_b == lp_State))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动VG_添加Vector到Vector组。相同Vector被认为是同一个，非高级功能不提供专用状态检查，如果Vector没有设置过Vector组专用状态，那么首次添加到Vector组不会赋予"true"（之后可通过"互动V_设定Vector状态"、"互动VG_设定Vector组的Vector状态"修改）。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HHD_AddVectorToGroup_Simple(Vector lp_vector, string lp_gs)
        {
            HHD_RegVector_Simple(lp_vector, lp_gs);
        }

        /// <summary>
        /// 【MM_函数库】互动VG_添加Vector到Vector组（高级）。相同Vector被认为是同一个，高级功能提供专用状态检查，如果Vector没有设置过Vector组专用状态，那么首次添加到Vector组会赋予"true"（之后可通过"互动V_设定Vector状态"、"互动VG_设定Vector组的Vector状态"修改）。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HHD_AddVectorToGroup(Vector lp_vector, string lp_gs)
        {
            HHD_RegVector_Simple(lp_vector, lp_gs);
            if (HashTableKeyExists(true, ("HHD_VectorState" + lp_gs + "Vector_" + HHD_RegVectorTagAndReturn(lp_vector))) == false)
            {
                HashTableSave0(true, ("HHD_VectorState" + lp_gs + "Vector_" + HHD_RegVectorTagAndReturn(lp_vector)), "true");
                //Console.WriteLine(lp_gs + "=>" + HHD_RegVectorTagAndReturn(lp_vector));
            }
        }

        /// <summary>
        /// 【MM_函数库】互动VG_移除Vector组中的元素。使用"互动VG_添加Vector到Vector组"后可使用本函数进行移除元素。移除使用了"互动V_移除Vector"，同一个存储区（Vector组ID）序号重排，移除时该存储区如有其他操作会排队等待。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_vector"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HHD_ClearVectorFromGroup(Vector lp_vector, string lp_gs)
        {
            HHD_RemoveVector(lp_vector, lp_gs);
        }

        //互动VG_为Vector组中的每个序号
        //GE（星际2的Galaxy Editor）的宏让编辑器保存时自动生成脚本并整合进脚本进行格式调整，C#仅参考需自行编写
        // #AUTOVAR(vs, string) = "#PARAM(group)";//"#PARAM(group)"是与字段、变量名一致的元素组名称，宏去声明string类型名为“Auto随机编号_vs”的自动变量，然后=右侧字符
        // #AUTOVAR(ae) = HHD_ReturnVectorNumMax(#AUTOVAR(vs));//宏去声明默认int类型名为“Auto随机编号_ae”的自动变量，然后=右侧字符
        // #INITAUTOVAR(ai,increment)//宏去声明int类型名为“Auto随机编号_ai”的自动变量，用于下面for循环增量（increment是传入参数）
        // #PARAM(var) = #PARAM(s);//#PARAM(var)是传进来的参数，用作“当前被挑选到的元素”（任意变量-整数 lp_var）， #PARAM(s)是传进来的参数用作"开始"（int lp_s）
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #PARAM(var) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #PARAM(var) >= #AUTOVAR(ae)) ) ; #PARAM(var) += #AUTOVAR(ai) ) {
        //     #SUBFUNCS(actions)//代表用户GUI填写的所有动作
        // }

        /// <summary>
        /// 【MM_函数库】互动VG_为Vector组中的每个序号。每次挑选的元素序号会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素序号，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void HHD_ForEachVectorNumFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            int lv_ae = HHD_ReturnVectorNumMax(lp_gs);
            int lv_var = lp_start;
            int lv_ai = lp_increment;
            for (; (lv_ai >= 0 && lv_var <= lv_ae) || (lv_ai < 0 && lv_var >= lv_ae); lv_var += lv_ai)
            {
                lp_funcref(lv_var);//用户填写的所有动作
            }
        }

        //互动VG_为Vector组中的每个元素
        // #AUTOVAR(vs, string) = "#PARAM(group)";
        // #AUTOVAR(ae) = HHD_ReturnVectorNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= #PARAM(s);
        // #INITAUTOVAR(ai,increment)
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     HashTableSave(false, "VectorGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)), HHD_ReturnVectorFromRegNum(#AUTOVAR(va),#AUTOVAR(vs)));
        // }
        // #AUTOVAR(va)= #PARAM(s);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #PARAM(var) = HashTableLoad(false, "VectorGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)));
        //     #SUBFUNCS(actions)
        // }

        /// <summary>
        /// 【MM_函数库】互动VG_为Vector组中的每个元素。每次挑选的元素会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void HHD_ForEachVectorFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            string lv_vs = lp_gs;
            int lv_ae = HHD_ReturnVectorNumMax(lv_vs);
            int lv_va = lp_start;
            int lv_ai = lp_increment;
            Vector lv_vector;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                HashTableSave0(false, "VectorGFor" + lv_vs + lv_va.ToString(), HHD_ReturnVectorFromRegNum(lv_va, lv_vs));
            }
            lv_va = lp_start;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                lv_vector = (Vector)HashTableLoad0(false, "VectorGFor" + lv_vs + lv_va.ToString());
                lp_funcref(lv_vector);//用户填写的所有动作
            }
        }

        /// <summary>
        /// 【MM_函数库】互动VG_返回Vector组中随机元素。返回指定Vector组中的随机Vector。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static Vector HHD_ReturnRandomVectorFromVectorGFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_num;
            int lv_a;
            Vector lv_c = new Vector(0, 0);
            // Variable Initialization
            lv_num = HHD_ReturnVectorNumMax(lp_gs);
            // Implementation
            if ((lv_num >= 1))
            {
                lv_a = RandomInt(1, lv_num);
                lv_c = HHD_ReturnVectorFromRegNum(lv_a, lp_gs);
            }
            return lv_c;
        }

        //互动VG_添加Vector组到Vector组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = HHD_ReturnVectorNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = HHD_ReturnVectorFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     HHD_AddVectorToGroup(#AUTOVAR(var), #AUTOVAR(vsb));
        // }


        /// <summary>
        /// 【MM_函数库】互动VG_添加Vector组到Vector组。添加一个Vector组A的元素到另一个Vector组B，相同Vector被认为是同一个。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void HHD_AddVectorGToVectorG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = HHD_ReturnVectorNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            Vector lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = HHD_ReturnVectorFromRegNum(lv_va, lv_vsa);
                HHD_AddVectorToGroup(lv_var, lv_vsb);
            }
        }

        //互动VG_从Vector组移除Vector组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = HHD_ReturnVectorNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = HHD_ReturnVectorFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     HHD_RemoveVector(#AUTOVAR(var), #AUTOVAR(vsb));
        // }

        /// <summary>
        /// 【MM_函数库】互动VG_从Vector组移除Vector组。将Vector组A的元素从Vector组B中移除，相同Vector被认为是同一个。移除使用了"互动V_移除Vector"，同一个存储区（Vector组ID）序号重排，移除时该存储区如有其他操作会排队等待。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void HHD_ClearVectorGFromVectorG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = HHD_ReturnVectorNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            Vector lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = HHD_ReturnVectorFromRegNum(lv_va, lv_vsa);
                HHD_RemoveVector(lv_var, lv_vsb);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动VG_移除Vector组全部元素。将Vector组（Key区）存储的元素全部移除，相同Vector被认为是同一个。移除时同一个存储区（Vector组ID）序号不进行重排，但该存储区如有其他操作会排队等待。Vector组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Vector组到Vector组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Vector组名称</param>
        public static void HHD_RemoveVectorGAll(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag = "";
            int lv_a;
            // Variable Initialization
            lv_str = (lp_key + "Vector");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            // Implementation
            ThreadWait(lv_str);
            HashTableSave0(true, "Key_VectorGroup" + lv_str, 1);
            for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
            {
                lv_tag = HashTableLoad1(true, (lp_key + "VectorTag"), lv_a).ToString();
                lv_num -= 1;
                HashTableClear0(true, "HHD_IfVectorTag" + lv_str + "_" + lv_tag);
                HashTableClear0(true, "HHD_VectorCV" + lv_str + "_" + lv_tag);
                HashTableClear0(true, "HHD_VectorState" + lv_str + "_" + lv_tag);
                HashTableSave0(true, (lp_key + "VectorNum"), lv_num);
            }
            HashTableSave0(true, "Key_VectorGroup" + lv_str, 0);
        }

        //--------------------------------------------------------------------------------------------------
        // 二维向量组End
        //--------------------------------------------------------------------------------------------------

        #endregion

        #region 计时器

        //提示：尽可能使用对口类型，以防值类型与引用类型发生转换时拆装箱降低性能

        //--------------------------------------------------------------------------------------------------
        // 计时器组Start
        //--------------------------------------------------------------------------------------------------

        /// <summary>
        /// 【MM_函数库】互动T_注册Timer标签句柄并返回。为Timer自动设置新的标签句柄，重复时会返回已注册的Timer标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns>返回一个Timer的已注册标签</returns>
        private static int HHD_RegTimerTagAndReturn_Int(Timer lp_timer)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)HashTableLoad0(true, "HHD_TimerJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                HashTableSave0(true, "HHD_TimerJBNum", lv_j);
                HashTableSave0(true, ("HHD_Timer_" + lv_j.ToString()), lp_timer);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if ((Timer)HashTableLoad0(true, ("HHD_Timer_" + lv_j.ToString())) == lp_timer)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            HashTableSave0(true, "HHD_TimerJBNum", lv_j);
                            HashTableSave0(true, ("HHD_Timer_" + lv_j.ToString()), lp_timer);
                        }
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer已注册标签句柄
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns>返回一个Timer的已注册标签，错误返回0</returns>
        public static int HHD_ReturnTimerTag_Int(Timer lp_timer)
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)HashTableLoad0(true, "HHD_TimerJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if ((Timer)HashTableLoad0(true, "HHD_Timer_" + lv_j.ToString()) == lp_timer)
                {
                    break;
                }
                else
                {
                    if ((lv_j == lv_jBNum))
                    {
                        lv_j = 0;
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动T_注册Timer标签句柄并返回。为Timer自动设置新的标签句柄，重复时会返回已注册的Timer标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns>返回一个Timer的已注册标签</returns>
        private static string HHD_RegTimerTagAndReturn(Timer lp_timer)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag = "";
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)HashTableLoad0(true, "HHD_TimerJBNum");
            lv_tag = "";
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                HashTableSave0(true, "HHD_TimerJBNum", lv_j);
                HashTableSave0(true, ("HHD_Timer_" + lv_j.ToString()), lp_timer);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if ((Timer)HashTableLoad0(true, "HHD_Timer_" + lv_j.ToString()) == lp_timer)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            HashTableSave0(true, "HHD_TimerJBNum", lv_j);
                            HashTableSave0(true, ("HHD_Timer_" + lv_j.ToString()), lp_timer);
                        }
                    }
                }
            }
            lv_tag = lv_j.ToString();
            //Console.WriteLine(("Tag：" + lv_tag));
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer已注册标签句柄
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns>返回一个Timer的已注册标签，错误返回""</returns>
        public static string HHD_ReturnTimerTag(Timer lp_timer)
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag = "";
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)HashTableLoad0(true, "HHD_TimerJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if ((Timer)HashTableLoad0(true, "HHD_Timer_" + lv_j.ToString()) == lp_timer)
                {
                    lv_tag = lv_j.ToString();
                    break;
                }
            }
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动T_注册Timer(高级)。在指定Key存入Timer，固有状态、自定义值是Timer独一无二的标志（本函数重复注册会刷新），之后可用互动T_"返回Timer注册总数"、"返回Timer序号"、"返回序号对应Timer"、"返回序号对应Timer标签"、"返回Timer自定义值"。Timer组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Timer组转为Key。首次注册时固有状态为true（相当于单位组单位活体），如需另外设置多个标记可使用"互动T_设定Timer状态/自定义值"
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        /// <param name="lp_inherentStats">固有状态</param>
        /// <param name="lp_inherentCustomValue">固有自定义值</param>
        public static void HHD_RegTimer(Timer lp_timer, string lp_key, string lp_inherentStats, string lp_inherentCustomValue)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_jBNum = (int)HashTableLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = HHD_RegTimerTagAndReturn(lp_timer);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                HashTableSave0(true, (lv_str + "Num"), lv_i);
                HashTableSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                HashTableSave0(true, (("HHD_IfTimerTag" + "") + "_" + lv_tagStr), true);
                HashTableSave1(true, ("HHD_IfTimerTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if ((HashTableLoad1(true, (lv_str + "Tag"), lv_i).ToString() == lv_tagStr))
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                HashTableSave0(true, (lv_str + "Num"), lv_i);
                                HashTableSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                HashTableSave0(true, (("HHD_IfTimerTag" + "") + "_" + lv_tagStr), true);
                                HashTableSave1(true, ("HHD_IfTimerTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            HashTableSave0(true, ("HHD_TimerState" + "" + "_" + lv_tagStr), lp_inherentStats);
            HashTableSave0(true, ("HHD_TimerCV" + "" + "_" + lv_tagStr), lp_inherentCustomValue);
        }

        /// <summary>
        /// 【MM_函数库】互动T_注册Timer。在指定Key存入Timer，固有状态、自定义值是Timer独一无二的标志（本函数重复注册不会刷新），之后可用互动T_"返回Timer注册总数"、"返回Timer序号"、"返回序号对应Timer"、"返回Timer自定义值"。Timer组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Timer组转为Key。首次注册时固有状态为true（相当于单位组单位活体），之后只能通过"互动T_注册Timer（高级）"改写，如需另外设置多个标记可使用"互动T_设定Timer状态/自定义值"
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        public static void HHD_RegTimer_Simple(Timer lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_jBNum = (int)HashTableLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = HHD_RegTimerTagAndReturn(lp_timer);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                HashTableSave0(true, (lv_str + "Num"), lv_i);
                HashTableSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                HashTableSave0(true, (("HHD_IfTimerTag" + "") + "_" + lv_tagStr), true);
                HashTableSave1(true, ("HHD_IfTimerTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if ((HashTableLoad1(true, (lv_str + "Tag"), lv_i).ToString() == lv_tagStr))
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                HashTableSave0(true, (lv_str + "Num"), lv_i);
                                HashTableSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                HashTableSave0(true, (("HHD_IfTimerTag" + "") + "_" + lv_tagStr), true);
                                HashTableSave1(true, ("HHD_IfTimerTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            if ((HashTableKeyExists(true, ("HHD_Timer" + "State" + "_" + lv_tag.ToString())) == false))
            {
                HashTableSave1(true, (("HHD_Timer" + "State")), lv_tag, "true");
            }
        }

        /// <summary>
        /// 【MM_函数库】互动T_注销Timer。用"互动T_注册Timer"到Key，之后可用本函数彻底摧毁注册信息并将序号重排（包括Timer标签有效状态、固有状态及自定义值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动T_设定Timer状态"让Timer状态失效（类似单位组的单位活体状态）。Timer组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Timer组转为Key。本函数无法摧毁用"互动T_设定Timer状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Timer组变量ID时会清空Timer组专用状态
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        public static void HHD_DestroyTimer(Timer lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag = "";
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_tag = HHD_ReturnTimerTag(lp_timer);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                HashTableSave0(true, "Key_TimerGroup" + lv_str, 1);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((HashTableLoad1(true, (lp_key + "TimerTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        HashTableClear0(true, "HHD_IfTimerTag_" + lv_tag);
                        HashTableClear0(true, "HHD_IfTimerTag" + lv_str + "_" + lv_tag);
                        HashTableClear0(true, "HHD_Timer_" + lv_tag);
                        HashTableClear0(true, "HHD_TimerCV_" + lv_tag);
                        HashTableClear0(true, "HHD_TimerState_" + lv_tag);
                        HashTableClear0(true, "HHD_TimerCV" + lv_str + "_" + lv_tag);
                        HashTableClear0(true, "HHD_TimerState" + lv_str + "_" + lv_tag);
                        HashTableSave0(true, (lp_key + "TimerNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = HashTableLoad1(true, (lp_key + "TimerTag"), lv_b + 1).ToString();
                            HashTableSave1(true, (lp_key + "TimerTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                HashTableSave0(true, "Key_TimerGroup" + lv_str, 0);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动T_移除Timer。用"互动T_注册Timer"到Key，之后可用本函数仅摧毁Key区注册的信息并将序号重排，用于Timer组或多个键区仅移除Timer（保留Timer标签有效状态、固有值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动T_设定Timer状态"让Timer状态失效（类似单位组的单位活体状态）。Timer组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Timer组转为Key。本函数无法摧毁用"互动T_设定Timer状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Timer组变量ID时会清空Timer组专用状态
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        public static void HHD_RemoveTimer(Timer lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag = "";
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_tag = HHD_ReturnTimerTag(lp_timer);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                HashTableSave0(true, "Key_TimerGroup" + lv_str, 1);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((HashTableLoad1(true, (lp_key + "TimerTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        HashTableClear0(true, "HHD_IfTimerTag" + lv_str + "_" + lv_tag);
                        HashTableClear0(true, "HHD_TimerCV" + lv_str + "_" + lv_tag);
                        HashTableClear0(true, "HHD_TimerState" + lv_str + "_" + lv_tag);
                        HashTableSave0(true, (lp_key + "TimerNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = HashTableLoad1(true, (lp_key + "TimerTag"), lv_b + 1).ToString();
                            HashTableSave1(true, (lp_key + "TimerTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                HashTableSave0(true, "Key_TimerGroup" + lv_str, 0);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer注册总数。必须先使用"互动T_注册Timer"才能返回指定Key里的注册总数。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key。
        /// </summary>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        /// <returns></returns>
        public static int HHD_ReturnTimerNumMax(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            // Implementation
            return lv_num;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer序号。使用"互动T_注册Timer"后使用本函数可返回Key里的注册序号，Key无元素返回0，Key有元素但对象不在里面则返回-1，Timer标签尚未注册则返回-2。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        /// <returns></returns>
        public static int HHD_ReturnTimerNum(Timer lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_i;
            string lv_tag = "";
            int lv_torf;
            // Automatic Variable Declarations
            const int auto_n = 1;
            int auto_i;
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_tag = HHD_ReturnTimerTag(lp_timer);
            lv_torf = -1;
            // Implementation
            for (auto_i = 1; auto_i <= auto_n; auto_i += 1)
            {
                if ((lv_tag != null))
                {
                    lv_torf = -2;
                    break;
                }
                if ((lv_num == 0))
                {
                    lv_torf = 0;
                }
                else
                {
                    if ((lv_num >= 1))
                    {
                        auto_ae = lv_num;
                        auto_var = 1;
                        for (; auto_var <= auto_ae; auto_var += 1)
                        {
                            lv_i = auto_var;
                            if ((HashTableLoad1(true, (lv_str + "Tag"), lv_i).ToString() == lv_tag))
                            {
                                lv_torf = lv_i;
                                break;
                            }
                        }
                    }
                }
            }
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回序号对应Timer。使用"互动T_注册Timer"后，在参数填入注册序号可返回Timer。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_regNum"></param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        /// <returns></returns>
        public static Timer HHD_ReturnTimerFromRegNum(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            Timer lv_timer;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = HashTableLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            lv_timer = (Timer)HashTableLoad0(true, ("HHD_Timer_" + lv_tag));
            // Implementation
            return lv_timer;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回句柄标签对应Timer。使用"互动T_注册Timer"后，在参数填入句柄标签（整数）可返回Timer，标签是Timer的句柄。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_tag">句柄标签</param>
        /// <returns></returns>
        public static Timer HHD_ReturnTimerFromTag(int lp_tag)
        {
            // Variable Declarations
            string lv_tag = "";
            Timer lv_timer;
            // Variable Initialization
            lv_tag = lp_tag.ToString();
            lv_timer = (Timer)HashTableLoad0(true, ("HHD_Timer_" + lv_tag));
            // Implementation
            return lv_timer;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回序号对应Timer标签句柄。使用"互动T_注册Timer"后，在参数填入注册序号可返回Timer标签（字符串）。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        /// <returns></returns>
        public static string HHD_ReturnTimerTagFromRegNum_String(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = HashTableLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回序号对应Timer标签句柄。使用"互动T_注册Timer"后，在参数填入注册序号可返回Timer标签（整数）。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        /// <returns></returns>
        public static int HHD_ReturnTimerTagFromRegNum_Int(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = HashTableLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return Convert.ToInt32(lv_tag);
        }

        /// <summary>
        /// 【MM_函数库】互动T_设置Timer状态。必须先"注册"获得功能库内部句柄，再使用本函数给Timer设定一个状态值，之后可用"互动T_返回Timer状态"。类型参数用以记录多个不同状态，仅当"类型"参数填Timer组ID转的Timer串时，状态值"true"和"false"是Timer的Timer组专用状态值，用于内部函数筛选Timer状态（相当于单位组单位索引是否有效），其他类型不会干扰系统内部，可随意填写。虽然注销时反向清空注册信息，但用"互动T_设定Timer状态/自定义值"创建的值需要手工填入""来排泄（非大量注销则提升内存量极小，可不管）。注：固有状态值是注册函数赋予的系统内部变量（相当于单位组单位是否活体），只能通过"互动T_注册Timer（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <param name="lp_stats">状态</param>
        public static void HHD_SetTimerState(Timer lp_timer, string lp_key, string lp_stats)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = HHD_RegTimerTagAndReturn(lp_timer);
            // Implementation
            HashTableSave0(true, ("HHD_TimerState" + lv_str + "_" + lv_tag), lp_stats);
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer状态。使用"互动T_设定Timer状态"后可使用本函数，将本函数参数"类型"设为空时返回固有值。类型参数用以记录多个不同状态，仅当"类型"参数为Timer组ID转的字符串时，返回的状态值"true"和"false"是Timer的Timer组专用状态值，用于内部函数筛选Timer状态（相当于单位组单位索引是否有效）
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <returns></returns>
        public static string HHD_ReturnTimerState(Timer lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = HHD_ReturnTimerTag(lp_timer);
            lv_stats = HashTableLoad0(true, ("HHD_TimerState" + lv_str + "_" + lv_tag)).ToString();
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动T_设置Timer自定义值。必须先"注册"获得功能库内部句柄，再使用本函数设定Timer的自定义值，之后可使用"互动T_返回Timer自定义值"，类型参数用以记录多个不同自定义值。注：固有自定义值是注册函数赋予的系统内部变量，只能通过"互动T_注册Timer（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <param name="lp_customValue">自定义值</param>
        public static void HHD_SetTimerCV(Timer lp_timer, string lp_key, string lp_customValue)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = HHD_RegTimerTagAndReturn(lp_timer);
            // Implementation
            HashTableSave0(true, ("HHD_TimerCV" + lv_str + "_" + lv_tag), lp_customValue);
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer自定义值。使用"互动T_设定Timer自定义值"后可使用本函数，将本函数参数"类型"设为空时返回固有值，该参数用以记录多个不同自定义值
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <returns></returns>
        public static string HHD_ReturnTimerCV(Timer lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = HHD_ReturnTimerTag(lp_timer);
            lv_customValue = HashTableLoad0(true, ("HHD_TimerCV" + lv_str + "_" + lv_tag)).ToString();
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer固有状态。必须先使用"互动T_注册Timer"才能返回到该值，固有状态是独一无二的标记（相当于单位组单位是否活体）
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns></returns>
        public static string HHD_ReturnTimerState_Only(Timer lp_timer)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_tag = HHD_ReturnTimerTag(lp_timer);
            lv_stats = HashTableLoad0(true, ("HHD_TimerState" + "" + "_" + lv_tag)).ToString();
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer固有自定义值。必须先使用"互动T_注册Timer"才能返回到该值，固有值是独一无二的标记
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns></returns>
        public static string HHD_ReturnTimerCV_Only(Timer lp_timer)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_tag = HHD_ReturnTimerTag(lp_timer);
            lv_customValue = HashTableLoad0(true, ("HHD_TimerCV" + "" + "_" + lv_tag)).ToString();
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动T_设置Timer的实数标记。必须先"注册"获得功能库内部句柄，再使用本函数让Timer携带一个实数值，之后可使用"互动T_返回Timer的实数标记"。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_realNumTag">实数标记</param>
        public static void HHD_SetTimerDouble(Timer lp_timer, double lp_realNumTag)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = HHD_RegTimerTagAndReturn(lp_timer);
            // Implementation
            HashTableSave0(true, ("HHD_CDDouble_T_" + lv_tag), lp_realNumTag);
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer的实数标记。使用"互动T_设定Timer的实数标记"后可使用本函数。Timer组使用时，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns></returns>
        public static double HHD_ReturnTimerDouble(Timer lp_timer)
        {
            // Variable Declarations
            string lv_tag = "";
            double lv_f;
            // Variable Initialization
            lv_tag = HHD_ReturnTimerTag(lp_timer);
            lv_f = (double)HashTableLoad0(true, ("HHD_CDDouble_T_" + lv_tag));
            // Implementation
            return lv_f;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer标签句柄有效状态。将Timer视作独一无二的个体，标签是它本身，有效状态则类似"单位是否有效"，当使用"互动T_注册Timer"或"互动TG_添加Timer到Timer组"后激活Timer有效状态（值为"true"），除非使用"互动T_注册Timer（高级）"改写，否则直到注销才会摧毁
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <returns></returns>
        public static bool HHD_ReturnIfTimerTag(Timer lp_timer)
        {
            // Variable Declarations
            string lv_tag = "";
            bool lv_torf;
            // Variable Initialization
            lv_tag = HHD_ReturnTimerTag(lp_timer);
            lv_torf = (bool)HashTableLoad0(true, ("HHD_IfTimerTag" + "" + "_" + lv_tag));
            // Implementation
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动T_返回Timer注册状态。使用"互动T_注册Timer"或"互动TG_添加Timer到Timer组"后可使用本函数获取注册Timer在Key中的注册状态，该状态只能注销或从Timer组中移除时清空。Timer组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Timer组转为Key
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_key">存储键区，默认值"_Timer"</param>
        /// <returns></returns>
        public static bool HHD_ReturnIfTimerTagKey(Timer lp_timer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            bool lv_torf;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_tag = HHD_ReturnTimerTag(lp_timer);
            lv_torf = (bool)HashTableLoad0(true, ("HHD_IfTimerTag" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动TG_根据自定义值类型将Timer组排序。根据Timer携带的自定义值类型，对指定的Timer组元素进行冒泡排序。Timer组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Timer组名称</param>
        /// <param name="lp_cVStr">自定义值类型</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void HHD_TimerGSortCV(string lp_key, string lp_cVStr, bool lp_big)
        {
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            string lv_tagValuestr;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            ThreadWait(lv_str);
            HashTableSave0(true, "Key_TimerGroup" + lv_str, 1);
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = HHD_ReturnTimerTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValuestr = HHD_ReturnTimerCV(HHD_ReturnTimerFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    HashTableSave1(false, "IntStackOutTag", 1, lv_tag);
                    HashTableSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    HashTableSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < (int)HashTableLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    HashTableSave1(false, "IntStackOutTag", lv_c, HashTableLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    HashTableSave1(false, "IntStackOutTagValue", lv_c, HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    HashTableSave1(false, "IntStackOutTagIteraOrig", lv_c, HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                HashTableSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                HashTableSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                HashTableSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > (int)HashTableLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(HHD_ReturnTimerTagFromRegNum(lv_b, lp_key))+"值"+IntToString(HashTableLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    HashTableSave1(false, "IntStackOutTag", lv_c, HashTableLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(HashTableLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    HashTableSave1(false, "IntStackOutTagValue", lv_c, HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    HashTableSave1(false, "IntStackOutTagIteraOrig", lv_c, HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                HashTableSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                HashTableSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                HashTableSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        HashTableSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        HashTableSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        HashTableSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = HashTableLoad1(true, (lp_key + "TimerTag"), lv_a).ToString(); //原始序号元素
                lv_tag = (int)HashTableLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValuestr = HHD_ReturnTimerCV(HHD_ReturnTimerFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = (int)HashTableLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    HashTableSave1(true, (lp_key + "TimerTag"), lv_a, lv_tag); //lv_tag放入新序号
                    //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            HashTableSave0(true, "Key_TimerGroup" + lv_str, 0);
        }

        /// <summary>
        /// 【MM_函数库】互动TG_Timer组排序。对指定的Timer组元素进行冒泡排序（根据元素句柄）。Timer组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Timer组名称</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void HHD_TimerGSort(string lp_key, bool lp_big)
        {
            // Automatic Variable Declarations
            // Implementation
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            ThreadWait(lv_str);
            HashTableSave0(true, "Key_TimerGroup" + lv_str, 1);
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = HHD_ReturnTimerTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValue = lv_tag;
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    HashTableSave1(false, "IntStackOutTag", 1, lv_tag);
                    HashTableSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    HashTableSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < (int)HashTableLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    HashTableSave1(false, "IntStackOutTag", lv_c, HashTableLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    HashTableSave1(false, "IntStackOutTagValue", lv_c, HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    HashTableSave1(false, "IntStackOutTagIteraOrig", lv_c, HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                HashTableSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                HashTableSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                HashTableSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > (int)HashTableLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(HHD_ReturnTimerTagFromRegNum(lv_b, lp_key))+"值"+IntToString(HashTableLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    HashTableSave1(false, "IntStackOutTag", lv_c, HashTableLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(HashTableLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    HashTableSave1(false, "IntStackOutTagValue", lv_c, HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    HashTableSave1(false, "IntStackOutTagIteraOrig", lv_c, HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                HashTableSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                HashTableSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                HashTableSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        HashTableSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        HashTableSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        HashTableSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = HashTableLoad1(true, (lp_key + "TimerTag"), lv_a).ToString(); //原始序号元素
                lv_tag = (int)HashTableLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValue = lv_tag;
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = (int)HashTableLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                                                                                    //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    HashTableSave1(true, (lp_key + "TimerTag"), lv_a, lv_tag); //lv_tag放入新序号
                                                                               //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            HashTableSave0(true, "Key_TimerGroup" + lv_str, 0);
        }

        /// <summary>
        /// 【MM_函数库】互动TG_设定Timer的Timer组专用状态。给Timer组的Timer设定一个状态值（字符串），之后可用"互动T_返回Timer、互动TG_返回Timer组的Timer状态"。状态值"true"和"false"是Timer的Timer组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效），而本函数可以重设干预，影响函数"互动TG_返回Timer组元素数量（仅检索XX状态）"。与"互动T_设定Timer状态"功能相同，只是状态参数在Timer组中被固定为"Timer组变量的内部ID"。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_timerGroup"></param>
        /// <param name="lp_groupState"></param>
        public static void HHD_SetTimerGState(Timer lp_timer, string lp_timerGroup, string lp_groupState)
        {
            HHD_SetTimerState(lp_timer, lp_timerGroup, lp_groupState);
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer的Timer组专用状态。使用"互动T_设定Timer、互动TG_设定Timer组的Timer状态"后可使用本函数。与"互动T_返回Timer状态"功能相同，只是状态参数在Timer组中被固定为"Timer组变量的内部ID"。状态值"true"和"false"是Timer的Timer组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效）。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_timerGroup"></param>
        public static void HHD_ReturnTimerGState(Timer lp_timer, string lp_timerGroup)
        {
            HHD_ReturnTimerState(lp_timer, lp_timerGroup);
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer组元素序号对应元素。返回Timer组元素序号指定Timer。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static Timer HHD_ReturnTimerFromTimerGFunc(int lp_regNum, string lp_gs)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            Timer lv_timer;
            // Variable Initialization
            lv_str = (lp_gs + "Timer");
            lv_tag = HashTableLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            lv_timer = (Timer)HashTableLoad0(true, ("HHD_Timer_" + lv_tag));
            // Implementation
            return lv_timer;
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer组元素总数。返回指定Timer组的元素数量。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HHD_ReturnTimerGNumMax(string lp_gs)
        {
            return (int)HashTableLoad0(true, lp_gs + "TimerNum");
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer组元素总数（仅检测Timer组专用状态="true"）。返回指定Timer组的元素数量。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HHD_ReturnTimerGNumMax_StateTrueFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Timer lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HHD_ReturnTimerNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HHD_ReturnTimerFromRegNum(lv_a, lp_gs);
                lv_b = HHD_ReturnTimerState(lv_c, lp_gs);
                if ((lv_b == "true"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer组元素总数（仅检测Timer组专用状态="false"）。返回指定Timer组的元素数量。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HHD_ReturnTimerGNumMax_StateFalseFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Timer lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HHD_ReturnTimerNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HHD_ReturnTimerFromRegNum(lv_a, lp_gs);
                lv_b = HHD_ReturnTimerState(lv_c, lp_gs);
                if ((lv_b == "false"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer组元素总数（仅检测Timer组无效专用状态："false"或""）。返回指定Timer组的元素数量（false、""、null）。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HHD_ReturnTimerGNumMax_StateUselessFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Timer lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HHD_ReturnTimerNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HHD_ReturnTimerFromRegNum(lv_a, lp_gs);
                lv_b = HHD_ReturnTimerState(lv_c, lp_gs);
                if (((lv_b == "false") || (lv_b == "") || (lv_b == null)))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer组元素总数（仅检测Timer组指定专用状态）。返回指定Timer组的元素数量。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_State">Timer组专用状态</param>
        /// <returns></returns>
        public static int HHD_ReturnTimerGNumMax_StateFunc_Specify(string lp_gs, string lp_State)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            Timer lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HHD_ReturnTimerNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HHD_ReturnTimerFromRegNum(lv_a, lp_gs);
                lv_b = HHD_ReturnTimerState(lv_c, lp_gs);
                if ((lv_b == lp_State))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动TG_添加Timer到Timer组。相同Timer被认为是同一个，非高级功能不提供专用状态检查，如果Timer没有设置过Timer组专用状态，那么首次添加到Timer组不会赋予"true"（之后可通过"互动T_设定Timer状态"、"互动TG_设定Timer组的Timer状态"修改）。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HHD_AddTimerToGroup_Simple(Timer lp_timer, string lp_gs)
        {
            HHD_RegTimer_Simple(lp_timer, lp_gs);
        }

        /// <summary>
        /// 【MM_函数库】互动TG_添加Timer到Timer组（高级）。相同Timer被认为是同一个，高级功能提供专用状态检查，如果Timer没有设置过Timer组专用状态，那么首次添加到Timer组会赋予"true"（之后可通过"互动T_设定Timer状态"、"互动TG_设定Timer组的Timer状态"修改）。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HHD_AddTimerToGroup(Timer lp_timer, string lp_gs)
        {
            HHD_RegTimer_Simple(lp_timer, lp_gs);
            if (HashTableKeyExists(true, ("HHD_TimerState" + lp_gs + "Timer_" + HHD_RegTimerTagAndReturn(lp_timer))) == false)
            {
                HashTableSave0(true, ("HHD_TimerState" + lp_gs + "Timer_" + HHD_RegTimerTagAndReturn(lp_timer)), "true");
                //Console.WriteLine(lp_gs + "=>" + HHD_RegTimerTagAndReturn(lp_timer));
            }
        }

        /// <summary>
        /// 【MM_函数库】互动TG_移除Timer组中的元素。使用"互动TG_添加Timer到Timer组"后可使用本函数进行移除元素。移除使用了"互动T_移除Timer"，同一个存储区（Timer组ID）序号重排，移除时该存储区如有其他操作会排队等待。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_timer"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HHD_ClearTimerFromGroup(Timer lp_timer, string lp_gs)
        {
            HHD_RemoveTimer(lp_timer, lp_gs);
        }

        //互动TG_为Timer组中的每个序号
        //GE（星际2的Galaxy Editor）的宏让编辑器保存时自动生成脚本并整合进脚本进行格式调整，C#仅参考需自行编写
        // #AUTOVAR(vs, string) = "#PARAM(group)";//"#PARAM(group)"是与字段、变量名一致的元素组名称，宏去声明string类型名为“Auto随机编号_vs”的自动变量，然后=右侧字符
        // #AUTOVAR(ae) = HHD_ReturnTimerNumMax(#AUTOVAR(vs));//宏去声明默认int类型名为“Auto随机编号_ae”的自动变量，然后=右侧字符
        // #INITAUTOVAR(ai,increment)//宏去声明int类型名为“Auto随机编号_ai”的自动变量，用于下面for循环增量（increment是传入参数）
        // #PARAM(var) = #PARAM(s);//#PARAM(var)是传进来的参数，用作“当前被挑选到的元素”（任意变量-整数 lp_var）， #PARAM(s)是传进来的参数用作"开始"（int lp_s）
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #PARAM(var) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #PARAM(var) >= #AUTOVAR(ae)) ) ; #PARAM(var) += #AUTOVAR(ai) ) {
        //     #SUBFUNCS(actions)//代表用户GUI填写的所有动作
        // }

        /// <summary>
        /// 【MM_函数库】互动TG_为Timer组中的每个序号。每次挑选的元素序号会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素序号，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void HHD_ForEachTimerNumFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            int lv_ae = HHD_ReturnTimerNumMax(lp_gs);
            int lv_var = lp_start;
            int lv_ai = lp_increment;
            for (; (lv_ai >= 0 && lv_var <= lv_ae) || (lv_ai < 0 && lv_var >= lv_ae); lv_var += lv_ai)
            {
                lp_funcref(lv_var);//用户填写的所有动作
            }
        }

        //互动TG_为Timer组中的每个元素
        // #AUTOVAR(vs, string) = "#PARAM(group)";
        // #AUTOVAR(ae) = HHD_ReturnTimerNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= #PARAM(s);
        // #INITAUTOVAR(ai,increment)
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     HashTableSave(false, "TimerGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)), HHD_ReturnTimerFromRegNum(#AUTOVAR(va),#AUTOVAR(vs)));
        // }
        // #AUTOVAR(va)= #PARAM(s);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #PARAM(var) = HashTableLoad(false, "TimerGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)));
        //     #SUBFUNCS(actions)
        // }

        /// <summary>
        /// 【MM_函数库】互动TG_为Timer组中的每个元素。每次挑选的元素会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void HHD_ForEachTimerFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            string lv_vs = lp_gs;
            int lv_ae = HHD_ReturnTimerNumMax(lv_vs);
            int lv_va = lp_start;
            int lv_ai = lp_increment;
            Timer lv_timer;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                HashTableSave0(false, "TimerGFor" + lv_vs + lv_va.ToString(), HHD_ReturnTimerFromRegNum(lv_va, lv_vs));
            }
            lv_va = lp_start;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                lv_timer = (Timer)HashTableLoad0(false, "TimerGFor" + lv_vs + lv_va.ToString());
                lp_funcref(lv_timer);//用户填写的所有动作
            }
        }

        /// <summary>
        /// 【MM_函数库】互动TG_返回Timer组中随机元素。返回指定Timer组中的随机Timer。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static Timer HHD_ReturnRandomTimerFromTimerGFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_num;
            int lv_a;
            Timer lv_c = null;
            // Variable Initialization
            lv_num = HHD_ReturnTimerNumMax(lp_gs);
            // Implementation
            if ((lv_num >= 1))
            {
                lv_a = RandomInt(1, lv_num);
                lv_c = HHD_ReturnTimerFromRegNum(lv_a, lp_gs);
            }
            return lv_c;
        }

        //互动TG_添加Timer组到Timer组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = HHD_ReturnTimerNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = HHD_ReturnTimerFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     HHD_AddTimerToGroup(#AUTOVAR(var), #AUTOVAR(vsb));
        // }


        /// <summary>
        /// 【MM_函数库】互动TG_添加Timer组到Timer组。添加一个Timer组A的元素到另一个Timer组B，相同Timer被认为是同一个。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void HHD_AddTimerGToTimerG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = HHD_ReturnTimerNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            Timer lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = HHD_ReturnTimerFromRegNum(lv_va, lv_vsa);
                HHD_AddTimerToGroup(lv_var, lv_vsb);
            }
        }

        //互动TG_从Timer组移除Timer组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = HHD_ReturnTimerNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = HHD_ReturnTimerFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     HHD_RemoveTimer(#AUTOVAR(var), #AUTOVAR(vsb));
        // }

        /// <summary>
        /// 【MM_函数库】互动TG_从Timer组移除Timer组。将Timer组A的元素从Timer组B中移除，相同Timer被认为是同一个。移除使用了"互动T_移除Timer"，同一个存储区（Timer组ID）序号重排，移除时该存储区如有其他操作会排队等待。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void HHD_ClearTimerGFromTimerG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = HHD_ReturnTimerNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            Timer lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = HHD_ReturnTimerFromRegNum(lv_va, lv_vsa);
                HHD_RemoveTimer(lv_var, lv_vsb);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动TG_移除Timer组全部元素。将Timer组（Key区）存储的元素全部移除，相同Timer被认为是同一个。移除时同一个存储区（Timer组ID）序号不进行重排，但该存储区如有其他操作会排队等待。Timer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Timer组到Timer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Timer组名称</param>
        public static void HHD_RemoveTimerGAll(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag = "";
            int lv_a;
            // Variable Initialization
            lv_str = (lp_key + "Timer");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            // Implementation
            ThreadWait(lv_str);
            HashTableSave0(true, "Key_TimerGroup" + lv_str, 1);
            for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
            {
                lv_tag = HashTableLoad1(true, (lp_key + "TimerTag"), lv_a).ToString();
                lv_num -= 1;
                HashTableClear0(true, "HHD_IfTimerTag" + lv_str + "_" + lv_tag);
                HashTableClear0(true, "HHD_TimerCV" + lv_str + "_" + lv_tag);
                HashTableClear0(true, "HHD_TimerState" + lv_str + "_" + lv_tag);
                HashTableSave0(true, (lp_key + "TimerNum"), lv_num);
            }
            HashTableSave0(true, "Key_TimerGroup" + lv_str, 0);
        }

        //--------------------------------------------------------------------------------------------------
        // 计时器组End
        //--------------------------------------------------------------------------------------------------

        #endregion

        #region 字符串

        //提示：可以将字符串作为模板修改后产生其他类型
        //提示：尽可能使用对口类型，以防值类型与引用类型发生转换时拆装箱降低性能

        //--------------------------------------------------------------------------------------------------
        // 字符串组Start
        //--------------------------------------------------------------------------------------------------

        /// <summary>
        /// 【MM_函数库】互动S_注册String标签句柄并返回。为String自动设置新的标签句柄，重复时会返回已注册的String标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_string"></param>
        /// <returns>返回一个String的已注册标签</returns>
        private static int HHD_RegStringTagAndReturn_Int(string lp_string)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)HashTableLoad0(true, "HHD_StringJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                HashTableSave0(true, "HHD_StringJBNum", lv_j);
                HashTableSave0(true, ("HHD_String_" + lv_j.ToString()), lp_string);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if ((string)HashTableLoad0(true, ("HHD_String_" + lv_j.ToString())) == lp_string)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            HashTableSave0(true, "HHD_StringJBNum", lv_j);
                            HashTableSave0(true, ("HHD_String_" + lv_j.ToString()), lp_string);
                        }
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String已注册标签句柄
        /// </summary>
        /// <param name="lp_string"></param>
        /// <returns>返回一个String的已注册标签，错误返回0</returns>
        public static int HHD_ReturnStringTag_Int(string lp_string)
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)HashTableLoad0(true, "HHD_StringJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if ((string)HashTableLoad0(true, "HHD_String_" + lv_j.ToString()) == lp_string)
                {
                    break;
                }
                else
                {
                    if ((lv_j == lv_jBNum))
                    {
                        lv_j = 0;
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动S_注册String标签句柄并返回。为String自动设置新的标签句柄，重复时会返回已注册的String标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_string"></param>
        /// <returns>返回一个String的已注册标签</returns>
        private static string HHD_RegStringTagAndReturn(string lp_string)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag = "";
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)HashTableLoad0(true, "HHD_StringJBNum");
            lv_tag = "";
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                HashTableSave0(true, "HHD_StringJBNum", lv_j);
                HashTableSave0(true, ("HHD_String_" + lv_j.ToString()), lp_string);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if ((string)HashTableLoad0(true, "HHD_String_" + lv_j.ToString()) == lp_string)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            HashTableSave0(true, "HHD_StringJBNum", lv_j);
                            HashTableSave0(true, ("HHD_String_" + lv_j.ToString()), lp_string);
                        }
                    }
                }
            }
            lv_tag = lv_j.ToString();
            //Console.WriteLine(("Tag：" + lv_tag));
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String已注册标签句柄
        /// </summary>
        /// <param name="lp_string"></param>
        /// <returns>返回一个String的已注册标签，错误返回""</returns>
        public static string HHD_ReturnStringTag(string lp_string)
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag = "";
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)HashTableLoad0(true, "HHD_StringJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if ((string)HashTableLoad0(true, "HHD_String_" + lv_j.ToString()) == lp_string)
                {
                    lv_tag = lv_j.ToString();
                    break;
                }
            }
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动S_注册String(高级)。在指定Key存入String，固有状态、自定义值是String独一无二的标志（本函数重复注册会刷新），之后可用互动S_"返回String注册总数"、"返回String序号"、"返回序号对应String"、"返回序号对应String标签"、"返回String自定义值"。String组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将String组转为Key。首次注册时固有状态为true（相当于单位组单位活体），如需另外设置多个标记可使用"互动S_设定String状态/自定义值"
        /// </summary>
        /// <param name="lp_string"></param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        /// <param name="lp_inherentStats">固有状态</param>
        /// <param name="lp_inherentCustomValue">固有自定义值</param>
        public static void HHD_RegString(string lp_string, string lp_key, string lp_inherentStats, string lp_inherentCustomValue)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_jBNum = (int)HashTableLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = HHD_RegStringTagAndReturn(lp_string);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                HashTableSave0(true, (lv_str + "Num"), lv_i);
                HashTableSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                HashTableSave0(true, (("HHD_IfStringTag" + "") + "_" + lv_tagStr), true);
                HashTableSave1(true, ("HHD_IfStringTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if ((HashTableLoad1(true, (lv_str + "Tag"), lv_i).ToString() == lv_tagStr))
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                HashTableSave0(true, (lv_str + "Num"), lv_i);
                                HashTableSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                HashTableSave0(true, (("HHD_IfStringTag" + "") + "_" + lv_tagStr), true);
                                HashTableSave1(true, ("HHD_IfStringTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            HashTableSave0(true, ("HHD_StringState" + "" + "_" + lv_tagStr), lp_inherentStats);
            HashTableSave0(true, ("HHD_StringCV" + "" + "_" + lv_tagStr), lp_inherentCustomValue);
        }

        /// <summary>
        /// 【MM_函数库】互动S_注册String。在指定Key存入String，固有状态、自定义值是String独一无二的标志（本函数重复注册不会刷新），之后可用互动S_"返回String注册总数"、"返回String序号"、"返回序号对应String"、"返回String自定义值"。String组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将String组转为Key。首次注册时固有状态为true（相当于单位组单位活体），之后只能通过"互动S_注册String（高级）"改写，如需另外设置多个标记可使用"互动S_设定String状态/自定义值"
        /// </summary>
        /// <param name="lp_string"></param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        public static void HHD_RegString_Simple(string lp_string, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_jBNum = (int)HashTableLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = HHD_RegStringTagAndReturn(lp_string);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                HashTableSave0(true, (lv_str + "Num"), lv_i);
                HashTableSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                HashTableSave0(true, (("HHD_IfStringTag" + "") + "_" + lv_tagStr), true);
                HashTableSave1(true, ("HHD_IfStringTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if ((HashTableLoad1(true, (lv_str + "Tag"), lv_i).ToString() == lv_tagStr))
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                HashTableSave0(true, (lv_str + "Num"), lv_i);
                                HashTableSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                HashTableSave0(true, (("HHD_IfStringTag" + "") + "_" + lv_tagStr), true);
                                HashTableSave1(true, ("HHD_IfStringTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            if ((HashTableKeyExists(true, ("HHD_String" + "State" + "_" + lv_tag.ToString())) == false))
            {
                HashTableSave1(true, (("HHD_String" + "State")), lv_tag, "true");
            }
        }

        /// <summary>
        /// 【MM_函数库】互动S_注销String。用"互动S_注册String"到Key，之后可用本函数彻底摧毁注册信息并将序号重排（包括String标签有效状态、固有状态及自定义值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动S_设定String状态"让String状态失效（类似单位组的单位活体状态）。String组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将String组转为Key。本函数无法摧毁用"互动S_设定String状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填String组变量ID时会清空String组专用状态
        /// </summary>
        /// <param name="lp_string"></param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        public static void HHD_DestroyString(string lp_string, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag = "";
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_tag = HHD_ReturnStringTag(lp_string);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                HashTableSave0(true, "Key_StringGroup" + lv_str, 1);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((HashTableLoad1(true, (lp_key + "StringTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        HashTableClear0(true, "HHD_IfStringTag_" + lv_tag);
                        HashTableClear0(true, "HHD_IfStringTag" + lv_str + "_" + lv_tag);
                        HashTableClear0(true, "HHD_String_" + lv_tag);
                        HashTableClear0(true, "HHD_StringCV_" + lv_tag);
                        HashTableClear0(true, "HHD_StringState_" + lv_tag);
                        HashTableClear0(true, "HHD_StringCV" + lv_str + "_" + lv_tag);
                        HashTableClear0(true, "HHD_StringState" + lv_str + "_" + lv_tag);
                        HashTableSave0(true, (lp_key + "StringNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = HashTableLoad1(true, (lp_key + "StringTag"), lv_b + 1).ToString();
                            HashTableSave1(true, (lp_key + "StringTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                HashTableSave0(true, "Key_StringGroup" + lv_str, 0);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动S_移除String。用"互动S_注册String"到Key，之后可用本函数仅摧毁Key区注册的信息并将序号重排，用于String组或多个键区仅移除String（保留String标签有效状态、固有值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动S_设定String状态"让String状态失效（类似单位组的单位活体状态）。String组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将String组转为Key。本函数无法摧毁用"互动S_设定String状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填String组变量ID时会清空String组专用状态
        /// </summary>
        /// <param name="lp_string"></param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        public static void HHD_RemoveString(string lp_string, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag = "";
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_tag = HHD_ReturnStringTag(lp_string);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                HashTableSave0(true, "Key_StringGroup" + lv_str, 1);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((HashTableLoad1(true, (lp_key + "StringTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        HashTableClear0(true, "HHD_IfStringTag" + lv_str + "_" + lv_tag);
                        HashTableClear0(true, "HHD_StringCV" + lv_str + "_" + lv_tag);
                        HashTableClear0(true, "HHD_StringState" + lv_str + "_" + lv_tag);
                        HashTableSave0(true, (lp_key + "StringNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = HashTableLoad1(true, (lp_key + "StringTag"), lv_b + 1).ToString();
                            HashTableSave1(true, (lp_key + "StringTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                HashTableSave0(true, "Key_StringGroup" + lv_str, 0);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String注册总数。必须先使用"互动S_注册String"才能返回指定Key里的注册总数。String组使用时，可用"获取变量的内部名称"将String组转为Key。
        /// </summary>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        /// <returns></returns>
        public static int HHD_ReturnStringNumMax(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            // Implementation
            return lv_num;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String序号。使用"互动S_注册String"后使用本函数可返回Key里的注册序号，Key无元素返回0，Key有元素但对象不在里面则返回-1，String标签尚未注册则返回-2。String组使用时，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_string"></param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        /// <returns></returns>
        public static int HHD_ReturnStringNum(string lp_string, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_i;
            string lv_tag = "";
            int lv_torf;
            // Automatic Variable Declarations
            const int auto_n = 1;
            int auto_i;
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_tag = HHD_ReturnStringTag(lp_string);
            lv_torf = -1;
            // Implementation
            for (auto_i = 1; auto_i <= auto_n; auto_i += 1)
            {
                if ((lv_tag != null))
                {
                    lv_torf = -2;
                    break;
                }
                if ((lv_num == 0))
                {
                    lv_torf = 0;
                }
                else
                {
                    if ((lv_num >= 1))
                    {
                        auto_ae = lv_num;
                        auto_var = 1;
                        for (; auto_var <= auto_ae; auto_var += 1)
                        {
                            lv_i = auto_var;
                            if ((HashTableLoad1(true, (lv_str + "Tag"), lv_i).ToString() == lv_tag))
                            {
                                lv_torf = lv_i;
                                break;
                            }
                        }
                    }
                }
            }
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回序号对应String。使用"互动S_注册String"后，在参数填入注册序号可返回String。String组使用时，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_regNum"></param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        /// <returns></returns>
        public static string HHD_ReturnStringFromRegNum(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_string;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = HashTableLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            lv_string = (string)HashTableLoad0(true, ("HHD_String_" + lv_tag));
            // Implementation
            return lv_string;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回句柄标签对应String。使用"互动S_注册String"后，在参数填入句柄标签（整数）可返回String，标签是String的句柄。String组使用时，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_tag">句柄标签</param>
        /// <returns></returns>
        public static string HHD_ReturnStringFromTag(int lp_tag)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_string;
            // Variable Initialization
            lv_tag = lp_tag.ToString();
            lv_string = (string)HashTableLoad0(true, ("HHD_String_" + lv_tag));
            // Implementation
            return lv_string;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回序号对应String标签句柄。使用"互动S_注册String"后，在参数填入注册序号可返回String标签（字符串串）。String组使用时，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        /// <returns></returns>
        public static string HHD_ReturnStringTagFromRegNum_String(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = HashTableLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回序号对应String标签句柄。使用"互动S_注册String"后，在参数填入注册序号可返回String标签（整数）。String组使用时，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        /// <returns></returns>
        public static int HHD_ReturnStringTagFromRegNum_Int(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = HashTableLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return Convert.ToInt32(lv_tag);
        }

        /// <summary>
        /// 【MM_函数库】互动S_设置String状态。必须先"注册"获得功能库内部句柄，再使用本函数给String设定一个状态值，之后可用"互动S_返回String状态"。类型参数用以记录多个不同状态，仅当"类型"参数填String组ID转的String串时，状态值"true"和"false"是String的String组专用状态值，用于内部函数筛选String状态（相当于单位组单位索引是否有效），其他类型不会干扰系统内部，可随意填写。虽然注销时反向清空注册信息，但用"互动S_设定String状态/自定义值"创建的值需要手工填入""来排泄（非大量注销则提升内存量极小，可不管）。注：固有状态值是注册函数赋予的系统内部变量（相当于单位组单位是否活体），只能通过"互动S_注册String（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_string"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <param name="lp_stats">状态</param>
        public static void HHD_SetStringState(string lp_string, string lp_key, string lp_stats)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = HHD_RegStringTagAndReturn(lp_string);
            // Implementation
            HashTableSave0(true, ("HHD_StringState" + lv_str + "_" + lv_tag), lp_stats);
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String状态。使用"互动S_设定String状态"后可使用本函数，将本函数参数"类型"设为空时返回固有值。类型参数用以记录多个不同状态，仅当"类型"参数为String组ID转的字符串串时，返回的状态值"true"和"false"是String的String组专用状态值，用于内部函数筛选String状态（相当于单位组单位索引是否有效）
        /// </summary>
        /// <param name="lp_string"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <returns></returns>
        public static string HHD_ReturnStringState(string lp_string, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = HHD_ReturnStringTag(lp_string);
            lv_stats = HashTableLoad0(true, ("HHD_StringState" + lv_str + "_" + lv_tag)).ToString();
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动S_设置String自定义值。必须先"注册"获得功能库内部句柄，再使用本函数设定String的自定义值，之后可使用"互动S_返回String自定义值"，类型参数用以记录多个不同自定义值。注：固有自定义值是注册函数赋予的系统内部变量，只能通过"互动S_注册String（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_string"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <param name="lp_customValue">自定义值</param>
        public static void HHD_SetStringCV(string lp_string, string lp_key, string lp_customValue)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = HHD_RegStringTagAndReturn(lp_string);
            // Implementation
            HashTableSave0(true, ("HHD_StringCV" + lv_str + "_" + lv_tag), lp_customValue);
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String自定义值。使用"互动S_设定String自定义值"后可使用本函数，将本函数参数"类型"设为空时返回固有值，该参数用以记录多个不同自定义值
        /// </summary>
        /// <param name="lp_string"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <returns></returns>
        public static string HHD_ReturnStringCV(string lp_string, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = HHD_ReturnStringTag(lp_string);
            lv_customValue = HashTableLoad0(true, ("HHD_StringCV" + lv_str + "_" + lv_tag)).ToString();
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String固有状态。必须先使用"互动S_注册String"才能返回到该值，固有状态是独一无二的标记（相当于单位组单位是否活体）
        /// </summary>
        /// <param name="lp_string"></param>
        /// <returns></returns>
        public static string HHD_ReturnStringState_Only(string lp_string)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_tag = HHD_ReturnStringTag(lp_string);
            lv_stats = HashTableLoad0(true, ("HHD_StringState" + "" + "_" + lv_tag)).ToString();
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String固有自定义值。必须先使用"互动S_注册String"才能返回到该值，固有值是独一无二的标记
        /// </summary>
        /// <param name="lp_string"></param>
        /// <returns></returns>
        public static string HHD_ReturnStringCV_Only(string lp_string)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_tag = HHD_ReturnStringTag(lp_string);
            lv_customValue = HashTableLoad0(true, ("HHD_StringCV" + "" + "_" + lv_tag)).ToString();
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动S_设置String的实数标记。必须先"注册"获得功能库内部句柄，再使用本函数让String携带一个实数值，之后可使用"互动S_返回String的实数标记"。String组使用时，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_string"></param>
        /// <param name="lp_realNumTag">实数标记</param>
        public static void HHD_SetStringDouble(string lp_string, double lp_realNumTag)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = HHD_RegStringTagAndReturn(lp_string);
            // Implementation
            HashTableSave0(true, ("HHD_CDDouble_T_" + lv_tag), lp_realNumTag);
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String的实数标记。使用"互动S_设定String的实数标记"后可使用本函数。String组使用时，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_string"></param>
        /// <returns></returns>
        public static double HHD_ReturnStringDouble(string lp_string)
        {
            // Variable Declarations
            string lv_tag = "";
            double lv_f;
            // Variable Initialization
            lv_tag = HHD_ReturnStringTag(lp_string);
            lv_f = (double)HashTableLoad0(true, ("HHD_CDDouble_T_" + lv_tag));
            // Implementation
            return lv_f;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String标签句柄有效状态。将String视作独一无二的个体，标签是它本身，有效状态则类似"单位是否有效"，当使用"互动S_注册String"或"互动SG_添加String到String组"后激活String有效状态（值为"true"），除非使用"互动S_注册String（高级）"改写，否则直到注销才会摧毁
        /// </summary>
        /// <param name="lp_string"></param>
        /// <returns></returns>
        public static bool HHD_ReturnIfStringTag(string lp_string)
        {
            // Variable Declarations
            string lv_tag = "";
            bool lv_torf;
            // Variable Initialization
            lv_tag = HHD_ReturnStringTag(lp_string);
            lv_torf = (bool)HashTableLoad0(true, ("HHD_IfStringTag" + "" + "_" + lv_tag));
            // Implementation
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动S_返回String注册状态。使用"互动S_注册String"或"互动SG_添加String到String组"后可使用本函数获取注册String在Key中的注册状态，该状态只能注销或从String组中移除时清空。String组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将String组转为Key
        /// </summary>
        /// <param name="lp_string"></param>
        /// <param name="lp_key">存储键区，默认值"_String"</param>
        /// <returns></returns>
        public static bool HHD_ReturnIfStringTagKey(string lp_string, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            bool lv_torf;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_tag = HHD_ReturnStringTag(lp_string);
            lv_torf = (bool)HashTableLoad0(true, ("HHD_IfStringTag" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动SG_根据自定义值类型将String组排序。根据String携带的自定义值类型，对指定的String组元素进行冒泡排序。String组变量字符串可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填String组名称</param>
        /// <param name="lp_cVStr">自定义值类型</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void HHD_StringGSortCV(string lp_key, string lp_cVStr, bool lp_big)
        {
            // Automatic Variable Declarations
            // Implementation
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            string lv_tagValuestr;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "String");
            ThreadWait(lv_str);
            HashTableSave0(true, "Key_StringGroup" + lv_str, 1);
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = HHD_ReturnStringTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValuestr = HHD_ReturnStringCV(HHD_ReturnStringFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    HashTableSave1(false, "IntStackOutTag", 1, lv_tag);
                    HashTableSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    HashTableSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < (int)HashTableLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    HashTableSave1(false, "IntStackOutTag", lv_c, HashTableLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    HashTableSave1(false, "IntStackOutTagValue", lv_c, HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    HashTableSave1(false, "IntStackOutTagIteraOrig", lv_c, HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                HashTableSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                HashTableSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                HashTableSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > (int)HashTableLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(HHD_ReturnStringTagFromRegNum(lv_b, lp_key))+"值"+IntToString(HashTableLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    HashTableSave1(false, "IntStackOutTag", lv_c, HashTableLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(HashTableLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    HashTableSave1(false, "IntStackOutTagValue", lv_c, HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    HashTableSave1(false, "IntStackOutTagIteraOrig", lv_c, HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                HashTableSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                HashTableSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                HashTableSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        HashTableSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        HashTableSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        HashTableSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = HashTableLoad1(true, (lp_key + "StringTag"), lv_a).ToString(); //原始序号元素
                lv_tag = (int)HashTableLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValuestr = HHD_ReturnStringCV(HHD_ReturnStringFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = (int)HashTableLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    HashTableSave1(true, (lp_key + "StringTag"), lv_a, lv_tag); //lv_tag放入新序号
                    //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            HashTableSave0(true, "Key_StringGroup" + lv_str, 0);
        }

        /// <summary>
        /// 【MM_函数库】互动SG_String组排序。对指定的String组元素进行冒泡排序（根据元素句柄）。String组变量字符串可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填String组名称</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void HHD_StringGSort(string lp_key, bool lp_big)
        {
            // Automatic Variable Declarations
            // Implementation
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "String");
            ThreadWait(lv_str);
            HashTableSave0(true, "Key_StringGroup" + lv_str, 1);
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = HHD_ReturnStringTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValue = lv_tag;
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    HashTableSave1(false, "IntStackOutTag", 1, lv_tag);
                    HashTableSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    HashTableSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < (int)HashTableLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    HashTableSave1(false, "IntStackOutTag", lv_c, HashTableLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    HashTableSave1(false, "IntStackOutTagValue", lv_c, HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    HashTableSave1(false, "IntStackOutTagIteraOrig", lv_c, HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                HashTableSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                HashTableSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                HashTableSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > (int)HashTableLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(HHD_ReturnStringTagFromRegNum(lv_b, lp_key))+"值"+IntToString(HashTableLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    HashTableSave1(false, "IntStackOutTag", lv_c, HashTableLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(HashTableLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    HashTableSave1(false, "IntStackOutTagValue", lv_c, HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    HashTableSave1(false, "IntStackOutTagIteraOrig", lv_c, HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                HashTableSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                HashTableSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                HashTableSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        HashTableSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        HashTableSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        HashTableSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = HashTableLoad1(true, (lp_key + "StringTag"), lv_a).ToString(); //原始序号元素
                lv_tag = (int)HashTableLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValue = lv_tag;
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = (int)HashTableLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                                                                                    //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    HashTableSave1(true, (lp_key + "StringTag"), lv_a, lv_tag); //lv_tag放入新序号
                                                                                //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            HashTableSave0(true, "Key_StringGroup" + lv_str, 0);
        }

        /// <summary>
        /// 【MM_函数库】互动SG_设定String的String组专用状态。给String组的String设定一个状态值（字符串串），之后可用"互动S_返回String、互动SG_返回String组的String状态"。状态值"true"和"false"是String的String组专用状态值，用于内部函数筛选字符串状态（相当于单位组单位索引是否有效），而本函数可以重设干预，影响函数"互动SG_返回String组元素数量（仅检索XX状态）"。与"互动S_设定String状态"功能相同，只是状态参数在String组中被固定为"String组变量的内部ID"。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_string"></param>
        /// <param name="lp_stringGroup"></param>
        /// <param name="lp_groupState"></param>
        public static void HHD_SetStringGState(string lp_string, string lp_stringGroup, string lp_groupState)
        {
            HHD_SetStringState(lp_string, lp_stringGroup, lp_groupState);
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String的String组专用状态。使用"互动S_设定String、互动SG_设定String组的String状态"后可使用本函数。与"互动S_返回String状态"功能相同，只是状态参数在String组中被固定为"String组变量的内部ID"。状态值"true"和"false"是String的String组专用状态值，用于内部函数筛选字符串状态（相当于单位组单位索引是否有效）。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_string"></param>
        /// <param name="lp_stringGroup"></param>
        public static void HHD_ReturnStringGState(string lp_string, string lp_stringGroup)
        {
            HHD_ReturnStringState(lp_string, lp_stringGroup);
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String组元素序号对应元素。返回String组元素序号指定String。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符串应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static string HHD_ReturnStringFromStringGFunc(int lp_regNum, string lp_gs)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_string;
            // Variable Initialization
            lv_str = (lp_gs + "String");
            lv_tag = HashTableLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            lv_string = (string)HashTableLoad0(true, ("HHD_String_" + lv_tag));
            // Implementation
            return lv_string;
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String组元素总数。返回指定String组的元素数量。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符串应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HHD_ReturnStringGNumMax(string lp_gs)
        {
            return (int)HashTableLoad0(true, lp_gs + "StringNum");
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String组元素总数（仅检测String组专用状态="true"）。返回指定String组的元素数量。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符串应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HHD_ReturnStringGNumMax_StateTrueFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            string lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HHD_ReturnStringNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HHD_ReturnStringFromRegNum(lv_a, lp_gs);
                lv_b = HHD_ReturnStringState(lv_c, lp_gs);
                if ((lv_b == "true"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String组元素总数（仅检测String组专用状态="false"）。返回指定String组的元素数量。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符串应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HHD_ReturnStringGNumMax_StateFalseFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            string lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HHD_ReturnStringNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HHD_ReturnStringFromRegNum(lv_a, lp_gs);
                lv_b = HHD_ReturnStringState(lv_c, lp_gs);
                if ((lv_b == "false"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String组元素总数（仅检测String组无效专用状态："false"或""）。返回指定String组的元素数量（false、""、null）。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符串应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HHD_ReturnStringGNumMax_StateUselessFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            string lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HHD_ReturnStringNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HHD_ReturnStringFromRegNum(lv_a, lp_gs);
                lv_b = HHD_ReturnStringState(lv_c, lp_gs);
                if (((lv_b == "false") || (lv_b == "") || (lv_b == null)))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String组元素总数（仅检测String组指定专用状态）。返回指定String组的元素数量。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符串应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_State">String组专用状态</param>
        /// <returns></returns>
        public static int HHD_ReturnStringGNumMax_StateFunc_Specify(string lp_gs, string lp_State)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            string lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HHD_ReturnStringNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HHD_ReturnStringFromRegNum(lv_a, lp_gs);
                lv_b = HHD_ReturnStringState(lv_c, lp_gs);
                if ((lv_b == lp_State))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动SG_添加String到String组。相同String被认为是同一个，非高级功能不提供专用状态检查，如果String没有设置过String组专用状态，那么首次添加到String组不会赋予"true"（之后可通过"互动S_设定String状态"、"互动SG_设定String组的String状态"修改）。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_string"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符串应写成：组[一维][二维]...以此类推</param>
        public static void HHD_AddStringToGroup_Simple(string lp_string, string lp_gs)
        {
            HHD_RegString_Simple(lp_string, lp_gs);
        }

        /// <summary>
        /// 【MM_函数库】互动SG_添加String到String组（高级）。相同String被认为是同一个，高级功能提供专用状态检查，如果String没有设置过String组专用状态，那么首次添加到String组会赋予"true"（之后可通过"互动S_设定String状态"、"互动SG_设定String组的String状态"修改）。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_string"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符串应写成：组[一维][二维]...以此类推</param>
        public static void HHD_AddStringToGroup(string lp_string, string lp_gs)
        {
            HHD_RegString_Simple(lp_string, lp_gs);
            if (HashTableKeyExists(true, ("HHD_StringState" + lp_gs + "String_" + HHD_RegStringTagAndReturn(lp_string))) == false)
            {
                HashTableSave0(true, ("HHD_StringState" + lp_gs + "String_" + HHD_RegStringTagAndReturn(lp_string)), "true");
                //Console.WriteLine(lp_gs + "=>" + HHD_RegStringTagAndReturn(lp_string));
            }
        }

        /// <summary>
        /// 【MM_函数库】互动SG_移除String组中的元素。使用"互动SG_添加String到String组"后可使用本函数进行移除元素。移除使用了"互动S_移除String"，同一个存储区（String组ID）序号重排，移除时该存储区如有其他操作会排队等待。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_string"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符串应写成：组[一维][二维]...以此类推</param>
        public static void HHD_ClearStringFromGroup(string lp_string, string lp_gs)
        {
            HHD_RemoveString(lp_string, lp_gs);
        }

        //互动SG_为String组中的每个序号
        //GE（星际2的Galaxy Editor）的宏让编辑器保存时自动生成脚本并整合进脚本进行格式调整，C#仅参考需自行编写
        // #AUTOVAR(vs, string) = "#PARAM(group)";//"#PARAM(group)"是与字段、变量名一致的元素组名称，宏去声明string类型名为“Auto随机编号_vs”的自动变量，然后=右侧字符串
        // #AUTOVAR(ae) = HHD_ReturnStringNumMax(#AUTOVAR(vs));//宏去声明默认int类型名为“Auto随机编号_ae”的自动变量，然后=右侧字符串
        // #INITAUTOVAR(ai,increment)//宏去声明int类型名为“Auto随机编号_ai”的自动变量，用于下面for循环增量（increment是传入参数）
        // #PARAM(var) = #PARAM(s);//#PARAM(var)是传进来的参数，用作“当前被挑选到的元素”（任意变量-整数 lp_var）， #PARAM(s)是传进来的参数用作"开始"（int lp_s）
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #PARAM(var) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #PARAM(var) >= #AUTOVAR(ae)) ) ; #PARAM(var) += #AUTOVAR(ai) ) {
        //     #SUBFUNCS(actions)//代表用户GUI填写的所有动作
        // }

        /// <summary>
        /// 【MM_函数库】互动SG_为String组中的每个序号。每次挑选的元素序号会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素序号，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符串应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void HHD_ForEachStringNumFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            int lv_ae = HHD_ReturnStringNumMax(lp_gs);
            int lv_var = lp_start;
            int lv_ai = lp_increment;
            for (; (lv_ai >= 0 && lv_var <= lv_ae) || (lv_ai < 0 && lv_var >= lv_ae); lv_var += lv_ai)
            {
                lp_funcref(lv_var);//用户填写的所有动作
            }
        }

        //互动SG_为String组中的每个元素
        // #AUTOVAR(vs, string) = "#PARAM(group)";
        // #AUTOVAR(ae) = HHD_ReturnStringNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= #PARAM(s);
        // #INITAUTOVAR(ai,increment)
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     HashTableSave(false, "StringGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)), HHD_ReturnStringFromRegNum(#AUTOVAR(va),#AUTOVAR(vs)));
        // }
        // #AUTOVAR(va)= #PARAM(s);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #PARAM(var) = HashTableLoad(false, "StringGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)));
        //     #SUBFUNCS(actions)
        // }

        /// <summary>
        /// 【MM_函数库】互动SG_为String组中的每个元素。每次挑选的元素会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符串应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void HHD_ForEachStringFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            string lv_vs = lp_gs;
            int lv_ae = HHD_ReturnStringNumMax(lv_vs);
            int lv_va = lp_start;
            int lv_ai = lp_increment;
            string lv_string;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                HashTableSave0(false, "StringGFor" + lv_vs + lv_va.ToString(), HHD_ReturnStringFromRegNum(lv_va, lv_vs));
            }
            lv_va = lp_start;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                lv_string = (string)HashTableLoad0(false, "StringGFor" + lv_vs + lv_va.ToString());
                lp_funcref(lv_string);//用户填写的所有动作
            }
        }

        /// <summary>
        /// 【MM_函数库】互动SG_返回String组中随机元素。返回指定String组中的随机String。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符串应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static string HHD_ReturnRandomStringFromStringGFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_num;
            int lv_a;
            string lv_c = null;
            // Variable Initialization
            lv_num = HHD_ReturnStringNumMax(lp_gs);
            // Implementation
            if ((lv_num >= 1))
            {
                lv_a = RandomInt(1, lv_num);
                lv_c = HHD_ReturnStringFromRegNum(lv_a, lp_gs);
            }
            return lv_c;
        }

        //互动SG_添加String组到String组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = HHD_ReturnStringNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = HHD_ReturnStringFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     HHD_AddStringToGroup(#AUTOVAR(var), #AUTOVAR(vsb));
        // }


        /// <summary>
        /// 【MM_函数库】互动SG_添加String组到String组。添加一个String组A的元素到另一个String组B，相同String被认为是同一个。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void HHD_AddStringGToStringG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = HHD_ReturnStringNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            string lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = HHD_ReturnStringFromRegNum(lv_va, lv_vsa);
                HHD_AddStringToGroup(lv_var, lv_vsb);
            }
        }

        //互动SG_从String组移除String组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = HHD_ReturnStringNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = HHD_ReturnStringFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     HHD_RemoveString(#AUTOVAR(var), #AUTOVAR(vsb));
        // }

        /// <summary>
        /// 【MM_函数库】互动SG_从String组移除String组。将String组A的元素从String组B中移除，相同String被认为是同一个。移除使用了"互动S_移除String"，同一个存储区（String组ID）序号重排，移除时该存储区如有其他操作会排队等待。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void HHD_ClearStringGFromStringG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = HHD_ReturnStringNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            string lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = HHD_ReturnStringFromRegNum(lv_va, lv_vsa);
                HHD_RemoveString(lv_var, lv_vsb);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动SG_移除String组全部元素。将String组（Key区）存储的元素全部移除，相同String被认为是同一个。移除时同一个存储区（String组ID）序号不进行重排，但该存储区如有其他操作会排队等待。String组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加String组到String组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_key">存储键区，默认填String组名称</param>
        public static void HHD_RemoveStringGAll(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag = "";
            int lv_a;
            // Variable Initialization
            lv_str = (lp_key + "String");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            // Implementation
            ThreadWait(lv_str);
            HashTableSave0(true, "Key_StringGroup" + lv_str, 1);
            for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
            {
                lv_tag = HashTableLoad1(true, (lp_key + "StringTag"), lv_a).ToString();
                lv_num -= 1;
                HashTableClear0(true, "HHD_IfStringTag" + lv_str + "_" + lv_tag);
                HashTableClear0(true, "HHD_StringCV" + lv_str + "_" + lv_tag);
                HashTableClear0(true, "HHD_StringState" + lv_str + "_" + lv_tag);
                HashTableSave0(true, (lp_key + "StringNum"), lv_num);
            }
            HashTableSave0(true, "Key_StringGroup" + lv_str, 0);
        }

        //--------------------------------------------------------------------------------------------------
        // 字符串组End
        //--------------------------------------------------------------------------------------------------

        #endregion

        #region 数字

        //提示：尽可能使用对口类型，以防值类型与引用类型发生转换时拆装箱降低性能

        //--------------------------------------------------------------------------------------------------
        // 数字组Start
        //--------------------------------------------------------------------------------------------------

        /// <summary>
        /// 【MM_函数库】互动I_注册Integer标签句柄并返回。为Integer自动设置新的标签句柄，重复时会返回已注册的Integer标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <returns>返回一个Integer的已注册标签</returns>
        private static int HHD_RegIntegerTagAndReturn_Int(int lp_integer)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)HashTableLoad0(true, "HHD_IntegerJBNum");
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                HashTableSave0(true, "HHD_IntegerJBNum", lv_j);
                HashTableSave0(true, ("HHD_Integer_" + lv_j.ToString()), lp_integer);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if ((int)HashTableLoad0(true, ("HHD_Integer_" + lv_j.ToString())) == lp_integer)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            HashTableSave0(true, "HHD_IntegerJBNum", lv_j);
                            HashTableSave0(true, ("HHD_Integer_" + lv_j.ToString()), lp_integer);
                        }
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Integer已注册标签句柄
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <returns>返回一个Integer的已注册标签，错误返回0</returns>
        public static int HHD_ReturnIntegerTag_Int(int lp_integer)
        {
            // Variable Declarations
            int lv_jBNum;
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)HashTableLoad0(true, "HHD_IntegerJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if ((int)HashTableLoad0(true, "HHD_Integer_" + lv_j.ToString()) == lp_integer)
                {
                    break;
                }
                else
                {
                    if ((lv_j == lv_jBNum))
                    {
                        lv_j = 0;
                    }
                }
            }
            return lv_j;
        }

        /// <summary>
        /// 【MM_函数库】互动I_注册Integer标签句柄并返回。为Integer自动设置新的标签句柄，重复时会返回已注册的Integer标签。这是一个内部函数，一般不需要手动使用
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <returns>返回一个Integer的已注册标签</returns>
        private static string HHD_RegIntegerTagAndReturn(int lp_integer)//内部使用
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag = "";
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)HashTableLoad0(true, "HHD_IntegerJBNum");
            lv_tag = "";
            // Implementation
            if ((lv_jBNum == 0))
            {
                lv_j = (lv_jBNum + 1);
                HashTableSave0(true, "HHD_IntegerJBNum", lv_j);
                HashTableSave0(true, ("HHD_Integer_" + lv_j.ToString()), lp_integer);
            }
            else
            {
                auto_ae = lv_jBNum;
                auto_var = 1;
                for (; auto_var <= auto_ae; auto_var += 1)
                {
                    lv_j = auto_var;
                    if ((int)HashTableLoad0(true, "HHD_Integer_" + lv_j.ToString()) == lp_integer)
                    {
                        break;
                    }
                    else
                    {
                        if ((lv_j == lv_jBNum))
                        {
                            lv_j = (lv_jBNum + 1);
                            HashTableSave0(true, "HHD_IntegerJBNum", lv_j);
                            HashTableSave0(true, ("HHD_Integer_" + lv_j.ToString()), lp_integer);
                        }
                    }
                }
            }
            lv_tag = lv_j.ToString();
            //Console.WriteLine(("Tag：" + lv_tag));
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Integer已注册标签句柄
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <returns>返回一个Integer的已注册标签，错误返回""</returns>
        public static string HHD_ReturnIntegerTag(int lp_integer)
        {
            // Variable Declarations
            int lv_jBNum;
            string lv_tag = "";
            int lv_j = 0;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_jBNum = (int)HashTableLoad0(true, "HHD_IntegerJBNum");
            // Implementation
            auto_ae = lv_jBNum;
            auto_var = 1;
            for (; auto_var <= auto_ae; auto_var += 1)
            {
                lv_j = auto_var;
                if ((int)HashTableLoad0(true, "HHD_Integer_" + lv_j.ToString()) == lp_integer)
                {
                    lv_tag = lv_j.ToString();
                    break;
                }
            }
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动I_注册Integer(高级)。在指定Key存入Integer，固有状态、自定义值是Integer独一无二的标志（本函数重复注册会刷新），之后可用互动I_"返回Integer注册总数"、"返回Integer序号"、"返回序号对应Integer"、"返回序号对应Integer标签"、"返回Integer自定义值"。Integer组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Integer组转为Key。首次注册时固有状态为true（相当于单位组单位活体），如需另外设置多个标记可使用"互动I_设定Integer状态/自定义值"
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <param name="lp_key">存储键区，默认值"_Integer"</param>
        /// <param name="lp_inherentStats">固有状态</param>
        /// <param name="lp_inherentCustomValue">固有自定义值</param>
        public static void HHD_RegInteger(int lp_integer, string lp_key, string lp_inherentStats, string lp_inherentCustomValue)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Integer");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_jBNum = (int)HashTableLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = HHD_RegIntegerTagAndReturn(lp_integer);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                HashTableSave0(true, (lv_str + "Num"), lv_i);
                HashTableSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                HashTableSave0(true, (("HHD_IfIntegerTag" + "") + "_" + lv_tagStr), true);
                HashTableSave1(true, ("HHD_IfIntegerTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if ((HashTableLoad1(true, (lv_str + "Tag"), lv_i).ToString() == lv_tagStr))
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                HashTableSave0(true, (lv_str + "Num"), lv_i);
                                HashTableSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                HashTableSave0(true, (("HHD_IfIntegerTag" + "") + "_" + lv_tagStr), true);
                                HashTableSave1(true, ("HHD_IfIntegerTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            HashTableSave0(true, ("HHD_IntegerState" + "" + "_" + lv_tagStr), lp_inherentStats);
            HashTableSave0(true, ("HHD_IntegerCV" + "" + "_" + lv_tagStr), lp_inherentCustomValue);
        }

        /// <summary>
        /// 【MM_函数库】互动I_注册Integer。在指定Key存入Integer，固有状态、自定义值是Integer独一无二的标志（本函数重复注册不会刷新），之后可用互动I_"返回Integer注册总数"、"返回Integer序号"、"返回序号对应Integer"、"返回Integer自定义值"。Integer组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Integer组转为Key。首次注册时固有状态为true（相当于单位组单位活体），之后只能通过"互动I_注册Integer（高级）"改写，如需另外设置多个标记可使用"互动I_设定Integer状态/自定义值"
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <param name="lp_key">存储键区，默认值"_Integer"</param>
        public static void HHD_RegInteger_Simple(int lp_integer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_jBNum;
            string lv_tagStr;
            int lv_tag;
            int lv_i;
            // Automatic Variable Declarations
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Integer");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_jBNum = (int)HashTableLoad0(true, (lv_str + "JBNum"));
            lv_tagStr = "";
            // Implementation
            ThreadWait(lv_str);
            lv_tagStr = HHD_RegIntegerTagAndReturn(lp_integer);
            lv_tag = Convert.ToInt32(lv_tagStr);
            if ((lv_num == 0))
            {
                lv_i = (lv_num + 1);
                HashTableSave0(true, (lv_str + "Num"), lv_i);
                HashTableSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                HashTableSave0(true, (("HHD_IfIntegerTag" + "") + "_" + lv_tagStr), true);
                HashTableSave1(true, ("HHD_IfIntegerTag" + lv_str), lv_tag, true);
            }
            else
            {
                if ((lv_num >= 1))
                {
                    auto_ae = lv_num;
                    auto_var = 1;
                    for (; auto_var <= auto_ae; auto_var += 1)
                    {
                        lv_i = auto_var;
                        if ((HashTableLoad1(true, (lv_str + "Tag"), lv_i).ToString() == lv_tagStr))
                        {
                            break;
                        }
                        else
                        {
                            if ((lv_i == lv_num))
                            {
                                lv_i = (lv_num + 1);
                                HashTableSave0(true, (lv_str + "Num"), lv_i);
                                HashTableSave1(true, (lv_str + "Tag"), lv_i, lv_tagStr);
                                HashTableSave0(true, (("HHD_IfIntegerTag" + "") + "_" + lv_tagStr), true);
                                HashTableSave1(true, ("HHD_IfIntegerTag" + lv_str), lv_tag, true);
                            }
                        }
                    }
                }
            }
            if ((HashTableKeyExists(true, ("HHD_Integer" + "State" + "_" + lv_tag.ToString())) == false))
            {
                HashTableSave1(true, (("HHD_Integer" + "State")), lv_tag, "true");
            }
        }

        /// <summary>
        /// 【MM_函数库】互动I_注销Integer。用"互动I_注册Integer"到Key，之后可用本函数彻底摧毁注册信息并将序号重排（包括Integer标签有效状态、固有状态及自定义值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动I_设定Integer状态"让Integer状态失效（类似单位组的单位活体状态）。Integer组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Integer组转为Key。本函数无法摧毁用"互动I_设定Integer状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Integer组变量ID时会清空Integer组专用状态
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <param name="lp_key">存储键区，默认值"_Integer"</param>
        public static void HHD_DestroyInteger(int lp_integer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag = "";
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Integer");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_tag = HHD_ReturnIntegerTag(lp_integer);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                ThreadWaitSet(true, "Key_IntegerGroup" + lv_str, true);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((HashTableLoad1(true, (lp_key + "IntegerTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        HashTableClear0(true, "HHD_IfIntegerTag_" + lv_tag);
                        HashTableClear0(true, "HHD_IfIntegerTag" + lv_str + "_" + lv_tag);
                        HashTableClear0(true, "HHD_Integer_" + lv_tag);
                        HashTableClear0(true, "HHD_IntegerCV_" + lv_tag);
                        HashTableClear0(true, "HHD_IntegerState_" + lv_tag);
                        HashTableClear0(true, "HHD_IntegerCV" + lv_str + "_" + lv_tag);
                        HashTableClear0(true, "HHD_IntegerState" + lv_str + "_" + lv_tag);
                        HashTableSave0(true, (lp_key + "IntegerNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = HashTableLoad1(true, (lp_key + "IntegerTag"), lv_b + 1).ToString();
                            HashTableSave1(true, (lp_key + "IntegerTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                ThreadWaitSet(true, "Key_IntegerGroup" + lv_str, false);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动I_移除Integer。用"互动I_注册Integer"到Key，之后可用本函数仅摧毁Key区注册的信息并将序号重排，用于Integer组或多个键区仅移除Integer（保留Integer标签有效状态、固有值）。注册注销同时进行会排队等待0.0625s直到没有注销动作，注销并不提升多少内存只是变量内容清空并序号重利用，非特殊要求一般不注销，而是用"互动I_设定Integer状态"让Integer状态失效（类似单位组的单位活体状态）。Integer组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Integer组转为Key。本函数无法摧毁用"互动I_设定Integer状态/自定义值"创建的状态和自定义值，需手工填入""来排泄（非大量注销则提升内存量极小，可不管）。本函数参数Key若填Integer组变量ID时会清空Integer组专用状态
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <param name="lp_key">存储键区，默认值"_Integer"</param>
        public static void HHD_RemoveInteger(int lp_integer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag = "";
            int lv_a;
            int lv_b;
            string lv_c;
            // Variable Initialization
            lv_str = (lp_key + "Integer");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_tag = HHD_ReturnIntegerTag(lp_integer);
            lv_c = "";
            // Implementation
            if ((lv_tag != null))
            {
                ThreadWait(lv_str);
                ThreadWaitSet(true, "Key_IntegerGroup" + lv_str, true);
                for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
                {
                    if ((HashTableLoad1(true, (lp_key + "IntegerTag"), lv_a).ToString() == lv_tag))
                    {
                        lv_num -= 1;
                        HashTableClear0(true, "HHD_IfIntegerTag" + lv_str + "_" + lv_tag);
                        HashTableClear0(true, "HHD_IntegerCV" + lv_str + "_" + lv_tag);
                        HashTableClear0(true, "HHD_IntegerState" + lv_str + "_" + lv_tag);
                        HashTableSave0(true, (lp_key + "IntegerNum"), lv_num);
                        for (lv_b = lv_a; lv_b <= lv_num; lv_b += 1)
                        {
                            lv_c = HashTableLoad1(true, (lp_key + "IntegerTag"), lv_b + 1).ToString();
                            HashTableSave1(true, (lp_key + "IntegerTag"), lv_b, lv_c);
                        }
                        //注销后触发序号重列，这里-1可以让挑选回滚，以再次检查重排后的当前挑选序号
                        lv_a -= 1;
                    }
                }
                ThreadWaitSet(true, "Key_IntegerGroup" + lv_str, false);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Integer注册总数。必须先使用"互动I_注册Integer"才能返回指定Key里的注册总数。Integer组使用时，可用"获取变量的内部名称"将Integer组转为Key。
        /// </summary>
        /// <param name="lp_key">存储键区，默认值"_Integer"</param>
        /// <returns></returns>
        public static int HHD_ReturnIntegerNumMax(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            // Variable Initialization
            lv_str = (lp_key + "Integer");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            // Implementation
            return lv_num;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Integer序号。使用"互动I_注册Integer"后使用本函数可返回Key里的注册序号，Key无元素返回0，Key有元素但对象不在里面则返回-1，Integer标签尚未注册则返回-2。Integer组使用时，可用"获取变量的内部名称"将Integer组转为Key
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <param name="lp_key">存储键区，默认值"_Integer"</param>
        /// <returns></returns>
        public static int HHD_ReturnIntegerNum(int lp_integer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            int lv_i;
            string lv_tag = "";
            int lv_torf;
            // Automatic Variable Declarations
            const int auto_n = 1;
            int auto_i;
            int auto_ae;
            int auto_var;
            // Variable Initialization
            lv_str = (lp_key + "Integer");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_tag = HHD_ReturnIntegerTag(lp_integer);
            lv_torf = -1;
            // Implementation
            for (auto_i = 1; auto_i <= auto_n; auto_i += 1)
            {
                if ((lv_tag != null))
                {
                    lv_torf = -2;
                    break;
                }
                if ((lv_num == 0))
                {
                    lv_torf = 0;
                }
                else
                {
                    if ((lv_num >= 1))
                    {
                        auto_ae = lv_num;
                        auto_var = 1;
                        for (; auto_var <= auto_ae; auto_var += 1)
                        {
                            lv_i = auto_var;
                            if ((HashTableLoad1(true, (lv_str + "Tag"), lv_i).ToString() == lv_tag))
                            {
                                lv_torf = lv_i;
                                break;
                            }
                        }
                    }
                }
            }
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回序号对应Integer。使用"互动I_注册Integer"后，在参数填入注册序号可返回Integer。Integer组使用时，可用"获取变量的内部名称"将Integer组转为Key
        /// </summary>
        /// <param name="lp_regNum"></param>
        /// <param name="lp_key">存储键区，默认值"_Integer"</param>
        /// <returns></returns>
        public static int HHD_ReturnIntegerFromRegNum(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            int lv_integer;
            // Variable Initialization
            lv_str = (lp_key + "Integer");
            lv_tag = HashTableLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            lv_integer = (int)HashTableLoad0(true, ("HHD_Integer_" + lv_tag));
            // Implementation
            return lv_integer;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回句柄标签对应Integer。使用"互动I_注册Integer"后，在参数填入句柄标签（整数）可返回Integer，标签是Integer的句柄。Integer组使用时，可用"获取变量的内部名称"将Integer组转为Key
        /// </summary>
        /// <param name="lp_tag">句柄标签</param>
        /// <returns></returns>
        public static int HHD_ReturnIntegerFromTag(int lp_tag)
        {
            // Variable Declarations
            string lv_tag = "";
            int lv_integer;
            // Variable Initialization
            lv_tag = lp_tag.ToString();
            lv_integer = (int)HashTableLoad0(true, ("HHD_Integer_" + lv_tag));
            // Implementation
            return lv_integer;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回序号对应Integer标签句柄。使用"互动I_注册Integer"后，在参数填入注册序号可返回Integer标签（字符串）。Integer组使用时，可用"获取变量的内部名称"将Integer组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Integer"</param>
        /// <returns></returns>
        public static string HHD_ReturnIntegerTagFromRegNum_String(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Integer");
            lv_tag = HashTableLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return lv_tag;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回序号对应Integer标签句柄。使用"互动I_注册Integer"后，在参数填入注册序号可返回Integer标签（整数）。Integer组使用时，可用"获取变量的内部名称"将Integer组转为Key
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_key">存储键区，默认值"_Integer"</param>
        /// <returns></returns>
        public static int HHD_ReturnIntegerTagFromRegNum_Int(int lp_regNum, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Integer");
            lv_tag = HashTableLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            // Implementation
            return Convert.ToInt32(lv_tag);
        }

        /// <summary>
        /// 【MM_函数库】互动I_设置Integer状态。必须先"注册"获得功能库内部句柄，再使用本函数给Integer设定一个状态值，之后可用"互动I_返回Integer状态"。类型参数用以记录多个不同状态，仅当"类型"参数填Integer组ID转的Integer串时，状态值"true"和"false"是Integer的Integer组专用状态值，用于内部函数筛选Integer状态（相当于单位组单位索引是否有效），其他类型不会干扰系统内部，可随意填写。虽然注销时反向清空注册信息，但用"互动I_设定Integer状态/自定义值"创建的值需要手工填入""来排泄（非大量注销则提升内存量极小，可不管）。注：固有状态值是注册函数赋予的系统内部变量（相当于单位组单位是否活体），只能通过"互动I_注册Integer（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <param name="lp_stats">状态</param>
        public static void HHD_SetIntegerState(int lp_integer, string lp_key, string lp_stats)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Integer");
            lv_tag = HHD_RegIntegerTagAndReturn(lp_integer);
            // Implementation
            HashTableSave0(true, ("HHD_IntegerState" + lv_str + "_" + lv_tag), lp_stats);
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Integer状态。使用"互动I_设定Integer状态"后可使用本函数，将本函数参数"类型"设为空时返回固有值。类型参数用以记录多个不同状态，仅当"类型"参数为Integer组ID转的字符串时，返回的状态值"true"和"false"是Integer的Integer组专用状态值，用于内部函数筛选Integer状态（相当于单位组单位索引是否有效）
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <param name="lp_key">存储类型，默认值"State"</param>
        /// <returns></returns>
        public static string HHD_ReturnIntegerState(int lp_integer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_str = (lp_key + "Integer");
            lv_tag = HHD_ReturnIntegerTag(lp_integer);
            lv_stats = HashTableLoad0(true, ("HHD_IntegerState" + lv_str + "_" + lv_tag)).ToString();
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动I_设置Integer自定义值。必须先"注册"获得功能库内部句柄，再使用本函数设定Integer的自定义值，之后可使用"互动I_返回Integer自定义值"，类型参数用以记录多个不同自定义值。注：固有自定义值是注册函数赋予的系统内部变量，只能通过"互动I_注册Integer（高级）"函数或将本函数参数"类型"设为空时改写
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <param name="lp_customValue">自定义值</param>
        public static void HHD_SetIntegerCV(int lp_integer, string lp_key, string lp_customValue)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            // Variable Initialization
            lv_str = (lp_key + "Integer");
            lv_tag = HHD_RegIntegerTagAndReturn(lp_integer);
            // Implementation
            HashTableSave0(true, ("HHD_IntegerCV" + lv_str + "_" + lv_tag), lp_customValue);
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Integer自定义值。使用"互动I_设定Integer自定义值"后可使用本函数，将本函数参数"类型"设为空时返回固有值，该参数用以记录多个不同自定义值
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <param name="lp_key">存储类型，默认值"A"</param>
        /// <returns></returns>
        public static string HHD_ReturnIntegerCV(int lp_integer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_str = (lp_key + "Integer");
            lv_tag = HHD_ReturnIntegerTag(lp_integer);
            lv_customValue = HashTableLoad0(true, ("HHD_IntegerCV" + lv_str + "_" + lv_tag)).ToString();
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Integer固有状态。必须先使用"互动I_注册Integer"才能返回到该值，固有状态是独一无二的标记（相当于单位组单位是否活体）
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <returns></returns>
        public static string HHD_ReturnIntegerState_Only(int lp_integer)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_stats;
            // Variable Initialization
            lv_tag = HHD_ReturnIntegerTag(lp_integer);
            lv_stats = HashTableLoad0(true, ("HHD_IntegerState" + "" + "_" + lv_tag)).ToString();
            // Implementation
            return lv_stats;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Integer固有自定义值。必须先使用"互动I_注册Integer"才能返回到该值，固有值是独一无二的标记
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <returns></returns>
        public static string HHD_ReturnIntegerCV_Only(int lp_integer)
        {
            // Variable Declarations
            string lv_tag = "";
            string lv_customValue;
            // Variable Initialization
            lv_tag = HHD_ReturnIntegerTag(lp_integer);
            lv_customValue = HashTableLoad0(true, ("HHD_IntegerCV" + "" + "_" + lv_tag)).ToString();
            // Implementation
            return lv_customValue;
        }

        /// <summary>
        /// 【MM_函数库】互动I_设置Integer的实数标记。必须先"注册"获得功能库内部句柄，再使用本函数让Integer携带一个实数值，之后可使用"互动I_返回Integer的实数标记"。Integer组使用时，可用"获取变量的内部名称"将Integer组转为Key
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <param name="lp_realNumTag">实数标记</param>
        public static void HHD_SetIntegerDouble(int lp_integer, double lp_realNumTag)
        {
            // Variable Declarations
            string lv_tag = "";
            // Variable Initialization
            lv_tag = HHD_RegIntegerTagAndReturn(lp_integer);
            // Implementation
            HashTableSave0(true, ("HHD_CDDouble_T_" + lv_tag), lp_realNumTag);
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Integer的实数标记。使用"互动I_设定Integer的实数标记"后可使用本函数。Integer组使用时，可用"获取变量的内部名称"将Integer组转为Key
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <returns></returns>
        public static double HHD_ReturnIntegerDouble(int lp_integer)
        {
            // Variable Declarations
            string lv_tag = "";
            double lv_f;
            // Variable Initialization
            lv_tag = HHD_ReturnIntegerTag(lp_integer);
            lv_f = (double)HashTableLoad0(true, ("HHD_CDDouble_T_" + lv_tag));
            // Implementation
            return lv_f;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Integer标签句柄有效状态。将Integer视作独一无二的个体，标签是它本身，有效状态则类似"单位是否有效"，当使用"互动I_注册Integer"或"互动IG_添加Integer到Integer组"后激活Integer有效状态（值为"true"），除非使用"互动I_注册Integer（高级）"改写，否则直到注销才会摧毁
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <returns></returns>
        public static bool HHD_ReturnIfIntegerTag(int lp_integer)
        {
            // Variable Declarations
            string lv_tag = "";
            bool lv_torf;
            // Variable Initialization
            lv_tag = HHD_ReturnIntegerTag(lp_integer);
            lv_torf = (bool)HashTableLoad0(true, ("HHD_IfIntegerTag" + "" + "_" + lv_tag));
            // Implementation
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动I_返回Integer注册状态。使用"互动I_注册Integer"或"互动IG_添加Integer到Integer组"后可使用本函数获取注册Integer在Key中的注册状态，该状态只能注销或从Integer组中移除时清空。Integer组使用时，Key被强制为变量ID，可用"获取变量的内部名称"将Integer组转为Key
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <param name="lp_key">存储键区，默认值"_Integer"</param>
        /// <returns></returns>
        public static bool HHD_ReturnIfIntegerTagKey(int lp_integer, string lp_key)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            bool lv_torf;
            // Variable Initialization
            lv_str = (lp_key + "Integer");
            lv_tag = HHD_ReturnIntegerTag(lp_integer);
            lv_torf = (bool)HashTableLoad0(true, ("HHD_IfIntegerTag" + lv_str + "_" + lv_tag));
            // Implementation
            return lv_torf;
        }

        /// <summary>
        /// 【MM_函数库】互动IG_根据自定义值类型将Integer组排序。根据Integer携带的自定义值类型，对指定的Integer组元素进行冒泡排序。Integer组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Integer组名称</param>
        /// <param name="lp_cVStr">自定义值类型</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void HHD_IntegerGSortCV(string lp_key, string lp_cVStr, bool lp_big)
        {
            // Automatic Variable Declarations
            // Implementation
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            string lv_tagValuestr;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Integer");
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_IntegerGroup" + lv_str, true);
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = HHD_ReturnIntegerTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValuestr = HHD_ReturnIntegerCV(HHD_ReturnIntegerFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    HashTableSave1(false, "IntStackOutTag", 1, lv_tag);
                    HashTableSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    HashTableSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < (int)HashTableLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    HashTableSave1(false, "IntStackOutTag", lv_c, HashTableLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    HashTableSave1(false, "IntStackOutTagValue", lv_c, HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    HashTableSave1(false, "IntStackOutTagIteraOrig", lv_c, HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                HashTableSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                HashTableSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                HashTableSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > (int)HashTableLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(HHD_ReturnIntegerTagFromRegNum(lv_b, lp_key))+"值"+IntToString(HashTableLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    HashTableSave1(false, "IntStackOutTag", lv_c, HashTableLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(HashTableLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    HashTableSave1(false, "IntStackOutTagValue", lv_c, HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    HashTableSave1(false, "IntStackOutTagIteraOrig", lv_c, HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                HashTableSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                HashTableSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                HashTableSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        HashTableSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        HashTableSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        HashTableSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = HashTableLoad1(true, (lp_key + "IntegerTag"), lv_a).ToString(); //原始序号元素
                lv_tag = (int)HashTableLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValuestr = HHD_ReturnIntegerCV(HHD_ReturnIntegerFromTag(lv_tag), lp_cVStr);
                lv_tagValue = Convert.ToInt32(lv_tagValuestr);
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = (int)HashTableLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    HashTableSave1(true, (lp_key + "IntegerTag"), lv_a, lv_tag); //lv_tag放入新序号
                    //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            ThreadWaitSet(true, "Key_IntegerGroup" + lv_str, false);
        }

        /// <summary>
        /// 【MM_函数库】互动IG_Integer组排序。对指定的Integer组元素进行冒泡排序（根据元素句柄）。Integer组变量字符可通过"转换变量内部名称"获得
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Integer组名称</param>
        /// <param name="lp_big">是否大值靠前</param>
        public static void HHD_IntegerGSort(string lp_key, bool lp_big)
        {
            // Automatic Variable Declarations
            // Implementation
            // Variable Declarations
            int lv_a;
            int lv_b;
            int lv_c;
            bool lv_bool;
            int lv_tag;
            int lv_tagValue;
            string lv_str;
            int lv_num;
            int lv_intStackOutSize;
            // Automatic Variable Declarations
            int autoB_ae;
            const int autoB_ai = 1;
            int autoC_ae;
            const int autoC_ai = 1;
            int autoHD_ae;
            const int autoHD_ai = -1;
            int autoE_ae;
            const int autoE_ai = 1;
            // Variable Initialization
            lv_str = (lp_key + "Integer");
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_IntegerGroup" + lv_str, true);
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            lv_intStackOutSize = 0;
            // Implementation
            autoB_ae = lv_num;
            lv_a = 1;
            for (; ((autoB_ai >= 0 && lv_a <= autoB_ae) || (autoB_ai < 0 && lv_a >= autoB_ae)); lv_a += autoB_ai)
            {
                lv_tag = HHD_ReturnIntegerTagFromRegNum_Int(lv_a, lp_key);
                lv_tagValue = lv_tag;
                //Console.WriteLine("循环" + IntToString(lv_a) +"tag"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue));
                if ((lv_intStackOutSize == 0))
                {
                    lv_intStackOutSize += 1;
                    HashTableSave1(false, "IntStackOutTag", 1, lv_tag);
                    HashTableSave1(false, "IntStackOutTagValue", 1, lv_tagValue);
                    HashTableSave1(false, "IntStackOutTagIteraOrig", 1, lv_a);
                    //Console.WriteLine("尺寸" + IntToString(lv_intStackOutSize) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue)+"，IteraOrig="+IntToString(lv_a));
                }
                else
                {
                    lv_bool = false;
                    autoC_ae = lv_intStackOutSize;
                    lv_b = 1;
                    //Console.WriteLine("For" + IntToString(1) +"到"+IntToString(autoC_ae));
                    for (; ((autoC_ai >= 0 && lv_b <= autoC_ae) || (autoC_ai < 0 && lv_b >= autoC_ae)); lv_b += autoC_ai)
                    {
                        if (lp_big == false)
                        {
                            //Console.WriteLine("小值靠前");
                            if (lv_tagValue < (int)HashTableLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                lv_intStackOutSize += 1;
                                autoHD_ae = (lv_b + 1);
                                lv_c = lv_intStackOutSize;
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    HashTableSave1(false, "IntStackOutTag", lv_c, HashTableLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    HashTableSave1(false, "IntStackOutTagValue", lv_c, HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    HashTableSave1(false, "IntStackOutTagIteraOrig", lv_c, HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                }
                                HashTableSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                HashTableSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                HashTableSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                lv_bool = true;
                                break;
                            }
                        }
                        else
                        {
                            //Console.WriteLine("大值靠前"+"，当前lv_b=" +IntToString(lv_b));
                            if (lv_tagValue > (int)HashTableLoad1(false, "IntStackOutTagValue", lv_b))
                            {
                                //Console.WriteLine("Num" + IntToString(lv_a) +"元素"+IntToString(lv_tag) +"值"+IntToString(lv_tagValue) + ">第Lv_b="+IntToString(lv_b)+"元素"+IntToString(HHD_ReturnIntegerTagFromRegNum(lv_b, lp_key))+"值"+IntToString(HashTableLoad1(false, "IntStackOutTagValue", lv_b)));
                                //Console.WriteLine("生效的lv_b：" + IntToString(lv_b));
                                lv_intStackOutSize += 1;
                                //Console.WriteLine("lv_intStackOutSize：" + IntToString(lv_intStackOutSize));
                                autoHD_ae = (lv_b + 1);
                                //Console.WriteLine("autoHD_ae：" + IntToString(autoHD_ae));
                                lv_c = lv_intStackOutSize;
                                //Console.WriteLine("lv_c：" + IntToString(lv_c));
                                //Console.WriteLine("递减For lv_c=" + IntToString(lv_c) +"≥"+IntToString(autoHD_ae));
                                for (; ((autoHD_ai >= 0 && lv_c <= autoHD_ae) || (autoHD_ai < 0 && lv_c >= autoHD_ae)); lv_c += autoHD_ai)
                                {
                                    HashTableSave1(false, "IntStackOutTag", lv_c, HashTableLoad1(false, "IntStackOutTag", (lv_c - 1)));
                                    //Console.WriteLine("交换元素" + IntToString(HashTableLoad1(false, "IntStackOutTag", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    HashTableSave1(false, "IntStackOutTagValue", lv_c, HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1)));
                                    //Console.WriteLine("交换值" + IntToString(HashTableLoad1(false, "IntStackOutTagValue", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                    HashTableSave1(false, "IntStackOutTagIteraOrig", lv_c, HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1)));
                                    //Console.WriteLine("交换新序值" + IntToString(HashTableLoad1(false, "IntStackOutTagIteraOrig", (lv_c - 1))) +"从序号"+IntToString(lv_c - 1) +"到"+IntToString(lv_c));
                                }
                                HashTableSave1(false, "IntStackOutTag", lv_b, lv_tag);
                                //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到lv_b="+IntToString(lv_b) +"位置");
                                HashTableSave1(false, "IntStackOutTagValue", lv_b, lv_tagValue);
                                //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到lv_b="+IntToString(lv_b) +"位置");
                                HashTableSave1(false, "IntStackOutTagIteraOrig", lv_b, lv_a);
                                //Console.WriteLine("值IteraOrig=lv_a=" + IntToString(lv_a) +"存到序号lv_b="+IntToString(lv_b) +"位置");
                                lv_bool = true;
                                break;
                            }
                        }
                    }
                    if ((lv_bool == false))
                    {
                        lv_intStackOutSize += 1;
                        HashTableSave1(false, "IntStackOutTag", lv_intStackOutSize, lv_tag);
                        //Console.WriteLine("lv_tag=" + IntToString(lv_tag) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        HashTableSave1(false, "IntStackOutTagValue", lv_intStackOutSize, lv_tagValue);
                        //Console.WriteLine("lv_tagValue=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                        HashTableSave1(false, "IntStackOutTagIteraOrig", lv_intStackOutSize, lv_a);
                        //Console.WriteLine("IteraOrig=lv_a=" + IntToString(lv_tagValue) +"存到尺寸="+IntToString(lv_intStackOutSize) +"位置");
                    }
                }
            }
            autoE_ae = lv_num; //此时lv_intStackOutSize=Num
            lv_a = 1;
            //Console.WriteLine("最终处理For 1~" + IntToString(lv_num));
            for (; ((autoE_ai >= 0 && lv_a <= autoE_ae) || (autoE_ai < 0 && lv_a >= autoE_ae)); lv_a += autoE_ai)
            {
                //从序号里取出元素Tag、自定义值、新老句柄，让元素交换
                //lv_tag = HashTableLoad1(true, (lp_key + "IntegerTag"), lv_a).ToString(); //原始序号元素
                lv_tag = (int)HashTableLoad1(false, "IntStackOutTag", lv_a);
                lv_tagValue = lv_tag;
                //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag));
                lv_b = (int)HashTableLoad1(false, "IntStackOutTagIteraOrig", lv_a); //lv_tag的原序号位置
                                                                                    //Console.WriteLine("第"+IntToString(lv_a) +"个元素：" + IntToString(lv_tag) + "值"+ IntToString(lv_tagValue)+"原序号：" + IntToString(lv_tag));
                if (lv_a != lv_b)
                {
                    //Console.WriteLine("lv_a："+IntToString(lv_a) +"不等于lv_b" + IntToString(lv_b));
                    HashTableSave1(true, (lp_key + "IntegerTag"), lv_a, lv_tag); //lv_tag放入新序号
                                                                                 //Console.WriteLine("元素"+IntToString(lv_tag) +"放入lv_b=" + IntToString(lv_b)+"位置");
                }
            }
            ThreadWaitSet(true, "Key_IntegerGroup" + lv_str, false);
        }

        /// <summary>
        /// 【MM_函数库】互动IG_设定Integer的Integer组专用状态。给Integer组的Integer设定一个状态值（字符串），之后可用"互动I_返回Integer、互动IG_返回Integer组的Integer状态"。状态值"true"和"false"是Integer的Integer组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效），而本函数可以重设干预，影响函数"互动IG_返回Integer组元素数量（仅检索XX状态）"。与"互动I_设定Integer状态"功能相同，只是状态参数在Integer组中被固定为"Integer组变量的内部ID"。Integer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Integer组到Integer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <param name="lp_integerGroup"></param>
        /// <param name="lp_groupState"></param>
        public static void HHD_SetIntegerGState(int lp_integer, string lp_integerGroup, string lp_groupState)
        {
            HHD_SetIntegerState(lp_integer, lp_integerGroup, lp_groupState);
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Integer的Integer组专用状态。使用"互动I_设定Integer、互动IG_设定Integer组的Integer状态"后可使用本函数。与"互动I_返回Integer状态"功能相同，只是状态参数在Integer组中被固定为"Integer组变量的内部ID"。状态值"true"和"false"是Integer的Integer组专用状态值，用于内部函数筛选字符状态（相当于单位组单位索引是否有效）。Integer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Integer组到Integer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <param name="lp_integerGroup"></param>
        public static void HHD_ReturnIntegerGState(int lp_integer, string lp_integerGroup)
        {
            HHD_ReturnIntegerState(lp_integer, lp_integerGroup);
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Integer组元素序号对应元素。返回Integer组元素序号指定Integer。Integer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Integer组到Integer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_regNum">注册序号</param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HHD_ReturnIntegerFromIntegerGFunc(int lp_regNum, string lp_gs)
        {
            // Variable Declarations
            string lv_str;
            string lv_tag = "";
            int lv_integer;
            // Variable Initialization
            lv_str = (lp_gs + "Integer");
            lv_tag = HashTableLoad1(true, (lv_str + "Tag"), lp_regNum).ToString();
            lv_integer = (int)HashTableLoad0(true, ("HHD_Integer_" + lv_tag));
            // Implementation
            return lv_integer;
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Integer组元素总数。返回指定Integer组的元素数量。Integer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Integer组到Integer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HHD_ReturnIntegerGNumMax(string lp_gs)
        {
            return (int)HashTableLoad0(true, lp_gs + "IntegerNum");
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Integer组元素总数（仅检测Integer组专用状态="true"）。返回指定Integer组的元素数量。Integer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Integer组到Integer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HHD_ReturnIntegerGNumMax_StateTrueFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            int lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HHD_ReturnIntegerNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HHD_ReturnIntegerFromRegNum(lv_a, lp_gs);
                lv_b = HHD_ReturnIntegerState(lv_c, lp_gs);
                if ((lv_b == "true"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Integer组元素总数（仅检测Integer组专用状态="false"）。返回指定Integer组的元素数量。Integer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Integer组到Integer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HHD_ReturnIntegerGNumMax_StateFalseFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            int lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HHD_ReturnIntegerNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HHD_ReturnIntegerFromRegNum(lv_a, lp_gs);
                lv_b = HHD_ReturnIntegerState(lv_c, lp_gs);
                if ((lv_b == "false"))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Integer组元素总数（仅检测Integer组无效专用状态："false"或""）。返回指定Integer组的元素数量（false、""、null）。Integer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Integer组到Integer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HHD_ReturnIntegerGNumMax_StateUselessFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            int lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HHD_ReturnIntegerNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HHD_ReturnIntegerFromRegNum(lv_a, lp_gs);
                lv_b = HHD_ReturnIntegerState(lv_c, lp_gs);
                if (((lv_b == "false") || (lv_b == "") || (lv_b == null)))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Integer组元素总数（仅检测Integer组指定专用状态）。返回指定Integer组的元素数量。Integer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Integer组到Integer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_State">Integer组专用状态</param>
        /// <returns></returns>
        public static int HHD_ReturnIntegerGNumMax_StateFunc_Specify(string lp_gs, string lp_State)
        {
            // Variable Declarations
            int lv_a;
            string lv_b;
            int lv_c;
            int lv_i = 0;
            // Automatic Variable Declarations
            int auto_ae;
            const int auto_ai = 1;
            // Variable Initialization
            lv_b = "";
            // Implementation
            auto_ae = HHD_ReturnIntegerNumMax(lp_gs);
            lv_a = 1;
            for (; ((auto_ai >= 0 && lv_a <= auto_ae) || (auto_ai < 0 && lv_a >= auto_ae)); lv_a += auto_ai)
            {
                lv_c = HHD_ReturnIntegerFromRegNum(lv_a, lp_gs);
                lv_b = HHD_ReturnIntegerState(lv_c, lp_gs);
                if ((lv_b == lp_State))
                {
                    lv_i += 1;
                }
            }
            return lv_i;
        }

        /// <summary>
        /// 【MM_函数库】互动IG_添加Integer到Integer组。相同Integer被认为是同一个，非高级功能不提供专用状态检查，如果Integer没有设置过Integer组专用状态，那么首次添加到Integer组不会赋予"true"（之后可通过"互动I_设定Integer状态"、"互动IG_设定Integer组的Integer状态"修改）。Integer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Integer组到Integer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HHD_AddIntegerToGroup_Simple(int lp_integer, string lp_gs)
        {
            HHD_RegInteger_Simple(lp_integer, lp_gs);
        }

        /// <summary>
        /// 【MM_函数库】互动IG_添加Integer到Integer组（高级）。相同Integer被认为是同一个，高级功能提供专用状态检查，如果Integer没有设置过Integer组专用状态，那么首次添加到Integer组会赋予"true"（之后可通过"互动I_设定Integer状态"、"互动IG_设定Integer组的Integer状态"修改）。Integer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Integer组到Integer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HHD_AddIntegerToGroup(int lp_integer, string lp_gs)
        {
            HHD_RegInteger_Simple(lp_integer, lp_gs);
            if (HashTableKeyExists(true, ("HHD_IntegerState" + lp_gs + "Integer_" + HHD_RegIntegerTagAndReturn(lp_integer))) == false)
            {
                HashTableSave0(true, ("HHD_IntegerState" + lp_gs + "Integer_" + HHD_RegIntegerTagAndReturn(lp_integer)), "true");
                //Console.WriteLine(lp_gs + "=>" + HHD_RegIntegerTagAndReturn(lp_integer));
            }
        }

        /// <summary>
        /// 【MM_函数库】互动IG_移除Integer组中的元素。使用"互动IG_添加Integer到Integer组"后可使用本函数进行移除元素。移除使用了"互动I_移除Integer"，同一个存储区（Integer组ID）序号重排，移除时该存储区如有其他操作会排队等待。Integer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Integer组到Integer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_integer"></param>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        public static void HHD_ClearIntegerFromGroup(int lp_integer, string lp_gs)
        {
            HHD_RemoveInteger(lp_integer, lp_gs);
        }

        //互动IG_为Integer组中的每个序号
        //GE（星际2的Galaxy Editor）的宏让编辑器保存时自动生成脚本并整合进脚本进行格式调整，C#仅参考需自行编写
        // #AUTOVAR(vs, string) = "#PARAM(group)";//"#PARAM(group)"是与字段、变量名一致的元素组名称，宏去声明string类型名为“Auto随机编号_vs”的自动变量，然后=右侧字符
        // #AUTOVAR(ae) = HHD_ReturnIntegerNumMax(#AUTOVAR(vs));//宏去声明默认int类型名为“Auto随机编号_ae”的自动变量，然后=右侧字符
        // #INITAUTOVAR(ai,increment)//宏去声明int类型名为“Auto随机编号_ai”的自动变量，用于下面for循环增量（increment是传入参数）
        // #PARAM(var) = #PARAM(s);//#PARAM(var)是传进来的参数，用作“当前被挑选到的元素”（任意变量-整数 lp_var）， #PARAM(s)是传进来的参数用作"开始"（int lp_s）
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #PARAM(var) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #PARAM(var) >= #AUTOVAR(ae)) ) ; #PARAM(var) += #AUTOVAR(ai) ) {
        //     #SUBFUNCS(actions)//代表用户GUI填写的所有动作
        // }

        /// <summary>
        /// 【MM_函数库】互动IG_为Integer组中的每个序号。每次挑选的元素序号会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素序号，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Integer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Integer组到Integer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void HHD_ForEachIntegerNumFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            int lv_ae = HHD_ReturnIntegerNumMax(lp_gs);
            int lv_var = lp_start;
            int lv_ai = lp_increment;
            for (; (lv_ai >= 0 && lv_var <= lv_ae) || (lv_ai < 0 && lv_var >= lv_ae); lv_var += lv_ai)
            {
                lp_funcref(lv_var);//用户填写的所有动作
            }
        }

        //互动IG_为Integer组中的每个元素
        // #AUTOVAR(vs, string) = "#PARAM(group)";
        // #AUTOVAR(ae) = HHD_ReturnIntegerNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= #PARAM(s);
        // #INITAUTOVAR(ai,increment)
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     HashTableSave(false, "IntegerGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)), HHD_ReturnIntegerFromRegNum(#AUTOVAR(va),#AUTOVAR(vs)));
        // }
        // #AUTOVAR(va)= #PARAM(s);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #PARAM(var) = HashTableLoad(false, "IntegerGFor"+ #AUTOVAR(vs) + IntToString(#AUTOVAR(va)));
        //     #SUBFUNCS(actions)
        // }

        /// <summary>
        /// 【MM_函数库】互动IG_为Integer组中的每个元素。每次挑选的元素会自行在动作组（委托函数）中使用，委托函数特征：void SubActionTest(int lp_var)，参数lp_var即每次遍历到的元素，请自行组织它在委托函数内如何使用，SubActionTest可直接作为本函数最后一个参数填入，填入多个动作范例：SubActionEventFuncref Actions += SubActionTest，然后Actions作为参数填入。Integer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Integer组到Integer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <param name="lp_start">开始</param>
        /// <param name="lp_increment">增量</param>
        /// <param name="lp_funcref">委托类型变量或函数引用</param>
        public static void HHD_ForEachIntegerFromGroup(string lp_gs, int lp_start, int lp_increment, SubActionEventFuncref lp_funcref)
        {
            string lv_vs = lp_gs;
            int lv_ae = HHD_ReturnIntegerNumMax(lv_vs);
            int lv_va = lp_start;
            int lv_ai = lp_increment;
            int lv_integer;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                HashTableSave0(false, "IntegerGFor" + lv_vs + lv_va.ToString(), HHD_ReturnIntegerFromRegNum(lv_va, lv_vs));
            }
            lv_va = lp_start;
            for (; (lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae); lv_va += lv_ai)
            {
                lv_integer = (int)HashTableLoad0(false, "IntegerGFor" + lv_vs + lv_va.ToString());
                lp_funcref(lv_integer);//用户填写的所有动作
            }
        }

        /// <summary>
        /// 【MM_函数库】互动IG_返回Integer组中随机元素。返回指定Integer组中的随机Integer。Integer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Integer组到Integer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_gs">元素组的名称，建议与字段、变量名一致，数组使用时字符应写成：组[一维][二维]...以此类推</param>
        /// <returns></returns>
        public static int HHD_ReturnRandomIntegerFromIntegerGFunc(string lp_gs)
        {
            // Variable Declarations
            int lv_num;
            int lv_a;
            int lv_c = 0;
            // Variable Initialization
            lv_num = HHD_ReturnIntegerNumMax(lp_gs);
            // Implementation
            if ((lv_num >= 1))
            {
                lv_a = RandomInt(1, lv_num);
                lv_c = HHD_ReturnIntegerFromRegNum(lv_a, lp_gs);
            }
            return lv_c;
        }

        //互动IG_添加Integer组到Integer组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = HHD_ReturnIntegerNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = HHD_ReturnIntegerFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     HHD_AddIntegerToGroup(#AUTOVAR(var), #AUTOVAR(vsb));
        // }


        /// <summary>
        /// 【MM_函数库】互动IG_添加Integer组到Integer组。添加一个Integer组A的元素到另一个Integer组B，相同Integer被认为是同一个。Integer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Integer组到Integer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void HHD_AddIntegerGToIntegerG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = HHD_ReturnIntegerNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            int lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = HHD_ReturnIntegerFromRegNum(lv_va, lv_vsa);
                HHD_AddIntegerToGroup(lv_var, lv_vsb);
            }
        }

        //互动IG_从Integer组移除Integer组
        // #AUTOVAR(vs, string) = "#PARAM(groupA)";
        // #AUTOVAR(vsb, string) = "#PARAM(groupB)";
        // #AUTOVAR(ae) = HHD_ReturnIntegerNumMax(#AUTOVAR(vs));
        // #AUTOVAR(va)= 1;
        // #AUTOVAR(ai)= 1;
        // #AUTOVAR(var);
        // for ( ; ( (#AUTOVAR(ai) >= 0 && #AUTOVAR(va) <= #AUTOVAR(ae)) || (#AUTOVAR(ai) < 0 && #AUTOVAR(va) >= #AUTOVAR(ae)) ) ; #AUTOVAR(va) += #AUTOVAR(ai) ) {
        //     #AUTOVAR(var) = HHD_ReturnIntegerFromRegNum(#AUTOVAR(va), #AUTOVAR(vs));
        //     HHD_RemoveInteger(#AUTOVAR(var), #AUTOVAR(vsb));
        // }

        /// <summary>
        /// 【MM_函数库】互动IG_从Integer组移除Integer组。将Integer组A的元素从Integer组B中移除，相同Integer被认为是同一个。移除使用了"互动I_移除Integer"，同一个存储区（Integer组ID）序号重排，移除时该存储区如有其他操作会排队等待。Integer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Integer组到Integer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_groupA"></param>
        /// <param name="lp_groupB"></param>
        public static void HHD_ClearIntegerGFromIntegerG(string lp_groupA, string lp_groupB)
        {
            string lv_vsa = lp_groupA;
            string lv_vsb = lp_groupB;
            int lv_ae = HHD_ReturnIntegerNumMax(lv_vsa);
            int lv_va = 1;
            int lv_ai = 1;
            int lv_var;
            for (; ((lv_ai >= 0 && lv_va <= lv_ae) || (lv_ai < 0 && lv_va >= lv_ae)); lv_va += lv_ai)
            {
                lv_var = HHD_ReturnIntegerFromRegNum(lv_va, lv_vsa);
                HHD_RemoveInteger(lv_var, lv_vsb);
            }
        }

        /// <summary>
        /// 【MM_函数库】互动IG_移除Integer组全部元素。将Integer组（Key区）存储的元素全部移除，相同Integer被认为是同一个。移除时同一个存储区（Integer组ID）序号不进行重排，但该存储区如有其他操作会排队等待。Integer组目前不支持赋值其他变量，绝对ID对应绝对Key，可使用"添加Integer组到Integer组"函数来完成赋值需求
        /// </summary>
        /// <param name="lp_key">存储键区，默认填Integer组名称</param>
        public static void HHD_RemoveIntegerGAll(string lp_key)
        {
            // Variable Declarations
            string lv_str;
            int lv_num;
            string lv_tag = "";
            int lv_a;
            // Variable Initialization
            lv_str = (lp_key + "Integer");
            lv_num = (int)HashTableLoad0(true, (lv_str + "Num"));
            // Implementation
            ThreadWait(lv_str);
            ThreadWaitSet(true, "Key_IntegerGroup" + lv_str, true);
            for (lv_a = 1; lv_a <= lv_num; lv_a += 1)
            {
                lv_tag = HashTableLoad1(true, (lp_key + "IntegerTag"), lv_a).ToString();
                lv_num -= 1;
                HashTableClear0(true, "HHD_IfIntegerTag" + lv_str + "_" + lv_tag);
                HashTableClear0(true, "HHD_IntegerCV" + lv_str + "_" + lv_tag);
                HashTableClear0(true, "HHD_IntegerState" + lv_str + "_" + lv_tag);
                HashTableSave0(true, (lp_key + "IntegerNum"), lv_num);
            }
            ThreadWaitSet(true, "Key_IntegerGroup" + lv_str, false);
        }

        //--------------------------------------------------------------------------------------------------
        // 数字组End
        //--------------------------------------------------------------------------------------------------

        #endregion

        #endregion

        #endregion

        #endregion

        #region Functions 键鼠事件动作主体

        //加入按键监听并传参执行

        /// <summary>
        /// 【MM_函数库】注册键鼠总控预制事件。通过本函数可快捷将RecordService类实例中5个预制事件KeyDown、KeyUp、MouseMove、MouseDown、MouseUp注册给库内预制函数引用，从而使用按键总控管理衍生的所有功能（比如将“移动”、“发射火箭”等函数动作注册给Q键）
        /// </summary>
        /// <param name="cover">true：覆盖注册，false：追加注册</param>
        public static void AddKeyMouseEvent(RecordService keyMouseRecordService, bool cover)
        {
            if (cover)
            {
                //执行事件覆盖
                keyMouseRecordService.KeyDownEvent = KeyDown;
                keyMouseRecordService.KeyUpEvent = KeyUp;
                keyMouseRecordService.MouseMoveEvent = MouseMove;
                keyMouseRecordService.MouseDownEvent = MouseDown;
                keyMouseRecordService.MouseUpEvent = MouseUp;
            }
            else if (!keyMouseRecordService.DefaultEvent)
            {
                //执行事件追加
                keyMouseRecordService.KeyDownEvent += KeyDown;
                keyMouseRecordService.KeyUpEvent += KeyUp;
                keyMouseRecordService.MouseMoveEvent += MouseMove;
                keyMouseRecordService.MouseDownEvent += MouseDown;
                keyMouseRecordService.MouseUpEvent += MouseUp;
            }
            keyMouseRecordService.DefaultEvent = true;
        }

        /// <summary>
        /// 【MM_函数库】注销键鼠总控预制事件
        /// </summary>
        /// <param name="lp_null">true注销全部，否则仅注销预制事件</param>
        public static void DelKeyMouseEvent(RecordService keyMouseRecordService, bool lp_null)
        {
            if (lp_null)
            {
                //全事件清除
                keyMouseRecordService.KeyDownEvent = null;
                keyMouseRecordService.KeyUpEvent = null;
                keyMouseRecordService.MouseMoveEvent = null;
                keyMouseRecordService.MouseDownEvent = null;
                keyMouseRecordService.MouseUpEvent = null;
            }
            else if (keyMouseRecordService.DefaultEvent)
            {
                //仅移除预制事件
                keyMouseRecordService.KeyDownEvent -= KeyDown;
                keyMouseRecordService.KeyUpEvent -= KeyUp;
                keyMouseRecordService.MouseMoveEvent -= MouseMove;
                keyMouseRecordService.MouseDownEvent -= MouseDown;
                keyMouseRecordService.MouseUpEvent -= MouseUp;
            }
            keyMouseRecordService.DefaultEvent = false;
        }

        /// <summary>
        /// 【MM_函数库】键盘按下事件主要动作（加入按键监听并传参执行）
        /// </summary>
        /// <param name="player"></param>
        /// <param name="key"></param>
        internal static bool KeyDown(int player, int key)
        {
            bool torf = !MMCore.StopKeyMouseEvent[player];
            Player.KeyDownState[player, key] = torf;  //当前按键状态值
            Player.KeyDown[player, key] = true;  //当前按键值

            if (MMCore.StopKeyMouseEvent[player] == false)
            {
                Player.KeyDownLoopOneBitNum[player] += 1; //玩家当前注册的按键队列数量
                MMCore.HashTableSave2(true, "KeyDownLoopOneBit", player, Player.KeyDownLoopOneBitNum[player], key);
                //↑存储玩家注册序号对应按键队列键位
                MMCore.HashTableSave2(true, "KeyDownLoopOneBitKey", player, key, true); //玩家按键队列键位状态
                //---------------------------------------------------------------------蓄力管理
                // if (XuLiGuanLi == true){
                // libBC0D3AAD_gf_HD_RegKXL(key, "IntGroup_XuLi" + IntToString(player)); //HD_注册蓄力按键
                // libBC0D3AAD_gf_HD_SetKeyFixedXL(player, key, 1.0);
                // }
                //---------------------------------------------------------------------双击管理
                // if (ShuangJiGuanLi == true){
                //     lv_a = libBC0D3AAD_gf_HD_ReturnKeyFixedSJ(player, key);
                //     if ((0.0 < lv_a) && (lv_a <= ShuangJiShiXian)){
                //         //符合双击标准，发送事件
                //         libBC0D3AAD_gf_Send_KeyDoubleClicked(player, key, ShuangJiShiXian - lv_a);
                //     } 
                //     else {   
                //         libBC0D3AAD_gf_HD_RegKSJ(key, "IntGroup_DoubleClicked" + IntToString(player)); //HD_注册按键
                //         libBC0D3AAD_gf_HD_SetKeyFixedSJ(player, key, ShuangJiShiXian);
                //     }
                // }
                //---------------------------------------------------------------------
                MMCore.KeyDownGlobalEvent(key, true, player);
            }
            return torf;
        }

        /// <summary>
        /// 【MM_函数库】键盘弹起事件主要动作（加入按键监听并传参执行）
        /// </summary>
        /// <param name="player"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        internal static bool KeyUp(int player, int key)
        {
            bool torf = !MMCore.StopKeyMouseEvent[player];
            Player.KeyDownState[player, key] = false;  //当前按键状态值，本事件始终为false
            Player.KeyDown[player, key] = false;  //当前按键值

            if (MMCore.StopKeyMouseEvent[player] == false)
            {
                //直接执行动作或通知延迟弹起函数去执行动作
                if ((bool)MMCore.HashTableLoad2(true, "KeyDownLoopOneBitKey", player, key) == false)
                {
                    //弹起时无该键动作队列（由延迟弹起执行完），则直接执行本次事件动作
                    MMCore.KeyUpFunc(player, key);
                }
                else
                {
                    //弹起时有该键动作队列，通知延迟弹起函数运行（按键队列>0时，清空一次队列并执行它们的动作）
                    MMCore.HashTableSave2(true, "KeyDownLoopOneBitEnd", player, key, true);
                }
            }
            return torf;
        }

        /// <summary>
        /// 【MM_函数库】键盘弹起事件处理函数
        /// </summary>
        /// <param name="player"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        internal static bool KeyUpFunc(int player, int key)
        {
            bool torf = true;
            if (MMCore.StopKeyMouseEvent[player] == true)
            {
                torf = false;
            }
            else
            {
                MMCore.KeyDownGlobalEvent(key, false, player);
            }
            return torf;
        }

        /// <summary>
        /// 【MM_函数库】鼠标移动事件主要动作（加入按键监听并传参执行）
        /// </summary>
        /// <param name="player"></param>
        /// <param name="lp_mouseVector3D"></param>
        /// <param name="uiX"></param>
        /// <param name="uiY"></param>
        internal static void MouseMove(int player, Vector3D lp_mouseVector3D, int uiX, int uiY)
        {
            if (MMCore.StopKeyMouseEvent[player] == false)
            {
                Player.MouseVector[player] = new Vector(lp_mouseVector3D.X, lp_mouseVector3D.Y);

                //↓注意取出来的是该点最高位Unit
                double unitTerrainHeight = double.Parse(MMCore.HD_ReturnVectorCV(Player.MouseVector[player], "Unit.TerrainHeight"));
                double unitHeight = double.Parse(MMCore.HD_ReturnVectorCV(Player.MouseVector[player], "Unit.Height"));

                Player.MouseVectorX[player] = lp_mouseVector3D.X;
                Player.MouseVectorY[player] = lp_mouseVector3D.Y;
                Player.MouseVectorZ[player] = lp_mouseVector3D.Z;
                Player.MouseVectorZFixed[player] = lp_mouseVector3D.Z - Game.MapHeight;

                Player.MouseUIX[player] = uiX;
                Player.MouseUIY[player] = uiY;

                Player.MouseVector3DFixed[player] = new Vector3D(lp_mouseVector3D.X, lp_mouseVector3D.Y, Player.MouseVectorZFixed[player]);
                Player.MouseVector3D[player] = lp_mouseVector3D;
                //下面2个动作应该要从二维点读取单位（可多个），将最高的单位的头顶坐标填入以修正鼠标Z点
                Player.MouseVector3DUnitTerrain[player] = new Vector3D(lp_mouseVector3D.X, lp_mouseVector3D.Y, lp_mouseVector3D.Z - unitTerrainHeight);
                Player.MouseVector3DTerrain[player] = new Vector3D(lp_mouseVector3D.X, lp_mouseVector3D.Y, lp_mouseVector3D.Z - unitTerrainHeight - unitHeight);

                //玩家控制单位存在时，计算鼠标距离控制单位的2D角度和3D距离
                if (Player.UnitControl[player] != null)
                {
                    //计算鼠标与控制单位的2D角度，用于调整角色在二维坐标系四象限内的的朝向
                    Player.MouseToUnitControlAngle[player] = MMCore.AngleBetween(Player.UnitControl[player].Vector, Player.MouseVector[player]);
                    //计算鼠标与控制单位的2D距离（由于点击的位置是单位头顶位置，2个单位重叠则返回最高位的，所以玩家会点到最高位单位）
                    Player.MouseToUnitControlRange[player] = MMCore.Distance(Player.UnitControl[player].Vector, Player.MouseVector[player]);
                    //计算鼠标与控制单位的3D距离（由于点击的位置是单位头顶位置，2个单位重叠则返回最高位的，所以玩家会点到最高位单位）
                    Player.MouseToUnitControlRange3D[player] = MMCore.Distance(Player.UnitControl[player].Vector3D, lp_mouseVector3D);
                }
            }
        }

        /// <summary>
        /// 【MM_函数库】鼠标按下事件主要动作（加入按键监听并传参执行）
        /// </summary>
        /// <param name="player"></param>
        /// <param name="key"></param>
        /// <param name="lp_mouseVector3D"></param>
        /// <param name="uiX"></param>
        /// <param name="uiY"></param>
        /// <returns></returns>
        internal static bool MouseDown(int player, int key, Vector3D lp_mouseVector3D, int uiX, int uiY)
        {
            bool torf = !MMCore.StopKeyMouseEvent[player];
            Player.MouseDownState[player, key] = torf;  //当前按键状态值
            Player.MouseDown[player, key] = true;  //当前按键值
            if (key == c_mouseButtonLeft)
            {
                Player.MouseDownLeft[player] = true;
            }
            if (key == c_mouseButtonRight)
            {
                Player.MouseDownRight[player] = true;
            }
            if (key == c_mouseButtonMiddle)
            {
                Player.MouseDownMiddle[player] = true;
            }

            if (MMCore.StopKeyMouseEvent[player] == false)
            {
                Player.MouseVector[player] = new Vector(lp_mouseVector3D.X, lp_mouseVector3D.Y);

                //↓注意取出来的是该点最高位Unit
                double unitTerrainHeight = double.Parse(MMCore.HD_ReturnVectorCV(Player.MouseVector[player], "Unit.TerrainHeight"));
                double unitHeight = double.Parse(MMCore.HD_ReturnVectorCV(Player.MouseVector[player], "Unit.Height"));

                Player.MouseVectorX[player] = lp_mouseVector3D.X;
                Player.MouseVectorY[player] = lp_mouseVector3D.Y;
                Player.MouseVectorZ[player] = lp_mouseVector3D.Z;
                Player.MouseVectorZFixed[player] = lp_mouseVector3D.Z - Game.MapHeight;

                Player.MouseUIX[player] = uiX;
                Player.MouseUIY[player] = uiY;

                Player.MouseVector3DFixed[player] = new Vector3D(lp_mouseVector3D.X, lp_mouseVector3D.Y, Player.MouseVectorZFixed[player]);
                Player.MouseVector3D[player] = lp_mouseVector3D;
                //下面2个动作应该要从二维点读取单位（可多个），将最高的单位的头顶坐标填入以修正鼠标Z点
                Player.MouseVector3DUnitTerrain[player] = new Vector3D(lp_mouseVector3D.X, lp_mouseVector3D.Y, lp_mouseVector3D.Z - unitTerrainHeight);
                Player.MouseVector3DTerrain[player] = new Vector3D(lp_mouseVector3D.X, lp_mouseVector3D.Y, lp_mouseVector3D.Z - unitTerrainHeight - unitHeight);

                //玩家控制单位存在时，计算鼠标距离控制单位的2D角度和3D距离
                if (Player.UnitControl[player] != null)
                {
                    //计算鼠标与控制单位的2D角度，用于调整角色在二维坐标系四象限内的的朝向
                    Player.MouseToUnitControlAngle[player] = MMCore.AngleBetween(Player.UnitControl[player].Vector, Player.MouseVector[player]);
                    //计算鼠标与控制单位的2D距离（由于点击的位置是单位头顶位置，2个单位重叠则返回最高位的，所以玩家会点到最高位单位）
                    Player.MouseToUnitControlRange[player] = MMCore.Distance(Player.UnitControl[player].Vector, Player.MouseVector[player]);
                    //计算鼠标与控制单位的3D距离（由于点击的位置是单位头顶位置，2个单位重叠则返回最高位的，所以玩家会点到最高位单位）
                    Player.MouseToUnitControlRange3D[player] = MMCore.Distance(Player.UnitControl[player].Vector3D, lp_mouseVector3D);
                }

                //---------------------------------------------------------------------
                Player.MouseDownLoopOneBitNum[player] += 1;
                MMCore.HashTableSave2(true, "MouseDownLoopOneBit", player, Player.MouseDownLoopOneBitNum[player], key);
                MMCore.HashTableSave2(true, "MouseDownLoopOneBitKey", player, key, true);
                //---------------------------------------------------------------------
                //if (libBC0D3AAD_gv_XuLiGuanLi == true)
                //{
                //    libBC0D3AAD_gf_HD_RegKXL(lv_mouseButton, "libBC0D3AAD_gv_IntGroup_XuLi" + IntToString(lv_player)); //HD_注册按键
                //    libBC0D3AAD_gf_HD_SetKeyFixedXL(lv_player, lv_mouseButton, 1.0);
                //}
                ////---------------------------------------------------------------------
                //if (libBC0D3AAD_gv_ShuangJiGuanLi == true)
                //{
                //    libBC0D3AAD_gf_HD_RegPTwo(lv_point1, "DoubleClicked_PTwo_" + IntToString(lv_player));
                //    lv_a = libBC0D3AAD_gf_HD_ReturnKeyFixedSJ(lv_player, lv_mouseButton);
                //    if ((0.0 < lv_a) && (lv_a <= libBC0D3AAD_gv_ShuangJiShiXian) && libBC0D3AAD_gf_HD_PTwoRangeTrue("DoubleClicked_PTwo_" + IntToString(lv_player)))
                //    {
                //        //符合双击标准（鼠标双击多个2点验证），发送事件
                //        libBC0D3AAD_gf_Send_MouseDoubleClicked(lv_player, lv_mouseButton, libBC0D3AAD_gv_ShuangJiShiXian - lv_a, lv_point0, lv_uiX, lv_uiY);
                //    }
                //    else
                //    {
                //        libBC0D3AAD_gf_HD_RegKSJ(lv_mouseButton, "libBC0D3AAD_gv_IntGroup_DoubleClicked" + IntToString(lv_player)); //HD_注册按键
                //        libBC0D3AAD_gf_HD_SetKeyFixedSJ(lv_player, lv_mouseButton, libBC0D3AAD_gv_ShuangJiShiXian);
                //    }
                //}
                ////---------------------------------------------------------------------
                MMCore.MouseDownFunc(player, key, lp_mouseVector3D, uiX, uiY);
            }
            return torf;
        }

        /// <summary>
        /// 【MM_函数库】鼠标按下事件处理函数
        /// </summary>
        /// <param name="player"></param>
        /// <param name="key"></param>
        /// <param name="lp_mouseVector3D"></param>
        /// <param name="uiX"></param>
        /// <param name="uiY"></param>
        /// <returns></returns>
        internal static bool MouseDownFunc(int player, int key, Vector3D lp_mouseVector3D, int uiX, int uiY)
        {
            // Variable Declarations
            bool torf = true;

            // Implementation
            if (MMCore.StopKeyMouseEvent[player] == true)
            {
                //阻止按键事件时强制取消按键状态
                Player.MouseDownState[player, key] = false;
                if (key == c_mouseButtonLeft)
                {
                    Player.MouseDownLeft[player] = false;
                }
                if (key == c_mouseButtonRight)
                {
                    Player.MouseDownRight[player] = false;
                }
                if (key == c_mouseButtonMiddle)
                {
                    Player.MouseDownMiddle[player] = false;
                }
                torf = false;
            }
            else
            {
                MMCore.MouseDownGlobalEvent(key, true, player);
            }
            return torf;
        }

        /// <summary>
        /// 【MM_函数库】鼠标弹起事件主要动作（加入按键监听并传参执行）
        /// </summary>
        /// <param name="player"></param>
        /// <param name="key"></param>
        /// <param name="lp_mouseVector3D"></param>
        /// <param name="uiX"></param>
        /// <param name="uiY"></param>
        internal static bool MouseUp(int player, int key, Vector3D lp_mouseVector3D, int uiX, int uiY)
        {
            bool torf = !MMCore.StopKeyMouseEvent[player];
            Player.MouseDownState[player, key] = false;  //当前按键状态值，本事件始终为false
            Player.MouseDown[player, key] = false;  //当前按键值
            if (key == c_mouseButtonLeft)
            {
                Player.MouseDownLeft[player] = false;
            }
            if (key == c_mouseButtonRight)
            {
                Player.MouseDownRight[player] = false;
            }
            if (key == c_mouseButtonMiddle)
            {
                Player.MouseDownMiddle[player] = false;
            }

            if (MMCore.StopKeyMouseEvent[player] == false)
            {
                //直接执行动作或通知延迟弹起函数去执行动作
                if ((bool)MMCore.HashTableLoad2(true, "MouseDownLoopOneBitKey", player, key) == false)
                {
                    //弹起时无该键动作队列（由延迟弹起执行完），则直接执行本次事件动作
                    MMCore.MouseUpFunc(player, key);
                }
                else
                {
                    //弹起时有该键动作队列，通知延迟弹起函数运行（按键队列>0时，清空一次队列并执行它们的动作）
                    MMCore.HashTableSave2(true, "MouseDownLoopOneBitEnd", player, key, true);
                }
            }
            return torf;
        }

        /// <summary>
        /// 【MM_函数库】鼠标弹起事件处理函数
        /// </summary>
        /// <param name="player"></param>
        /// <param name="key"></param>
        internal static bool MouseUpFunc(int player, int key)
        {
            bool torf = true;
            if (MMCore.StopKeyMouseEvent[player] == true)
            {
                torf = false;
            }
            else
            {
                MMCore.MouseDownGlobalEvent(key, false, player);
            }
            return torf;
        }

        /// <summary>
        /// 【MM_函数库】键鼠弹起事件延迟执行函数，会按序执行键鼠事件动作队列，需加入到每帧执行
        /// </summary>
        /// <param name="player"></param>
        /// <param name="key"></param>
        /// <param name="lp_mouseVector3D"></param>
        /// <param name="uiX"></param>
        /// <param name="uiY"></param>
        internal static void MouseKeyUpWait(int player, int key)
        {
            int ae, be, a, ai = 1, bi = 1;
            //玩家有鼠标按键事件动作队列时
            if (Player.MouseDownLoopOneBitNum[player] > 0)
            {
                ae = Player.MouseDownLoopOneBitNum[player];//获取动作队列数量
                a = 1;
                for (; ((ai >= 0 && a <= ae) || (ai < 0 && a >= ae)); a += ai)
                {
                    key = (int)HashTableLoad2(true, "MouseDownLoopOneBit", player, a);//读取玩家指定动作队列按键
                    if ((bool)HashTableLoad2(true, "MouseDownLoopOneBitEnd", player, key) == true)//判断玩家指定按键的动作队列是否结束
                    {
                        //如果该键的动作队列结束，重置按键状态
                        if (key == c_mouseButtonLeft)
                        {
                            Player.MouseDown[player, MMCore.c_mouseButtonLeft] = false;
                        }
                        if (key == c_mouseButtonRight)
                        {
                            Player.MouseDown[player, MMCore.c_mouseButtonRight] = false;
                        }
                        if (key == c_mouseButtonMiddle)
                        {
                            Player.MouseDown[player, MMCore.c_mouseButtonMiddle] = false;
                        }
                        //
                        MMCore.MouseDownFunc(player, key, Player.MouseVector3D[player], Player.MouseUIX[player], Player.MouseUIY[player]);
                    }
                    HashTableClear2(true, "MouseDownLoopOneBit", player, a);
                    HashTableClear2(true, "MouseDownLoopOneBitKey", player, key);
                    HashTableClear2(true, "MouseDownLoopOneBitEnd", player, key);
                }
                Player.MouseDownLoopOneBitNum[player] = 0; //动作全部执行，全队列清空
            }
            //玩家有键盘按键事件动作队列时
            if (Player.KeyDownLoopOneBitNum[player] > 0)//获取动作队列数量
            {
                be = Player.KeyDownLoopOneBitNum[player];
                a = 1;
                for (; ((bi >= 0 && a <= be) || (bi < 0 && a >= be)); a += bi)
                {
                    key = (int)HashTableLoad2(true, "KeyDownLoopOneBit", player, a);//读取玩家指定动作队列按键
                    if ((bool)HashTableLoad2(true, "KeyDownLoopOneBitEnd", player, key) == true)//判断玩家指定按键的动作队列是否结束
                    {
                        //如果该键的动作队列结束，重置按键状态
                        Player.KeyDown[player, key] = false;
                        MMCore.KeyUpFunc(player, key);
                    }
                    HashTableClear2(true, "KeyDownLoopOneBit", player, a);
                    HashTableClear2(true, "KeyDownLoopOneBitKey", player, key);
                    HashTableClear2(true, "KeyDownLoopOneBitEnd", player, key);
                }
                Player.KeyDownLoopOneBitNum[player] = 0; //全键盘队列清空
            }
        }

        #endregion

        #region Functions 键鼠事件函数引用管理

        //可进行注册注销查询更换归并执行委托

        //------------------------------------↓KeyDownEventStart↓-----------------------------------------

        /// <summary>
        /// 【MM_函数库】将（1个或多个）委托函数注册到键盘按键事件（或者说给委托函数添加指定事件，完成事件注册）。
        /// 注册指定键盘按键的委托函数，每个键盘按键最大注册数量限制（8），超过则什么也不做
        /// </summary>
        /// <param name="key"></param>
        /// <param name="funcref"></param>
        public static void RegistKeyEventFuncref(int key, KeyMouseEventFuncref funcref)
        {
            ThreadWait("MMCore_KeyEventFuncref_");//注册注销时进行等待
            ThreadWaitSet("MMCore_KeyEventFuncref_", true);
            if (keyEventFuncrefGroupNum[key] >= c_regKeyMax)
            {
                return;
            }
            keyEventFuncrefGroupNum[key] += 1;//注册成功记录+1
            keyEventFuncrefGroup[key, keyEventFuncrefGroupNum[key]] = funcref;//这里采用等于，设计为覆盖
            ThreadWaitSet("MMCore_KeyEventFuncref_", false);
        }
        /// <summary>
        /// 【MM_函数库】注册指定键盘按键的委托函数（登录在指定注册序号num位置）
        /// </summary>
        /// <param name="key"></param>
        /// <param name="num">不能超过最大注册数量限制（8）</param>
        /// <param name="funcref"></param>
        public static void RegistKeyEventFuncref(int key, int num, KeyMouseEventFuncref funcref)
        {
            ThreadWait("MMCore_KeyEventFuncref_");//注册注销时进行等待
            ThreadWaitSet("MMCore_KeyEventFuncref_", true);
            keyEventFuncrefGroup[key, num] = funcref;
            ThreadWaitSet("MMCore_KeyEventFuncref_", false);
        }

        /// <summary>
        /// 【MM_函数库】注销指定键盘按键的委托函数（发生序号重排）
        /// </summary>
        /// <param name="key"></param>
        /// <param name="funcref"></param>
        public static void RemoveKeyEventFuncref(int key, KeyMouseEventFuncref funcref)
        {
            ThreadWait("MMCore_KeyEventFuncref_");
            ThreadWaitSet("MMCore_KeyEventFuncref_", true);
            for (int a = 1; a <= keyEventFuncrefGroupNum[key]; a += 1)
            {
                //遍历检查所填函数注册序号
                if (keyEventFuncrefGroup[key, a] == funcref)
                {
                    //该键位注册总数减一
                    keyEventFuncrefGroupNum[key] -= 1;
                    for (int b = a; b <= keyEventFuncrefGroupNum[key]; b += 1)
                    {
                        //将后序有效函数（如有）按序重排
                        keyEventFuncrefGroup[key, b] = keyEventFuncrefGroup[key, b];
                    }
                    //新的序号下从可疑序号重新开始检查，确保该函数在键位中彻底消失
                    a -= 1;
                }
            }
            ThreadWaitSet("MMCore_KeyEventFuncref_", false);
        }

        /// <summary>
        /// 【MM_函数库】返回指定键盘按键注册函数的序号
        /// </summary>
        /// <param name="key"></param>
        /// <param name="funcref"></param>
        /// <returns>错误时返回-1</returns>
        public static int GetKeyEventFuncrefNearestNum(int key, KeyMouseEventFuncref funcref)
        {
            int num = -1;
            for (int a = 1; a <= keyEventFuncrefGroupNum[key]; a += 1)
            {
                //遍历检查所填函数注册序号
                if (keyEventFuncrefGroup[key, a] == funcref)
                {
                    //返回最近的函数序号
                    num = a;
                    break;
                }
            }
            return num;
        }

        /// <summary>
        /// 【MM_函数库】返回指定键盘按键指定函数的注册数量（>1则注册了多个同样的函数）
        /// </summary>
        /// <param name="key"></param>
        /// <param name="funcref"></param>
        /// <returns></returns>
        public static int GetKeyEventFuncrefCount(int key, KeyMouseEventFuncref funcref)
        {
            int count = 0;
            for (int a = 1; a <= keyEventFuncrefGroupNum[key]; a += 1)
            {
                //遍历检查所填函数注册序号
                if (keyEventFuncrefGroup[key, a] == funcref)
                {
                    count += 1;
                }
            }

            return count;
        }

        /// <summary>
        /// 【MM_函数库】归并键盘按键指定函数（如存在则移除该函数注册并序号重排，之后重新注册1次）
        /// </summary>
        /// <param name="key"></param>
        /// <param name="funcref"></param>
        /// <returns></returns>
        public static bool RedoKeyEventFuncref(int key, KeyMouseEventFuncref funcref)
        {
            ThreadWait("MMCore_KeyEventFuncref_");//注册注销时进行等待
            ThreadWaitSet("MMCore_KeyEventFuncref_", true);
            bool result = false;
            int num = GetKeyEventFuncrefCount(key, funcref);
            if (num > 1)
            {
                result = true;
                //发现重复函数，移除后重新注册
                RemoveKeyEventFuncref(key, funcref);
                RegistKeyEventFuncref(key, funcref);
            }
            ThreadWaitSet("MMCore_KeyEventFuncref_", false);
            return result;
        }

        /// <summary>
        /// 【MM_函数库】全局键盘按键事件，对指定键盘按键执行委托函数动作集合
        /// </summary>
        /// <param name="key"></param>
        /// <param name="keydown"></param>
        /// <param name="player"></param>
        public static void KeyDownGlobalEvent(int key, bool keydown, int player)
        {
            for (int a = 1; a <= keyEventFuncrefGroupNum[key]; a += 1)
            {
                //这里不开新线程，是否另开线程运行宜由委托函数去写
                keyEventFuncrefGroup[key, a](keydown, player);//执行键盘按键委托
            }
        }

        //--------------------------------------↑KeyDownEventEnd↑-----------------------------------------

        //------------------------------------↓MouseDownEventStart↓---------------------------------------

        /// <summary>
        /// 【MM_函数库】将（1个或多个）委托函数注册到鼠标按键事件（或者说给委托函数添加指定事件，完成事件注册）。
        /// 注册指定鼠标键位的委托函数，每个鼠标按键最大注册数量限制（24），超过则什么也不做
        /// </summary>
        /// <param name="key"></param>
        /// <param name="funcref"></param>
        public static void RegistMouseEventFuncref(int key, KeyMouseEventFuncref funcref)
        {
            ThreadWait("MouseEventFuncref");//注册注销时进行等待
            ThreadWaitSet("MouseEventFuncref", true);
            if (mouseEventFuncrefGroupNum[key] >= c_regMouseMax)
            {
                return;
            }
            mouseEventFuncrefGroupNum[key] += 1;//注册成功记录+1
            mouseEventFuncrefGroup[key, mouseEventFuncrefGroupNum[key]] = funcref;//这里采用等于，设计为覆盖
            ThreadWaitSet("MouseEventFuncref", false);
        }

        /// <summary>
        /// 【MM_函数库】注册指定鼠标键位的委托函数（登录在指定注册序号num位置）
        /// </summary>
        /// <param name="key"></param>
        /// <param name="num">不能超过最大注册数量限制（24）</param>
        /// <param name="funcref"></param>
        public static void RegistMouseEventFuncref(int key, int num, KeyMouseEventFuncref funcref)
        {
            ThreadWait("MouseEventFuncref");//注册注销时进行等待
            ThreadWaitSet("MouseEventFuncref", true);
            mouseEventFuncrefGroup[key, num] = funcref;
            ThreadWaitSet("MouseEventFuncref", false);
        }

        /// <summary>
        /// 【MM_函数库】注销指定鼠标键位的委托函数（发生序号重排）
        /// </summary>
        /// <param name="key"></param>
        /// <param name="funcref"></param>
        public static void RemoveMouseEventFuncref(int key, KeyMouseEventFuncref funcref)
        {
            ThreadWait("MouseEventFuncref");
            ThreadWaitSet("MouseEventFuncref", true);
            for (int a = 1; a <= mouseEventFuncrefGroupNum[key]; a += 1)
            {
                if (mouseEventFuncrefGroup[key, a] == funcref)
                {
                    mouseEventFuncrefGroupNum[key] -= 1;
                    for (int b = a; b <= mouseEventFuncrefGroupNum[key]; b += 1)
                    {
                        mouseEventFuncrefGroup[key, b] = mouseEventFuncrefGroup[key, b];
                    }
                    a -= 1;
                }
            }
            ThreadWaitSet("MouseEventFuncref", false);
        }

        /// <summary>
        /// 【MM_函数库】返回指定鼠标键位注册函数的序号
        /// </summary>
        /// <param name="key"></param>
        /// <param name="funcref"></param>
        /// <returns>错误时返回-1</returns>
        public static int GetMouseEventFuncrefNearestNum(int key, KeyMouseEventFuncref funcref)
        {
            int num = -1;
            for (int a = 1; a <= mouseEventFuncrefGroupNum[key]; a += 1)
            {
                //遍历检查所填函数注册序号
                if (mouseEventFuncrefGroup[key, a] == funcref)
                {
                    //返回最近的函数序号
                    num = a;
                    break;
                }
            }
            return num;
        }

        /// <summary>
        /// 【MM_函数库】返回指定鼠标键位指定注册函数的数量（>1则注册了多个同样的函数）
        /// </summary>
        /// <param name="key"></param>
        /// <param name="funcref"></param>
        /// <returns></returns>
        public static int GetMouseEventFuncrefCount(int key, KeyMouseEventFuncref funcref)
        {
            int count = 0;
            for (int a = 1; a <= mouseEventFuncrefGroupNum[key]; a += 1)
            {
                //遍历检查所填函数注册序号
                if (mouseEventFuncrefGroup[key, a] == funcref)
                {
                    count += 1;
                }
            }
            return count;
        }

        /// <summary>
        /// 【MM_函数库】归并鼠标按键指定函数（如存在则移除该函数注册并序号重排，之后重新注册1次）
        /// </summary>
        /// <param name="key"></param>
        /// <param name="funcref"></param>
        /// <returns></returns>
        public static bool RedoMouseEventFuncref(int key, KeyMouseEventFuncref funcref)
        {
            bool torf = false;
            int num = GetMouseEventFuncrefCount(key, funcref);
            if (num > 1)
            {
                torf = true;
                //发现重复函数，移除后重新注册
                RemoveMouseEventFuncref(key, funcref);
                RegistMouseEventFuncref(key, funcref);
            }
            return torf;
        }

        /// <summary>
        /// 【MM_函数库】全局鼠标按键事件，对指定鼠标按键执行委托函数动作集合
        /// </summary>
        /// <param name="key"></param>
        /// <param name="keydown"></param>
        /// <param name="player"></param>
        public static void MouseDownGlobalEvent(int key, bool keydown, int player)
        {
            int a = 1;
            for (; a <= mouseEventFuncrefGroupNum[key]; a += 1)
            {
                //这里不开新线程，是否另开线程运行宜由委托函数去写
                mouseEventFuncrefGroup[key, a](keydown, player);//执行鼠标按键委托
            }
        }

        //------------------------------------↑MouseDownEventEnd↑-----------------------------------------

        #endregion

        #region Functions 主副循环入口事件函数管理

        //可进行注册注销查询更换归并执行委托

        //------------------------------------↓EntryFuncStart↓-----------------------------------------

        /// <summary>
        /// 【MM_函数库】将（1个或多个）委托函数注册到主副循环入口事件（或者说给委托函数添加指定事件，完成事件注册）。
        /// 注册指定主副循环入口的委托函数，每个入口最大注册数量限制（1），超过则什么也不做
        /// </summary>
        /// <param name="entry"></param>
        /// <param name="funcref"></param>
        public static void RegistEntryEventFuncref(Entry entry, EntryEventFuncref funcref)
        {
            ThreadWait("EntryEventFuncref");//注册注销时进行等待
            ThreadWaitSet("EntryEventFuncref", true);
            if (entryEventFuncrefGroupNum[(int)entry] >= c_regEntryMax)
            {
                return;
            }
            entryEventFuncrefGroupNum[(int)entry] += 1;//注册成功记录+1
            entryEventFuncrefGroup[(int)entry, entryEventFuncrefGroupNum[(int)entry]] = funcref;//这里采用等于，设计为覆盖
            ThreadWaitSet("EntryEventFuncref", false);
        }

        /// <summary>
        /// 【MM_函数库】注册指定主副循环入口的委托函数（登录在指定注册序号num位置）
        /// </summary>
        /// <param name="entry"></param>
        /// <param name="num">不能超过最大注册数量限制（8）</param>
        /// <param name="funcref"></param>
        public static void RegistEntryEventFuncref(Entry entry, int num, EntryEventFuncref funcref)
        {
            ThreadWait("EntryEventFuncref");//注册注销时进行等待
            ThreadWaitSet("EntryEventFuncref", true);
            entryEventFuncrefGroup[(int)entry, num] = funcref;
            ThreadWaitSet("EntryEventFuncref", false);
        }

        /// <summary>
        /// 【MM_函数库】注销指定主副循环入口的委托函数（发生序号重排）
        /// </summary>
        /// <param name="entry"></param>
        /// <param name="funcref"></param>
        public static void RemoveEntryEventFuncref(Entry entry, EntryEventFuncref funcref)
        {
            ThreadWait("EntryEventFuncref");
            ThreadWaitSet("EntryEventFuncref", true);
            for (int a = 1; a <= entryEventFuncrefGroupNum[(int)entry]; a += 1)
            {
                //遍历检查所填函数注册序号
                if (entryEventFuncrefGroup[(int)entry, a] == funcref)
                {
                    //该键位注册总数减一
                    entryEventFuncrefGroupNum[(int)entry] -= 1;
                    for (int b = a; b <= entryEventFuncrefGroupNum[(int)entry]; b += 1)
                    {
                        //将后序有效函数（如有）按序重排
                        entryEventFuncrefGroup[(int)entry, b] = entryEventFuncrefGroup[(int)entry, b];
                    }
                    //新的序号下从可疑序号重新开始检查，确保该函数在键位中彻底消失
                    a -= 1;
                }
            }
            ThreadWaitSet("EntryEventFuncref", false);
        }

        /// <summary>
        /// 【MM_函数库】返回指定主副循环入口注册函数的序号
        /// </summary>
        /// <param name="entry"></param>
        /// <param name="funcref"></param>
        /// <returns>错误时返回-1</returns>
        public static int GetEntryEventFuncrefNearestNum(Entry entry, EntryEventFuncref funcref)
        {
            int num = -1;
            for (int a = 1; a <= entryEventFuncrefGroupNum[(int)entry]; a += 1)
            {
                //遍历检查所填函数注册序号
                if (entryEventFuncrefGroup[(int)entry, a] == funcref)
                {
                    //返回最近的函数序号
                    num = a;
                    break;
                }
            }
            return num;
        }

        /// <summary>
        /// 【MM_函数库】返回指定主副循环入口指定函数的注册数量（>1则注册了多个同样的函数）
        /// </summary>
        /// <param name="entry"></param>
        /// <param name="funcref"></param>
        /// <returns></returns>
        public static int GetEntryEventFuncrefCount(Entry entry, EntryEventFuncref funcref)
        {
            int count = 0;
            for (int a = 1; a <= entryEventFuncrefGroupNum[(int)entry]; a += 1)
            {
                //遍历检查所填函数注册序号
                if (entryEventFuncrefGroup[(int)entry, a] == funcref)
                {
                    count += 1;
                }
            }

            return count;
        }

        /// <summary>
        /// 【MM_函数库】归并主副循环入口指定函数（如存在则移除该函数注册并序号重排，之后重新注册1次）
        /// </summary>
        /// <param name="entry"></param>
        /// <param name="funcref"></param>
        /// <returns></returns>
        public static bool RedoEntryEventFuncref(Entry entry, EntryEventFuncref funcref)
        {
            bool result = false;
            int num = GetEntryEventFuncrefCount(entry, funcref);
            if (num > 1)
            {
                result = true;
                //发现重复函数，移除后重新注册
                RemoveEntryEventFuncref(entry, funcref);
                RegistEntryEventFuncref(entry, funcref);
            }
            return result;
        }

        /// <summary>
        /// 【MM_函数库】全局主副循环入口事件，对指定入口执行委托函数动作集合
        /// </summary>
        /// <param name="entry"></param>
        public static void EntryGlobalEvent(Entry entry)
        {
            for (int a = 1; a <= entryEventFuncrefGroupNum[(int)entry]; a += 1)
            {
                entryEventFuncrefGroup[(int)entry, a]();//执行主副循环入口委托
            }
        }

        //------------------------------------↑EntryFuncEnd↑-----------------------------------------

        #endregion

    }

    /// <summary>
    /// 【MM_函数库】存储Game相关信息及方法的类
    /// </summary>
    public static class Game
    {
        #region 字段及属性

        #region EGameCatalog

        const int c_gameCatalogAbil = 0;
        const int c_gameCatalogAchievement = 1;
        const int c_gameCatalogAchievementTerm = 2;
        const int c_gameCatalogActor = 3;
        const int c_gameCatalogActorSupport = 4;
        const int c_gameCatalogAlert = 5;
        const int c_gameCatalogArmyCategory = 6;
        const int c_gameCatalogArmyUnit = 7;
        const int c_gameCatalogArmyUpgrade = 8;
        const int c_gameCatalogArtifact = 9;
        const int c_gameCatalogArtifactSlot = 10;
        const int c_gameCatalogAttachMethod = 11;
        const int c_gameCatalogBankCondition = 12;
        const int c_gameCatalogBeam = 13;
        const int c_gameCatalogBehavior = 14;
        const int c_gameCatalogBundle = 15;
        const int c_gameCatalogBoost = 16;
        const int c_gameCatalogButton = 17;
        const int c_gameCatalogCamera = 18;
        const int c_gameCatalogCampaign = 19;
        const int c_gameCatalogCharacter = 20;
        const int c_gameCatalogCliff = 21;
        const int c_gameCatalogCliffMesh = 22;
        const int c_gameCatalogColorStyle = 23;
        const int c_gameCatalogCommander = 24;
        const int c_gameCatalogConfig = 25;
        const int c_gameCatalogConsoleSkin = 26;
        const int c_gameCatalogConversation = 27;
        const int c_gameCatalogConversationState = 28;
        const int c_gameCatalogCursor = 29;
        const int c_gameCatalogDecalPack = 30;
        const int c_gameCatalogDSP = 31;
        const int c_gameCatalogEffect = 32;
        const int c_gameCatalogEmoticon = 33;
        const int c_gameCatalogEmoticonPack = 34;
        const int c_gameCatalogError = 35;
        const int c_gameCatalogFootprint = 36;
        const int c_gameCatalogFoW = 37;
        const int c_gameCatalogGame = 38;
        const int c_gameCatalogGameUI = 39;
        const int c_gameCatalogHerd = 40;
        const int c_gameCatalogHerdNode = 41;
        const int c_gameCatalogHero = 42;
        const int c_gameCatalogHeroAbil = 43;
        const int c_gameCatalogHeroStat = 44;
        const int c_gameCatalogItem = 45;
        const int c_gameCatalogItemClass = 46;
        const int c_gameCatalogItemContainer = 47;
        const int c_gameCatalogKinetic = 48;
        const int c_gameCatalogLensFlareSet = 49;
        const int c_gameCatalogLight = 50;
        const int c_gameCatalogLocation = 51;
        const int c_gameCatalogLoot = 52;
        const int c_gameCatalogMap = 53;
        const int c_gameCatalogModel = 54;
        const int c_gameCatalogMount = 55;
        const int c_gameCatalogMover = 56;
        const int c_gameCatalogObjective = 57;
        const int c_gameCatalogPhysicsMaterial = 58;
        const int c_gameCatalogPing = 59;
        const int c_gameCatalogPortraitPack = 60;
        const int c_gameCatalogPreload = 61;
        const int c_gameCatalogPremiumMap = 62;
        const int c_gameCatalogRace = 63;
        const int c_gameCatalogRaceBannerPack = 64;
        const int c_gameCatalogRequirement = 65;
        const int c_gameCatalogRequirementNode = 66;
        const int c_gameCatalogReverb = 67;
        const int c_gameCatalogReward = 68;
        const int c_gameCatalogScoreResult = 69;
        const int c_gameCatalogScoreValue = 70;
        const int c_gameCatalogShape = 71;
        const int c_gameCatalogSkin = 72;
        const int c_gameCatalogSkinPack = 73;
        const int c_gameCatalogSound = 74;
        const int c_gameCatalogSoundExclusivity = 75;
        const int c_gameCatalogSoundMixSnapshot = 76;
        const int c_gameCatalogSoundtrack = 77;
        const int c_gameCatalogSpray = 78;
        const int c_gameCatalogSprayPack = 79;
        const int c_gameCatalogTacCooldown = 80;
        const int c_gameCatalogTactical = 81;
        const int c_gameCatalogTalent = 82;
        const int c_gameCatalogTalentProfile = 83;
        const int c_gameCatalogTargetFind = 84;
        const int c_gameCatalogTargetSort = 85;
        const int c_gameCatalogTerrain = 86;
        const int c_gameCatalogTerrainObject = 87;
        const int c_gameCatalogTerrainTex = 88;
        const int c_gameCatalogTexture = 89;
        const int c_gameCatalogTextureSheet = 90;
        const int c_gameCatalogTile = 91;
        const int c_gameCatalogTrophy = 92;
        const int c_gameCatalogTurret = 93;
        const int c_gameCatalogUnit = 94;
        const int c_gameCatalogUpgrade = 95;
        const int c_gameCatalogUser = 96;
        const int c_gameCatalogValidator = 97;
        const int c_gameCatalogVoiceOver = 98;
        const int c_gameCatalogVoicePack = 99;
        const int c_gameCatalogWarChest = 100;
        const int c_gameCatalogWarChestSeason = 101;
        const int c_gameCatalogWater = 102;
        const int c_gameCatalogWeapon = 103;
        const int c_gameCatalogStimPack = 104;
        const int c_gameCatalogAccumulator = 105;
        const int c_gameCatalogPlayerResponse = 106;
        const int c_gameCatalogDataCollection = 107;
        const int c_gameCatalogDataCollectionPattern = 108;
        const string c_gameCatalogAbilName = "Abil";
        const string c_gameCatalogAchievementName = "Achievement";
        const string c_gameCatalogAchievementTermName = "AchievementTerm";
        const string c_gameCatalogActorName = "Actor";
        const string c_gameCatalogActorSupportName = "ActorSupport";
        const string c_gameCatalogAlertName = "Alert";
        const string c_gameCatalogArmyCategoryName = "ArmyCategory";
        const string c_gameCatalogArmyUnitName = "ArmyUnit";
        const string c_gameCatalogArmyUpgradeName = "ArmyUpgrade";
        const string c_gameCatalogArtifactName = "Artifact";
        const string c_gameCatalogArtifactSlotName = "ArtifactSlot";
        const string c_gameCatalogAttachMethodName = "AttachMethod";
        const string c_gameCatalogBankConditionName = "BankCondition";
        const string c_gameCatalogBeamName = "Beam";
        const string c_gameCatalogBehaviorName = "Behavior";
        const string c_gameCatalogBundleName = "Bundle";
        const string c_gameCatalogBoostName = "Boost";
        const string c_gameCatalogButtonName = "Button";
        const string c_gameCatalogCameraName = "Camera";
        const string c_gameCatalogCampaignName = "Campaign";
        const string c_gameCatalogCharacterName = "Character";
        const string c_gameCatalogCliffName = "Cliff";
        const string c_gameCatalogCliffMeshName = "CliffMesh";
        const string c_gameCatalogColorStyleName = "ColorStyle";
        const string c_gameCatalogCommanderName = "Commander";
        const string c_gameCatalogConfigName = "Config";
        const string c_gameCatalogConsoleSkinName = "ConsoleSkin";
        const string c_gameCatalogConversationName = "Conversation";
        const string c_gameCatalogConversationStateName = "ConversationState";
        const string c_gameCatalogCursorName = "Cursor";
        const string c_gameCatalogDecalPackName = "DecalPack";
        const string c_gameCatalogDSPName = "DSP";
        const string c_gameCatalogEffectName = "Effect";
        const string c_gameCatalogEmoticonName = "Emoticon";
        const string c_gameCatalogEmoticonPackName = "EmoticonPack";
        const string c_gameCatalogErrorName = "Error";
        const string c_gameCatalogFootprintName = "Footprint";
        const string c_gameCatalogFoWName = "FoW";
        const string c_gameCatalogGameName = "Game";
        const string c_gameCatalogGameUIName = "GameUI";
        const string c_gameCatalogHerdName = "Herd";
        const string c_gameCatalogHerdNodeName = "HerdNode";
        const string c_gameCatalogHeroName = "Hero";
        const string c_gameCatalogHeroAbilName = "HeroAbil";
        const string c_gameCatalogHeroStatName = "HeroStat";
        const string c_gameCatalogItemName = "Item";
        const string c_gameCatalogItemClassName = "ItemClass";
        const string c_gameCatalogItemContainerName = "ItemContainer";
        const string c_gameCatalogKineticName = "Kinetic";
        const string c_gameCatalogLensFlareSetName = "LensFlareSet";
        const string c_gameCatalogLightName = "Light";
        const string c_gameCatalogLocationName = "Location";
        const string c_gameCatalogLootName = "Loot";
        const string c_gameCatalogMapName = "Map";
        const string c_gameCatalogModelName = "Model";
        const string c_gameCatalogMountName = "Mount";
        const string c_gameCatalogMoverName = "Mover";
        const string c_gameCatalogObjectiveName = "Objective";
        const string c_gameCatalogPhysicsMaterialName = "PhysicsMaterial";
        const string c_gameCatalogPingName = "Ping";
        const string c_gameCatalogPortraitPackName = "PortraitPack";
        const string c_gameCatalogPreloadName = "Preload";
        const string c_gameCatalogPremiumMapName = "PremiumMap";
        const string c_gameCatalogRaceName = "Race";
        const string c_gameCatalogRaceBannerPackName = "RaceBannerPack";
        const string c_gameCatalogRequirementName = "Requirement";
        const string c_gameCatalogRequirementNodeName = "RequirementNode";
        const string c_gameCatalogReverbName = "Reverb";
        const string c_gameCatalogRewardName = "Reward";
        const string c_gameCatalogScoreResultName = "ScoreResult";
        const string c_gameCatalogScoreValueName = "ScoreValue";
        const string c_gameCatalogShapeName = "Shape";
        const string c_gameCatalogSkinName = "Skin";
        const string c_gameCatalogSkinPackName = "SkinPack";
        const string c_gameCatalogSoundName = "Sound";
        const string c_gameCatalogSoundExclusivityName = "SoundExclusivity";
        const string c_gameCatalogSoundMixSnapshotName = "SoundMixSnapshot";
        const string c_gameCatalogSoundtrackName = "Soundtrack";
        const string c_gameCatalogSprayName = "Spray";
        const string c_gameCatalogSprayPackName = "SprayPack";
        const string c_gameCatalogTacCooldownName = "TacCooldown";
        const string c_gameCatalogTacticalName = "Tactical";
        const string c_gameCatalogTalentName = "Talent";
        const string c_gameCatalogTalentProfileName = "TalentProfile";
        const string c_gameCatalogTargetFindName = "TargetFind";
        const string c_gameCatalogTargetSortName = "TargetSort";
        const string c_gameCatalogTerrainName = "Terrain";
        const string c_gameCatalogTerrainObjectName = "TerrainObject";
        const string c_gameCatalogTerrainTexName = "TerrainTex";
        const string c_gameCatalogTextureName = "Texture";
        const string c_gameCatalogTextureSheetName = "TextureSheet";
        const string c_gameCatalogTileName = "Tile";
        const string c_gameCatalogTrophyName = "Trophy";
        const string c_gameCatalogTurretName = "Turret";
        const string c_gameCatalogUnitName = "Unit";
        const string c_gameCatalogUpgradeName = "Upgrade";
        const string c_gameCatalogUserName = "User";
        const string c_gameCatalogValidatorName = "Validator";
        const string c_gameCatalogVoiceOverName = "VoiceOver";
        const string c_gameCatalogVoicePackName = "VoicePack";
        const string c_gameCatalogWarChestName = "WarChest";
        const string c_gameCatalogWarChestSeasonName = "WarChestSeason";
        const string c_gameCatalogWaterName = "Water";
        const string c_gameCatalogWeaponName = "Weapon";
        const string c_gameCatalogStimPackName = "StimPack";
        const string c_gameCatalogAccumulatorName = "Accumulator";
        const string c_gameCatalogPlayerResponseName = "PlayerResponse";
        const string c_gameCatalogDataCollectionName = "DataCollection";
        const string c_gameCatalogDataCollectionPatternName = "DataCollectionPattern";

        #endregion

        #region 地图相关

        private static double _mapHeight;
        private static double[,] _terrainHeight = new double[2560 + 1, 2560 + 1];
        private static double[,,] _terrainType;

        /// <summary>
        /// 【MM_函数库】地图首个纹理图层顶面高度，默认值=8（m），亦称地面高度或地图高度
        /// </summary>
        public static double MapHeight { get => _mapHeight; set => _mapHeight = value; }

        /// <summary>
        /// 【MM_函数库】地面上附加的悬崖、地形物件的高度，二维坐标数组元素[2560+1,2560+1]（设计精度0.1m，按256m计）
        /// </summary>
        public static double[,] TerrainHeight { get => _terrainHeight; set => _terrainHeight = value; }

        /// <summary>
        /// 【MM_函数库】土、矿、水、气等空间内每个点的属性类型和数量（密度），数组元素[2560+1,2560+1,2560+1]，设计精度0.1m，小数点左侧表示土的类型，右侧为数值（密度）
        /// </summary>
        public static double[,,] TerrainType { get => _terrainType; set => _terrainType = value; }

        #endregion

        #region 其他

        /// <summary>
        /// 【MM_函数库】载具类型上限
        /// </summary>
        public const int c_vehicleTypeMax = 200;

        /// <summary>
        /// 【MM_函数库】任意玩家编号（玩家编号从0-15共16个，16是上帝由系统执行，某些函数中也作"任意玩家"参数）
        /// </summary>
        public const int c_playerAny = 16;

        /// <summary>
        /// 【MM_函数库】玩家编号上限（限制最大玩家数）
        /// </summary>
        public const int c_maxPlayers = 16;

        private static int _uID;
        /// <summary>
        /// 【MM_函数库】本地用户玩家的编号
        /// </summary>
        public static int UID { get => _uID; set => _uID = value; }

        private static int _currentUnitHandle;
        /// <summary>
        /// 【MM_函数库】最近一次新建的单位句柄
        /// </summary>
        public static int CurrentUnitHandle { get => _currentUnitHandle; set => _currentUnitHandle = value; }

        private static Unit _unitLastCreated;
        /// <summary>
        /// 【MM_函数库】最近一次新建的单位
        /// </summary>
        public static Unit UnitLastCreated { get => _unitLastCreated; set => _unitLastCreated = value; }

        private static int _initialization;
        /// <summary>
        /// 【MM_函数库】初始化阶段
        /// </summary>
        public static int Initialization { get => _initialization; set => _initialization = value; }

        #endregion

        #endregion

        #region 函数

        /// <summary>
        /// 设置指定目录数据类型的字段值
        /// </summary>
        /// <param name="catalog">目录</param>
        /// <param name="entry">数据类型</param>
        /// <param name="fieldPath">字段路径</param>
        /// <param name="player">玩家</param>
        /// <param name="value">值</param>
        public static void CatalogFieldValueSet(int catalog, string entry, string fieldPath, int player, string value)
        {
            MMCore.DataTableStringSave0(true, catalog.ToString() + "_" + entry + "_" + fieldPath + "_" + player, value);
        }

        /// <summary>
        /// 获取指定目录数据类型的字段值
        /// </summary>
        /// <param name="catalog">目录</param>
        /// <param name="entry">数据类型</param>
        /// <param name="fieldPath">字段路径</param>
        /// <param name="player">玩家</param>
        /// <returns></returns>
        public static string CatalogFieldValueGet(int catalog, string entry, string fieldPath, int player)
        {
            return MMCore.DataTableStringLoad0(true, catalog.ToString() + "_" + entry + "_" + fieldPath + "_" + player);
        }

        /// <summary>
        /// 创建单位
        /// </summary>
        /// <param name="player"></param>
        /// <param name="unitType"></param>
        /// <param name="vector"></param>
        /// <param name="unitCreateTag"></param>
        /// <returns>返回根据unitType创建的单位实例</returns>
        public static Unit UnitCreate(string unitType, UnitCreateTag unitCreateTag, int player, Vector vector)
        {
            Unit unit;
            switch (unitType)
            {
                case "Marine":
                    unit = new Marine();
                    break;
                default:
                    unit = new Unit();
                    break;
            }
            unit.Owner = player;
            unit.Vector = vector;
            if (unit.Hp <= 0.0) { unit.Hp = 1.0; }
            return unit;
        }

        /// <summary>
        /// 创建AI指令
        /// </summary>
        /// <param name="player"></param>
        /// <param name="abilLink"></param>
        /// <param name="abilIndex"></param>
        /// <returns></returns>
        public static Order AICreateOrder(int player, string abilLink, int abilIndex)
        {
            Abilcmd cmd = AbilityCommand(abilLink, abilIndex);
            if (cmd == null)
            {
                return null;
            }
            Order ord = new Order(cmd);
            ord.Player = player;
            return ord;
        }

        public static Abilcmd AbilityCommand(string abilLink, int abilIndex)
        {
            return new Abilcmd(abilLink, abilIndex);
        }

        public static Order OrderTargetingPoint(Abilcmd inAbilCmd, Vector inPoint)
        {
            Order ord = new Order(inAbilCmd);
            ord.TargetType = 2;
            ord.TargetVector = inPoint;
            return ord;
        }

        #endregion
    }

    /// <summary>
    /// 【MM_函数库】主循环触发器，请给函数注册事件（语法：MainUpdate.Awake/Start/Update/End/Destroy +=/-= 任意符合事件参数格式的函数的名称如MyFunc，其声明为void MyFun(object sender, EventArgs e)，sender传递本类实例（其他类型也可），e传递额外事件参数类的信息），TriggerStart方法将自动创建独立触发器线程并启动周期触发器（主体事件发布动作），启动前可用Duetime、Period属性方法设定Update阶段每次循环的前摇和间隔，启动后按序执行Awake/Start/Update/End/Destroy被这5种事件注册过的委托函数，其中事件Update阶段是一个计时器循环，直到用户手动调用Stop属性方法，该属性为false时会让计时器到期退出Update循环，而计时器所在父线程（即触发器线程）将运行End和Destory事件
    /// </summary>
    public static class MainUpdate
    {
        #region 字段及其属性

        private static Thread _thread;
        /// <summary>
        /// 【MM_函数库】主循环线程
        /// </summary>
        public static Thread Thread { get => _thread; }//不提供外部赋值

        private static Timer _timer;
        /// <summary>
        /// 【MM_函数库】主循环Update阶段，用来实现周期循环的计时器
        /// </summary>
        public static Timer Timer { get => _timer; }//不提供外部赋值

        private static AutoResetEvent _autoResetEvent;
        /// <summary>
        /// 【MM_函数库】主循环自动复位事件对象（用来向主循环线程发送信号），属性动作AutoResetEvent.Set()可让触发器线程终止（效果等同MainUpdate.TimerStop = true）
        /// </summary>
        public static AutoResetEvent AutoResetEvent { get => _autoResetEvent; }//不提供外部赋值

        private static int _invokeCount;
        /// <summary>
        /// 【MM_函数库】主循环Update事件运行次数
        /// </summary>
        public static int InvokeCount { get => _invokeCount; set => _invokeCount = value; }

        private static bool _timerState;
        /// <summary>
        /// 【MM_函数库】主循环状态，手动设置为false则计时器工作时将收到信号退出循环（不执行Update事件），计时器所在父线程将运行End和Destory事件
        /// </summary>
        public static bool TimerStop { get => _timerState; set => _timerState = value; }

        private static int _Duetime, _Period;
        /// <summary>
        /// 【MM_函数库】主循环Update阶段前摇时间，设置后每次循环前都会等待
        /// </summary>
        public static int Duetime { get => _Duetime; set => _Duetime = value; }
        /// <summary>
        /// 【MM_函数库】主循环Update阶段间隔运行时间
        /// </summary>
        public static int Period { get => _Period; set => _Period = value; }

        #endregion

        #region 静态构造函数

        /// <summary>
        /// 【MM_函数库】主循环状态监控类（用来读写InvokeCount、TimerStop属性），计时器实例创建时本类方法CheckStatus以参数填入被反复执行，主循环Update事件被执行时创建计时器的父线程（MainUpdate.Thread）将暂停，直到该方法确认到TimerStop为真，退出计时器循环，并通知计时器所在父线程恢复运行（将执行End和Destory事件）
        /// </summary>
        static MainUpdate()
        {
            InvokeCount = 0;
            TimerStop = false;
        }

        #endregion

        #region 函数

        /// <summary>
        /// 【MM_函数库】主循环的计时器实例创建时以参数填入、被反复执行的函数，Update事件被执行时创建计时器的父线程将暂停，直到本函数确认到TimerStop为真，退出计时器循环，并通知计时器所在父线程恢复运行（将执行End和Destory事件）。一般不需要用户操作，TimerStop为true时手动调用会额外增加Update次数
        /// </summary>
        /// <param name="state"></param>
        public static void CheckStatus(object state)
        {
            if (TimerStop)
            {
                ((AutoResetEvent)state).Set();
            }
            else
            {
                InvokeCount++;
                Update();
            }
        }

        /// <summary>
        /// 【MM_函数库】开启主循环（默认0.05现实时间秒，如需修改请在开启前用属性方法MainUpdate.Period、MainUpdate.Duetime来调整计时器Update阶段的间隔、前摇，若已经开启想要修改，可使用MainUpdate.Timer.Change）
        /// </summary>
        /// <param name="isBackground"></param>
        public static void Start(bool isBackground)
        {
            if (_thread == null)
            {
                _thread = new Thread(Func) { IsBackground = isBackground };
                _thread.Start();
            }
        }

        /// <summary>
        /// 【MM_函数库】主循环方法，若Update阶段属性未定义则默认每轮前摇0ms、间隔50ms
        /// </summary>
        private static void Func()//内部使用
        {
            if (Duetime < 0) { Duetime = 0; }
            if (Period <= 0) { Period = 50; }
            Action(Duetime, Period);
        }

        /// <summary>
        /// 【MM_函数库】主循环唤醒阶段运行一次，允许主动调用
        /// </summary>
        public static void Awake()
        {
            MMCore.EntryGlobalEvent(Entry.MainAwake);
        }

        /// <summary>
        /// 【MM_函数库】主循环开始阶段运行一次，允许主动调用
        /// </summary>
        public static void Start()
        {
            MMCore.EntryGlobalEvent(Entry.MainStart);
        }

        /// <summary>
        /// 【MM_函数库】主循环每轮更新运行，主动调用时跟Unity引擎一样只运行一次
        /// </summary>
        public static void Update()
        {
            MMCore.EntryGlobalEvent(Entry.MainUpdate);
        }

        /// <summary>
        /// 【MM_函数库】主循环结束阶段运行一次，允许主动调用
        /// </summary>
        public static void End()
        {
            MMCore.EntryGlobalEvent(Entry.MainEnd);
        }

        /// <summary>
        /// 【MM_函数库】主循环摧毁阶段运行一次，允许主动调用
        /// </summary>
        public static void Destroy()
        {
            MMCore.EntryGlobalEvent(Entry.MainDestroy);
        }

        /// <summary>
        /// 【MM_函数库】主循环主体事件发布动作（重复执行则什么也不做），若Update阶段属性未定义则默认每轮前摇0ms、间隔50ms
        /// </summary>
        private static void Action()//内部使用
        {
            if (AutoResetEvent == null)
            {
                _autoResetEvent = new AutoResetEvent(false);
                Awake();
                Start();
                if (Duetime < 0) { Duetime = 0; }
                if (Period <= 0) { Period = 50; }
                //Timer自带线程，第一参数填入要间隔执行的方法（参数须符合委托类型），第二参数填状态对象，如自动复位事件对象来控制其他线程启停
                _timer = new Timer(CheckStatus, AutoResetEvent, Duetime, Period);
                AutoResetEvent.WaitOne();
                End();
                AutoResetEvent.WaitOne();
                Timer.Dispose();
                Destroy();
            }

        }

        /// <summary>
        /// 【MM_函数库】主循环主体事件发布动作（重复执行则什么也不做），可自定义Update阶段属性Duetime（前摇）、Period（间隔）
        /// </summary>
        /// <param name="duetime">Updata阶段执行开始前等待（毫秒），仅生效一次</param>
        /// <param name="period">Updata阶段执行间隔（毫秒）</param>
        private static void Action(int duetime, int period)//内部使用
        {
            if (AutoResetEvent == null)
            {
                _autoResetEvent = new AutoResetEvent(false);
                Awake();
                Start();
                if (duetime < 0) { Duetime = 0; }
                if (period <= 0) { Period = 50; }
                //Timer自带线程，第一参数填入要间隔执行的方法（参数须符合委托类型），第二参数填状态对象，如自动复位事件对象来控制其他线程启停
                _timer = new Timer(CheckStatus, AutoResetEvent, Duetime, Period);
                AutoResetEvent.WaitOne();
                End();
                AutoResetEvent.WaitOne();
                Timer.Dispose();
                Destroy();
            }

        }

        #endregion

    }

    /// <summary>
    /// 【MM_函数库】副循环触发器，请给函数注册事件（语法：SubUpdate.Awake/Start/Update/End/Destroy +=/-= 任意符合事件参数格式的函数的名称如MyFunc，其声明为void MyFun(object sender, EventArgs e)，sender传递本类实例（其他类型也可），e传递额外事件参数类的信息），TriggerStart方法将自动创建独立触发器线程并启动周期触发器（主体事件发布动作），启动前可用Duetime、Period属性方法设定Update阶段每次循环的前摇和间隔，启动后按序执行Awake/Start/Update/End/Destroy被这5种事件注册过的委托函数，其中事件Update阶段是一个计时器循环，直到用户手动调用Stop属性方法，该属性为false时会让计时器到期退出Update循环，而计时器所在父线程（即触发器线程）将运行End和Destory事件
    /// </summary>
    public static class SubUpdate
    {
        #region 字段及其属性

        private static Thread _thread;
        /// <summary>
        /// 【MM_函数库】副循环线程
        /// </summary>
        public static Thread Thread { get => _thread; }//不提供外部赋值

        private static Timer _timer;
        /// <summary>
        /// 【MM_函数库】副循环Update阶段，用来实现周期循环的计时器
        /// </summary>
        public static Timer Timer { get => _timer; }//不提供外部赋值

        private static AutoResetEvent _autoResetEvent;
        /// <summary>
        /// 【MM_函数库】副循环自动复位事件对象（用来向副循环线程发送信号），属性动作AutoResetEvent.Set()可让触发器线程终止（效果等同SubUpdate.TimerStop = true）
        /// </summary>
        public static AutoResetEvent AutoResetEvent { get => _autoResetEvent; }//不提供外部赋值

        private static int _invokeCount;
        /// <summary>
        /// 【MM_函数库】副循环Update事件运行次数
        /// </summary>
        public static int InvokeCount { get => _invokeCount; set => _invokeCount = value; }

        private static bool _timerState;
        /// <summary>
        /// 【MM_函数库】副循环状态，手动设置为false则计时器工作时将收到信号退出循环（不执行Update事件），计时器所在父线程将运行End和Destory事件
        /// </summary>
        public static bool TimerStop { get => _timerState; set => _timerState = value; }

        private static int _Duetime, _Period;
        /// <summary>
        /// 【MM_函数库】副循环Update阶段前摇时间，设置后每次循环前都会等待
        /// </summary>
        public static int Duetime { get => _Duetime; set => _Duetime = value; }
        /// <summary>
        /// 【MM_函数库】副循环Update阶段间隔运行时间
        /// </summary>
        public static int Period { get => _Period; set => _Period = value; }

        #endregion

        #region 静态构造函数

        /// <summary>
        /// 【MM_函数库】副循环状态监控类（用来读写InvokeCount、TimerStop属性），计时器实例创建时本类方法CheckStatus以参数填入被反复执行，副循环Update事件被执行时创建计时器的父线程（SubUpdate.Thread）将暂停，直到该方法确认到TimerStop为真，退出计时器循环，并通知计时器所在父线程恢复运行（将执行End和Destory事件）
        /// </summary>
        static SubUpdate()
        {
            InvokeCount = 0;
            TimerStop = false;
        }

        #endregion

        #region 函数

        /// <summary>
        /// 【MM_函数库】副循环的计时器实例创建时以参数填入、被反复执行的函数，Update事件被执行时创建计时器的父线程将暂停，直到本函数确认到TimerStop为真，退出计时器循环，并通知计时器所在父线程恢复运行（将执行End和Destory事件）。一般不需要用户操作，TimerStop为true时手动调用会额外增加Update次数
        /// </summary>
        /// <param name="state"></param>
        public static void CheckStatus(object state)
        {
            if (TimerStop)
            {
                ((AutoResetEvent)state).Set();
            }
            else
            {
                InvokeCount++;
                Update();
            }
        }

        /// <summary>
        /// 【MM_函数库】开启副循环（默认0.05现实时间秒，如需修改请在开启前用属性方法SubUpdate.Period、SubUpdate.Duetime来调整计时器Update阶段的间隔、前摇，若已经开启想要修改，可使用SubUpdate.Timer.Change）
        /// </summary>
        /// <param name="isBackground"></param>
        public static void Start(bool isBackground)
        {
            if (_thread == null)
            {
                _thread = new Thread(Func) { IsBackground = isBackground };
                _thread.Start();
            }
        }

        /// <summary>
        /// 【MM_函数库】副循环方法，若Update阶段属性未定义则默认每轮前摇0ms、间隔50ms
        /// </summary>
        private static void Func()//内部使用
        {
            if (Duetime < 0) { Duetime = 0; }
            if (Period <= 0) { Period = 50; }
            Action(Duetime, Period);
        }

        /// <summary>
        /// 【MM_函数库】副循环唤醒阶段运行一次，允许主动调用
        /// </summary>
        public static void Awake()
        {
            MMCore.EntryGlobalEvent(Entry.SubAwake);
        }

        /// <summary>
        /// 【MM_函数库】副循环开始阶段运行一次，允许主动调用
        /// </summary>
        public static void Start()
        {
            MMCore.EntryGlobalEvent(Entry.SubStart);
        }

        /// <summary>
        /// 【MM_函数库】副循环每轮更新运行，主动调用时跟Unity引擎一样只运行一次
        /// </summary>
        public static void Update()
        {
            MMCore.EntryGlobalEvent(Entry.SubUpdate);
        }

        /// <summary>
        /// 【MM_函数库】副循环结束阶段运行一次，允许主动调用
        /// </summary>
        public static void End()
        {
            MMCore.EntryGlobalEvent(Entry.SubEnd);
        }

        /// <summary>
        /// 【MM_函数库】副循环摧毁阶段运行一次，允许主动调用
        /// </summary>
        public static void Destroy()
        {
            MMCore.EntryGlobalEvent(Entry.SubDestroy);
        }

        /// <summary>
        /// 【MM_函数库】副循环主体事件发布动作（重复执行则什么也不做），若Update阶段属性未定义则默认每轮前摇0ms、间隔50ms
        /// </summary>
        private static void Action()//内部使用
        {
            if (AutoResetEvent == null)
            {
                _autoResetEvent = new AutoResetEvent(false);
                Awake();
                Start();
                if (Duetime < 0) { Duetime = 0; }
                if (Period <= 0) { Period = 50; }
                //Timer自带线程，第一参数填入要间隔执行的方法（参数须符合委托类型），第二参数填状态对象，如自动复位事件对象来控制其他线程启停
                _timer = new Timer(CheckStatus, AutoResetEvent, Duetime, Period);
                AutoResetEvent.WaitOne();
                End();
                AutoResetEvent.WaitOne();
                Timer.Dispose();
                Destroy();
            }

        }

        /// <summary>
        /// 【MM_函数库】副循环主体事件发布动作（重复执行则什么也不做），可自定义Update阶段属性Duetime（前摇）、Period（间隔）
        /// </summary>
        /// <param name="duetime">Updata阶段执行开始前等待（毫秒），仅生效一次</param>
        /// <param name="period">Updata阶段执行间隔（毫秒）</param>
        private static void Action(int duetime, int period)//内部使用
        {
            if (AutoResetEvent == null)
            {
                _autoResetEvent = new AutoResetEvent(false);
                Awake();
                Start();
                if (duetime < 0) { Duetime = 0; }
                if (period <= 0) { Period = 50; }
                //Timer自带线程，第一参数填入要间隔执行的方法（参数须符合委托类型），第二参数填状态对象，如自动复位事件对象来控制其他线程启停
                _timer = new Timer(CheckStatus, AutoResetEvent, Duetime, Period);
                AutoResetEvent.WaitOne();
                End();
                AutoResetEvent.WaitOne();
                Timer.Dispose();
                Destroy();
            }

        }

        #endregion

    }

    /// <summary>
    /// 【MM_函数库】周期触发器，创建实例后请给函数注册事件（语法：TimerUpdate.Awake/Start/Update/End/Destroy +=/-= 任意符合事件参数格式的函数的名称如MyFunc，其声明为void MyFun(object sender, EventArgs e)，sender传递本类实例（其他类型也可），e传递额外事件参数类的信息），TriggerStart方法将自动创建独立触发器线程并启动周期触发器（主体事件发布动作），启动前可用Duetime、Period属性方法设定Update阶段每次循环的前摇和间隔，启动后按序执行Awake/Start/Update/End/Destroy被这5种事件注册过的委托函数，其中事件Update阶段是一个计时器循环，直到用户手动调用TimerStop属性方法，该属性为false时会让计时器到期退出Update循环，而计时器所在父线程（即触发器线程）将运行End和Destory事件
    /// </summary>
    public class TimerUpdate
    {
        #region 变量、字段及其属性方法

        /// <summary>
        /// 【MM_函数库】自动复位事件（用来控制触发线程信号）
        /// </summary>
        private AutoResetEvent _autoResetEvent_TimerUpdate;
        /// <summary>
        /// 【MM_函数库】自动复位事件，提供该属性方便随时读取，属性动作AutoResetEvent_TimerUpdate.Set()可让触发器线程终止（效果等同TimerUpdate.TimerState = true）
        /// </summary>
        public AutoResetEvent AutoResetEvent_TimerUpdate { get => _autoResetEvent_TimerUpdate; }

        /// <summary>
        /// 【MM_函数库】周期触发器主体事件发布动作所在线程的实例
        /// </summary>
        private Thread _thread;

        /// <summary>
        /// 【MM_函数库】周期触发器执行Update事件的计时器实例
        /// </summary>
        private Timer _timer;

        /// <summary>
        /// 【MM_函数库】周期触发器Update事件运行次数
        /// </summary>
        private int _invokeCount;
        /// <summary>
        /// 【MM_函数库】周期触发器Update事件运行次数，该属性可随时读取或清零
        /// </summary>
        public int InvokeCount { get => _invokeCount; set => _invokeCount = value; }

        /// <summary>
        /// 【MM_函数库】周期触发器Update事件运行次数上限，该属性让计时器到期退出循环，计时器所在父线程将运行End和Destory事件
        /// </summary>
        private int _invokeCountMax;
        /// <summary>
        /// 【MM_函数库】周期触发器Update事件运行次数上限，该属性让计时器到期退出循环，计时器所在父线程将运行End和Destory事件
        /// </summary>
        public int InvokeCountMax { get => _invokeCountMax; set => _invokeCountMax = value; }

        /// <summary>
        /// 【MM_函数库】周期触发器Update事件前摇，未设置直接启动TriggerStart则默认为0
        /// </summary>
        private int _duetime;
        /// <summary>
        /// 【MM_函数库】周期触发器Update事件前摇，未设置直接启动TriggerStart则默认为0
        /// </summary>
        public int Duetime { get => _duetime; set => _duetime = value; }

        /// <summary>
        /// 【MM_函数库】周期触发器的运行间隔字段，未设置直接启动TriggerStart则默认为1s
        /// </summary>
        private int _period;
        /// <summary>
        /// 【MM_函数库】周期触发器的运行间隔属性，未设置直接启动TriggerStart则默认为1s
        /// </summary>
        public int Period { get => _period; set => _period = value; }

        /// <summary>
        /// 【MM_函数库】周期触发器的状态字段，手动设置为false则计时器工作时将收到信号退出循环（不执行Update事件），计时器所在父线程将运行End和Destory事件
        /// </summary>
        private bool _timerState;
        /// <summary>
        /// 【MM_函数库】周期触发器的状态属性，手动设置为false则计时器工作时将收到信号退出循环（不执行Update事件），计时器所在父线程将运行End和Destory事件
        /// </summary>
        public bool TimerState { get => _timerState; set => _timerState = value; }

        /// <summary>
        /// 【MM_函数库】事件委托列表，用来存储多个事件委托，用对象类型的键来取出，内部属性，用户不需要操作
        /// </summary>
        protected EventHandlerList _listEventDelegates = new EventHandlerList();

        /// <summary>
        /// 【MM_函数库】周期触发器主体事件发布动作所在线程的实例，提供该属性方便随时读取，但不允许不安全赋值
        /// </summary>
        public Thread Thread { get => _thread; }

        /// <summary>
        /// 【MM_函数库】周期触发器执行Update事件的计时器实例，提供该属性方便随时读取，但不允许不安全赋值
        /// </summary>
        public Timer Timer { get => _timer; }

        #endregion

        #region 定义区分委托对象的键

        //每个new object()都是一个单独的实例个体，所以定义的五个变量相当于内存ID不同的object类型的键
        //由于EventHandlerList类型的_listEventDelegates委托队列是实例成员，相同键返回的委托对象不会相同
        //所以即便创建了多个实例，以下键只需内存独此一份且私有只读

        /// <summary>
        /// 【MM_函数库】周期触发器用于返回事件委托队列中Awake事件委托对象的键
        /// </summary>
        private static readonly object awakeEventKey = new object();
        /// <summary>
        /// 【MM_函数库】周期触发器用于返回事件委托队列中Start事件委托对象的键
        /// </summary>
        private static readonly object startEventKey = new object();
        /// <summary>
        /// 【MM_函数库】周期触发器用于返回事件委托队列中Update事件委托对象的键
        /// </summary>
        private static readonly object updateEventKey = new object();
        /// <summary>
        /// 【MM_函数库】周期触发器用于返回事件委托队列中End事件委托对象的键
        /// </summary>
        private static readonly object endEventKey = new object();
        /// <summary>
        /// 【MM_函数库】周期触发器用于返回事件委托队列中Destroy事件委托对象的键
        /// </summary>
        private static readonly object destroyEventKey = new object();

        #endregion

        #region 声明事件委托

        //事件委托必须安全方式注册事件给函数，不能直接运行，而常规委托则相反。从事件委托列表通过键取出的事件委托可赋值给常规委托去执行，常规委托可以赋值给事件委托但不能交换顺序
        //声明事件委托变量（首字母大写），相比常规委托，事件委托因安全考虑无法直接被执行，通过OnAwake内部函数确保安全执行（其实是声明临时常规委托在赋值后执行）

        /// <summary>
        /// 【MM_函数库】将周期触发器的唤醒事件注册到函数，语法：TimerUpdate.Awake +=/-= 实例或静态函数（特征格式：void 函数名(object sender, EventArgs e)）
        /// </summary>
        public event TimerEventHandler Awake
        {
            // Add the input delegate to the collection.
            add
            {
                _listEventDelegates.AddHandler(awakeEventKey, value);
            }
            // Remove the input delegate from the collection.
            remove
            {
                _listEventDelegates.RemoveHandler(awakeEventKey, value);
            }
        }

        /// <summary>
        /// 【MM_函数库】将周期触发器的开始事件注册到函数，语法：TimerUpdate.Start +=/-= 实例或静态函数（特征格式：void 函数名(object sender, EventArgs e)）
        /// </summary>
        public event TimerEventHandler Start
        {
            add
            {
                _listEventDelegates.AddHandler(startEventKey, value);
            }
            remove
            {
                _listEventDelegates.RemoveHandler(startEventKey, value);
            }
        }

        /// <summary>
        /// 【MM_函数库】将周期触发器的开始事件注册到函数，语法：TimerUpdate.Update +=/-= 实例或静态函数（特征格式：void 函数名(object sender, EventArgs e)）
        /// </summary>
        public event TimerEventHandler Update
        {
            add
            {
                _listEventDelegates.AddHandler(updateEventKey, value);
            }
            remove
            {
                _listEventDelegates.RemoveHandler(updateEventKey, value);
            }
        }

        /// <summary>
        /// 【MM_函数库】将周期触发器的开始事件注册到函数，语法：TimerUpdate.End +=/-= 实例或静态函数（特征格式：void 函数名(object sender, EventArgs e)）
        /// </summary>
        public event TimerEventHandler End
        {
            add
            {
                _listEventDelegates.AddHandler(endEventKey, value);
            }
            remove
            {
                _listEventDelegates.RemoveHandler(endEventKey, value);
            }
        }

        /// <summary>
        /// 【MM_函数库】将周期触发器的开始事件注册到函数，语法：TimerUpdate.Destroy +=/-= 实例或静态函数（特征格式：void 函数名(object sender, EventArgs e)）
        /// </summary>
        public event TimerEventHandler Destroy
        {
            add
            {
                _listEventDelegates.AddHandler(destroyEventKey, value);
            }
            remove
            {
                _listEventDelegates.RemoveHandler(destroyEventKey, value);
            }
        }

        #endregion

        #region 构造函数（本类创建时的2个重载方法）

        /// <summary>
        /// 【MM_函数库】创建一个不会到期的周期触发器
        /// </summary>
        public TimerUpdate()//构造函数
        {
            InvokeCount = 0;
            InvokeCountMax = 0;
            TimerState = false;
        }

        /// <summary>
        /// 【MM_函数库】创建一个有执行次数的周期触发器
        /// </summary>
        /// <param name="invokeCountMax">决定计时器Update阶段循环次数</param>
        public TimerUpdate(int invokeCountMax)//构造函数
        {
            InvokeCount = 0;
            InvokeCountMax = invokeCountMax;
            TimerState = false;
        }

        #endregion

        //非静态（实例）方法可以访问类中的任何成员

        /// <summary>
        /// 【MM_函数库】计时器实例创建时以参数填入、被反复执行的函数，Update事件被执行时创建计时器的父线程将暂停，直到本函数确认到TimerState为真，退出计时器循环，并通知计时器所在父线程恢复运行（将执行End和Destory事件）
        /// </summary>
        /// <param name="state"></param>
        private void CheckStatus(object state)
        {
            if (TimerState)
            {
                ((AutoResetEvent)state).Set();
            }
            else if (InvokeCountMax > 0 && InvokeCount >= InvokeCountMax)
            {
                ((AutoResetEvent)state).Set();
            }
            else
            {
                InvokeCount++;
                OnUpdate(this, new EventArgs());
            }
        }

        //注：Action函数在特殊需要时再设置为公开（不让用户直接使用），用户使用TimerUpdate.TriggerStart自带线程启动

        /// <summary>
        /// 【MM_函数库】周期触发器主体事件发布动作（重复执行则什么也不做），在当前线程创建周期触发器并执行事件委托（提前定义事件委托变量TimerUpdate.Awake/Start/Update/End/Destroy += 要委托执行的函数，即完成事件注册到函数），可预先自定义计时器Updata阶段的执行间隔（否则默认以Duetime=0、Period=1000运行计时器）。注：若直接调用本函数则在计时器Updata阶段会暂停当前线程，不想暂停请额外开线程手动加载Action运行或使用TimerUpdate.TriggerStart自带线程启动（推荐）
        /// </summary>
        private void Action()
        {
            if (_autoResetEvent_TimerUpdate == null)
            {
                //private void OnAwake(object sender, EventArgs e)
                //sender参数用于传递指向事件源对象的引用，简单来讲就是当前的对象
                //sender参数也可填任意类型，填this的话传递后能从本实例类中得到字段值等信息，要传递事件变量可写在本类里
                //e参数是是EventArgs类型，简单来理解就是记录事件传递过来的额外信息
                //e参数可通过自定义类继承EventArgs类，里面记录额外事件变量，该类以参数填入完成传递

                _autoResetEvent_TimerUpdate = new AutoResetEvent(false);
                //执行委托并传递事件参数
                OnAwake(this, new EventArgs());
                OnStart(this, new EventArgs());
                if (_duetime < 0) { _duetime = 0; }
                if (_period <= 0) { _period = 1000; }
                _timer = new Timer(CheckStatus, _autoResetEvent_TimerUpdate, _duetime, _period);
                _autoResetEvent_TimerUpdate.WaitOne();
                OnEnd(this, new EventArgs());
                _autoResetEvent_TimerUpdate.WaitOne();
                _timer.Dispose();
                OnDestroy(this, new EventArgs());
            }
        }

        /// <summary>
        /// 【MM_函数库】周期触发器主体事件发布动作（重复执行则什么也不做），在当前线程创建周期触发器并执行事件委托（提前定义事件委托变量TimerUpdate.Awake/Start/Update/End/Destroy += 要委托执行的函数，即完成事件注册到函数），可预先自定义计时器Updata阶段的执行间隔（否则默认以Duetime=0、Period=1000运行计时器）。注：若直接调用本函数则在计时器Updata阶段会暂停当前线程，不想暂停请额外开线程手动加载Action运行或使用TimerUpdate.TriggerStart自带线程启动（推荐）
        /// </summary>
        /// <param name="duetime">Updata阶段执行开始前等待（毫秒），仅生效一次</param>
        /// <param name="period">Updata阶段执行间隔（毫秒）</param>
        private void Action(int duetime, int period)
        {
            if (_autoResetEvent_TimerUpdate == null)
            {
                _autoResetEvent_TimerUpdate = new AutoResetEvent(false);
                OnAwake(this, new EventArgs());
                OnStart(this, new EventArgs());
                if (_duetime < 0) { _duetime = 0; }
                if (_period <= 0) { _period = 1000; }
                _timer = new Timer(CheckStatus, _autoResetEvent_TimerUpdate, duetime, period);
                _autoResetEvent_TimerUpdate.WaitOne();
                OnEnd(this, new EventArgs());
                _autoResetEvent_TimerUpdate.WaitOne();
                _timer.Dispose();
                OnDestroy(this, new EventArgs());
            }
        }

        #region 声明常规委托，安全执行事件委托并传递事件参数

        /// <summary>
        /// 【MM_函数库】计时器唤醒阶段时运行一次
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void OnAwake(object sender, EventArgs e)
        {
            TimerEventHandler timerEventHandler = (TimerEventHandler)_listEventDelegates[awakeEventKey];
            timerEventHandler?.Invoke(sender, e);
        }

        /// <summary>
        /// 【MM_函数库】周期触发器开始阶段运行一次
        /// </summary>
        private void OnStart(object sender, EventArgs e)
        {
            TimerEventHandler timerEventHandler = (TimerEventHandler)_listEventDelegates[startEventKey];
            timerEventHandler?.Invoke(sender, e);
        }

        /// <summary>
        /// 【MM_函数库】周期触发器Update阶段按预设间隔反复运行
        /// </summary>
        private void OnUpdate(object sender, EventArgs e)
        {
            TimerEventHandler timerEventHandler = (TimerEventHandler)_listEventDelegates[updateEventKey];
            timerEventHandler?.Invoke(sender, e);
        }

        /// <summary>
        /// 【MM_函数库】周期触发器结束阶段运行一次
        /// </summary>
        private void OnEnd(object sender, EventArgs e)
        {
            TimerEventHandler timerEventHandler = (TimerEventHandler)_listEventDelegates[endEventKey];
            timerEventHandler?.Invoke(sender, e);
        }

        /// <summary>
        /// 【MM_函数库】周期触发器摧毁阶段运行一次
        /// </summary>
        private void OnDestroy(object sender, EventArgs e)
        {
            TimerEventHandler timerEventHandler = (TimerEventHandler)_listEventDelegates[destroyEventKey];
            timerEventHandler?.Invoke(sender, e);
        }

        #endregion

        #region 自动创建线程执行周期触发器（模拟触发器运行）

        /// <summary>
        /// 【MM_函数库】自动创建线程启动周期触发器（模拟触发器运行），重复启动时什么也不做，未设置Update属性则默认以Duetime=0、Period=1000运行计时器循环
        /// </summary>
        /// <param name="isBackground">true将启动线程调整为后台线程</param>
        public void TriggerStart(bool isBackground)
        {
            if (_thread == null)
            {
                _thread = new Thread(Action) { IsBackground = isBackground };
                _thread.Start();
            }
        }

        #endregion

    }

    /// <summary>
    /// 【MM_函数库】单位
    /// </summary>
    public class Unit
    {
        #region 字段

        //字段用于每个实例存储不同的值

        private string _name;

        private double _age;
        private double _speed;
        private double _attackSpeed;
        private double _strength;
        private double _vitality;
        private double _agility;
        private double _intelligence;
        private double _dexterity;
        private double _luck;
        private double _atk;
        private double _def;
        private double _matk;
        private double _mdef;
        private double _critical;
        private double _antiCritical;
        private double _maspd;
        private double _hp;
        private double _mp;
        private double _sp;
        private double[] _tp;
        private double _exp;
        private double _hps;
        private double _mps;
        private double _sps;
        private double[] _tps;
        private double _evasion;
        private double _evasionRate;
        private double _perfectEvasion;
        private double _perfectEvasionRate;
        private double _hit;
        private double _hitRate;
        private double _perfectHit;
        private double _perfectHitRate;
        private double _killRate;
        private double _antiAntiKilledRate;
        private double _carryWeight = 300.0;

        private double _ageMax;
        private double _speedMax;
        private double _strengthMax;
        private double _vitalityMax;
        private double _agilityMax;
        private double _intelligenceMax;
        private double _dexterityMax;
        private double _luckMax;
        private double _atkMax;
        private double _defMax;
        private double _matkMax;
        private double _mdefMax;
        private double _criticalMax;
        private double _antiCriticalMax;
        private double _maspdMax;
        private double _hpMax;
        private double _mpMax;
        private double _spMax;
        private double[] _tpMax;
        private double _expMax;
        private double _hpsMax;
        private double _mpsMax;
        private double _spsMax;
        private double[] _tpsMax;
        private double _evasionMax;
        private double _evasionRateMax;
        private double _perfectEvasionMax;
        private double _perfectEvasionRateMax;
        private double _hitMax;
        private double _hitRateMax;
        private double _perfectHitMax;
        private double _perfectHitRateMax;
        private double _killRateMax;
        private double _antiAntiKilledRateMax;
        private double _carryWeightMax = 300.0;

        private int _Tag;
        private string _typeName;
        private Vector3D _vector3D;
        private Vector _vector;
        private double _terrainHeight = 0.0;
        private double _height = 1.8;
        private double _radius = 0.5;
        private double _selectedRadius = 0.5;
        private int _owner;
        private int _controller;
        private double _angle;
        private bool _alive;

        #endregion

        #region 构造函数

        /// <summary>
        /// 【MM_函数库】单位
        /// </summary>
        public Unit()
        {
            //创建新类时的初始化动作
            Tag = Game.CurrentUnitHandle + 1;
            Game.UnitLastCreated = this;
        }

        #endregion

        #region 属性方法

        /// <summary>
        /// 名字
        /// </summary>
        public string Name { get => _name; set => _name = value; }
        /// <summary>
        /// 年龄
        /// </summary>
        public double Age { get => _age; set => _age = value; }
        /// <summary>
        /// 移动速度（每帧行动距离换算到每秒），由游戏内部针对当前帧速进行修改（如每帧50ms时，实际每帧移动距离=50*Speed/1000）
        /// </summary>
        public double Speed { get => _speed; set => _speed = value; }
        /// <summary>
        /// ASPD：物理攻击速度（每帧行动次数换算到每秒），受到多个因素同时影响如AGI、DEX、职业、武器、药水等（设计ASPD=100即每秒攻击5次，则每4帧攻击1次），由游戏内部针对当前帧速进行修改（如每帧50ms时，实际每次攻击等待毫秒数=50*ASPD/（100/5）=200ms）
        /// </summary>
        public double AttackSpeed { get => _attackSpeed; set => _attackSpeed = value; }
        /// <summary>
        /// STR：力量，影响物理攻击（每点加2）、负重上限（每点加30，按牛顿为单位约50~60个鸡蛋）、武器发挥（当STR很低时，武器攻击无法完全发挥，在STR为0时只能发挥25%），但不影响暴击和抵挡几率和每秒伤害输出DPS(Attack Power)
        /// 当用斧、书、剑、拳刃、拳套、钝器、矛等近战武器或空手时ATK +1、武器ATK+0.5%）仅对基础武器ATK有效，且强制无属性），当用弓、枪械、乐器、鞭等远程武器时ATK+0.2
        /// </summary>
        public double Strength { get => _strength; set => _strength = value; }
        /// <summary>
        /// VIT：耐力（体力），影响生命值上限和物理防御，每点增加HP上限30或1%、HP恢复+0.2、物理防御0.5~1、魔防0.2、HP恢复类道具效果+2%，每5点增加HP回复1
        /// 状态效果影响：中毒状态成功率-1%且持续时间减少，VIT≥100时免疫中毒状态，混乱状态成功率减少，昏迷状态成功率-1%且持续时间减少，VIT≥100时免疫昏迷状态，沉默状态成功率 -1%且持续时间-0.01秒，诅咒状态持续时间-0.01秒，霜冻状态成功率减少且持续时间-0.05秒，冷冻状态持续时间-0.1秒
        /// </summary>
        public double Vitality { get => _vitality; set => _vitality = value; }
        /// <summary>
        /// AGI：敏捷，每点增加攻击速度1%、闪避1、防御力0.2、致命一击或暴击
        /// 状态效果影响：出血状态成功率和持续时间减少，移动不可状态中部分陷阱类状态成功率和持续时间减少，灼烧状态成功率和持续时间减少
        /// </summary>
        public double Agility { get => _agility; set => _agility = value; }
        /// <summary>
        /// INT：智力，影响魔攻、魔法值和魔法致命一击几率，每点加魔攻2、魔防0.5~1、魔法值1%，每6点增Sp恢复速度（INT<120时，SP自然恢复 +0.6，INT≥120时，SP自然恢复+1.3），增至偶数时Sp上限加7、奇数时Sp上限加6，可变吟唱时间减少，恢复类道具效果+1%
        /// 状态效果影响：冰冻状态持续时间减少，对口职业睡眠状态成功率 -1%，持续时间减少，黑暗状态成功率减少，持续时间减少，恐惧状态成功率减少，持续时间减少，沉睡状态成功率减少，持续时间减少
        /// </summary>
        public double Intelligence { get => _intelligence; set => _intelligence = value; }
        /// <summary>
        /// DEX：敏捷（灵巧），影响玩家命中和可变吟唱时间，每点加命中1，每3点减0.1秒可变咏唱时间并加物理攻击1，每5点加物理攻击1，每30点减1秒可变咏唱时间（游戏中有个重要名词叫“不可变吟唱时间”也就是说某个技能存在一个最低下限）
        /// 当用弓、枪械、乐器、鞭等远程武器时ATK+1、武器ATK+0.5%（仅对基础武器ATK有效且强制无属性），当用斧、书、剑、拳刃、拳套、钝器、矛等近战武器或空手时ATK+0.2、MATK+0.2、HIT+1、MDEF+1、可变吟唱时间减少、按比例增加ASPD
        /// 状态效果影响：装备卸除状态持续时间减少，霜冻状态成功率减少且持续时间-0.05秒
        /// </summary>
        public double Dexterity { get => _dexterity; set => _dexterity = value; }
        /// <summary>
        /// LUK：幸运（厄运为负），影响装备道具的出现率&探索发现率、暴击率、完全回避等，每点CRI+0.3、ATK+0.3、MATK+0.3、HIT+0.3、回避+0.2、完全回避+0.1、免暴率+1，每3点加暴击1，每5点加物理攻击1和防暴击1
        /// 状态效果影响：中毒状态成功率&持续时间减少，冰冻状态成功率减少，混乱状态成功率减少，石化状态成功率减少，睡眠状态成功率减少，昏迷状态成功率减少，持续时间减少，沉默状态成功率减少，诅咒状态成功率减少，黑暗状态成功率减少，沉睡状态成功率减少
        /// </summary>
        public double Luck { get => _luck; set => _luck = value; }
        /// <summary>
        /// Atk：物理攻击力，力量的主要相关因素以及受其他辅助因素影响
        /// </summary>
        public double Atk { get => _atk; set => _atk = value; }
        /// <summary>
        /// DEF：防御力，敏捷的主要相关因素以及受其他辅助因素影响
        /// </summary>
        public double Def { get => _def; set => _def = value; }
        /// <summary>
        /// Matk：魔法攻击力
        /// </summary>
        public double Matk { get => _matk; set => _matk = value; }
        /// <summary>
        /// Mdef ：魔法防御力
        /// </summary>
        public double Mdef { get => _mdef; set => _mdef = value; }
        /// <summary>
        /// CRI：暴击率，一般根据人物等级设计攻击力来计算（按一定比率采取反推方式完成）
        /// </summary>
        public double Critical { get => _critical; set => _critical = value; }
        /// <summary>
        /// 抗暴率，实际暴击率按抗暴率程度将暴击率消减再修正数值得到实际暴击率，简单点就直接相减
        /// </summary>
        public double AntiCritical { get => _antiCritical; set => _antiCritical = value; }
        /// <summary>
        /// Maspd：魔法攻击速度，MASPD受到多个因素同时影响：INT、AGI、DEX、职业、武器、药水等，其中敏捷和常规物理攻击速度关联较大，施法频率参考ASPD
        /// </summary>
        public double Maspd { get => _maspd; set => _maspd = value; }
        /// <summary>
        /// 生命值
        /// </summary>
        public double Hp { get => _hp; set => _hp = value; }
        /// <summary>
        /// 魔法点：ManaPoint，当低于所需时，角色无法使用相关武器装备和常规技能
        /// </summary>
        public double Mp { get => _mp; set => _mp = value; }
        /// <summary>
        /// 特殊技能点：当低于所需时，角色无法使用特殊技能
        /// </summary>
        public double Sp { get => _sp; set => _sp = value; }
        /// <summary>
        /// 计时阶段状态条（可有多个），用于单位工作或施法阶段进行计时等用途
        /// </summary>
        public double[] Tp { get => _tp; set => _tp = value; }
        /// <summary>
        /// 经验值：experience，积累到一定数量可提高等级、能力
        /// </summary>
        public double Exp { get => _exp; set => _exp = value; }
        /// <summary>
        /// 生命值恢复速度（每帧），延时恢复另详设计
        /// </summary>
        public double Hps { get => _hps; set => _hps = value; }
        /// <summary>
        /// 魔法点恢复速度（每帧），延时恢复另详设计
        /// </summary>
        public double Mps { get => _mps; set => _mps = value; }
        /// <summary>
        /// 技能点恢复速度（每帧），延时恢复另详设计
        /// </summary>
        public double Sps { get => _sps; set => _sps = value; }
        /// <summary>
        /// 工作、施法时间阶段的状态值恢复或倒计速度
        /// </summary>
        public double[] Tps { get => _tps; set => _tps = value; }
        /// <summary>
        /// 闪避
        /// </summary>
        public double Evasion { get => _evasion; set => _evasion = value; }
        /// <summary>
        /// 闪避率，其值=1 / (1 + 100 / 闪避面板数值)，允许超过100的原因是面对命中率时可扣减，并不是最终结果
        /// </summary>
        public double EvasionRate { get => _evasionRate; set => _evasionRate = value; }
        /// <summary>
        /// 完美闪避，此项仅受幸运影响
        /// </summary>
        public double PerfectEvasion { get => _perfectEvasion; set => _perfectEvasion = value; }
        /// <summary>
        /// 完美闪避率，根据完美闪避计算后修正得出，并用来参与结果
        /// </summary>
        public double PerfectEvasionRate { get => _perfectEvasionRate; set => _perfectEvasionRate = value; }
        /// <summary>
        /// 命中
        /// </summary>
        public double Hit { get => _hit; set => _hit = value; }
        /// <summary>
        /// 命中率
        /// </summary>
        public double HitRate { get => _hitRate; set => _hitRate = value; }
        /// <summary>
        /// 完美命中，此项仅受幸运影响
        /// </summary>
        public double PerfectHit { get => _perfectHit; set => _perfectHit = value; }
        /// <summary>
        /// 完美命中率，根据完美命中计算后修正得出，并用来参与结果
        /// </summary>
        public double PerfectHitRate { get => _perfectHitRate; set => _perfectHitRate = value; }
        /// <summary>
        /// 致命一击率，允许超过100的原因是遇对方有抗即死率时进行扣减，并不是最终结果
        /// </summary>
        public double KillRate { get => _killRate; set => _killRate = value; }
        /// <summary>
        /// 抗即死率，用来防御致命一击
        /// </summary>
        public double AntiKilledRate { get => _antiAntiKilledRate; set => _antiAntiKilledRate = value; }
        /// <summary>
        /// 单位负重
        /// </summary>
        public double CarryWeight { get => _carryWeight; set => _carryWeight = value; }

        //↓限制

        public double AgeMax { get => _ageMax; set => _ageMax = value; }
        public double SpeedMax { get => _speedMax; set => _speedMax = value; }
        public double StrengthMax { get => _strengthMax; set => _strengthMax = value; }
        public double VitalityMax { get => _vitalityMax; set => _vitalityMax = value; }
        public double AgilityMax { get => _agilityMax; set => _agilityMax = value; }
        public double IntelligenceMax { get => _intelligenceMax; set => _intelligenceMax = value; }
        public double DexterityMax { get => _dexterityMax; set => _dexterityMax = value; }
        public double LuckMax { get => _luckMax; set => _luckMax = value; }
        public double AtkMax { get => _atkMax; set => _atkMax = value; }
        public double DefMax { get => _defMax; set => _defMax = value; }
        public double MatkMax { get => _matkMax; set => _matkMax = value; }
        public double MdefMax { get => _mdefMax; set => _mdefMax = value; }
        public double CriticalMax { get => _criticalMax; set => _criticalMax = value; }
        public double AntiCriticalMax { get => _antiCriticalMax; set => _antiCriticalMax = value; }
        public double MaspdMax { get => _maspdMax; set => _maspdMax = value; }
        public double HpMax { get => _hpMax; set => _hpMax = value; }
        public double MpMax { get => _mpMax; set => _mpMax = value; }
        public double SpMax { get => _spMax; set => _spMax = value; }
        public double[] TpMax { get => _tpMax; set => _tpMax = value; }
        public double ExpMax { get => _expMax; set => _expMax = value; }
        public double HpsMax { get => _hpsMax; set => _hpsMax = value; }
        public double MpsMax { get => _mpsMax; set => _mpsMax = value; }
        public double SpsMax { get => _spsMax; set => _spsMax = value; }
        public double[] TpsMax { get => _tpsMax; set => _tpsMax = value; }
        public double EvasionMax { get => _evasionMax; set => _evasionMax = value; }
        public double EvasionRateMax { get => _evasionRateMax; set => _evasionRateMax = value; }
        public double PerfectEvasionMax { get => _perfectEvasionMax; set => _perfectEvasionMax = value; }
        public double PerfectEvasionRateMax { get => _perfectEvasionRateMax; set => _perfectEvasionRateMax = value; }
        public double HitMax { get => _hitMax; set => _hitMax = value; }
        public double HitRateMax { get => _hitRateMax; set => _hitRateMax = value; }
        public double PerfectHitMax { get => _perfectHitMax; set => _perfectHitMax = value; }
        public double PerfectHitRateMax { get => _perfectHitRateMax; set => _perfectHitRateMax = value; }
        public double KillRateMax { get => _killRateMax; set => _killRateMax = value; }
        public double AntiKilledRateMax { get => _antiAntiKilledRateMax; set => _antiAntiKilledRateMax = value; }
        public double CarryWeightMax { get => _carryWeightMax; set => _carryWeightMax = value; }

        //↓其他属性

        /// <summary>
        /// 单位标签（句柄）
        /// </summary>
        public int Tag { get => _Tag; set => _Tag = value; }

        /// <summary>
        /// 单位类型在编辑器的名字
        /// </summary>
        public string TypeName { get => _typeName; set => _typeName = value; }

        /// <summary>
        /// 单位脚底坐标向量(三维)，Z坐标是根据计算得到（Z=MapHeight+TerrainHeight+Unit.TerrainHeight），平时只要实时更新平面坐标即可根据该二维点高度信息更新3D高度
        /// </summary>
        public Vector3D Vector3D { get => _vector3D; set => _vector3D = value; }

        /// <summary>
        /// 单位脚底坐标向量(二维)
        /// </summary>
        public Vector Vector { get => _vector; set => _vector = value; }

        /// <summary>
        /// 单位层地形物件高度（区别地图层地形物件），其值使单位浮空或嵌入地面
        /// </summary>
        public double TerrainHeight { get => _terrainHeight; set => _terrainHeight = value; }

        /// <summary>
        /// 单位高度，注意当鼠标划过或点击单位时返回的Z坐标是在其头顶的（mouseVectorZ=MapHeight+TerrainHeight+Unit.TerrainHeight+Unit.Height）
        /// </summary>
        public double Height { get => _height; set => _height = value; }

        /// <summary>
        /// 单位碰撞检查半径，默认与模型半径一致，可修改每个单位的碰撞范围
        /// </summary>
        public double Radius { get => _radius; set => _radius = value; }

        /// <summary>
        /// 鼠标点击单位时的选择及搜索范围
        /// </summary>
        public double SelectedRadius { get => _selectedRadius; set => _selectedRadius = value; }

        /// <summary>
        /// 单位所有者的玩家编号
        /// </summary>
        public int Owner { get => _owner; set => _owner = value; }

        /// <summary>
        /// 单位控制者的玩家编号
        /// </summary>
        public int Controller { get => _controller; set => _controller = value; }

        /// <summary>
        /// 单位朝向角度
        /// </summary>
        public double Angle { get => _angle; set => _angle = value; }

        /// <summary>
        /// 单位活体状态
        /// </summary>
        public bool Alive { get => _alive; set => _alive = value; }

        #endregion

        #region 函数

        /// <summary>
        /// 发布指令
        /// </summary>
        /// <param name="inOrder"></param>
        /// <param name="inQueueType"></param>
        public void IssueOrder(Order inOrder, int inQueueType)
        {

        }

        /// <summary>
        /// 设置单位属性
        /// </summary>
        /// <param name="unitProp"></param>
        /// <param name="value"></param>
        public void SetProperty(UnitProp unitProp, double value)
        {

        }

        /// <summary>
        /// 返回单位的世界坐标点（二维）
        /// </summary>
        /// <returns></returns>
        public Vector GetPosition()
        {
            return Vector;
        }

        #endregion

    }

    #region 派生单位

    /// <summary>
    /// 【MM_函数库】道具
    /// </summary>
    public class Item : Unit { }

    /// <summary>
    /// 轨道控制基地
    /// </summary>
    public class OrbitalCommand : Unit { }

    /// <summary>
    /// 储物箱
    /// </summary>
    public class CCData_StorageBox : Unit { }

    /// <summary>
    /// 火焰虫
    /// </summary>
    public class CCData_FlameBeetle : Unit { }

    /// <summary>
    /// 建筑废墟
    /// </summary>
    public class CCData_BuildingRuin : Unit { }

    /// <summary>
    /// 通讯大楼
    /// </summary>
    public class CCData_TongXunDaLou : Unit { }

    /// <summary>
    /// 备用车库
    /// </summary>
    public class CCData_BeiYongCheKu : Unit { }

    /// <summary>
    /// 生产车间
    /// </summary>
    public class CCData_ShengChanCheJian : Unit { }

    /// <summary>
    /// 修理场
    /// </summary>
    public class CCData_XiuLiChang : Unit { }

    /// <summary>
    /// 主车库
    /// </summary>
    public class CCData_ZhuCheKu : Unit { }

    /// <summary>
    /// 飞船（剧情）
    /// </summary>
    public class CCData_Story_FeiChuan : Unit { }

    /// <summary>
    /// 巴拉克
    /// </summary>
    public class CCData_StoryBoss_Brakk : Unit { }

    /// <summary>
    /// 百生丝莉芬
    /// </summary>
    public class CCData_StoryBoss_Slivan : Unit { }

    /// <summary>
    /// 毒裂兽
    /// </summary>
    public class CCData_StoryBoss_Mitosaurus : Unit { }

    /// <summary>
    /// 毒瘴兽
    /// </summary>
    public class CCData_StoryBoss_HotSNoxious : Unit { }

    /// <summary>
    /// 异形大牛
    /// </summary>
    public class CCData_StoryBoss_HotSTorrasque : Unit { }

    /// <summary>
    /// 僵尸
    /// </summary>
    public class CCData_Zombie : Unit { }

    /// <summary>
    /// 僵尸生成器
    /// </summary>
    public class CCData_ZobieMaker : Unit { }

    /// <summary>
    /// 瓦力生成器
    /// </summary>
    public class CCData_WaLiMaker : Unit { }

    /// <summary>
    /// 外星生成器
    /// </summary>
    public class CCData_AlienMaker : Unit { }

    /// <summary>
    /// 火王兽
    /// </summary>
    public class CCData_KingBoss_HuoWangShou : Unit { }

    /// <summary>
    /// 机械雷王兽
    /// </summary>
    public class CCData_KingBoss_MechanicalThunderBeast : Unit { }

    /// <summary>
    /// 雷王兽
    /// </summary>
    public class CCData_KingBoss_LeiWangShou : Unit { }

    /// <summary>
    /// 末日兽
    /// </summary>
    public class CCData_KingBoss_MoRiShou : Unit { }

    /// <summary>
    /// 虚空兽
    /// </summary>
    public class CCData_KingBoss_XuKongShou : Unit { }

    /// <summary>
    /// 亚格卓拉
    /// </summary>
    public class CCData_KingBoss_Yagdra : Unit { }

    /// <summary>
    /// 武装者
    /// </summary>
    public class CCData_Hero_Armer : Unit { }

    /// <summary>
    /// 伪装者（诺亚势力）
    /// </summary>
    public class CCData_Pretender : Unit { }

    /// <summary>
    /// 沙袋
    /// </summary>
    public class CCData_HB_SandBag : Unit { }

    /// <summary>
    /// 营火
    /// </summary>
    public class CCData_HB_Campfire : Unit { }

    /// <summary>
    /// 自动机炮
    /// </summary>
    public class CCData_HB_AutoTurret : Unit { }

    /// <summary>
    /// 末日炮塔
    /// </summary>
    public class CCData_HB_PerditionTurret : Unit { }

    /// <summary>
    /// 方阵机炮
    /// </summary>
    public class CCData_HB_FangZhenJiPao : Unit { }

    /// <summary>
    /// 特斯拉电磁塔
    /// </summary>
    public class CCData_HB_TeslaTurret : Unit { }

    /// <summary>
    /// 导弹塔
    /// </summary>
    public class CCData_HB_MissileTurret : Unit { }

    /// <summary>
    /// 地堡
    /// </summary>
    public class CCData_HB_Bunker : Unit { }

    /// <summary>
    /// 军用沙袋
    /// </summary>
    public class CCData_HB_MilitarySandbag : Unit { }

    /// <summary>
    /// 路障
    /// </summary>
    public class CCData_HB_Barricade : Unit { }

    /// <summary>
    /// 机枪炮台
    /// </summary>
    public class CCData_HB_GunTurret : Unit { }

    /// <summary>
    /// 毒气炮台
    /// </summary>
    public class CCData_HB_GasFortDown : Unit { }

    /// <summary>
    /// 旋转炮台
    /// </summary>
    public class CCData_HB_RotatingTurret : Unit { }

    /// <summary>
    /// 宝箱
    /// </summary>
    public class CCData_BaoXiang : Unit { }

    /// <summary>
    /// 特殊宝箱
    /// </summary>
    public class CCData_TeShuBaoXiang : Unit { }

    /// <summary>
    /// 特异宝箱
    /// </summary>
    public class CCData_TeYiBaoXiang : Unit { }

    /// <summary>
    /// 王兽宝箱
    /// </summary>
    public class CCData_WangShouBaoXiang : Unit { }

    /// <summary>
    /// 珍宝箱
    /// </summary>
    public class CCData_ZhenBaoXiang : Unit { }

    /// <summary>
    /// 功勋
    /// </summary>
    public class CCData_Honor : Unit { }

    /// <summary>
    /// 机件
    /// </summary>
    public class CCData_JiJian : Unit { }

    /// <summary>
    /// 强化星
    /// </summary>
    public class CCData_Star : Unit { }

    /// <summary>
    /// 全满补给
    /// </summary>
    public class CCData_PickupHealthFull : Unit { }

    /// <summary>
    /// 设计图
    /// </summary>
    public class CCData_SheJiTu : Unit { }

    /// <summary>
    /// 武器
    /// </summary>
    public class CCData_WuQi : Unit { }

    /// <summary>
    /// 新机件
    /// </summary>
    public class CCData_JiJianNew : Unit { }

    /// <summary>
    /// 新型设计图
    /// </summary>
    public class CCData_SheJiTuNew : Unit { }

    /// <summary>
    /// 新型武器
    /// </summary>
    public class CCData_WuQiNew : Unit { }

    /// <summary>
    /// 诺亚核心（不完全形态）
    /// </summary>
    public class CCData_NYCoreImperfection : Unit { }

    /// <summary>
    /// 诺亚核心
    /// </summary>
    public class CCData_NYCore : Unit { }

    /// <summary>
    /// 储藏箱
    /// </summary>
    public class CCData_NovaResupplyCrate : Unit { }

    /// <summary>
    /// 手榴弹
    /// </summary>
    public class CCData_PickupGrenades : Unit { }

    /// <summary>
    /// 飞行装备
    /// </summary>
    public class CCData_FlightEquipment : Unit { }

    /// <summary>
    /// 装备箱（里面存放着几件随机物品）
    /// </summary>
    public class CCData_PickupZbx : Unit { }

    /// <summary>
    /// 陆战队员
    /// </summary>
    public class Marine : Unit { }

    /// <summary>
    /// 劫掠者(Dominion Kill Team)
    /// </summary>
    public class DominionKillTeam : Unit { }

    /// <summary>
    /// 火蝠
    /// </summary>
    public class Firebat : Unit { }

    /// <summary>
    /// 攻城坦克
    /// </summary>
    public class SiegeTank : Unit { }

    /// <summary>
    /// 战狼
    /// </summary>
    public class WarHound : Unit { }

    /// <summary>
    /// 牛头人太空陆战队员
    /// </summary>
    public class TaurenSpaceMarine : Unit { }

    /// <summary>
    /// 恶蝠
    /// </summary>
    public class HellionTank : Unit { }

    /// <summary>
    /// 铁锤安保
    /// </summary>
    public class HammerSecurity : Unit { }

    /// <summary>
    /// 歌利亚武装机器人
    /// </summary>
    public class Goliath : Unit { }

    /// <summary>
    /// 赫克
    /// </summary>
    public class HERC : Unit { }

    /// <summary>
    /// 吉姆·雷诺
    /// </summary>
    public class Raynor01 : Unit { }

    /// <summary>
    /// 收割者
    /// </summary>
    public class Reaper : Unit { }

    /// <summary>
    /// 泰凯斯·芬利
    /// </summary>
    public class TychusChaingun : Unit { }

    /// <summary>
    /// 维京战机
    /// </summary>
    public class VikingAssault : Unit { }

    /// <summary>
    /// 秃鹫
    /// </summary>
    public class Vulture : Unit { }

    /// <summary>
    /// 沃菲尔德将军
    /// </summary>
    public class MarineWarfield : Unit { }

    /// <summary>
    /// 劫掠者
    /// </summary>
    public class Marauder : Unit { }

    /// <summary>
    /// 普罗米修斯连队
    /// </summary>
    public class MengskFirebat : Unit { }

    /// <summary>
    /// 恶火
    /// </summary>
    public class Hellion : Unit { }

    /// <summary>
    /// 掠食者
    /// </summary>
    public class Predator : Unit { }

    /// <summary>
    /// 飓风
    /// </summary>
    public class Cyclone : Unit { }

    /// <summary>
    /// 解放者
    /// </summary>
    public class Liberator : Unit { }

    /// <summary>
    /// 士兵
    /// </summary>
    public class Separatist : Unit { }

    #endregion

    #region Game相关类

    /// <summary>
    /// 技能命令。一个技能可以有多个命令，本类代表了具体命令
    /// </summary>
    public class Abilcmd
    {
        private int _index;
        public int Index { get => _index; set => _index = value; }
        private string _link;
        public string Link { get => _link; set => _link = value; }
        private Unit _targetUnit;
        public Unit TargetUnit { get => _targetUnit; set => _targetUnit = value; }
        private Vector _targetVector;
        public Vector TargetVector { get => _targetVector; set => _targetVector = value; }
        private int _targetType;
        /// <summary>
        /// 目标类型：0=无，1=单位，2=二维点，3=物品
        /// </summary>
        public int TargetType { get => _targetType; set => _targetType = value; }

        public Abilcmd(string abilLink, int abilIndex)
        {
            Link = abilLink;
            Index = abilIndex;
        }
    }

    /// <summary>
    /// 指令
    /// </summary>
    public class Order
    {
        private int _player;
        public int Player { get => _player; set => _player = value; }

        private int _index;
        public int Index { get => _index; set => _index = value; }
        private string _link;
        public string Link { get => _link; set => _link = value; }
        private Unit _targetUnit;
        public Unit TargetUnit { get => _targetUnit; set => _targetUnit = value; }
        private Vector _targetVector;
        public Vector TargetVector { get => _targetVector; set => _targetVector = value; }
        private int _targetType;
        /// <summary>
        /// 目标类型：0=无，1=单位，2=二维点，3=物品
        /// </summary>
        public int TargetType { get => _targetType; set => _targetType = value; }

        public Order(Abilcmd cmd)
        {
            Link = cmd.Link;
            Index = cmd.Index;
        }

    }

    /// <summary>
    /// 单位组
    /// </summary>
    public class UnitGroup
    {
        private string _name;
        public string Name { get => _name; set => _name = "UnitGroup_" + value; }

        public UnitGroup(string name)
        {
            Name = name;
        }

        public void Add(Unit unit)
        {
            MMCore.DHD_AddObjectToGroup(unit, Name);
        }

        public void AddGroup(UnitGroup unitGroup)
        {
            MMCore.DHD_AddObjectGToObjectG(unitGroup.Name, Name);
        }

        public void Del(Unit unit)
        {
            MMCore.DHD_RemoveObject(unit, Name);
        }

        public void DelALL()
        {
            MMCore.DHD_RemoveObjectGAll(Name);
        }

        public int Count()
        {
            return MMCore.DHD_ReturnObjectNumMax(Name);
        }

        public bool IsUnitInGroup(Unit unit)
        {
            int ae = MMCore.DHD_ReturnObjectNumMax(Name);
            int va = 1, ai = 1;
            for (; (ai >= 0 && va <= ae) || (ai < 0 && va >= ae); va += ai)
            {
                //直接对比单位也是可以的，但以防从Object转换出来的Unit是新的实例，最好给字典追加一个单位类型
                //这里采用标签句柄对比：每个单位组元素序号必然对应一个已注册单位标签，且注册序号从1开始，若单位的标签句柄不存在（为0）不会匹配到
                if (MMCore.DHD_ReturnObjectTagFromRegNum_String(va, Name) == MMCore.DHD_ReturnObjectTag(unit))
                {
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// 玩家闲置单位
        /// </summary>
        /// <param name="player">玩家</param>
        /// <param name="workerOnly">true=仅输出闲置工人</param>
        /// <returns></returns>
        public static UnitGroup Idle(int player, bool workerOnly)
        {
            UnitGroup idle = new UnitGroup("Idle_" + workerOnly.ToString() + "_" + player.ToString());
            return idle;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="inGroup"></param>
        /// <param name="inIndex"></param>
        /// <returns></returns>
        public static Unit UnitFromEnd(UnitGroup inGroup, int inIndex)
        {
            int ae = MMCore.DHD_ReturnObjectNumMax(inGroup.Name);
            if (inIndex > 0 && inIndex <= ae)
            {
                return (Unit)MMCore.DHD_ReturnObjectFromRegNum(inIndex, inGroup.Name);
            }
            return null;

        }

    }

    #endregion

    /// <summary>
    /// 【MM_函数库】玩家类，为每个玩家创建它并初始化所需信息，内置字段以外的临时属性可用数据表添加修改
    /// </summary>
    public static class Player
    {
        #region 字段

        private static Unit[] _hero = new Unit[Game.c_maxPlayers + 1];
        private static Unit[,] vehicle = new Unit[Game.c_maxPlayers + 1, Game.c_vehicleTypeMax];
        private static Unit[] currentVehicle = new Unit[Game.c_maxPlayers + 1];
        private static Unit[] unitMain = new Unit[Game.c_maxPlayers + 1];
        private static Unit[] unitControl = new Unit[Game.c_maxPlayers + 1];
        private static bool[] _canNotOperation = new bool[Game.c_maxPlayers + 1];

        private static bool[,] _keyDown = new bool[Game.c_maxPlayers + 1, MMCore.c_keyMax + 1];
        private static bool[,] _keyDownState = new bool[Game.c_maxPlayers + 1, MMCore.c_keyMax + 1];
        private static bool[] _keyDownLoop = new bool[Game.c_maxPlayers + 1];
        private static int[] _keyDownLoopOneBitNum = new int[Game.c_maxPlayers + 1];

        private static bool[] _mouseDownLeft = new bool[Game.c_maxPlayers + 1];
        private static bool[] _mouseDownMiddle = new bool[Game.c_maxPlayers + 1];
        private static bool[] _mouseDownRight = new bool[Game.c_maxPlayers + 1];
        private static bool[,] _mouseDown = new bool[Game.c_maxPlayers + 1, MMCore.c_mouseMax + 1];
        private static bool[,] _mouseDownState = new bool[Game.c_maxPlayers + 1, MMCore.c_mouseMax + 1];
        private static bool[] _mouseDownLoop = new bool[Game.c_maxPlayers + 1];
        private static int[] _mouseDownLoopOneBitNum = new int[Game.c_maxPlayers + 1];

        private static bool[,] _keyDoubleClick = new bool[Game.c_maxPlayers + 1, MMCore.c_mouseMax + 1];
        private static bool[,] _mouseDoubleClick = new bool[Game.c_maxPlayers + 1, MMCore.c_mouseMax + 1];

        private static int[] _mouseUIX = new int[Game.c_maxPlayers + 1];
        private static int[] _mouseUIY = new int[Game.c_maxPlayers + 1];

        private static double[] _mouseVectorX = new double[Game.c_maxPlayers + 1];
        private static double[] _mouseVectorY = new double[Game.c_maxPlayers + 1];
        private static double[] _mouseVectorZ = new double[Game.c_maxPlayers + 1];
        private static double[] _mouseVectorZFixed = new double[Game.c_maxPlayers + 1];
        private static double[] _mouseToUnitControlAngle = new double[Game.c_maxPlayers + 1];
        private static double[] _mouseToUnitControlRange = new double[Game.c_maxPlayers + 1];
        private static double[] _mouseToUnitControlRange3D = new double[Game.c_maxPlayers + 1];
        private static Vector3D[] _cameraVector3D = new Vector3D[Game.c_maxPlayers + 1];
        private static Vector3D[] _mouseVector3DFixed = new Vector3D[Game.c_maxPlayers + 1];
        private static Vector3D[] _mouseVector3D = new Vector3D[Game.c_maxPlayers + 1];
        private static Vector3D[] _mouseVector3DUnitTerrain = new Vector3D[Game.c_maxPlayers + 1];
        private static Vector3D[] _mouseVector3DTerrain = new Vector3D[Game.c_maxPlayers + 1];
        private static Vector[] _mouseVector = new Vector[Game.c_maxPlayers + 1];

        private static string[] _type = new string[Game.c_maxPlayers + 1];
        private static string[] _handle = new string[Game.c_maxPlayers + 1];//句柄格式："A1-A1-A1-A0000001"

        private static bool[] _localUser = new bool[Game.c_maxPlayers + 1];
        private static string[] _status = new string[Game.c_maxPlayers + 1];
        private static int[] _teamID = new int[Game.c_maxPlayers + 1];

        #endregion

        #region 属性方法

        /// <summary>
        /// 英雄单位
        /// </summary>
        public static Unit[] Hero { get => _hero; set => _hero = value; }
        /// <summary>
        /// 私人载具
        /// </summary>
        public static Unit[,] Vehicle { get => vehicle; set => vehicle = value; }
        /// <summary>
        /// 当前载具
        /// </summary>
        public static Unit[] CurrentVehicle { get => currentVehicle; set => currentVehicle = value; }
        /// <summary>
        /// 主单位
        /// </summary>
        public static Unit[] UnitMain { get => unitMain; set => unitMain = value; }
        /// <summary>
        /// 控制单位
        /// </summary>
        public static Unit[] UnitControl { get => unitControl; set => unitControl = value; }
        /// <summary>
        /// 禁止操作
        /// </summary>
        public static bool[] CanNotOperation { get => _canNotOperation; set => _canNotOperation = value; }

        /// <summary>
        /// 键盘按键按下[键,玩家]
        /// </summary>
        public static bool[,] KeyDown { get => _keyDown; set => _keyDown = value; }
        /// <summary>
        /// 键盘按键按下的有效状态（因为即便按下也能逻辑否决，所以真实有效按键必须键按下+有效状态同时符合）。禁用玩家操作时总是false，某些情况可设计针对某键禁止操作
        /// </summary>
        public static bool[,] KeyDownState { get => _keyDownState; set => _keyDownState = value; }
        /// <summary>
        /// 键盘按键队列
        /// </summary>
        public static bool[] KeyDownLoop { get => _keyDownLoop; set => _keyDownLoop = value; }
        /// <summary>
        /// 键盘按键队列数
        /// </summary>
        public static int[] KeyDownLoopOneBitNum { get => _keyDownLoopOneBitNum; set => _keyDownLoopOneBitNum = value; }

        /// <summary>
        /// 鼠标左键按下
        /// </summary>
        public static bool[] MouseDownLeft { get => _mouseDownLeft; set => _mouseDownLeft = value; }
        /// <summary>
        /// 鼠标中键按下
        /// </summary>
        public static bool[] MouseDownMiddle { get => _mouseDownMiddle; set => _mouseDownMiddle = value; }
        /// <summary>
        /// 鼠标右键按下
        /// </summary>
        public static bool[] MouseDownRight { get => _mouseDownRight; set => _mouseDownRight = value; }
        /// <summary>
        /// 鼠标按键按下
        /// </summary>
        public static bool[,] MouseDown { get => _mouseDown; set => _mouseDown = value; }
        /// <summary>
        /// 鼠标按键按下的有效状态（因为即便按下也能逻辑否决，所以真实有效按键必须键按下+有效状态同时符合）
        /// </summary>
        public static bool[,] MouseDownState { get => _mouseDownState; set => _mouseDownState = value; }
        /// <summary>
        /// 鼠标按键队列
        /// </summary>
        public static bool[] MouseDownLoop { get => _mouseDownLoop; set => _mouseDownLoop = value; }
        /// <summary>
        /// 鼠标按键队列数
        /// </summary>
        public static int[] MouseDownLoopOneBitNum { get => _mouseDownLoopOneBitNum; set => _mouseDownLoopOneBitNum = value; }

        /// <summary>
        /// 按键双击
        /// </summary>
        public static bool[,] KeyDoubleClick { get => _keyDoubleClick; set => _keyDoubleClick = value; }
        /// <summary>
        /// 鼠标双击
        /// </summary>
        public static bool[,] MouseDoubleClick { get => _mouseDoubleClick; set => _mouseDoubleClick = value; }

        /// <summary>
        /// 鼠标在UI的X坐标
        /// </summary>
        public static int[] MouseUIX { get => _mouseUIX; set => _mouseUIX = value; }
        /// <summary>
        /// 鼠标在UI的Y坐标
        /// </summary>
        public static int[] MouseUIY { get => _mouseUIY; set => _mouseUIY = value; }
        /// <summary>
        /// 鼠标在世界的X坐标
        /// </summary>
        public static double[] MouseVectorX { get => _mouseVectorX; set => _mouseVectorX = value; }
        /// <summary>
        /// 鼠标在世界的Y坐标
        /// </summary>
        public static double[] MouseVectorY { get => _mouseVectorY; set => _mouseVectorY = value; }
        /// <summary>
        /// 鼠标点高度，mouseVectorZ=MapHeight+TerrainHeight+Unit.TerrainHeight+Unit.Height
        /// 悬崖、地形物件及单位在移动、诞生摧毁时应将高度信息刷新，以便实时获取
        /// </summary>
        public static double[] MouseVectorZ { get => _mouseVectorZ; set => _mouseVectorZ = value; }
        /// <summary>
        /// 修正后的鼠标点高度（扣减了地面高度，所以这是相对地面的高度），mouseVectorZFixed=mouseVectorZ-MapHeight=TerrainHeight+Unit.TerrainHeight+Unit.Height
        /// </summary>
        public static double[] MouseVectorZFixed { get => _mouseVectorZFixed; set => _mouseVectorZFixed = value; }
        /// <summary>
        /// 鼠标与玩家控制单位在世界中的2D角度，象限分布：右=0度，上=90°，左=180°，下=270°，可用于调整行走方向
        /// </summary>
        public static double[] MouseToUnitControlAngle { get => _mouseToUnitControlAngle; set => _mouseToUnitControlAngle = value; }
        /// <summary>
        /// 鼠标与玩家控制单位在世界中的2D距离
        /// </summary>
        public static double[] MouseToUnitControlRange { get => _mouseToUnitControlRange; set => _mouseToUnitControlRange = value; }
        /// <summary>
        /// 鼠标与玩家控制单位在世界中的3D角度，常用于调整鼠标自动镜头
        /// </summary>
        public static double[] MouseToUnitControlRange3D { get => _mouseToUnitControlRange3D; set => _mouseToUnitControlRange3D = value; }
        /// <summary>
        /// 相机位置
        /// </summary>
        public static Vector3D[] CameraVector3D { get => _cameraVector3D; set => _cameraVector3D = value; }
        /// <summary>
        /// 鼠标3D点向量坐标，修正了鼠标点高度（扣减了地图高度，所以这是相对地面的高度），mouseVectorZFixed=mouseVectorZ-MapHeight=TerrainHeight+Unit.TerrainHeight+Unit.Height
        /// </summary>
        public static Vector3D[] MouseVector3DFixed { get => _mouseVector3DFixed; set => _mouseVector3DFixed = value; }
        /// <summary>
        /// 鼠标3D点向量坐标，鼠标Z点在单位高度顶部，Z=MapHeight+TerrainHeight+Unit.TerrainHeight+Unit.Height
        /// </summary>
        public static Vector3D[] MouseVector3D { get => _mouseVector3D; set => _mouseVector3D = value; }
        /// <summary>
        /// 鼠标3D点向量坐标，鼠标Z点在单位层地形物件高度顶部（单位脚底），Z=MapHeight+TerrainHeight+Unit.TerrainHeight
        /// </summary>
        public static Vector3D[] MouseVector3DUnitTerrain { get => _mouseVector3DUnitTerrain; set => _mouseVector3DUnitTerrain = value; }
        /// <summary>
        /// 鼠标3D点向量坐标，鼠标Z点在悬崖、地形物件顶部，Z=MapHeight+TerrainHeight
        /// </summary>
        public static Vector3D[] MouseVector3DTerrain { get => _mouseVector3DTerrain; set => _mouseVector3DTerrain = value; }
        /// <summary>
        /// 鼠标2D点向量坐标
        /// </summary>
        public static Vector[] MouseVector { get => _mouseVector; set => _mouseVector = value; }

        /// <summary>
        /// 玩家类型（中立Neutral、电脑Ai、用户User、玩家Player、敌人Enemy）
        /// </summary>
        public static string[] Type { get => _type; set => _type = value; }
        /// <summary>
        /// 玩家句柄
        /// </summary>
        public static string[] Handle { get => _handle; set => _handle = value; }
        /// <summary>
        /// 判断Player是否为本机用户
        /// </summary>
        public static bool[] LocalUser { get => _localUser; set => _localUser = value; }
        /// <summary>
        /// 用户状态（"Online"、"Offline"、其他状态字符）
        /// </summary>
        public static string[] Status { get => _status; set => _status = value; }
        /// <summary>
        /// 所属队伍ID
        /// </summary>
        public static int[] TeamID { get => _teamID; set => _teamID = value; }

        #endregion

        public static void ModifyProperty(int player, PlayerProp playerProp, PlayerPropOp playerPropOp, double value) { }

    }

    #region 键鼠钩子及监听服务

    #region 监听服务

    /// <summary>
    /// 【MM_函数库】监听服务
    /// </summary>
    public class RecordService
    {
        #region 字段及其属性方法

        private bool _defaultEvent = false;
        /// <summary>
        /// 判断键鼠总控预制事件是否已注册，通过函数“AddKeyMouseEvent”可快捷将本类实例中5个预制事件KeyDown、KeyUp、MouseMove、MouseDown、MouseUp注册给库内预制函数引用，从而使用按键总控管理衍生的所有功能（比如将“移动”、“发射火箭”等函数动作注册给Q键）
        /// </summary>
        public bool DefaultEvent { get => _defaultEvent; set => _defaultEvent = value; }

        private readonly MouseHook MyMouseHook;
        private readonly KeyboardHook MyKeyboardHook;

        //用户可自定义委托函数，在监听到事件发生时去执行

        public KeyDownEventFuncref KeyDownEvent;
        public KeyDoubleClickEventFuncref KeyDoubleClickEvent;
        public KeyUpEventFuncref KeyUpEvent;
        public MouseMoveEventFuncref MouseMoveEvent;
        public MouseDownEventFuncref MouseDownEvent;
        public MouseLDoubleClickEventFuncref MouseLDoubleClickEvent;
        public MouseRDoubleClickEventFuncref MouseRDoubleClickEvent;
        public MouseUpEventFuncref MouseUpEvent;

        #endregion

        #region 钩子开关

        /// <summary>
        /// 创建监听服务并默认用户玩家编号=MMCore.LocalID
        /// </summary>
        public RecordService()//构造函数
        {
            PlayerID = MMCore.LocalID;
            MyMouseHook = MouseHook.GetMouseHook();
            MyKeyboardHook = KeyboardHook.GetKeyboardHook();
        }

        /// <summary>
        /// 创建监听服务，可自定用户玩家编号（范围是1-15）
        /// </summary>
        public RecordService(int player)//构造函数
        {
            PlayerID = player;
            MyMouseHook = MouseHook.GetMouseHook();
            MyKeyboardHook = KeyboardHook.GetKeyboardHook();
        }

        /// <summary>
        /// 开启鼠标钩子
        /// </summary>
        /// <param name="handler"></param>
        public void StartMouseHook()
        {
            MyMouseHook.AddMouseHandler(MouseEventHandler);
            MyMouseHook.Start();
        }

        /// <summary>
        /// 关闭鼠标钩子
        /// </summary>
        public void StopMouseHook()
        {
            MyMouseHook.Stop();
        }

        /// <summary>
        /// 开启键盘钩子
        /// </summary>
        /// <param name="handler"></param>
        public void StartKeyboardHook()
        {
            MyKeyboardHook.AddKeyboardHandler(KeyboardHandler);
            MyKeyboardHook.Start();
        }

        /// <summary>
        /// 关闭键盘钩子
        /// </summary>
        public void StopKeyboardHook()
        {
            MyKeyboardHook.Stop();
        }

        #endregion

        #region 热键操作

        #region 成员变量

        private int _x;

        /// <summary>
        /// 鼠标当前位置的X坐标
        /// </summary>
        public int X
        {
            get { return _x; }
            set { _x = value; }
        }

        private int _y;

        /// <summary>
        /// 鼠标当前位置的Y坐标
        /// </summary>
        public int Y
        {
            get { return _y; }
            set { _y = value; }
        }

        private double _z;

        /// <summary>
        /// 鼠标当前位置的Z坐标
        /// </summary>
        public double Z
        {
            get { return _z; }
            set { _z = value; }
        }

        private int _wParam;

        /// <summary>
        /// 被按下的鼠标按键
        /// </summary>
        public int WParam
        {
            get { return _wParam; }
            set { _wParam = value; }
        }


        private int _KeyStatus;

        /// <summary>
        /// 键钮状态
        /// </summary>
        public int KeyStatus
        {
            get { return _KeyStatus; }
            set { _KeyStatus = value; }
        }

        private int _KeyValue;

        /// <summary>
        /// 键码
        /// </summary>
        public int KeyValue
        {
            get { return _KeyValue; }
            set { _KeyValue = value; }
        }

        private bool[] _CtrlAlt = new bool[2] { false, false };

        /// <summary>
        /// Ctrl 和 Alt
        /// </summary>
        public bool[] CtrlAlt
        {
            get { return _CtrlAlt; }
            set { _CtrlAlt = value; }
        }

        private bool[] _OneToNine = new bool[10] { false, false, false, false, false, false, false, false, false, false };

        /// <summary>
        /// 1-9
        /// </summary>
        public bool[] OneToNine
        {
            get { return _OneToNine; }
            set { _OneToNine = value; }
        }

        private int _playerID;

        /// <summary>
        /// 玩家编号
        /// </summary>
        public int PlayerID { get => _playerID; set => _playerID = value; }

        #endregion

        //以下处理动作不宜放时间复杂度高的函数动作，建议只记录变量变化，由其他线程读取这些变量后决定触发动作

        #region 鼠标事件处理

        /// <summary>
        /// 鼠标事件处理函数，对接系统底层非托管事件，并按用户设定线程的周期间隔将指定状态记录到托管数据，本函数不做其他消耗时间的处理，请另外读取这些状态数据来组织动作
        /// </summary>
        /// <param name="wParam">鼠标事件状态</param>
        /// <param name="mouseMsg">存储着鼠标信息</param>
        private void MouseEventHandler(Int32 wParam, MouseHookStruct mouseMsg)
        {
            this.WParam = wParam;
            switch (wParam)
            {
                case WM_MOUSEMOVE:
                    // 记录鼠标移动位置
                    X = mouseMsg.pt.x;//UI坐标，是整数
                    Y = mouseMsg.pt.y;//UI坐标，是整数

                    //注：到此记录了WParam和X,Y即可，不宜写时间复杂度较高的逻辑，剩下的"按键总控"功能（给按键注册注销更换委托函数，用于蓄力、移动、释放技能、按弹菜单等游戏世界逻辑）通过读取本类信息另外开线程去制作即可

                    //思考：X,Y如何转化为世界坐标？

                    //Z从上述（X,Y）的信息中获得
                    Z = Game.MapHeight + Game.TerrainHeight[X, Y] + (double)MMCore.DictionaryDoubleLoad0(true, "Unit.TerrainHeight");

                    MouseMoveEvent?.Invoke(PlayerID, new Vector3D(X, Y, Z), X, Y);//当没给函数注册事件时不运行

                    break;
                case WM_LBUTTONDOWN:
                    // 记录鼠标左键按下
                    MouseDownEvent?.Invoke(PlayerID, MMCore.c_mouseButtonLeft, Player.MouseVector3D[PlayerID], X, Y);

                    break;
                case WM_LBUTTONUP:
                    // 记录鼠标左键弹起
                    MouseUpEvent?.Invoke(PlayerID, MMCore.c_mouseButtonLeft, Player.MouseVector3D[PlayerID], X, Y);

                    break;
                case WM_LBUTTONDBLCLK:
                    // 记录鼠标左键双击
                    MouseLDoubleClickEvent?.Invoke(PlayerID, Player.MouseVector3D[PlayerID], X, Y);

                    break;
                case WM_RBUTTONDOWN:
                    // 记录鼠标右键按下
                    MouseDownEvent?.Invoke(PlayerID, MMCore.c_mouseButtonRight, Player.MouseVector3D[PlayerID], X, Y);

                    break;
                case WM_RBUTTONUP:
                    // 记录鼠标右键弹起
                    MouseUpEvent?.Invoke(PlayerID, MMCore.c_mouseButtonRight, Player.MouseVector3D[PlayerID], X, Y);

                    break;
                case WM_RBUTTONDBLCLK:
                    // 记录鼠标右键双击
                    MouseRDoubleClickEvent?.Invoke(PlayerID, Player.MouseVector3D[PlayerID], X, Y);

                    break;
            }

        }

        #endregion

        #region 键盘事件处理
        // 虚拟键码
        private const int CTRL = 162;
        private const int ALT = 164;
        private const int ZERO = 48;

        /*
         * ctrl 162
         * alt 164
         * 1-9 -》 49-57
         * 0 -》48
         */

        /// <summary>
        /// 键盘事件处理函数，对接系统底层非托管事件，并按用户设定线程的周期间隔将指定状态记录到托管数据，本函数不做其他消耗时间的处理，请另外读取这些状态数据来组织动作
        /// </summary>
        /// <param name="wParam">键盘事件状态</param>
        /// <param name="keyboardHookStruct">存储着虚拟键码</param>
        private void KeyboardHandler(Int32 wParam, KeyboardHookStruct keyboardHookStruct)
        {
            KeyStatus = wParam;
            KeyValue = keyboardHookStruct.vkCode;
            // 热键判断
            if (KeyStatus == KeyboardHook.WM_KEYDOWN || KeyStatus == KeyboardHook.WM_SYSKEYDOWN)
            {
                // 按下某个按钮
                switch (KeyValue)
                {
                    case CTRL:
                        CtrlAlt[0] = true;
                        break;
                    case ALT:
                        CtrlAlt[1] = true;
                        break;
                }
                if (KeyValue >= ZERO && KeyValue <= (ZERO + 9))
                {
                    // 按下了0-9
                    int temp = KeyValue - ZERO;
                    OneToNine[temp] = true;
                }
            }
            else if (KeyStatus == KeyboardHook.WM_KEYUP || KeyStatus == KeyboardHook.WM_SYSKEYUP)
            {
                // 松开某个按钮
                switch (KeyValue)
                {
                    case CTRL:
                        CtrlAlt[0] = false;
                        break;
                    case ALT:
                        CtrlAlt[1] = false;
                        break;
                }
                if (KeyValue >= ZERO && KeyValue <= (ZERO + 9))
                {
                    // 按下了0-9
                    int temp = KeyValue - ZERO;
                    OneToNine[temp] = false;
                }
            }
        }

        /// <summary>
        /// 是否按下了 Ctrl + alt + 0-9
        /// </summary>
        /// <returns>返回0-9代表按下了Ctrl+alt+0-9，返回-1代表没有按下</returns>
        public int IsPressTarget()
        {
            if ((!CtrlAlt[0]) || (!CtrlAlt[1]))
            {
                return -1;
            }
            for (int i = 0; i < 10; i++)
            {
                if (OneToNine[i])
                {
                    return i;
                }
            }
            return -1;
        }
        #endregion

        #endregion
    }

    #endregion

    #region 键鼠钩子

    //虚拟键码：https://learn.microsoft.com/zh-cn/windows/win32/inputdev/virtual-key-codes?redirectedfrom=MSDN
    //CSDN原址：https://blog.csdn.net/qq_43851684/article/details/113096306

    /// <summary>
    /// 【MM_函数库】键盘钩子
    /// </summary>
    public class KeyboardHook
    {
        #region 常数和结构

        #region wParam键盘输入通知

        public const int WM_KEYDOWN = 0x100;    // 键盘被按下
        public const int WM_KEYUP = 0x101;      // 键盘被松开
        public const int WM_SYSKEYDOWN = 0x104; // 系统键被按下，例如Alt、Ctrl等键
        public const int WM_SYSKEYUP = 0x105;   // 系统键被松开，例如Alt、Ctrl等键
        public const int WH_KEYBOARD_LL = 13;

        #endregion

        [StructLayout(LayoutKind.Sequential)] //声明键盘钩子的封送结构类型 
        public class KeyboardHookStruct

        {
            public int vkCode; //表示一个在1到254间的虚似键盘码 
            public int scanCode; //表示硬件扫描码 
            public int flags;
            public int time;
            public int dwExtraInfo;
        }
        #endregion

        #region 成员变量、委托、事件
        private static int hHook;
        private static HookProc KeyboardHookDelegate;
        /// <summary>
        /// 键盘回调委托
        /// </summary>
        /// <param name="wParam">按键的状态</param>
        /// <param name="keyboardHookStruct">存储着虚拟键码</param>
        public delegate void KeyboardHandler(Int32 wParam, KeyboardHookStruct keyboardHookStruct);
        // 键盘回调事件
        private static event KeyboardHandler Handlers;
        // 锁
        private readonly object lockObject = new object();
        // 当前状态,是否已经启动
        private volatile bool isStart = false;
        #endregion

        #region Win32的Api
        private delegate int HookProc(int nCode, Int32 wParam, IntPtr lParam);
        //安装钩子的函数 
        [DllImport("user32.dll", CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall)]
        private static extern int SetWindowsHookEx(int idHook, HookProc lpfn, IntPtr hInstance, int threadId);

        //卸下钩子的函数 
        [DllImport("user32.dll", CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall)]
        private static extern bool UnhookWindowsHookEx(int idHook);

        //下一个钩挂的函数 
        [DllImport("user32.dll", CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall)]
        private static extern int CallNextHookEx(int idHook, int nCode, Int32 wParam, IntPtr lParam);

        [DllImport("kernel32.dll", CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall)]
        private static extern IntPtr GetModuleHandle(string lpModuleName);
        #endregion

        #region 单例模式
        private static volatile KeyboardHook MyKeyboard;
        private readonly static object createLock = new object();
        private KeyboardHook() { }
        public static KeyboardHook GetKeyboardHook()
        {
            if (MyKeyboard == null)
            {
                lock (createLock)
                {
                    if (MyKeyboard == null)
                    {
                        MyKeyboard = new KeyboardHook();
                    }
                }
            }
            return MyKeyboard;
        }
        #endregion

        /// <summary>
        /// 安装钩子
        /// </summary>
        public void Start()
        {
            if (isStart)
            {
                return;
            }
            lock (lockObject)
            {
                if (isStart)
                {
                    return;
                }
                if (Handlers == null)
                {
                    throw new Exception("Please set handler first!Then run Start");
                }
                KeyboardHookDelegate = new HookProc(KeyboardHookProc);
                Process cProcess = Process.GetCurrentProcess();
                ProcessModule cModule = cProcess.MainModule;
                var mh = GetModuleHandle(cModule.ModuleName);
                hHook = SetWindowsHookEx(WH_KEYBOARD_LL, KeyboardHookDelegate, mh, 0);
                isStart = true;
            }
        }

        /// <summary>
        /// 卸载钩子
        /// </summary>
        public void Stop()
        {
            if (!isStart)
            {
                return;
            }
            lock (lockObject)
            {
                if (!isStart)
                {
                    return;
                }
                UnhookWindowsHookEx(hHook);
                // 清除所有事件
                Handlers = null;
                isStart = false;
            }
        }

        /// <summary>
        /// 键盘的系统回调函数
        /// </summary>
        /// <param name="nCode">如果代码小于零，则挂钩过程必须将消息传递给CallNextHookEx函数，而无需进一步处理，并且应返回CallNextHookEx返回的值。此参数可以是下列值之一(见虚拟键码)</param>
        /// <param name="wParam">鼠标输入通知，代表发生的鼠标的事件，各种虚拟键事件发生后传入此参（WM_）</param>
        /// <param name="lParam">平台特定整数类型（是一个结构体），用于本机资源（存储着互动窗口句柄等相关事件信息）多线程安全使用</param>
        /// <returns></returns>
        private static int KeyboardHookProc(int nCode, Int32 wParam, IntPtr lParam)
        {
            //如果该消息被丢弃（nCode<0）或者没有事件绑定处理程序则不会触发事件
            if ((nCode >= 0) && Handlers != null)
            {
                KeyboardHookStruct KeyDataFromHook = (KeyboardHookStruct)Marshal.PtrToStructure(lParam, typeof(KeyboardHookStruct));
                Handlers(wParam, KeyDataFromHook);
            }
            return CallNextHookEx(hHook, nCode, wParam, lParam);
        }

        /// <summary>
        /// 添加按键的回调函数
        /// </summary>
        /// <param name="handler"></param>
        public void AddKeyboardHandler(KeyboardHandler handler)
        {
            Handlers += handler;
        }

        /// <summary>
        /// 删除指定按键的回调函数
        /// </summary>
        /// <param name="handler"></param>
        public void RemoveKeyboardHandler(KeyboardHandler handler)
        {
            if (Handlers != null)
            {
                Handlers -= handler;
            }
        }
    }

    /// <summary>
    /// 【MM_函数库】鼠标钩子
    /// </summary>
    public class MouseHook
    {
        #region 常量（用于匹配鼠标输入通知）
        public const int WM_MOUSEMOVE = 0x200; // 鼠标移动
        public const int WM_LBUTTONDOWN = 0x201;// 鼠标左键按下
        public const int WM_RBUTTONDOWN = 0x204;// 鼠标右键按下
        public const int WM_MBUTTONDOWN = 0x207;// 鼠标中键按下
        public const int WM_LBUTTONUP = 0x202;// 鼠标左键抬起
        public const int WM_RBUTTONUP = 0x205;// 鼠标右键抬起
        public const int WM_MBUTTONUP = 0x208;// 鼠标中键抬起
        public const int WM_LBUTTONDBLCLK = 0x203;// 鼠标左键双击
        public const int WM_RBUTTONDBLCLK = 0x206;// 鼠标右键双击
        public const int WM_MBUTTONDBLCLK = 0x209;// 鼠标中键双击
        public const int WH_MOUSE_LL = 14; //可以截获整个系统所有模块的鼠标事件。
        #endregion

        #region 成员变量、回调函数、事件
        /// <summary>
        /// 钩子回调常规函数引用（委托类型），特征：int HookProc(int nCode, Int32 wParam, IntPtr lParam)
        /// </summary>
        /// <param name="nCode">如果代码小于零，则挂钩过程必须将消息传递给CallNextHookEx函数，而无需进一步处理，并且应返回CallNextHookEx返回的值。此参数可以是下列值之一(见虚拟键码)</param>
        /// <param name="wParam">鼠标输入通知，代表发生的鼠标的事件，各种虚拟键事件发生后传入此参（WM_）</param>
        /// <param name="lParam">平台特定整数类型（是一个结构体），用于本机资源（存储着互动窗口句柄等相关事件信息）多线程安全使用</param>
        /// <returns></returns>
        public delegate int HookProc(int nCode, Int32 wParam, IntPtr lParam);
        /// <summary>
        /// 全局鼠标常规函数引用（委托类型）
        /// </summary>
        /// <param name="wParam"> 鼠标输入通知，代表发生的鼠标的事件，各种虚拟键事件发生后传入此参（WM_）</param>
        /// <param name="mouseMsg">鼠标钩子结构体，存储着鼠标位置、互动窗口句柄等相关事件信息</param>
        public delegate void MyMouseEventHandler(Int32 wParam, MouseHookStruct mouseMsg);
        private event MyMouseEventHandler OnMouseActivity;
        // 声明鼠标钩子事件类型
        private HookProc _mouseHookProcedure;
        private static int _hMouseHook = 0; // 鼠标钩子句柄
        // 锁
        private readonly object lockObject = new object();
        // 当前状态,是否已经启动
        private bool isStart = false;
        #endregion

        #region Win32的API
        /// <summary>
        /// 钩子结构体
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public class MouseHookStruct
        {
            /// <summary>
            /// 指定在屏幕坐标系下，包含有光标x、y坐标的POINT结构（鼠标位置）
            /// </summary>
            public POINT pt;
            /// <summary>
            /// 希望对鼠标事件做出响应、接收鼠标消息的窗体的句柄
            /// </summary>
            public int hWnd;
            /// <summary>
            /// 指定点击测试值，查看WM_NCHITTEST消息可以得到值的列表
            /// </summary>
            public int wHitTestCode;
            /// <summary>
            /// 指定和该消息相关联的附加信息
            /// </summary>
            public int dwExtraInfo;
        }

        //声明一个Point的封送类型  
        [StructLayout(LayoutKind.Sequential)]
        public class POINT
        {
            public int x;
            public int y;
        }

        // 装置钩子的函数
        [DllImport("user32.dll", CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall)]
        public static extern int SetWindowsHookEx(int idHook, HookProc lpfn, IntPtr hInstance, int threadId);

        // 卸下钩子的函数
        [DllImport("user32.dll", CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall)]
        public static extern bool UnhookWindowsHookEx(int idHook);

        // 下一个钩挂的函数
        [DllImport("user32.dll", CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall)]
        public static extern int CallNextHookEx(int idHook, int nCode, Int32 wParam, IntPtr lParam);
        #endregion


        #region 构造(单例模式)与析构函数
        private static volatile MouseHook MyMouseHook;
        private readonly static object createLock = new object();
        private MouseHook() { }

        public static MouseHook GetMouseHook()
        {
            if (MyMouseHook == null)
            {
                lock (createLock)
                {
                    if (MyMouseHook == null)
                    {
                        MyMouseHook = new MouseHook();
                    }
                }
            }
            return MyMouseHook;
        }

        /// <summary>
        /// 析构函数
        /// </summary>
        ~MouseHook()
        {
            Stop();
        }
        #endregion


        /// <summary>
        /// 启动全局钩子
        /// </summary>
        public void Start()
        {
            if (isStart)
            {
                return;
            }
            lock (lockObject)
            {
                if (isStart)
                {
                    return;
                }
                if (OnMouseActivity == null)
                {
                    throw new Exception("Please set handler first!Then run Start");
                }
                // 安装鼠标钩子
                if (_hMouseHook == 0)
                {
                    // 生成一个HookProc的实例.
                    _mouseHookProcedure = new HookProc(MouseHookProc);
                    _hMouseHook = SetWindowsHookEx(WH_MOUSE_LL, _mouseHookProcedure, Marshal.GetHINSTANCE(System.Reflection.Assembly.GetExecutingAssembly().GetModules()[0]), 0);
                    //假设装置失败停止钩子
                    if (_hMouseHook == 0)
                    {
                        Stop();
                        throw new Exception("SetWindowsHookEx failed.");
                    }
                }
                isStart = true;
            }
        }

        /// <summary>
        /// 停止全局钩子
        /// </summary>
        public void Stop()
        {
            if (!isStart)
            {
                return;
            }
            lock (lockObject)
            {
                if (!isStart)
                {
                    return;
                }
                bool retMouse = true;
                if (_hMouseHook != 0)
                {
                    retMouse = UnhookWindowsHookEx(_hMouseHook);
                    _hMouseHook = 0;
                }
                // 假设卸下钩子失败
                if (!(retMouse))
                    throw new Exception("UnhookWindowsHookEx failed.");
                // 删除所有事件
                OnMouseActivity = null;
                // 标志位改变
                isStart = false;
            }
        }

        /// <summary>
        /// 鼠标钩子回调函数
        /// </summary>
        private int MouseHookProc(int nCode, Int32 wParam, IntPtr lParam)
        {
            // 假设正常执行而且用户要监听鼠标的消息
            if ((nCode >= 0) && (OnMouseActivity != null))
            {
                MouseHookStruct MyMouseHookStruct = (MouseHookStruct)Marshal.PtrToStructure(lParam, typeof(MouseHookStruct));
                OnMouseActivity(wParam, MyMouseHookStruct);
            }
            // 启动下一次钩子
            return CallNextHookEx(_hMouseHook, nCode, wParam, lParam);
        }

        /// <summary>
        /// 注册全局鼠标事件
        /// </summary>
        /// <param name="handler"></param>
        public void AddMouseHandler(MyMouseEventHandler handler)
        {
            OnMouseActivity += handler;
        }

        /// <summary>
        /// 注销全局鼠标事件
        /// </summary>
        /// <param name="handler"></param>
        public void RemoveMouseHandler(MyMouseEventHandler handler)
        {
            if (OnMouseActivity != null)
            {
                OnMouseActivity -= handler;
            }
        }
    }

    #endregion

    #endregion

    #endregion

    /// <summary>
    /// 代码混肴器类
    /// </summary>
    public class CodeObfuscator
    {
        private Random random;
        private HashSet<string> usedNames;
        private HashSet<string> exclusionSet;
        private Dictionary<string, string> _replacements;
        private Dictionary<string, string> _replacements2;
        /// <summary>
        /// 自定义的混肴规则属性，用于正则匹配代码正文进行替换
        /// </summary>
        public Dictionary<string, string> Replacements { get => _replacements; set => _replacements = value; }
        /// <summary>
        /// 自定义的混肴规则属性，用于正则匹配代码正文进行第二遍替换
        /// </summary>
        public Dictionary<string, string> Replacements2 { get => _replacements2; set => _replacements2 = value; }

        /// <summary>
        /// 创建代码混肴器类实例，此后可使用"实例名.Replacements"属性自定义混肴规则以及使用"ObfuscateCode"方法进行代码混肴。
        /// </summary>
        public CodeObfuscator()
        {
            Replacements = new Dictionary<string, string>();
            Replacements2 = new Dictionary<string, string>();
            usedNames = new HashSet<string>();
            exclusionSet = new HashSet<string>();
            random = new Random(Guid.NewGuid().GetHashCode());
        }

        public void LoadExclusionRules(string exclusionFilePath)
        {
            if (!File.Exists(exclusionFilePath))
            {
                //Debug.WriteLine("排除规则文件不存在！");
                return;
            }

            string[] exclusionRules = File.ReadAllLines(exclusionFilePath);
            foreach (string rule in exclusionRules)
            {
                exclusionSet.Add(rule.Trim());
                //Console.WriteLine(rule.Trim());
            }
        }

        /// <summary>
        /// 手动添加混肴规则（以字典中的键值对，字符形式添加）
        /// </summary>
        /// <param name="originalName"></param>
        /// <param name="obfuscatedName"></param>
        public void AddReplacement2(string originalName, string obfuscatedName)
        {
            if (originalName != "")
            {
                // 检查是否已经存在相同的键
                if (Replacements2.ContainsKey(originalName))
                {
                    // 可以选择跳过重复的函数名或者生成一个不同的唯一替换名称
                    //Debug.WriteLine($"函数名 {originalName} 已经存在相同的替换名称，将跳过该函数名。");
                    return;
                }
                Replacements2.Add(originalName, obfuscatedName);
            }
        }

        /// <summary>
        /// 自动添加混肴规则：指定函数名会自动生成其混肴名称到混肴规则（过程中会自动去重，也不会生成相同混肴名称）
        /// </summary>
        /// <param name="originalName"></param>
        public void AddReplacement(string originalName)
        {
            if (originalName != "")
            {
                if (exclusionSet.Contains(originalName))
                {
                    //Debug.WriteLine($"函数名 {originalName} 在排除规则中，将跳过该函数名。");
                    return;
                }
                
                // 检查是否已经存在相同的键
                if (Replacements.ContainsKey(originalName))
                {
                    // 可以选择跳过重复的函数名或者生成一个不同的唯一替换名称
                    //Debug.WriteLine($"函数名 {originalName} 已经存在相同的替换名称，将跳过该函数名。");
                    return;
                }
                string obfuscatedName = GenerateRandomString(8); // 生成8个字符的随机字符串作为替换名称

                Random random = new Random(Guid.NewGuid().GetHashCode());
                int randomIndex = random.Next(65, 91); // 65-90 为大写字母 A-Z 的 ASCII 码
                char randomLetter = Convert.ToChar(randomIndex);
                obfuscatedName = randomLetter.ToString() + obfuscatedName;//防止函数名开头是数字，这里加一个随机大写字母

                Replacements.Add(originalName, obfuscatedName);
            }
        }

        //使用指定长度的随机字符串生成算法，生成一个包含字母和数字的随机字符串。
        private string GenerateRandomString(int length)
        {
            const string chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
            string randomString = new string(Enumerable.Repeat(chars, length)
            .Select(s => s[random.Next(s.Length)]).ToArray());

            while (usedNames.Contains(randomString))
            {
                randomString = new string(Enumerable.Repeat(chars, length)
                    .Select(s => s[random.Next(s.Length)]).ToArray());
            }
            usedNames.Add(randomString);
            return randomString;
        }

        /// <summary>
        /// 以字典中自定义的混肴规则，进行代码混肴
        /// </summary>
        /// <param name="code"></param>
        /// <returns></returns>
        public string ObfuscateCode(string code)
        {
            //以分组形式创建正则匹配替换规则：将Replacements字典中所有键里的具有特殊含义的符号通过正则表达式进行转义（使用时不需要加@）
            string pattern = string.Join("|", Replacements.Keys.Select(Regex.Escape));

            //创建名为replacementDelegate的委托实例，它接受一个字符串参数（匹配项）
            //在委托内部检查Replacements字典中是否存在该键，如果存在则返回相应的值，如果不存在则输出一条错误消息并将原始匹配项返回
            Func<string, string> replacementDelegate = (match) =>
            {
                if (Replacements.ContainsKey(match))
                {
                    //键存在且没有指定前缀字符时返回键对应的替换值
                    //要解决：Lib_gf_A和gf_A，如后者加到混肴规则，前者也会被替换一部分，需调用本函数前检查全函数名，如第一遍混肴规则里的键名是函数名的一部分则剔除该键
                    return Replacements[match];
                }
                else
                {
                    //否则返回原字符（替换相同字符）
                    //Debug.WriteLine("Key not found: " + match);
                    return match;
                }
            };

            //将代码中经过pattern正则匹配到的函数名替换为Replacements字典中以函数名为键对应的值
            string obfuscatedCode = Regex.Replace(code, pattern,
                (Match m) => replacementDelegate(m.Value)
                );

            return obfuscatedCode;
        }

        /// <summary>
        /// 以字典中自定义的混肴规则，进行代码混肴
        /// </summary>
        /// <param name="code"></param>
        /// <returns></returns>
        public string ObfuscateCode2(string code)
        {
            //以分组形式创建正则匹配替换规则：将Replacements2字典中所有键里的具有特殊含义的符号通过正则表达式进行转义（使用时不需要加@）
            string pattern = string.Join("|", Replacements2.Keys.Select(Regex.Escape));

            //创建名为replacementDelegate2的委托实例，它接受一个字符串参数（匹配项）
            //在委托内部检查Replacements2字典中是否存在该键，如果存在则返回相应的值，如果不存在则输出一条错误消息并将原始匹配项返回
            Func<string, string> replacementDelegate = (match) =>
            {
                if (Replacements2.ContainsKey(match))
                {
                    //键存在且没有指定前缀字符时返回键对应的替换值
                    //要解决：："A"+"A"和"+"，如后者加到混肴规则，会出问题，所幸分组显示混肴规则中+或&不打反斜线转义匹配不出来，所以大概无需改良
                    return Replacements2[match];
                }
                else
                {
                    //否则返回原字符（替换相同字符）
                    //Debug.WriteLine("Key not found: " + match);
                    return match;
                }
            };

            //将代码中经过pattern正则匹配到的函数名替换为Replacements字典中以函数名为键对应的值
            string obfuscatedCode = Regex.Replace(code, pattern,
                (Match m) => replacementDelegate(m.Value)
                );

            return obfuscatedCode;
        }

    }

}

